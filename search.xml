<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[View的工作原理]]></title>
    <url>%2F2018%2F03%2F01%2FView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRoot和DecorView这是在View三大流程之前(measure, layout, draw),需要了解的概念. ViewRoot对应于ViewRootImpl, 它是连接WindowManager和DecorView的纽带. View的三大流程都是通过ViewRoot来完成的. 当一个Activity对象在ActivityThread被创建后. 会将DecorView添加到Window中, 同时会创建ViewRootImp对象, 并将ViewRootImpl对象和DecorView建立关联. View绘制流程是从ViewRoot的PerformTraversals()开始的. 经过三大流程才能将一个View绘制出来. PerformTraversals()会依次调用performMeasure, performLayout, performDraw. 而前两种内部的调用基本一致,都是先调用measure()/layout(),然后再调用onMeasure()/onLayout()在这个方法中会对所有子元素进行测量和绘制.依次向内部传递. performDraw()有点不同是在draw调用的dispatchDraw(). PerformTraversals绘制流程如下图： ​ measure过程: 决定了View宽高, measure后可以通过getMeasureWidth和getMeasureHeight来获取View的宽高. 一般情况下是最终宽高. layout过程: 决定了View的顶点坐标和实际View的宽高. 完成后通过getTop, getBottom, getLeft, getRight获得四个顶点, 通过getWidth,和getHeight获得宽高 draw过程: 只有draw()方法完成之后View的内容才会显示出来. 12setContentView(R.layout.activity_inside_intercept);((ViewGroup) getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); 上面第一行可以说无时无刻不存在. 而下面这行在上一章说过就是获得我们设置的布局.那DecorView布局究竟是怎么样的, 下图. DecorView就是一个FrameLayout. 而一般情况下它的布局就如上面图那样(具体和主题有关系). 而我们经常setContentView(xxx). 就是把我们编写的xml的布局添加到了DecorView的android.R.id.content的控件布局中. 所以也就能说通为什么getChildAt(0)会获得我们的的布局.并且为什么我们用的关联布局的方法是setContent… MeasureSpec 很大程度上决定一个View的尺寸规格, 之所以不是绝对, 是因为这个过程还受父容器的影响. 理解MeasureSpecMeasureSpec本身是一个32位的int值, 但是却表示了两种信息. 高2位: 代表了SpecMode, 测量模式 低30位: 代表了SpecSize, 在上述测量模式中的大小 1234567891011121314151617181920212223242526272829303132public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; .....&#125; 是不是挺有意思. 三种类型分别高二位01, 00, 10来代表. 直接利用位运算. 来实现可以让频繁计算的东西使用最接近计算机的运算方式. 不需要额外的转换. 也避免了过多的对象内存分配. 说一下SpecMode的三种模式 UNSPECIFIED: 父容器不对View有任何的限制,要多大就给多大, 这种情况一般用于系统内部,表示一中测量状态 EXACTLY: 父容器已经检测出View所需要的精确大小, 这个时候View的最终大小就是SpecSize所指定的值. 对应着LayoutParams中的match_parent和具体的数值. AT_MOST: 父容器制定了一个可用的大小及SpecSize, View的大小不能超过这个值, 它对应与LayoutParams中的wrap_content MeasureSpec和LayoutParams关系通常设置的LayoutParams,系统会在父容器的的约束下转换成对应的MeasureSpec,然后根据这个MeasureSpec来确定View测量后的宽高. 所以View自身的MeasureSpec是需要LayoutParams和父容器一起组合生成的. 上面讲述的是普通View, 但是顶级View(DecorView)有所不同. DecorView是物理窗口尺寸和自身的LayoutParams决定的. 具体在ViewRootImpl类measureHierarchy()进行生成的. MeasureSpec一旦确定, onMeasure中就可以测量View的宽高. 对于我们日常操作的View View的measure过程是由ViewGroup传递而来的. 看ViewGroup#measureChildWithMargins()方法 123456789101112131415protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 上面会对子元素进行measure, 而在此之前,会通过getChildMeasureSpec()来得到子元素的MeasureSpec. 通过调用方法传入的参数看到. 生成View的MeasureSpec和父容器的MeasureSpec, View自身方向的padding``margin, 和自身的LayoutParams这三个因素相关联. 而其中的getChildmeasureSpec()方法: 就是根据父容器的MeasureSpec同时结合View自身的LayoutParams来确定子元素的MeasureSpec.这个方法总结如下: dp/px: 不管父容器的MeasureSpec是什么. View都是EXACTLY(精确模式), 而大小遵循自身LayoutParams的大小. match_parent: 如果父容器是EXACTLY(精确模式),那么子View也是EXACTLY(精确模式)并且大小是父容器的剩余空间. 如果父容器是AT_MOST(最大模式),那么子View也是AT_MOST(最大模式)并且大小不会超过父容器的剩余空间. wrap_content: 不管父容器是什么. View都是AT_MOST(最大模式), 并且大小不能超过父容器剩余空间. 上述没有说明UNSPECIFIED在match_parent和wrap_content中. 因为这个模式主要用于系统多次Measure的情形,一般来说不需要关注. 普通View的MeasureSpec的创建流程,规则如下表所示： View的工作流程 主要指measure, layout, draw三大流程. 即测量,布局,绘制. measure过程这里面存在两种场景: View: 通过了measure方法就完成了测量过程 ViewGroup: 除了测量自己,还会遍历去调用所有子元素的measure方法. 各个子元素在递归去执行这个流程 View的measure过程 View的measure过程由其measure()方法来完成, measure()方法是一个final类型, 而在内部调用了onMeasure()这个可不是final, 所以也可以自定义的时候复写. 看一下内部. 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; setMeasureDimension()会设置View宽高的测量值. 这里需要看一下getDefaultSize()这个方法. 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 看到如果这个view是EXACTLY(精准模式), 那么返回的大小就是==SpecSize==. UNSPECIFIED一般用于系统测量先不说. 而AT_MOST(最大模式)的时候. 虽然是不同模式但是默认情况下和精确模式是一样的结果. getSuggestedMinimumWidth()和getSuggestedMinimumHeight(). 看一下实现. 1234567protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; 首先会看是否设置了背景. 无背景: 那么宽度为mMinWidth,这个值对应布局中的android:minWidth属性,默认为0. 有背景: 那么取mMinWidth和mBackground.getMinimumHeight()最大值. 而getMinimumHeight()根据看一下: 1234public int getMinimumHeight() &#123; final int intrinsicHeight = getIntrinsicHeight(); return intrinsicHeight &gt; 0 ? intrinsicHeight : 0;&#125; 原来getMinimumHeight()返回的就是Drawable的原始高度. 如果没有就返回0. 关于原始高度举个例子ShapeDrawable无原始宽高, BitmapDrawble有原始宽高就是图片的尺寸. 整理getDefaultSize(): 直接继承View的自定义控件需要重写onMeasure()方法并设置wrap_content时的自身大小,否则在布局中使用wrap_content虽然View自身的MeasureSpec的低30位保存了父容器计算自身的剩余大小. 但是在==自定义的时候如果不进行处理wrap_content,那么就会调用默认setMeasureDimension()方法. 而默认中方法的实参传递的是getDefaultSize()这个方法中对AT_MOST这种模式没有处理. 直接沿用和精确模式的大小(相当于设置了wrap_content却得到了match_parent的显示结果)== 可以针对这个问题, 做出对应的编码进行解决: 123456789101112131415161718192021222324@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpaceMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpaceMode = MeasureSpec.getMode(heightMeasureSpec); //设置两个默认值宽高 int defaultHeight = 100; int defaultWidth = 100; // 针对AT_MOST模式进行特殊处理 if (widthSpaceMode == MeasureSpec.AT_MOST &amp;&amp; heightSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, defaultHeight); &#125; else if (widthSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, heightSpaceSize); &#125; else if (heightSpaceMode == MeasureSpec.AT_MOST) setMeasuredDimension(widthMeasureSpec, defaultHeight); &#125; &#125; ViewGroup的Measure 对于ViewGroup不光会测量自己,还会遍历调用所有的子元素的measure(). 和View不同的是ViewGroup是一个抽象类,它没有重写onMeasure,但提供了measureChildren()的方法. 这个measureChildren()方法内部比较简单就是遍历自己的孩子然后调用-&gt;measureChild() 这个measureChild()这个方法前面贴过源码. 就是取出子元素的LayoutParams,并调用-&gt;getChildMeasureSpec(). 通过传入子元素的LayoutParams里面的宽高属性, 子元素的padding和margin, 父元素当前(当前ViewGroup)的MeasureSpec属性来计算出子元素的MeasureSpec最后调用-&gt;child.measure()传入之前计算的测量规格. ViewGroup为什么没有定义测量的具体过程? 因为具体的测量过程需要交给子类去实现的. 比如LinearLayout,RelativeLayout. 看一下LinearLayout的onMeasure()是如何定义的. 12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; 根据设置的排列方式这里分之了两种测量方法. 稍微看一下大概轮廓,选择measureVertical()不贴源码了这个方法300行呢! 首先这个方法会遍历每个子元素并执行-&gt;measureChildBeforeLayout()方法.这个方法内部会调用子元素的measure(), 这样子元素会依次测量. 并且会通过mTotalLenght这个变量来存储LinearLayout在竖直方向上的初步高度, 每测量一个就会增加. 当子元素测量完之后,LinearLayout会测量自己的大小. 在对自己进行测量的时候. 如果布局中的高度采用的是match_parent或者具体数值, 那么它的测量过程和View一样,即高度为specSize. 如果布局中采用wrap_content那么高度就是所有的子元素总和但是不能超过父元素剩余空间, 还有竖直方向LinearLayout的padding. 具体可参考resolveSizeAndState()的实现. 到这里基本上measure测量过程已经做了比较详细的分析. 这个过程也是三大过程中最复杂的一个. 在measure完成之后就可以通过getMeasuredWidth/Height方法获取View的测量宽高. 但是请注意:某些极端情况下,measure可能执行多次. 所以尽量在onLayout()方法中去获得最终宽高. 正确获取宽高方法首先明确一点:View的measure和Activity的生命周期方法不是同步执行.所以无法保证在某个生命周期(onCreate,onStart)获取到正确的测量宽高 Activity/View#onWindowFocusChanged() view.post(runnable) ViewTreeObserver#onGlobalLayout view.measure() onWindowFocusChanged():View已经初始化完毕,宽高已经准备好. 这里需要注意只要Activity的焦点发生变化此方法就会被调用.所以如果你的界面会频繁的进行onPause和onResume.并且里面有很多关联依赖的方法. 那就请注意这不是一个好办法. 通过post可以将一个runnable投递到消息队列的尾部,然后等待Looper调用此runnable的时候.View已经初始化完毕. 使用ViewTreeObserver. 当View的可见性发生了改变的时候.onGlobalLayout()将发生回调.注意伴随着View树的状态改变等,这个回调方法可能会被调用多次. 使用代码如下 123456789ViewTreeObserver viewTreeObserver = view.getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); int height = view.getMeasuredHeight(); int width = view.getMeasuredWidth(); &#125; &#125;); view.measure(widthMeasureSpec, heightMeasureSpec) 也可以手动进行测量,但是需要分情况处理. match_parent 当View是此属性的时候无法使用measure(),首先使用这种方法需要的参数,是通过父容器和子元素组合来生成的子元素的MeasureSpec属性. 所以在外部我们不知道父元素的参数值得时候只能处理不需要父元素数据就可以生成子元素的MeasureSpec的模式 所以很清楚, 这个match_patch这个模式,在给其子元素构造MeasureSpec的时候需要得值parentSize,所以得到的也是无效. 具体数值px/dx 假设这里是100px, 首先构成宽高对应的MeasureSpec属性 123int widthSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int heightSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY); view.measure(widthSpec, heightSpec); wrap_content 123int widthSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST);int heightSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST); view.measure(widthSpec, heightSpec); 通过(1&lt;&lt;30) - 1 可以构成一个MeasureSpec低30位的最大值. 用理论上View能支持的最大值去构造MeasureSpec 关于网上一些在make的使用传入UNSPECIFIED,属于违背了内部实现的规范.不用最好 关于网上另一种measure()直接传入LayoutParams.WRAP_CONTENT. 其实也只有当子元素为wrap_content和子元素为match_parent并且父元素是wrap_conetnt时会碰巧有效. layout过程在ViewGroup中会先通过layout()方法确定本身的位置. 然后调用onLayout()方法遍历所有的子元素,并调用子元素的layout()方法确定子元素的位置…依次循环. 提出View的layout方法, 这里抽取部分代码 123456789101112public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); &#125; &#125; 这样来看,大致流程通过setFrame()方法来设定View的四个顶点的位置, 即mLeft,mTop,mBottom,mRight,这四个顶点一旦确定.当前View的位置也就确定. 然后会调用onLayout()方法. 这个方法是确定子元素的View位置. 这里的和onMeasure()类似, onLayout()具体实现和具体的布局有关, 所以View和ViewGroup均没有真正实现onLayout()方法. 看一下LinearLayout的onLayout()源码 12345678@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; 和onMeasure()一样分支,接下来跟进layoutVertical()贴出主要代码 1234567891011121314151617181920212223242526272829303132void layoutVertical(int left, int top, int right, int bottom) &#123; //省略一部分... for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; //省略一部分... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; 上面代码大体逻辑: 首先遍历所有孩子并调用setChildFrame()来为子元素指定对应的位置. 其中childTop会逐渐增大, 这就意味着后面的子元素会被放置在靠下的位置. 而setChildFrame()内部仅有一行代码, 就是调用子元素的layout()并传入它自身应该存放的位置. 123private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; 而在setChildFrame()中传入的宽高就是子元素的测量宽高. 而在子元素的layout()中通过setFrame()来设置元素的四个顶点. View的测量宽高getMeasureWidth()/getMeasureHeight() 和 layout后用getWidth()/getHeight()获得的最终宽/高有什么区别? 在一般情况下,测量measure和layout时候的值是完全一样的. 因为layout()中接受的参数就是通过测量的结果获取到的. 并且内部直接通过setFrame()赋值到自己的四个成员变量上. 但是如果对layout()进行了复写.如下 1234 @Overrideprotected void layout(int l, int t, int r, int b) &#123; super.layout( l, t+200, r, b+200);&#125; 如果进行了这样的复写, 那么最终宽高永远会与测量的出来的值相差200,但是这样做会导致显示不正常，并没有什么意义. draw过程这个过程只是将View绘制到屏幕上面. 绘制背景background.draw(canvas) 绘制自己onDraw() 绘制childrendispatchDraw() 绘制装饰onDrawScrollBars() View绘制过程传递是通过dispatchDraw()实现的. 传递了自己的画布. 这个方法会遍历子元素并且调用元素的draw() View一个特有的方法setWillNotDraw(), 这个方法是设置了true那么系统会进行相应的优化. 在View中默认是关闭的. 而ViewGroup默认是开启的. 如果我们继承了自定义ViewGroup如果还需要绘制自己的内容那么需要显示的关闭此标记. 自定义View自定义View的分类相关代码 1.继承View重写onDraw方法 这种方法主要用于实现一些不规则的效果, 不方便组合布局实现,或者又有动态显示的一些图形. 需要自己绘制那么就重写onDraw()方法. 这种方法需要自己支持wrap_content和padding 2.继承ViewGroup派生特殊Layout 这种方式用于实现自定义布局, 这种布局的实现稍微复杂,需要合适的处理ViewGroup的测量,布局这两个过程,并同时处理子元素的测量和布局过程. 3.继承特定的View(TextView) 比较常见, 一般用于扩展已有的View的功能. 这种不需要自己处理wrap_content和padding 4.继承特定ViewGroup(LinearLayout) 当某种效果看起来像几种View的组合在一起的时候,可以采用这种方式. 这种方式不需要自己处理ViewGroup的测量和布局. 其实这种方式和2没什么区别, 主要是2更接近于底层的View实现. 自定义View的须知 让View支持wrap_content 最好让你的View支持padding -&gt; 如果直接继承View,在draw()中不处理padding,那么属性是无法起作用的. 还有继承ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin会造成的影响. 尽量不要在View中使用Handler -&gt; 内部已经提供了post系列方法. 除非很明确要是用Handler发送消息. View中如果有线程或者动画,需要及时的停止.-&gt; 当包含此View的Activity退出或者此View被remove的时候,View的onDetachedFromWindow()会被调用,可以适当处理防止内存泄漏. View带有的滑动嵌套时,需要处理好滑动冲突. 自定义View实例1.自定义View派生类 首先写一个类继承View, 并在ondraw()画一个圆. 并设置margin属性. 效果没有问题,因为margin属性是由父容器控制的. 问题1:这里把android:layout_width=&quot;wrap_content&quot;设置根据内容. 发现无效. 对于直接继承View的空间，不管是设置match_parent也好,wrap_content也好父容器都会给分配自己剩余空间的大小给子容器作为specSize的空间大小这时需要手动处理. 如果不对wrap_content处理那就是相当于和match_parent填充父容器的效果一样. 所以增添对onMeasure()方法中的AT_MOST模式的制定默认大小, 然后在运行, ok,如下 问题2:这时加上属性padding=20dp发现无效. 无变化. 之前说过margin是交给父容器分配的.padding确实要自己要分配处理的. 这时需要在onDraw()来处理. 处理后如下 问题3:有时候我们需要提供自定义属性. 例如android:id=这种. 接下来添加自定义属性. 在values目录下创建自定义属性的xml. 名字随便当最好attrs.xml或者attrs_xxx_xxx.xml. 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;CircleView&quot;&gt; &lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 上面相当于,定义了一个CircleView的属性集合. 在这个集合里面会有自定义属性. 这里的format格式可以是指定尺寸的dimension, 资源id引用的reference, 基本类型string, integer ,boolean等. 声明好了属性在我们自定义View中就可以引用处理了. 如构造方法中. 1234567891011public CircleView(Context context, AttributeSet attrs) &#123; super(context, attrs, defStyleAttr); //获得一个自定义的对应属性值集合 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView); //取出属性集合中的某个属性值 mColor = typedArray.getColor(R.styleable.CircleView_circle_color, Color.GREEN); //释放资源 typedArray.recycle(); init(); &#125; 在布局中使用即可. 先声明schemas. xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; ,使用app来替代之前的类似android前缀的引导. 继承View的派生类就到此为止了.]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 源码分析1]]></title>
    <url>%2F2018%2F02%2F26%2FRxJava%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901%2F</url>
    <content type="text"><![CDATA[基于 RxJava 2.1.2 给定下面的一段代码，从源码的角度分析 RxJava 的实现原理： 12345678910111213141516171819202122232425262728293031323334353637ObservableOnSubscribe&lt;Integer&gt; oos = new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(max); &#125; e.onComplete(); &#125;&#125;;Observer&lt;Integer&gt; o = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;;Observable.create(oos) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.computation()) .subscribe(o); 分析源码之前，我们先定义一下名词，RxJava 是基于观察者模式的，这里将被观察者叫做主题（Source），观察者叫做观察者（Observer）。 上面的代码首先创建了一个主题对象，然后又创建了一个观察者对象，最后将两者关联起来，并且最重要的一点，指定了主题对象和观察者对象执行的线程。 Observable.create(oos)首先分析这行代码做了什么事情： 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ObjectHelper 只是用来做非空判断，这里就不用管它了。看看 RxJavaPlugins 做了什么： 123456789101112131415/** * Calls the associated hook function. * @param &lt;T&gt; the value type * @param source the hook's input value * @return the value returned by the hook */@SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;)@NonNullpublic static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 注释上都说了，这是一个钩子函数，也就是说如果 onObservableAssembly 的值不为空，那么就调用这个钩子函数，onObservableAssembly 是一个静态变量，需要我们主动的去设置才会赋值，这里当做空来考虑，如果 onObservableAssembly 为空的话，也就是说这个方法啥都没做，直接返回 source 参数，也就是上面的 ObservableCreate 对象。 总结一下，Observable.create(oos) 只是创建了一个 ObservableCreate 对象。这个方法就暂时先分析到这里，至于这个对象内部有什么东西，我们后面会说到。 observeOn(AndroidSchedulers.mainThread())既然之前的 create 方法创建了一个 ObservableCreate 对象并返回，也就是说 observeOn(Schedulers.computation()) 这个方法是调用的 ObservableCreate 这个对象上的方法。 1public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; ObservableCreate 是继承至 Observable 的。 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; Observable 的 observeOn 是 final 的，所以走的父类的方法。继续跟踪 observeOn 调用的同名方法： 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; ObjectHelper 跳过。这里又是一个 onAssembly 方法的调用，我很好奇这个单词是什么意思。点进去看一下： 1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 同样是一个钩子方法，现在也是有经验的人呢，再看到这个方法，就直接跳过，只关心它传递的参数和返回值就行了。它的返回值默认就是传递进来的参数。 所以，observeOn 方法就是创建并返回了一个 ObservableObserveOn 对象（大神教你起类名系列二），这里预警一下，之后像这样类似的类名差不多还有3个。 subscribeOn(Schedulers.computation())由于 observeOn 创建并返回了一个 ObservableObserveOn 对象，所以这里调用的是 ObservableObserveOn 对象上的方法。 1public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; 也是继承至 Observable 。 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 不出意料，也是 final 的，创建了一个 ObservableSubscribeOn 对象（大神教你起类名系列三）并返回。 subscribe(o)前面 subscribeOn 创建了一个 ObservableSubscribeOn 对象并返回，所以这里调用的是 ObservableSubscribeOn 这个对象上面的方法。 1public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; 继承至 Observable 类。 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 这个方法也是 final 的，所以是调用的这个方法。 public final void subscribe(Observer&lt;? super T&gt; observer) { … } 这个方法是我们需要分析的重点，看看内部具体的代码吧先： 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 这里忽略 ObjectHelper 和异常处理的代码只有两行代码是关键。 先看 observer = RxJavaPlugins.onSubscribe(this, observer); 1234567public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) &#123; BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe; if (f != null) &#123; return apply(f, source, observer); &#125; return observer;&#125; 没想到啊没想到，你这浓眉大眼的家伙也是一个钩子方法。所以这行代码相当于 obsever = observer; 接着看，subscribeActual(observer); 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 这是一个抽象方法，没啥好分析的。 接下来我们要进入正题了，根据我们编写的代码，是 ObservableSubscribeOn 这个对象调用了 subscribe 方法，所以我们看看这个类的 subscribeActual 方法。 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 这里需要注意的是 s 这个参数，后面会有很多地方看到这个参数，一定要搞清楚这个参数是谁传递过来的。比如说： 12A.subscribe(B)那么，参数 s 就是 B。 在我们的代码中是 ObservableSubscribeOn.subscribe(o); 理解了这一点，我们详细分析代码里面的内容：首先创建了一个 SubscribeOnObserver （大神教你起类名系列四）。然后调用了我们创建的对象 o 的 onSubscribe 方法： 1234@Overridepublic void onSubscribe(Disposable d) &#123;&#125; 我们的 onSubscribe 方法里面啥都没做。不过一般来说，你应该调用一下 onStart 方法。 接下来是调用 parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); setDisposable 的方法不影响流程分析，这里就先跳过了，有兴趣的可以点进去看一下。然后就是 scheduler 变量，这个变量就是我们使用 subscribeOn 传递的参数： 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; 这个 scheduler 就是 Schedulers.computation()。然后调用了它的 scheduleDirect 方法： 123public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125; 1234567891011public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); w.schedule(task, delay, unit); return task;&#125; 这两个方法是父类的，Schedulers.computation() 返回的是一个 ComputationScheduler 对象，这里找具体的实现类由于调用链比较长，就不给出了，自己点着点着就能找到了。看看 ComputationScheduler 有没有复写这两个方法： 123456@NonNull@Overridepublic Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) &#123; PoolWorker w = pool.get().getEventLoop(); return w.scheduleDirect(run, delay, unit);&#125; 它覆盖了父类的第2个 scheduleDirect 方法。这里就不深入分析里面的池了。看 w.scheduleDirect(run, delay, unit);： 12345678910111213141516public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 熟悉的线程池使用代码。希望看到这里你还没有忘记我们要分析的是什么。简单的归纳一下，其实就是向我们创建的 scheduler 里面提交了一个 runnable。最终这个 Runnable 肯定会执行，那么看看这个 Runnable 里面有什么代码： 1parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); 123456789101112final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; run 方法里面就只有一句代码，但是我们需要搞清楚这里的 source 和 parent 分别是哪个对象。 parent 可以直接看到是 SubscribeOnObserver 对象。 source 是使用的外部类的变量。 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; 这里调用了 super 方法，所以构造函数里传递的变量就是 source。 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 这里是我们之前分析过的创建 ObservableSubscribeOn 的代码，这里的 this 指的是 observeOn 创建的 ObservableObserveOn 对象。希望看到这里你没有搞晕，如果你是使用手机看的，并且看懂了，我是真的佩服。 也就是说，run 里面的代码就是调用了 ObservableObserveOn 对象的 subscribe 方法。之前我们分析过了，subscribe 方法实际上没有做什么，只是调用了 subscribeActual 方法，所以我们进入这个类内部看看： 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 我们在 observeOn 传递的 scheduler 不是 TrampolineScheduler 类型的，所以只需要看 else 的代码。这里是先创建了一个工作线程（由于我们使用的是 AndroidScheduler，所以这里是指的主线程），然后调用了 source 的 subscribe 方法。需要注意的是这里最后创建了一个 ObserveOnObserver 对象（大神教你起类名系列五）。 先看看 createWork，在 HandlerScheduler 中： 1234@Overridepublic Worker createWorker() &#123; return new HandlerWorker(handler);&#125; 返回了一个 HandlerWorker 对象。 再看 source.subscribe()，首先这里的 source 指的是 create 方法创建的 ObservableCreate 对象，调用 subscribe 传递的是 ObserveOnObserver。看看这个对象的 subscribeActual 方法： 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 这里的参数 observer 是 ObserveOnObserver，source 是我们代码中创建的 oos 对象。 首先创建了一个 CreateEmitter 对象。 接着看 ObserveOnObserver 的 onSubscribe 方法做了啥： 12345678910111213141516171819202122232425262728293031@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.validate(this.s, s)) &#123; this.s = s; if (s instanceof QueueDisposable) &#123; @SuppressWarnings("unchecked") QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) &#123; sourceMode = m; queue = qd; done = true; actual.onSubscribe(this); schedule(); return; &#125; if (m == QueueDisposable.ASYNC) &#123; sourceMode = m; queue = qd; actual.onSubscribe(this); return; &#125; &#125; queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); actual.onSubscribe(this); &#125;&#125; 这里代码比较长，只分析重要的代码，就是 actual.onSubscribe 这句。actual 是构造函数中赋值的，所以我们回到创建 ObserveOnObserver 的地方，actual 指的是 SubscribeOnObserver 对象。所以它调用了 SubscribeOnObserver 的 onSubscribe 方法。接下来分析一下它的 onSubscribe 方法做了什么，这里不看也不会影响流程。 123456789SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; this.s = new AtomicReference&lt;Disposable&gt;();&#125;@Overridepublic void onSubscribe(Disposable s) &#123; DisposableHelper.setOnce(this.s, s);&#125; 这个方法调用了 setOnce 方法： 1234567891011public static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; ObjectHelper.requireNonNull(d, "d is null"); if (!field.compareAndSet(null, d)) &#123; d.dispose(); if (field.get() != DISPOSED) &#123; reportDisposableSet(); &#125; return false; &#125; return true;&#125; 这里涉及到了乐观锁等玩意，简单来说就是先判断 field 的值是否为空，如果为空则设置为 d，不为空则将 d dispose。然后判断 field 的值，由于 field 的值只能设定一次非 DISPOSED 值，所以如果不为 DISPOSED，说明已经被设置过了，再报出异常，如果为 DISPOSED 是可以再次设置的。按照正常的流程，这里只是将 field 的值设置为 d，然后返回true。这个方法可以先不用管。 回到主线流程上，source.subscribe(parent); 这是最重要的一句代码。source 是在构造函数赋值的，看看构造方法： 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 也就是说这里的 source 是我们代码中创建的 oos 对象。parent 是新创建的 CreateEmitter 对象。看看我们 oos 的 subscribe 方法： 123456789@Overridepublic void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e("aprz", Thread.currentThread().getName()); final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(i); &#125; e.onComplete();&#125; 这里就是事件开始的起点。所有的事件都由 ObservableEmitter 开始发送，看看它的代码，它是一个接口，在我们的例子中，它的实现类是 CreateEmitter，所有我们分析这个类的 onNext 方法： 12345678910@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; isDisposed 方法返回 false 才会去调用 observer 的 onNext 方法，这个 observer 是谁呢? 看到这里我们就要从后往前推一遍之前的代码了，不管你绝不绝望，反正我是很绝望。这的 observer 是 ObserveOnObserver 对象。 接下来我们就进入 ObserveOnObserver 里面，看看它接受事件之后做了什么，上面的参数 e 就是： 1234567891011@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125; 调用了 schedule 方法： 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; 向 work 中提交了一个 Runnable，这里传递的是 this。说明它自己肯定实现了这个接口，我们看看它的 run 方法做了啥： 12345678@Overridepublic void run() &#123; if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125; 这里一般是走 drainNormal 吧，我猜的，我们分析这个方法吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; 代码很长，具体做了啥我们暂时不用关心，只需要注意到 a.onNexe(v) 这行代码，这个 a 是 actual 变量，actual 又是 SubscribeOnObserver 对象，我们看看它的 onNext 方法： 1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; 很简单，这里的 actual 就是我们创建的 o 了，所以最终调用到了我们的代码里面。 好了，到这里一个完整的流程就整理出来了，但是还有一个问题没有解决，就是线程切换是发生在哪里。因为为了不影响整体流程的分析，所以上面并没有去分析线程切换的东西，下面开始分析。 直接从 subscribeOn 开始，看 ObservableSubscribeOn 的代码 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 从这里开始就进行了线程的切换，根据上面的分析我们知道这里是将 SubscribeTask 作为一个 Runnable 对象给提交进了我们指定的 scheduler （subscribeOn 传递的）中。所以后面的流程都是在 scheduler 所在的线程在运行。 再看 observeOn，看 ObservableObserveOn 的代码。 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 这里的线程切换是发生在 ObserveOnObserver 这个对象的里面。 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; schedule 的流程，我们上面分析过，worker.schedule(this) 这行代码就发生了线程切换，是将 this 作为 Runnable 对象提交到了我们指定的（observerOn 传递的）scheduler 中。具体分析，由于之前的流程是在别的线程中，所以想要进行线程切换，最先想到的肯定是 Handler。由于我们传递的是 AndroidSchedulers.mainThread()，所以我们就分析这个吧。 AndroidSchedulers.mainThread() 的实现是 HandlerScheduler。看看它的 schedule 方法： 1234567891011121314151617181920212223242526@Overridepublic Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; if (run == null) throw new NullPointerException("run == null"); if (unit == null) throw new NullPointerException("unit == null"); if (disposed) &#123; return Disposables.disposed(); &#125; run = RxJavaPlugins.onSchedule(run); ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker's runnables. handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) &#123; handler.removeCallbacks(scheduled); return Disposables.disposed(); &#125; return scheduled;&#125; post 了一个 msg，这样就完成了线程的切换。 下面上一张图，有助于理解和记忆： 只需要理解，每次 observerOn 和 subscribeOn 的时候，内部都会创建一个新的 observable 和 observer。 新创建的 observable 会引用前面的 observable，就是代码中我们分析的 source 变量。 新创建的 observer 会引用前面的 observer，就是代码中我们分析的 actual 变量。 最后我们 subscribe 的时候，是调用的最后创建的 observable 的方法。而每个 observable 内部又调用了 source 的 subscribe 方法，这样就形成了一层一层往前传递的调用链。当调用到最前面的一个 observable 的时候，就是我们自己创建的 observable，在这里我们需要手动触发该与该 observable 对应的 observer 对象的 onNext 方法。而 observer 的 onNext 方法的内部又调用了 actual 的 onNext 方法，这样就形成了一层一层往后传递的调用链。 虽然在我们的例子中，CreateEmitter 并不是一个 observer ，但是它也有 onNext 等方法，可以把它看做一个 observer。 如此，RxJava 的一个流程就理清楚了。这货的流程和 OkHttp 怎么有点像，只是稍微有点不一样。 2018年01月08日20:49:03 补充一下关于背压的知识：在异步订阅的时候，使用 Observable，默认的缓冲大小是 128，超过 这个数量之后会 resize，也就是说会缓冲所有的事件，这样就会导致内存占用一直增加。]]></content>
      <categories>
        <category>Rxjava</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC机制]]></title>
    <url>%2F2018%2F02%2F22%2FIPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android中的多进程模式开启多进程模式 在AndroidMenifest中为四大组件指定android:process属性 通过JNI在native层fork一个新的进程 查看进程信adb shell ps | grep packagename android:process 属性方式区别 “:remote”开头，进程名为packagename:remote ,属于当前应用的私有进程。 “com.packagename.remote”完整命名则属于全局进程，通过具有相同的ShareUID和签名，两个不同应用可以跑在同一个进程中。具有相同UID的应用可以共享数据（data目录、组件信息等） 多进程模式运行机制 不同的进程的组件会拥有独立的虚拟机、Application、以及内存空间。 多进程注意的问题： 静态成员和单列不能跨进程使用 线程同步失效 SharedPreference的可靠性下降 Application会多次创建 SharePref底层通过读写xml文件实现，并发执行读写操作可能会导致一定几率的数据丢失 ​ IPC基础概念介绍Serializable接口 123456public class User implements Serializable &#123; private static final long serialVersionUID = 87113688048893844L; public int userId; public String userName; public boolean isMale;&#125; 这个serialVersionUID是用来辅助序列化和反序列化的，序列化时会将该字段写入文件中，然后反序列化时检测文件中的serialVersionUID是否与当前类一致。如果不一致，将序列化失败。 最好能够手动指定serialVersionUID，这样版本更新后，我们可能删除或新增了一些Field，但是反序列化仍能成功。不指定的话由于类内部成员变化，所以计算hash值变化，导致反序列失败。 静态成员不参与序列化 transient关键字标记的成员变量不参与序列化 Serialable接口是序列化需要大量I/O操作，开销大 Parcelable接口 Parcelable主要用在内存序列化上，效率高，Android平台推荐用。 但是对象序列化后要网络传输和持久化存储推荐用Serialable。 Binder Binder是客户端和服务端通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务和数据。aidl类核心实现内部类Stub以及Stub的内部代理类Proxy。 DESCRIPTOR Binder的唯一标示，一般用当前Binder的类名 asInterface(android.os.IBinder obj) 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型对象，区分进程，如果客户端和服务端位于同一进程，返回服务端的Stub对象本身，否则返回Stub.proxy对象。 asBinder 返回当前的Binder对象 onTransact 运行在服务端的Binder线程池中，原型为 1public Boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flag) code确定目标方法，data目标参数，reply写入返回值。 Proxy#getBookList 这个方法运行在客户端，客户端远程调用该方法，创建输入型Parcel对象data，输出型Parcel对象_reply和返回值对象List。接着调用transact方法发起RPC（远程过程调用）请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC返回，当前线程继续执行，并从_reply中返回结果。 通过linkToDeath 和 unlinkToDeath给Binder设置死亡代理DeathRecipient，当服务端进程异常终止时，可以收到通知。 Android中的IPC方式 使用Bundle 使用文件共享（考虑并发读写的问题，注意⚠️SharedPrefences不支持跨进程读写） 使用Messenger 信使 使用AIDL ​ 使用Messager ​ Messgener的工作原理 AIDL 服务端：创建一个service来监听客户端的请求，创建一个AIDL文件，暴露出AIDL接口供客户端调用，最后在service中实现这个AIDL接口。 客户端：bindService绑定服务，调用AIDL接口 AIDL文件支持类型：基本数据类型、String、ArrayList、HashMap、Pacelable对象、其他AIDL接口。 注意⚠️自定义的Pacelable对象必须新建一个和它同名的AIDL文件，并显示import进来。 除了基本数据类型，其他参数必须表上方向：in、out、inout 1234##Book.aidlpackage com.ryg.chapter_2.aidl;parcelable Book; 123456789101112##IBookManager.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;import com.ryg.chapter_2.aidl.IOnNewBookArrivedListener;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookArrivedListener listener);//obsever mode void unregisterListener(IOnNewBookArrivedListener listener);&#125; 12345678##IOnNewBookArrivedListener.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;interface IOnNewBookArrivedListener &#123; void onNewBookArrived(in Book newBook);&#125; AIDL中观察者模式的使用，提供一个AIDL接口，客户端需要实现该listener（通过继承该Listener.Stub接口），传递给服务端，服务端处理完成后再回调回客户端。 注册和解注册，使用==RemoteCallbackList==，专门提供用于删除跨进程的listener接口。 如果某个远程方法是耗时的，那么要避免在客户端UI线程中去访问远程方法，否则会导致客户端ANR。客户端的onServiceConnected和onServiceDisconnected方法都运行在UI线程中，所以也不能在这里调用服务端的耗时方法。解决的办法是在非UI线程中调用原厂方法。 同理，如果有服务端需要调用客户端的listener方法，被调用的方法将运行在客户端的Binder线程池中，如果listener中的方法比较耗时，也要注意服务端的ANR问题。 Binder意外死亡重连 给Binder设置DeathRecipient监听（在客户端Binder线程中被回调） 在onServiceDisconnected中重连远程服务（在客户端UI线程被回调） 权限验证 AndroidMenifest.xml声明权限 123&lt;permission android:name="com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE" android:protectionLevel="normal" /&gt; 在服务队的onBind或者onTransact方法中进行权限验证。 使用ContentProvider继承ContentProvider，通过ContentResolver的query、update、insert、delete方法实现数据库SQLiteOpenHelper的CRUD操作。 使用Socket使用ServerSocket—&gt;TCP连接; UDP也是跨进城的通信方式。 Binder连接池 面对多个模块需要用到AIDL，我们不能针对每一个AIDL接口单独创建多个Service。 这种模式下：每个业务模块创建自己的AIDL接口并实现此接口，不同业务模块之间没有耦合，并向服务端提供自己的唯一标识和对应的Binder对象；对于服务端来说，只需要提供一个Service，并包含一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象；不同业务模块拿到自己的Binder对象后就可以进行远程方法调用了。 Binder连接池的作用就是将每个业务模块的Binder请求统一转发到远程的Service中去执行，从而避免重复创建Service。 Binder连接池工作原理 123456## Module A package com.ryg.chapter_2.binderpool;interface ISecurityCenter &#123; String encrypt(String content); String decrypt(String password);&#125; 12345## Module Bpackage com.ryg.chapter_2.binderpool;interface ICompute &#123; int add(int a, int b);&#125; 12345678910## BinderPool aidl interfacepackage com.ryg.chapter_2.binderpool;interface IBinderPool &#123; /** * @param binderCode, the unique token of specific Binder&lt;br/&gt; * @return specific Binder who's token is binderCode. */ IBinder queryBinder(int binderCode);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.ryg.chapter_2.binderpool;import java.util.concurrent.CountDownLatch;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;public class BinderPool &#123; private static final String TAG = "BinderPool"; public static final int BINDER_NONE = -1; public static final int BINDER_COMPUTE = 0; public static final int BINDER_SECURITY_CENTER = 1; private Context mContext; private IBinderPool mBinderPool; //BinderPool aidl interface private static volatile BinderPool sInstance; private CountDownLatch mConnectBinderPoolCountDownLatch; private BinderPool(Context context) &#123; mContext = context.getApplicationContext(); connectBinderPoolService(); &#125; // singleton, double check public static BinderPool getInsance(Context context) &#123; if (sInstance == null) &#123; synchronized (BinderPool.class) &#123; if (sInstance == null) &#123; sInstance = new BinderPool(context); &#125; &#125; &#125; return sInstance; &#125; /** ** 绑定BinderPool的远程服务 **/ private synchronized void connectBinderPoolService() &#123; mConnectBinderPoolCountDownLatch = new CountDownLatch(1); Intent service = new Intent(mContext, BinderPoolService.class); mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE); try &#123; //将bindService这异步操作转为同步的，耗时操作 mConnectBinderPoolCountDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * query binder by binderCode from binder pool * * @param binderCode * the unique token of binder * @return binder who's token is binderCode&lt;br&gt; * return null when not found or BinderPoolService died. */ public IBinder queryBinder(int binderCode) &#123; IBinder binder = null; try &#123; if (mBinderPool != null) &#123; binder = mBinderPool.queryBinder(binderCode); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; return binder; &#125; private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // ignored. &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinderPool = IBinderPool.Stub.asInterface(service); try &#123; mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient, 0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; mConnectBinderPoolCountDownLatch.countDown(); &#125; &#125;; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; Log.w(TAG, "binder died."); mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, 0); mBinderPool = null; connectBinderPoolService(); &#125; &#125;; /** * 当Binder连接池连接上远程服务时，会根据不同模块的标识bindeCode返回不同的Binder对象， * 通过这个对象所执行的操作发生在远程服务器 **/ public static class BinderPoolImpl extends IBinderPool.Stub &#123; public BinderPoolImpl() &#123; super(); &#125; @Override public IBinder queryBinder(int binderCode) throws RemoteException &#123; IBinder binder = null; switch (binderCode) &#123; case BINDER_SECURITY_CENTER: &#123; binder = new SecurityCenterImpl(); break; &#125; case BINDER_COMPUTE: &#123; binder = new ComputeImpl(); break; &#125; default: break; &#125; return binder; &#125; &#125;&#125; 有了BinderPool机制后，如果有一个新的业务模块需要加AIDL，那么在实现的自己的AIDL接口后，只需要修改BInderPoolImpl中的queryBinder方法给自己添加一个binderCode并返回对应的Binder对象即可，不需要创建新的Service。 选用合适的IPC方式 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据 四大组件间的进程通信 文件共享 简单易懂 不适合高并发场景，并且无法做到进程间即时通信 无并发，交换简单的数据、实时性不高的场景 AIDL 功能强大，支持一对多并发通信 使用复杂，需要处理好线程同步 一对多通信有RPC需求 Messager 功能一般，支持一对多串行通信 不能处理并发情形，不支持RPC，数据通过Message传输，只能支持Bundle数据类型 串行一对多即时通信，无RPC需求，或者无需返回结果RPC需求 ContentProvider 在数据源访问功能强大，支持一对多并发数据共享 可以理解为受约束的AIDL，主要提供数据源的CRUD 一对多的进程间数据共享 Socket 功能强大，通过网络传输字节流，支持一对多的并发实时通信 实现细节稍微繁琐，不支持直接的RPC 网络数据交换]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>AIDL</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的生命周期和启动模式]]></title>
    <url>%2F2017%2F07%2F13%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activity的生命周期和启动模式生命周期分析典型生命周期分析 onStart和onStop是从Activity是否可见的这个角度回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的。 Activity的启动过程很复杂，涉及Instrumentation、ActivityThread和ActivityManagerService（简称AMS）；简单理解，启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护一个ActivityStack并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期方法的调用。 假设当前Activity是A，新启动一个Activity B，那么A的onPause先执行，然后B的onCreate、onStart、onResume，再是A的onStop。 所以Android官方文档中有说明，不能在onPause中作重量级的耗时操作，因为onPause执行完后新的Activity才能Resume。注：不要在onPause和onStop中执行耗时操作，尤其是onPause。 异常情况下的生命周期分析 资源相关的系统配置改变导致Activity被杀死并重新创建 配置改变（旋转）onPause–&gt;onSaveInstanceState–&gt;onStop–&gt;onDestroy–&gt;重建–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState 注意：onSaveInstanceState在onStop之前，onRestoreInstanceState在onStart之后 资源内存不足导致低优先级的Activity被杀死 屏幕旋转时候Activity不想重新创建，配置android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot; Activity的启动模式（LaunchMode） standard：标准模式 与启动他的Activity运行在同一个的任务栈中； singleTop：栈顶复用模式 singleTask：栈内复用模式 多次启动Activity不会重复创建实例，回调其onNewIntent，并附带ClearTop效果。 什么是任务栈？？ 与参数TaskAffinity关联，也称为任务相关性，该属性表示任务栈的名字，默认就是packageName，也可以单独指定TaskAffinity的属性； 根据Activity是否位于暂停状态，又可以分为前台任务栈和后台任务栈。 1adb shell dumpsys activiy Activity的Flag FLAG_ACTIVITY_NEW_TASK—&gt;”singleTask” FLAG_ACTIVITY_SINGLE_TOP—&gt;”singleTop” FLAG_ACITIVY_CLEAR_TOP—&gt;一般配合“singleTask”使用，回调onNewIntent FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 移除历史Activity列表 IntentFilter的匹配规则 action的匹配规则—&gt;Intent中必须有一个action能够和IntentFilter中的某个action相同 categoty的匹配规则—&gt;Intent中可以没有category，但是如果有categoty，则每个category都需要和IntentFilter中的相同。 在startActiviy时，系统默认会为Intent加上android.intent.categoty.DEFAULT这个category，所以IntentFilter中必须有上述category才能接受隐式调用； data的匹配规则: mimeType + URI URI默认为content和file；如果要为Intent完整指定data，必须调用setDataAndType方法。 判断是否有Activity配置隐式Intent—&gt;可以用PackageManager的resolveActivity方法或者Intent的resolveActivity方法]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Activity的生命周期和启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构 改善既有的代码设计]]></title>
    <url>%2F2017%2F07%2F13%2Frefactor%2F</url>
    <content type="text"><![CDATA[《重构改善既有代码设计》 重构 Extract Method (提炼函数) Move Method (搬移函数） Self Encapsulate Field (自封装字段) Replace Type Code With State/Strategy (以状态／策略模式取代状态码) Replace Condition with Polymorphism (以多态取代条件表达式) 重构原则 何为重构 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 为何重构 改进软件设计、是软件更容易理解、帮助找到bug、提高编程速度。 何时重构 添加功能时重构、修补错误时重构、复审代码时重构 重构与间接层 间接层价值： 允许逻辑共享、分开解释意图和实现、隔离变化、封装条件逻辑（多态） 重构的难题 数据库迁移、修改已公布的接口、难以重构的复杂设计 ​ 代码的坏味道 Duplicated code（重复代码） Long Method（过长函数） Large Class（过大的类） Long Parameter List (过长参数列） Divergent Change （发散式变化）一种类受多种变化的影响，类过大，需Extract class Shotgun Surgery（散弹式修改）一种变化引起多个类修改，需Move Method移到同一个类 Feature Envy（依恋情结）总是一起变化的东西放在一块 Data Clumps （数据泥团）多个类中重复的字段、方法。需Extract class到一个独立对象 Primitive Obsesstion （基本类型偏执）必要时用对象代替基本数据 Switch Statement（switch语句）需要抽出方法，用子类或state/strategy模式替代 Parallel Inheritance Hierarchies （平行继承体系）散弹修改的一种，需用引用代替继承 Lazy Class（冗余类） Speculative Generality（夸夸其谈未来性）多余的抽象、委托、参数应该去除 Temporary Field (迷惑的暂时字段) 可以的话提炼到一个独立的类中 Message ChainsI（过度耦合的消息链） Middle Man（中间人）过度使用委托 Inappropriate Intimacy (狎昵关系) 拆散过渡亲密的类，Move Method 或 Move Field到合适的地方；提炼共性到新类；Replace Inheritance with Delegation Alternative Classes With Different Interfaces (异曲同工的类) 重新命名或提取超类 Incomplete Library Class (不完美的类库) Data Class（存粹的数据类）注意封装和访问权限 Refused Bequest（被拒绝的馈赠）子类服用的超类的行为（实现），却不愿支持超类的接口，需重构（这里思考Basesso类的3个abstract方法有这个问题，不愿支持超类的接口） Comments（过多注释） ​ 重新组织函数 Extract Method（提炼函数） 将一段代码放进一个独立的函数中，并让函数名称解释该函数的用途。 如果源函数中局部变量比较多，先用Replace Temp With Query减少临时变量，源函数中读取的临时变量和参数，提炼到目标函数作为参数，并考虑是否需要返回值。 Inline Method （内联函数） 一个函数和本体一样清楚易懂，在函数调用点插入函数体，然后移除该函数。 Inline Temp（内联临时变量） 将临时变量替换为对它赋值的表达式或函数。 Replace Temp With Query（以查询取代临时变量） 将临时变量的计算代码提炼到一个独立的函数中，这样临时变量的引用点就可以替换为新函数的调用。 以查询代替临时变量可以减少临时变量，是提炼函数的重要步骤。 Introduce Explaining Variable (引入解释性变量) 将该复杂表达式的结果放进一个临时变量，以此变量名称来解释表达式的作用。 或者Extract Method来处理 Split Temporary Variable (分解临时变量) 某个临时变量，既不是循环变量也不是收集变量；针对每次赋值，创造一个独立的、有合理名称的临时变量来分解重复赋值。 Remove Assignments to Parameters(移除对参数的赋值） 代码对参数进行赋值，以一个临时变量取代该参数的位置 Java是按值传递的 1234void aMethod(Object foo) &#123; foo.modifySomeWay(); //that's OK，将改变foo引用的对象 foo = anothnerObject; //trouble will follow, 函数返回后并不会改变foo。&#125; Replace Method with Method Object(以函数对象取代函数） 有一个大型函数其中存在大量的局部变量，很难Extract Method来分解这个函数，那么使用函数对象。 将原函数替代成函数对象，该函数对象的构造函数接受源对象和原函数的参数作为参数； 针对原函数每个临时变量和每个参数，在新的函数对象中建立一个对应的字段保存； 然后就可以在函数对象中Extract Method来分解原函数； Substitute Algorithm (替换算法) 将函数本体替换为新的算法，建议先考虑分解函数再做替换。 ​ 在对象之间搬移特性 Move Method (搬移函数) 函数与其他类耦合过多，考虑使用委托或搬移到合适的类中。 搬移过程中，当目标类需要源类特性时，1）将这个特性也搬移到目标类 2）建立使用目标类到源类的使用 3）将源对象或该特性变量作为参数传递给目标类 Move Field (搬移字段) 某个字段被所驻类之外的另一个类更多地用到，考虑搬移这个字段到目标类。 Self Encapsulate（使用自我封装）在字段搬移后，就只需要修改访问函数（set／get），而无需修改引用点。 Extract Class（提炼类） 建立一个新类，将相关字段和函数从旧类搬移到新类。 可能需要双向连接，尽量避免建议新类到旧类的连接；决定是否公开新类； Inline Class（内联化类） 将这个类的所有特性搬移到另一个类，然后移除这个类； Hide Delegate (隐藏“委托关系“) 客户类通过委托类来调用另一个对象，在服务类上建立客户需要的所有委托函数，用于隐藏委托关系。 Remove Middle Man（移除中间人） 某个类做了过多的委托动作，那么可以直接让客户类调用受托类； 服务类中建立一个函数，直接返回受托类，客户类直接调用该类； 隐藏委托关系与移除中间人互为逆向的行为。 Introduce foreign Method (引入外加函数) 场景：你需要为提供服务的类增加一个函数，但是却无法修改这个类 应对：在客户类中建立一个函数，并传入一个服务类的实例参数； 如果需要外加多个函数，考虑使用引入本地扩展。 Introduce Local Extension (引入本地扩展) 场景：你需要为服务类提供一些额外的函数，但是你无法修改这个类 应对：建立一个新类，包含这些额外的函数，让这个扩展品称为源类的字类（subclass）或包装类（wrapper）； ​ 重新组织数据 Self Encapsulate Field (自封装字段) 直接访问字段，产生耦合关系；为这些字段建立get/set函数，并以这些函数访问字段。 直接访问字段还是通过get/set函数访问哪个好没有定论。 Replace Data Value with Object(以对象取代数据值) 如果有一个数据项需要与其他数据或者行为一起使用才有意义，那么将数据变成对象。 数据值 —&gt; 值对象,值对象应该是不可修改的 区别：如果数据可修改，使用引用对象，Change value to Reference Change Value into Reference(将值对象改为引用对象) 从一个类衍生出多个相等的实例，希望它们是同一个对象；将值对象变成引用对象； 多个Order共享同一个Customer对象 引用对象都代表真实世界中的一个实物，可以用==直接检查两个对象是否相等；如“客户”、“账户”等.. 值对象不可变，完全由其数据值来定义，有多个副本存在，需要复写equals()判断是否相等，如“日期”、“钱”.. Change Reference to Value(将引用对象改为值对象) 有一个引用对象，很小且不可变，将它改为值对象。 值对象是“不可变”（immutable）的，表示对象自身是不可变的。判断相等用equals()方法 Replace Array with Object(以对象代替组数) 有一个数组，其中的元素各自代表不同的东西 以对象代替数组，对于数组中的每一个元素，以一个字段来表示 Duplicate Observed Data(复制“被监视的数据”) 有一些领域（Model）数据置身于GUI控件中，而领域函数需要访问需要访问这数据； 将该数据复制到领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据； Change Unidirectional Association to Bidirectional(将单向关联改为双向关联) 场景：两个类都需要使用对方的特性，但只有一条单向关联 实现：添加一个反向指针，并使修改函数能够同事更新两条连接 决定哪个类是控制端；控制端（提供控制函数，维护反向指针），修改函数调用控制函数；被控制端（提供一个辅助函数提供反向指针），修改函数调用控制端的控制函数。 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联) 场景：两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性； 去除不必要的关联 Replace Magic Number with Symbolic Constant(以字面常量代替魔法数) 创建一个常量，根据其意义命名，替换上述魔法数 Encapsulate Field(封装字段) 将public字段声明为private，并提供相应的get/set访问函数 Encapsulate Collection(封装集合) 场景：有一个函数返回一个集合 优化：让这个函数返回该集合的一个只读副本，并提供添加／移除该集合元素的方法 Replace Record with Data Class(以数据类取代记录) 为记录结构型数据创建一个数据对象 Replace Type Code with Class(以类取代类型码) 场景：类中又一个数值类型码，但它并不影响类的行为 以一个新的类替换该数值类型码 Replace Type Code with Subclasses(以子类取代类型码) 场景：有一个不可变的类型码，它会影响类的行为 重构：以字类取代这个类型码，借助多态实现变化行为,将和特定字类相关的字段／函数push down到字类 Replace Type Code with State/Stratege(以状态／策略取代类型码) 场景：如果一个类型码的值在对象生命周期发生变化或者其他原因是宿主类不能被继承； 重构：以状态对象或策略模式取代类型码 Replace Subclass with Fields(以字段代替子类) 场景：各个子类的唯一差别只在“返回常量数据”的函数身上 重构：修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类 ​ 简化条件表达式 Decompose Conditional(简化条件表达式) 场景：有一个复杂的条件if-then-else语句 从if、then、else段落中分别提炼出独立的函数，函数名可以直观反映出函数的用途 Consolidate Conditional Expression(合并条件表达式) 场景：有一系列的条件测试，均得到相同的结果 重构：将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立的函数 使用||、&amp;&amp;、？：合并测试条件 Consolidate Duplicate Conditional Fragments(合并重复的条件片段) 场景：在条件表达式的每个分支上都有相同的一段代码 重构：将这段代码搬移到条件表达式外，并提炼出独立函数 Remove Control Flag(移除控制标记) 在一系列的布尔表达式中，某个变量带有控制标记（control flag）的作用 以break或者return语句取代这个控制标记 Replace Nested Conditional with Guard Clauses(以位语句取代嵌套的条件表达式) 场景：函数中条件逻辑使人迷惑 重构：使用卫语句表现所有特殊情况，立即返回结果；最后处理正常逻辑； 使用卫语句检查特殊条件，立刻返回或抛出异常； 可以先将条件表达式反转实现卫语句（P253）； Replace Conditional with Polymorphism(以多态取代条件表达式) 场景：有一个条件表达式，根据对象类型的不同选择不同的行为 重构：将这个条件表达式的每个分支放进一个子类的复写函数中，然后将原始的函数声明为抽象 在使用Replace Coditional with Polymorphism之前,必须建立一个继承结构：优先使用Repalce Type Code with Subclass，但是如果需要在对象创建后修改类型码，就不能用继承手法，那么使用 Replace Type Code with State/Stratege; Introduce Null Object(引入Null对象) 场景：你需要再三检查某个对象是否为null 重构：建立Null对象，替换null值的判断 空对象继承源对象，或者实现Null Interface；空对象一定是一个常量，它的任何成分都不会变化； Introduce Assertion(引入断言) 某一段代码需要对程序状态作出假设，以断言明确表示这种假设 简化函数调用 Rename Method(函数改名) 给每一个函数取一个可以揭示函数用途的、直观的名字 Add Parameter(添加参数) 为此函数添加一个对象参数，让该对象参数带进函数所需信息 Remove Parameter(移除参数) 移除多余的参数 Separate Query from Modifier(将查询函数和修改函数分离) 场景：某个函数既返回对象状态值，有修改对象状态 重构：建立两个独立的函数，一个负责查询，另一个负责修改 注意并发编程中，可保留查询-修改函数，调用各自独立的查询函数和修改函数，并声明为synchronised Parameterize Method(令函数携带参数) 若干函数做了类似的工作，但因少数几个值致使行为略有不同 建立单一函数，以参数表达那些不同的值 Replace Parameter with Explicit Method(以明确函数取代参数) 有一个函数安全取决于参数值而采取不同的行为 针对该参数的每一个可能值，建立一个独立函数；相反与Parameterize Method Preserve Whole Object(保持完整对象) 场景：你从对象中取出一些值，将它们作为参数传递给函数 重构：改为传递整个对象 Replace Parameter with Methods(以函数取代参数) 场景：对象调用一个函数，并将所得的结果作为参数，传递给另一个函数 重构：让参数接收这去处该项参数，并直接调用前一个函数 如果函数可以通过其他途径获取参数值，那么就应该去除该多余的参数 Introduce Parameter Object(引入参数对象) 场景：某些参数总是很自然的同时出现 重构：以一个对象取代这些参数，比如Range模式，范围对象取代(start,end) Remove Setting Method(移除设值函数) 场景：类中的某个字段应该在对象创建的时候被设值，然后不再改变 重构：去除该字段所有设值函数，同时声明该字段为final Hide Method(隐藏函数) 有一个函数从类没有被其他任何类用到过 将这个函数修改为private Replace Constructor with Factory Method(以工厂函数取代构造函数) 场景：在派生子类的过程中，需要根据类型码，创建相应的对象 重构：使用工厂函数取代构造函数 Encapsulate Downcast(封装向下转型) 场景：某个函数返回的对象需要由函数的调用者执行向下转型 重构：将向下转型的动作移到函数中 123Object lastReading() &#123; return reading.lastElement();&#125; 改为： 123Reading lastReading() &#123; return (Reading)reading.lastElement();&#125; Replace Error Code with Exception(以异常取代错误码) 场景：某个函数返回一个特定的代码，表示某种错误的情况 重构：改用异常 12345678int withdraw(int amount) &#123; if(amount &gt; _balance) &#123; return -1; &#125; else &#123; _balance -= amount; return 0; &#125;&#125; 改为： 1234void withdraw(int amount) throws BalanceException &#123; if(amount &gt; _balance) throw new BalanceExctption(); _balance -= amount;&#125; 决定函数应该抛出受控异常（checked）还是非受控异常（unchecked） 如果函数的调用者有责任在调用前检查必要状态，就抛出unchecked异常 抛出checked异常可以新建一个异常类继承Exception，或者使用现有的checked异常类 Replace Exception with Test(以测试取代异常) 场景：面对一个调用者可以预先检查的条件，你抛出了一个异常 修改调用者，使它在函数调用之前预先检查 1234567double getValueForPeriod(int periodNumber) &#123; try &#123; return _values[periodNumber]; &#125; catch(ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125; 改为： 1234double getValueForPeriod(int periodNumber) &#123; if ( periodNumber &gt;= _values.length ) return 0; return _values[periodNumber];&#125; 异常应该只被用于那些产生意料之外的错误行为，而不应该成为条件检查的工具；不要用try-catch语句作为条件判断语句； 概括处理关系 Pull Up Field(字段上移) 如果两个子类拥有相同的字段，将该子段移到超类 Pull Up Method(函数上移) 场景：有些函数在子类中产生完全相同的结果 重构：将该函数移至超类 Pull Up Method过程中最麻烦的一点就是：被提升的函数可能会引用只出现在子类而不出现在超类的特性。 如果被引用的是一个函数，你可以将该函数一同提升到超类；或者在超类中建立一个抽象函数；或者建立一个委托函数 如果被引用的是子类的字段，你可以将该字段也提升到超类；或者先在子类中自封装字段，然后在超类中把取值函数声明为抽象 Pull Up Constructor Body(构造函数本体上移) 在子类中各拥有一些构造函数，它们的本体几乎一致 在超类中新建一个构造函数，并在子类构造函数中调用它 Pull Down Method(函数下移) 超类中的某个函数只与部分（而非全部）子类有关，将这个函数移到相关的那些子类中去 Pull Down Field(字段下移) 超类中的某个字段只被部分（而非全部）子类所用到，将这个字段移到需要它的那个子类中去 Extract SubClass(提炼子类) 场景：类中的某些特性只被某些（而非全部）实例用到 重构：新建一个子类，将上述一部分特性移到子类中 Extract SuperClass(提炼超类) 场景：两个类具有相似的特性 重构：为这两个类建立一个超类，将这些相同的特性搬移到超类 Extract Interface(提炼接口) 场景：若干客户使用类接口中的同一子集，或者两个类的接口有相同的部分 重构：将相同的子集提炼到一个独立的接口中 Collapse Hierarchy(折叠继承体系) 超类和子类之间无太大区别，将它们合为一体 From Template Method(塑造模版函数) 场景：你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作细节上有所不同 重构：将这些细节操作分别放进独立的函数中，并保持它们都有相同的签名，于是原函数也变得相同了；然后将原函数上移到超类 Replace Inheritance with Delegation(以委托取代继承) 场景：某些子类只使用超类接口中的一部分，或者根本不需要继承而来的数据 重构：在子类中新建一个子段用以保存超类；调整子类函数令它委托超类；然后去掉继承关系 Replace Delegation with Inheritance(以继承取代委托) 场景：你在两个类之间使用委托关系，并经常为整个接口编写很多及其简单的委托函数 重构：让委托类继承受托类 大型重构 Tease Apart Inheritance(梳理并分解继承体系) 场景：某个继承体系同时承担两项责任 重构：建立两个继承体系，并通过委托关系让其中一个可以调用另一个 Convert Procedural Design to Objects(将过程化设计转化为对象设计) 场景：你手中有一些传统过程化风格的代码 重构：将数据记录变为对象，将大块行为分为小块，并将行为移入相关对象之中 Separate Domain from Presentation(将领域和显示分离) 某些GUI类中包含了领域逻辑 将领域逻辑分离出来，为它们建立独立的领域类 Extract Hierarchy(提炼继承体系) 场景：你有某个类做了大量的工作，其中一部分工作是以大量的条件表达式完成的 重构：建立继承体系，以一个子类表示一种特殊情况]]></content>
      <categories>
        <category>重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>refactor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2017%2F05%2F16%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Generate static files1$ hexo generate More info: Generating Run server1$ hexo server More info: Server Deploy to remote sites1$ hexo deploy BenefitsWith this feature, now you can put all your configurations into one place (source/_data/next.yml), you don’t need to touch next/_config.yml. If there are any new options in new releases, you just need to copy those options from next/_config.yml, paste into _data/next.yml and set their values to whatever you want. How to use this feature Please ensure you are using Hexo 3 (or above) Create an file named next.yml in site’s source/_data directory (create _data directory if it did not exist) Copy NexT theme options both in site’s _config.yml and theme’s _config.yml into next.yml. Use --config source/_data/next.yml parameter to start server, generate or deploy.For example: hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml. More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
