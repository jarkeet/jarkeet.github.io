<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[gitÈÖçÁΩÆÂ§ö‰∏™SSH Key]]></title>
    <url>%2F2019%2F06%2F15%2Fgit%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key%2F</url>
    <content type="text"><![CDATA[gitÈÖçÁΩÆÂ§ö‰∏™SSH KeyÂΩìÊúâÂ§ö‰∏™gitË¥¶Âè∑Êó∂ÔºåÊØîÂ¶ÇÔºö ‰∏Ä‰∏™githubÔºåÂõΩÈôÖËÆ§ÂèØÁöÑ‰ªìÂ∫ì ‰∏Ä‰∏™giteeÁ†Å‰∫ëÔºåÂõΩÂÜÖ‰ªìÂ∫ìÔºåÈÄüÂ∫¶Âø´ Ëøô‰∏§ËÄÖÂ¶ÇÊûúÈÇÆÁÆ±‰∏çÂêåÁöÑËØùÔºåÂú®ÁîüÊàêÁ¨¨‰∫å‰∏™keyÁöÑÊó∂ÂÄô‰ºöË¶ÜÁõñÁ¨¨‰∏Ä‰∏™ÁöÑkeyÔºåÂØºËá¥‰∏Ä‰∏™Áî®‰∏ç‰∫Ü„ÄÇ Ëß£ÂÜ≥ÂäûÊ≥ïÂ∞±ÊòØÔºö ÁîüÊàê‰∏§‰∏™ÔºàÊàñÂ§ö‰∏™Ôºâ‰∏çÂêåÁöÑÂÖ¨ÁßÅÂØÜÈí•ÂØπÔºåÁî®configÊñá‰ª∂ÁÆ°ÁêÜÂÆÉ‰ª¨„ÄÇ 1 Ê≠•È™§Êàë‰ª¨ÂÅáËÆæÂéüÊù•Âú®~/.sshÁõÆÂΩï‰∏ãÂ∑≤ÁªèÁîüÊàê‰∫Ü‰∏Ä‰∏™ÂØÜÈí•ÂØπÔºö 12id_rsaid_rsa.pub 1.1 ÁîüÊàêÁ¨¨‰∫å‰∏™keyÊé•‰∏ãÊù•Êàë‰ª¨ÁîüÊàêÁ¨¨‰∫å‰∏™ssh keyÔºö 1ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot; ËøôÈáå‰∏çË¶Å‰∏ÄË∑ØÂõûËΩ¶ÔºåÊàë‰ª¨Ëá™Â∑±ÊâãÂä®Â°´ÂÜô‰øùÂ≠òË∑ØÂæÑÔºö Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Gary/.ssh/id_rsa): /c/Users/Gary/.ssh/id_rsa_github&lt;Ââ©‰∏ã‰∏§‰∏™Áõ¥Êé•ÂõûËΩ¶&gt; ËøôÈáåÊàë‰ª¨Áî®id_rsa_githubÊù•Âå∫Âà´ÂéüÊúâÂØÜÈí•ÂØπÔºåÈÅøÂÖçË¢´Ë¶ÜÁõñ„ÄÇ ÂÆåÊàê‰πãÂêéÔºåÊàë‰ª¨ÂèØ‰ª•ÁúãÂà∞~/.sshÁõÆÂΩï‰∏ãÂ§ö‰∫Ü‰∏§‰∏™Êñá‰ª∂ÔºåÂèòÊàêÔºö id_rsa id_ras.pub id_rsa_github id_rsa_github.pub known_hosts 1.2 ÊâìÂºÄssh-agentËøôÈáåÂ¶ÇÊûú‰Ω†Áî®ÁöÑgithubÂÆòÊñπÁöÑbashÔºåÁî®Ôºö 1ssh-agent -s Â¶ÇÊûúÊòØÂÖ∂‰ªñÁöÑÔºåÊØîÂ¶ÇmsysgitÔºåÁî®Ôºö 1eval $(ssh-agent -s) Áï•ËøáËøô‰∏ÄÊ≠•ÁöÑËØùÔºå‰∏ã‰∏ÄÊ≠•‰ºöÊèêÁ§∫ËøôÊ†∑ÁöÑÈîôËØØÔºöCould not open a connection to your authentication agent. 1.3 Ê∑ªÂä†ÁßÅÈí•12ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_github Â¶ÇÊûúÊèêÁ§∫Êñá‰ª∂ÊàñÁõÆÂΩï‰∏çÂ≠òÂú®ÔºåÂ∞±‰ΩøÁî®ÁªùÂØπÂú∞ÂùÄ„ÄÇ 1.4 ÂàõÂª∫configÊñá‰ª∂Âú®~/.sshÁõÆÂΩï‰∏ãÂàõÂª∫Âêç‰∏∫configÁöÑÊñá‰ª∂„ÄÇ Ê∑ªÂä†‰∏Ä‰∏ãÂÜÖÂÆπÔºö 1234567891011# gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee# github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github ÂÖ∂‰∏≠ÔºåHostÂíåHostNameÂ°´ÂÜôgitÊúçÂä°Âô®ÁöÑÂüüÂêç„ÄÇ IdentityFileÊåáÂÆöÁßÅÈí•ÁöÑË∑ØÂæÑ„ÄÇ Â¶ÇÊûúÂú®LinuxÁ≥ªÁªü‰∏ãÊèêÁ§∫ÈîôËØØÔºöBad owner or permissions on /home/gary/.ssh/config ËØ¥ÊòéconfigÊùÉÈôêËøáÂ§ßÔºåchmodÂëΩ‰ª§Ë∞ÉÊï¥Ôºö 1$ chmod 644 ~/.ssh/config ÁÑ∂ÂêéÂú®githubÂíågiteeÁ†Å‰∫ë‰∏äÊ∑ªÂä†ÂÖ¨Èí•Âç≥ÂèØÔºåËøôÈáå‰∏çÂÜçÂ§öËØ¥„ÄÇ 1.5 ÊµãËØïÁÑ∂ÂêéÁî®sshÂëΩ‰ª§ÂàÜÂà´ÊµãËØïÔºö 1ssh -T git@github.com 2 Ë∞ÉËØïÂ¶ÇÊûúÂà∞ËøôÈáå‰Ω†Ê≤°ÊúâÊàêÂäüÁöÑËØùÔºåÂà´ÊÄ•ÔºåÊïô‰Ω†Ëß£ÂÜ≥ÈóÆÈ¢òÁöÑÁªàÊûÅÂäûÊ≥ï--debug ÊØîÂ¶ÇÊµãËØïgithubÔºö 1ssh -vT git@github.com -v ÊòØËæìÂá∫ÁºñËØë‰ø°ÊÅØÔºåÁÑ∂ÂêéÊ†πÊçÆÁºñËØë‰ø°ÊÅØËá™Â∑±ÂéªËß£ÂÜ≥ÈóÆÈ¢òÂêß„ÄÇ Â∞±ÊàëËá™Â∑±Êù•ËØ¥‰∏ÄËà¨ÊòØconfigÈáåÁöÑhostÈÇ£ÂùóÂÜôÈîô‰∫Ü„ÄÇ 3 ÂÖ≥‰∫éÁî®Êà∑ÂêçÂ¶ÇÊûú‰πãÂâçÊúâËÆæÁΩÆÂÖ®Â±ÄÁî®Êà∑ÂêçÂíåÈÇÆÁÆ±ÁöÑËØùÔºåÈúÄË¶Åunset‰∏Ä‰∏ã 12git config --global --unset user.namegit config --global --unset user.email ÁÑ∂ÂêéÂú®‰∏çÂêåÁöÑ‰ªìÂ∫ì‰∏ãËÆæÁΩÆÂ±ÄÈÉ®ÁöÑÁî®Êà∑ÂêçÂíåÈÇÆÁÆ±ÊØîÂ¶ÇÂú®ÂÖ¨Âè∏ÁöÑrepository‰∏ã 12git config user.name "yourname" git config user.email "youremail" Âú®Ëá™Â∑±ÁöÑgithubÁöÑ‰ªìÂ∫ìÂú®ÊâßË°åÂàöÂàöÁöÑÂëΩ‰ª§‰∏ÄÈÅçÂç≥ÂèØ„ÄÇ ËøôÊ†∑Â∞±ÂèØ‰ª•Âú®‰∏çÂêåÁöÑ‰ªìÂ∫ìÔºåÂ∑≤‰∏çÂêåÁöÑË¥¶Âè∑ÁôªÂΩï„ÄÇ]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ËÅäËÅäÊÄßËÉΩ‰ºòÂåñ]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Â∏ÉÂ±Ä‰ºòÂåñ Â∞ΩÈáèÂáèÂ∞ëÂµåÂ•ó include„ÄÅmerge„ÄÅViewStub ÂáèÂ∞ëËøáÂ∫¶ÁªòÂà∂ backgroudÂ±ûÊÄß‰∏çË¶ÅÈáçÂ§çËÆæÁΩÆ ÁÆÄÂçïÈ°µÈù¢‰ºòÂÖà‰ΩøÁî®LinearLayout „ÄÅFrameLayout„ÄÅÂ§çÊùÇÈ°µÈù¢‰ΩøÁî®ConstraintLayout onDraw‰∏çË¶ÅÂÅöËÄóÊó∂‰ªªÂä°Ôºå‰∏çË¶ÅÂæ™ÁéØÂàõÂª∫Â§ßÈáèÂØπË±° ‚Äã Ê∏≤ÊüìÈóÆÈ¢ò ËøáÂ∫¶ÁªòÂà∂ÔºàËÆæÁΩÆ ‚Äî ÂºÄÂèëËÄÖÈÄâÈ°π ‚Äî Ë∞ÉËØïGPUËøáÂ∫¶ÁªòÂà∂‚Äîx4Ê¨°Á∫¢Ëâ≤ÊòæÁ§∫Ôºâ ‚Äã 1„ÄÅÁßªÈô§Êàñ‰øÆÊîπTheme„ÄÅWindowÈªòËÆ§ÁöÑBackground 2„ÄÅÁßªÈô§XMLÂ∏ÉÂ±ÄÊñá‰ª∂‰∏≠ÈùûÂøÖÈúÄÁöÑBackground 3„ÄÅÊåâÈúÄÊòæÁ§∫Âç†‰ΩçËÉåÊôØÂõæÁâá 4„ÄÅÊéßÂà∂ÁªòÂà∂Âå∫Âüü Â∏ÉÂ±Ä‰ºòÂåñ ÂáèÂ∞ëÂ∏ÉÂ±ÄÂµåÂ•óÂíåÂ±ÇÁ∫ß merge„ÄÅinclude„ÄÅViewStub Êü•ÁúãÊ∏≤ÊüìÊÄßËÉΩÂ∑•ÂÖ∑ GPUÂëàÁé∞Ê®°ÂºèÂàÜÊûê GPU monitor ÂêØÁî®‰∏•Ê†ºÊ®°ÂºèÔºö‰∏ªÁ∫øÁ®ã‰∏äÊâßË°åÈïøÊó∂Èó¥Êìç‰Ωú‰ºöÈó™ÁÉÅÂ±èÂπï ÊÄßËÉΩ‰ºòÂåñÂøÖÂ§áÁ•ûÂô®LintÊ£ÄÊü•Â∑•ÂÖ∑ÔºåPerformance ÂÜÖÂ≠ò‰ºòÂåñÂÜÖÂ≠òÊ≥ÑÊºè ÈõÜÂêàÁ±ªÊ≥ÑÊºè Âçï‰æã/ÈùôÊÄÅÂèòÈáèÈÄ†ÊàêÁöÑÂÜÖÂ≠òÊ≥ÑÊºè ÂåøÂêçÂÜÖÈÉ®Á±ª/ÈùûÈùôÊÄÅÂÜÖÈÉ®Á±ª ËµÑÊ∫êÊú™ÂÖ≥Èó≠ÈÄ†ÊàêÁöÑÂÜÖÂ≠òÊ≥ÑÊºè ÂàÜÊûêÂ∑•ÂÖ∑ÔºöMemory Profiler„ÄÅ Leakcanary„ÄÅMAT„ÄÅTraceView„ÄÅGTÔºàËÖæËÆØÁßªÂä®Ë∞ÉËØïÂπ≥Âè∞Ôºâ ÂÜÖÂ≠òÊµ™Ë¥π ‰ΩøÁî®ArrayMap„ÄÅSparseArrayÔºàÈÅøÂÖç‰∫ÜËá™Âä®Ë£ÖÁÆ±Ôºâ‰ª£ÊõøHashMap ÈÅøÂÖç‰ΩøÁî®EnumÔºåÂÜÖÂ≠òËÄóË¥πÊòØfinal static int ÁöÑ10Âá†ÂÄç ÂÜÖÂ≠òÊäñÂä®ÔºöÈÅøÂÖçÂæ™ÁéØ‰ΩìÂÜÖÂ§ßÈáèÂàõÂª∫Â§ßÂûãÂØπË±° ‚Äã ÂêØÂä®ÈÄüÂ∫¶‰ºòÂåñÊÄùË∑ØÔºöApplication„ÄÅActivityÂàõÂª∫‰ª•ÂèäÂõûË∞ÉÁ≠âËøáÁ®ã ÂêØÂä®È°µËÆæÁΩÆwindowBackgroundÂ±ûÊÄßÔºåÂø´ÈÄüÂ±ïÁ§∫Âá∫Êù•‰∏Ä‰∏™ÁïåÈù¢Ôºõ ÈÅøÂÖçÂú®ÂêØÂä®Êó∂ÂÅöÂØÜÈõÜÊ≤âÈáçÁöÑÂàùÂßãÂåñÔºàHeavy app initializationÔºâÔºõ 1„ÄÅÊØîÂ¶ÇÂÉèÂèãÁõüÔºåbuglyËøôÊ†∑ÁöÑ‰∏öÂä°ÈùûÂøÖË¶ÅÁöÑÂèØ‰ª•ÁöÑÂºÇÊ≠•Âä†ËΩΩ„ÄÇ 2„ÄÅÊØîÂ¶ÇÂú∞ÂõæÔºåÊé®ÈÄÅÁ≠âÔºåÈùûÁ¨¨‰∏ÄÊó∂Èó¥ÈúÄË¶ÅÁöÑÂèØ‰ª•Âú®‰∏ªÁ∫øÁ®ãÂÅöÂª∂Êó∂ÂêØÂä®„ÄÇÂΩìÁ®ãÂ∫èÂ∑≤ÁªèÂêØÂä®Ëµ∑Êù•‰πãÂêéÔºåÂú®ËøõË°åÂàùÂßãÂåñ„ÄÇ 3„ÄÅÂØπ‰∫éÂõæÁâáÔºåÁΩëÁªúËØ∑Ê±ÇÊ°ÜÊû∂ÂøÖÈ°ªÂú®‰∏ªÁ∫øÁ®ãÈáåÂàùÂßãÂåñ‰∫Ü„ÄÇ ÂêåÊó∂Âõ†‰∏∫Êàë‰ª¨‰∏ÄËà¨‰ºöÊúâÈó™Â±èÈ°µÈù¢Ôºå‰πüÂèØ‰ª•ÊääÂª∂Êó∂ÂêØÂä®ÁöÑÂú∞ÂõæÔºåÊé®Âä®ÁöÑÂêØÂä®Âú®Ëøô‰∏™Êó∂Èó¥ÊÆµÈáåÔºåËøôÊ†∑ÂêàÁêÜÂÆâÊéíÊó∂Èó¥ÁâáÁöÑ‰ΩøÁî®„ÄÇÊûÅÂ§ßÁöÑÊèêÈ´ò‰∫ÜÂêØÂä®ÈÄüÂ∫¶„ÄÇ ‚Äã ÈÅøÂÖçI/OÊìç‰Ωú„ÄÅÂèçÂ∫èÂàóÂåñ„ÄÅÁΩëÁªúÊìç‰Ωú„ÄÅÂ∏ÉÂ±ÄÂµåÂ•óÁ≠â„ÄÇ ApkÂ§ßÂ∞è‰ºòÂåñ lintÂ∑•ÂÖ∑ÂéªÈô§Êó†Áî®ËµÑÊ∫ê ÂºÄÂêØÊ∑∑Ê∑ÜÂíåËµÑÊ∫êÂéãÁº© shrinkResources true minifyEnabled true Âà©Áî®shapeÂíåcolorTintÂáèÂ∞ëÈÉ®ÂàÜÂõæÁâá ÂõæÁâáÂéãÁº© webp„ÄÅpngcrush Áü¢ÈáèÂõæÂΩ¢VectorDrawable Êèí‰ª∂ÂåñÈÉ®ÁΩ≤ ËÄóÁîµ‰ºòÂåñ Êõ¥ÁªÜÁöÑËÄóÁîµÂàÜÊûêÂèØ‰ª•‰ΩøÁî®Ëøô‰∏™Battery Historian ‰ΩøÁî®JobScheduler JobSchedulerÊù•Ë∞ÉÊï¥‰ªªÂä°‰ºòÂÖàÁ∫ßÁ≠âÁ≠ñÁï•Êù•ËææÂà∞Èôç‰ΩéÊçüËÄóÁöÑÁõÆÁöÑ, ÈÅøÂÖçÈ¢ëÁπÅÁöÑÂî§ÈÜíÁ°¨‰ª∂Ê®°ÂùóÔºåÈÄ†Êàê‰∏çÂøÖË¶ÅÁöÑÁîµÈáèÊ∂àËÄó„ÄÇÈÅøÂÖçÂú®‰∏çÂêàÈÄÇÁöÑÊó∂Èó¥(‰æãÂ¶Ç‰ΩéÁîµÈáèÊÉÖÂÜµ‰∏ã„ÄÅÂº±ÁΩëÁªúÊàñËÄÖÁßªÂä®ÁΩëÁªúÊÉÖÂÜµ‰∏ãÁöÑ)ÊâßË°åËøáÂ§öÁöÑ‰ªªÂä°Ê∂àËÄóÁîµÈáè„ÄÇ ÊáíÊÉ∞Á¨¨‰∏ÄÁöÑÊ≥ïÂàô: ÂáèÂ∞ëÈáçÂ§çÊìç‰Ωú„ÄÅÊé®ËøüÊâßË°å„ÄÅÂêàÂπ∂Â§ÑÁêÜ ÁâπÂà´ÂÖ≥Ê≥®WakeLock„ÄÅGPS„ÄÅËìùÁâôÁ≠âËÄóÁîµ‰∏öÂä° BitMap‰ºòÂåñ ÂØπÂõæÁâáË¥®ÈáèËøõË°åÂéãÁº© ÂØπÂõæÁâáÂ∞∫ÂØ∏ËøõË°åÂéãÁº© ‰ΩøÁî®libjpeg.soÂ∫ìËøõË°åÂéãÁº© RecyclerView ÂàÜÈ°µÂä†ËΩΩÔºåListView‰ΩøÁî®ViewHolder ÁΩëÁªú‰ºòÂåñ Â∑•ÂÖ∑ÔºöWireShark„ÄÅFiddler„ÄÅCharles„ÄÅNetWork Profiler ÂáèÂ∞ëÁΩëÁªúËØ∑Ê±ÇÈ¢ëÊ¨°„ÄÅApiÊé•Âè£ÂêàÂπ∂ËØ∑Ê±Ç GzipÂéãÁº©ÔºåÁî®Protocol Buffer‰ª£ÊõøJson ÂàóË°®Âä†ËΩΩËØ∑Ê±ÇÁº©Áï•Âõæ„ÄÅwebp„ÄÅÂõæÁâáÁºìÂ≠ò IPÁõ¥ËøûÔºåÁúÅÂéªDNSËß£ÊûêËøáÁ®ã ÂÖ∂‰ªñ‰ºòÂåñ ‰∏ªÁ∫øÁ®ãÈÅøÂÖçËÄóÊó∂Êìç‰Ωú„ÄÅÂºÇÊ≠•Â§ÑÁêÜ ÈááÁî®Á∫øÁ®ãÊ±†„ÄÅÈÅøÂÖçÁ∫øÁ®ãÂàáÊç¢ÂºÄÈîÄ GoogleÂÆòÊñπÂª∫ËÆÆ: Performance Android Performance Patterns ËßÜÂ±è Áõ∏ÂÖ≥Â≠¶‰π†Êï¥ÁêÜÂèØ‰ª•ÂâçÂæÄËÉ°ÂáØÂ§ß‰Ω¨ÁöÑÂçöÂÆ¢ÈòÖËØªÔºåÊÑüË∞¢‰ªñÁöÑÊó†ÁßÅÂàÜ‰∫´Ôºö Android ÊÄßËÉΩ‰ºòÂåñÂÖ∏ËåÉ - Á¨¨ 1 Â≠£ Android ÊÄßËÉΩ‰ºòÂåñÂÖ∏ËåÉ - Á¨¨ 2 Â≠£ Android ÊÄßËÉΩ‰ºòÂåñÂÖ∏ËåÉ - Á¨¨ 3 Â≠£ Android ÊÄßËÉΩ‰ºòÂåñÂÖ∏ËåÉ - Á¨¨ 4 Â≠£ Android ÊÄßËÉΩ‰ºòÂåñÂÖ∏ËåÉ - Á¨¨ 5 Â≠£ Android ÊÄßËÉΩ‰ºòÂåñÂÖ∏ËåÉ - Á¨¨ 6 Â≠£]]></content>
      <categories>
        <category>ÊÄßËÉΩ‰ºòÂåñ</category>
      </categories>
      <tags>
        <tag>ÊÄßËÉΩ‰ºòÂåñ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RetrofitÊ∫êÁ†ÅËß£Êûê]]></title>
    <url>%2F2018%2F04%2F10%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Retrofit ÊòØAndroidÂºÄÂèë‰∏≠ÈùûÂ∏∏ÊµÅË°åÁöÑÁΩëÁªúËØ∑Ê±ÇÂ∫ìÔºåÂÆÉËÉΩÂ§üËÆ©ÂºÄÂèëËÄÖ‰ΩøÁî®Êé•Âè£ÂÆö‰πâÂä†Ê≥®Ëß£ÁöÑÊñπÂºèÔºåÈùûÂ∏∏‰ºòÈõÖÁöÑÂèëÈÄÅÁΩëÁªúËØ∑Ê±ÇÔºåÂÖ∂ÂÆûRetrofitÂè™ÊòØÁî®Áªü‰∏ÄÊé•Âè£ÁöÑÊñπÂºèÂ∞ÅË£Ö‰∫ÜÁΩëÁªúËØ∑Ê±ÇÔºåÂ∫ïÂ±ÇÁΩëÁªúËØ∑Ê±ÇËøòÊòØÈÄöËøá OkHttpÊù•ÂÆûÁé∞ÁöÑ „ÄÇÂÖ∂Â∞ÅË£ÖËøáÁ®ãÂçÅÂàÜÁöÑ‰ºòÈõÖÔºåÁî®‰∏§‰∏™Â≠óÊù•Ê¶ÇÊã¨Â∞±ÊòØ‚Äî-Ëß£ËÄ¶„ÄÇ Retrofit GitHub Âú∞ÂùÄÔºöhttps://github.com/square/retrofit ‰∏ãÈù¢ÂÖàÁúã‰∏Ä‰∏ã Retrofit ÁöÑÁÆÄÂçïÂÆûÁî®ÊñπÂºè„ÄÇ Retrofit ‰ΩøÁî®ÊñπÊ≥ïÁõ¥Êé•ÊäÑÂÆòÁΩëÁöÑÔºö Á¨¨‰∏ÄÊ≠•ÔºåÂ£∞Êòé API Êé•Âè£Ôºö 1234public interface GitHubService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125; Á¨¨‰∫åÊ≠•ÔºåÊûÑÈÄ†Âá∫ Retrofit ÂØπË±°Ôºö 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); Á¨¨‰∏âÊ≠•ÔºåÂæóÂà∞ API Êé•Âè£ÔºåÁõ¥Êé•Ë∞ÉÁî®Ôºö 12GitHubService service = retrofit.create(GitHubService.class);//ÂæóÂà∞‰ª£ÁêÜÂØπË±°Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos("octocat"); ÊúÄÂêéÔºåÂ∞±ÊòØË∞ÉÁî® repos ÊâßË°å Call Ôºö 1234// syncrepos.execute();// asyncrepos.enqueue(CallBack callback); ËØ∑Ê±ÇÊ∫êÁ†ÅËß£ÊûêRetrofitËØ∑Ê±ÇÊµÅÁ®ãÂØπÊØî‰∏ÄËà¨ÁöÑOkHttpËØ∑Ê±ÇÊµÅÁ®ãÔºö Êàë‰ª¨ÂÖàÊù•ÁúãÁúãÂèëÂá∫ÁΩëÁªúËØ∑Ê±ÇÈÉ®ÂàÜÁöÑÊ∫êÁ†Å„ÄÇ Retrofit.BuilderÈ¶ñÂÖàÂàáÂÖ•ÁÇπÂ∞±ÊòØ Retrofit.Builder „ÄÇ 123456789101112131415161718192021222324//Retrofit.java#Builderpublic static final class Builder &#123; private final Platform platform; private okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private Executor callbackExecutor; private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform;// Á°ÆÂÆöÂπ≥Âè∞ÔºåÊúâ Android„ÄÅ Java8 ÈªòËÆ§Platform ‰∏âÁßç // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); &#125; public Builder() &#123; this(Platform.get()); &#125; ... &#125; Âú® Retrofit.Builder ‰∏≠Êúâ‰ª•‰∏ãÁöÑÊñπÊ≥ïÔºö platform : Á°ÆÂÆöËøêË°åÂπ≥Âè∞ÔºåAndroidÁéØÂ¢ÉÂØπÂ∫î‰∫éAndroid callFactory Ôºö ËÆæÁΩÆÁΩëÁªúËØ∑Ê±Ç call ÁöÑÂ∑•ÂéÇÔºåÈªòËÆ§Â∞±ÊòØ‰∏äÈù¢ÁöÑOkHttpClient baseUrl Ôºö api ÁöÑ base url addConverterFactory Ôºö Ê∑ªÂä†Êï∞ÊçÆËΩ¨Êç¢Âô®Â∑•ÂéÇ addCallAdapterFactory Ôºö Ê∑ªÂä†ÁΩëÁªúËØ∑Ê±ÇÈÄÇÈÖçÂô®Â∑•ÂéÇ callbackExecutor Ôºö ÂõûË∞ÉÊñπÊ≥ïÊâßË°åÂô®ÔºåÁî®‰∫éÂàáÊç¢Á∫øÁ®ã validateEagerly Ôºö ÊòØÂê¶ÊèêÂâçËß£ÊûêÊé•Âè£ÊñπÊ≥ï Ëøô‰∫õÈÉΩÊòØÁî®Êù•ÈÖçÁΩÆ Builder ÁöÑÔºåËøôËæπÁî®Âà∞‰∫ÜÂª∫ÈÄ†ËÄÖÊ®°Âºè„ÄÇ Âª∫ÈÄ†ËÄÖÊ®°Âºè: Â∞Ü‰∏Ä‰∏™Â§çÊùÇÂØπË±°ÁöÑÊûÑÂª∫‰∏éÂÆÉÁöÑË°®Á§∫ÂàÜÁ¶ªÔºå‰ΩøÂæóÂêåÊ†∑ÁöÑÊûÑÂª∫ËøáÁ®ãÂèØ‰ª•ÂàõÂª∫‰∏çÂêåÁöÑË°®Á§∫„ÄÇ ÈÇ£‰πàÊàë‰ª¨Êù•Áúã‰∏ã Builder ÁöÑÊûÑÈÄ†ÊñπÊ≥ïÔºöÊù•‰∏™Â∞èÊèíÊõ≤ÔºåÊàë‰ª¨Êù•Áúã‰∏ã Retrofit ÊòØÂ¶Ç‰ΩïÁ°ÆÂÆöÂπ≥Âè∞ÁöÑÔºö Platform1234567891011121314151617181920212223242526//Platform.javaclass Platform &#123; private static final Platform PLATFORM = findPlatform(); static Platform get() &#123; return PLATFORM; &#125; private static Platform findPlatform() &#123; try &#123; Class.forName("android.os.Build"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android();//ËøôÈáåÊûÑÂª∫‰∫Ü‰∏Ä‰∏™AndroidÂØπË±° &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName("java.util.Optional"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform(); &#125; ...&#125; ‰ªé‰∏äÈù¢ÁöÑ‰ª£Á†Å‰∏≠ÂèØ‰ª•ÁúãÂà∞ÔºåÊòØÈÄöËøáÂèçÂ∞ÑÊù•Âà§Êñ≠ÂÖ∑‰ΩìÊòØÂì™‰∏™PlatfromÔºåËøô‰∏™Áî®Âà∞ÁöÑÁÆÄÂçïÁöÑÁ≠ñÁï•Ê®°Âºè„ÄÇ Á≠ñÁï•Ê®°ÂºèÔºöÂÆö‰πâ‰∏ÄÁ≥ªÂàóÁöÑÁÆóÊ≥ïÔºåÊääÂÆÉ‰ª¨‰∏Ä‰∏™‰∏™Â∞ÅË£ÖËµ∑Êù•, Âπ∂‰∏î‰ΩøÂÆÉ‰ª¨ÂèØÁõ∏‰∫íÊõøÊç¢„ÄÇ Êé•ÁùÄÔºåÂú®ÂàõÂª∫ Builder ÂØπË±°Âπ∂ËøõË°åËá™ÂÆö‰πâÈÖçÁΩÆÂêéÔºåÊàë‰ª¨Â∞±Ë¶ÅË∞ÉÁî® build() ÊñπÊ≥ïÊù•ÊûÑÂª∫Âá∫ Retrofit ÂØπË±°‰∫Ü„ÄÇÈÇ£‰πàÔºåÊàë‰ª¨Êù•Áúã‰∏ã build() ÊñπÊ≥ïÈáåÂπ≤‰∫Ü‰ªÄ‰πàÔºö 123456789101112131415161718192021222324252627//Retrofit.javapublic Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; // ÁΩëÁªúËØ∑Ê±ÇÊâßË°åÂô® ÈªòËÆ§‰∏∫ OkHttpClient okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // Android Âπ≥Âè∞‰∏ãÈªòËÆ§‰∏∫ MainThreadExecutor ÂèØÂàáÊç¢Âà∞‰∏ªÁ∫øÁ®ã Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); // Android Âπ≥Âè∞‰∏ãÊ∑ªÂä†ÈªòËÆ§ÁöÑ ExecutorCallAdapterFactoryÔºåÊñáÁ´†ÂêéÈù¢‰ºöÂàÜÊûê adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. ÈªòËÆ§Êúâ BuiltInConverters List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly);&#125; Âú® build() ‰∏≠ÔºåÈÖçÁΩÆ‰∫ÜÁΩëÁªúÊâßË°åÂô®OkHttpClient, ÂºÇÊ≠•ÂõûË∞ÉÁ∫øÁ®ãÂàáÊç¢Âô®MainThreadExecutor, ÁΩëÁªúÈÄÇÈÖçÂô®Â∑•ÂéÇÂàóË°®ÔºàÈªòËÆ§Ê∑ªÂä†ExecutorCallAdapterFactoryÔºâÔºåÊï∞ÊçÆËΩ¨Êç¢Âô®Â∑•ÂéÇÂàóË°®(ÈªòËÆ§Ê∑ªÂä†BuiltInConverters),Âπ∂‰ª•Ê≠§ÊûÑÂª∫Âá∫‰∫ÜRetrofitÁ±ª„ÄÇ RetrofitRetrofit Á±ªÁöÑÊûÑÈÄ†ÊñπÊ≥ïÊ≤°‰ªÄ‰πàÂ•ΩÁúãÁöÑÔºåÂè™ÊòØÁÆÄÂçïÁöÑÂ∞ÜBuildÁöÑÂ±ûÊÄß‰æùÊ¨°ËµãÁªôRetrofit„ÄÇ ÂæóÂà∞ Retrofit ÂØπË±°ÂêéÂ∞±ÊòØË∞ÉÁî® create(final Class&lt;T&gt; service) ÊñπÊ≥ïÊù•ÂàõÂª∫Êàë‰ª¨ API Êé•Âè£ÁöÑÂÆû‰æã„ÄÇ ÊâÄ‰ª•Êàë‰ª¨ÈúÄË¶ÅË∑üËøõ create(final Class&lt;T&gt; service) ‰∏≠Êù•Áúã‰∏ãÔºö 12345678910111213141516171819202122232425262728//Retrofit.javapublic &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; //ÁîüÊàêÂä®ÊÄÅ‰ª£ÁêÜÔºåÂêéÈù¢Ë∞ÉÁî®‰ª£ÁêÜÁöÑÊñπÊ≥ïÈÉΩÂ∞ÜËµ∞Âà∞InvocationHandlerÁöÑinvokeÊñπÊ≥ï return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; //Êï≤ÈªëÊùø----&gt;ÊúÄÊúÄÊúÄÈáçË¶ÅÁöÑ3Âè•ËØù ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; Âú®‰∏äÈù¢ÁöÑ‰ª£Á†Å‰∏≠ÔºåÂæàÂ∑ßÂ¶ôÁöÑ‰ΩøÁî®‰∫ÜÂä®ÊÄÅ‰ª£ÁêÜÊ®°ÂºèÔºöÂú®Ë∞ÉÁî®‰ª£ÁêÜÁ±ªÁöÑ‰ªª‰ΩïÊñπÊ≥ïÊó∂ÔºåÈÉΩÂ∞ÜÁªü‰∏ÄÊâßË°åInvocationHandlerÁöÑinvokeÊñπÊ≥ïÔºåÂπ∂Âú®ËøôÈáåÊ∑ªÂä†È¢ùÂ§ñÁöÑÂ§ÑÁêÜ„ÄÇ Âä®ÊÄÅ‰ª£ÁêÜÔºö‰ª£ÁêÜÁ±ªÂú®Á®ãÂ∫èËøêË°åÂâç‰∏çÂ≠òÂú®„ÄÅËøêË°åÊó∂Áî±Á®ãÂ∫èÂä®ÊÄÅÁîüÊàêÁöÑ‰ª£ÁêÜÊñπÂºè„ÄÇ ËøôÁßç‰ª£ÁêÜÊñπÂºèÁöÑ‰∏ÄÂ§ßÂ•ΩÂ§ÑÊòØÂèØ‰ª•Êñπ‰æøÂØπ‰ª£ÁêÜÁ±ªÁöÑÂáΩÊï∞ÂÅöÁªü‰∏ÄÊàñÁâπÊÆäÂ§ÑÁêÜÔºåÂ¶ÇËÆ∞ÂΩïÊâÄÊúâÂáΩÊï∞ÊâßË°åÊó∂Èó¥„ÄÅÊâÄÊúâÂáΩÊï∞ÊâßË°åÂâçÊ∑ªÂä†È™åËØÅÂà§Êñ≠„ÄÅÂØπÊüê‰∏™ÁâπÊÆäÂáΩÊï∞ËøõË°åÁâπÊÆäÊìç‰ΩúÔºåËÄå‰∏çÁî®ÂÉèÈùôÊÄÅ‰ª£ÁêÜÊñπÂºèÈÇ£Ê†∑ÈúÄË¶Å‰øÆÊîπÊØè‰∏™ÂáΩÊï∞„ÄÇ invoke‰∏≠ÁöÑÊ†∏ÂøÉÂ∞±ÊòØ‰ª•‰∏ã3Âè•ËØùÔºö 123456// Â∞ÜÊé•Âè£‰∏≠ÊØè‰∏™ÊñπÊ≥ïÈÖçÁΩÆ‰∏∫‰∏Ä‰∏™ ServiceMethodServiceMethod serviceMethod = loadServiceMethod(method);//Áî®ServiceMethodÂíåargsÊûÑÈÄ†Âá∫‰∏Ä‰∏™ OkhttpCallOkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);//ÊâßË°åÁΩëÁªúÈÄÇÈÖçÂô®ÁöÑadapterÊñπÊ≥ïreturn serviceMethod.callAdapter.adapt(okHttpCall); Ëøô‰∏âÂè•‰ª£Á†ÅÔºå‰∏ãÈù¢Êàë‰ª¨ÈáçÁÇπÂàÜÊûê„ÄÇ Âú®‰ª£ÁêÜ‰∏≠Ôºå‰ºöÊ†πÊçÆÂèÇÊï∞‰∏≠‰º†ÂÖ•ÁöÑÂÖ∑‰ΩìÊé•Âè£ÊñπÊ≥ïÊù•ÊûÑÈÄ†Âá∫ÂØπÂ∫îÁöÑ ServiceMethod „ÄÇServiceMethod Á±ªÁöÑ‰ΩúÁî®Â∞±ÊòØÊääÊé•Âè£ÁöÑÊñπÊ≥ïÈÄÇÈÖç‰∏∫ÂØπÂ∫îÁöÑ HTTP call „ÄÇ 1234567891011121314//Retrofit.javaServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; // ÂÖà‰ªéÁºìÂ≠ò‰∏≠ÂèñÔºåËã•Ê≤°ÊúâÂ∞±ÂéªÂàõÂª∫ÂØπÂ∫îÁöÑ ServiceMethod result = serviceMethodCache.get(method); if (result == null) &#123; // Ê≤°ÊúâÁºìÂ≠òÂ∞±ÂàõÂª∫Ôºå‰πãÂêéÂÜçÊîæÂÖ•ÁºìÂ≠ò‰∏≠ result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; ÂèØ‰ª•ÁúãÂà∞Âú®ÂÜÖÈÉ®ËøòÁª¥Êä§‰∫Ü‰∏Ä‰∏™ Map serviceMethodCache Êù•ÁºìÂ≠ò ServiceMethodÔºåÊèêÈ´òÂà©Áî®ÊïàÁéá„ÄÇServiceMethodÁöÑÂàõÂª∫ËøòÊòØÁî®Âà∞‰∫ÜÂª∫ÈÄ†ËÄÖÊ®°ÂºèÔºåÊù•Â§ç‰π†‰∏Ä‰∏ã „ÄÇ Âª∫ÈÄ†ËÄÖÊ®°Âºè: Â∞Ü‰∏Ä‰∏™Â§çÊùÇÂØπË±°ÁöÑÊûÑÂª∫‰∏éÂÆÉÁöÑË°®Á§∫ÂàÜÁ¶ªÔºå‰ΩøÂæóÂêåÊ†∑ÁöÑÊûÑÂª∫ËøáÁ®ãÂèØ‰ª•ÂàõÂª∫‰∏çÂêåÁöÑË°®Á§∫. ServiceMethodÂèëÁé∞ ServiceMethod ‰πüÊòØÈÄöËøáÂª∫ÈÄ†ËÄÖÊ®°ÂºèÊù•ÂàõÂª∫ÂØπË±°ÁöÑ„ÄÇÂÖàÁúã‰∏ãÂÆÉÁöÑBuilderÔºö 12345678910111213141516171819202122232425262728293031323334353637383940//ServiceMethod.java#Builder static final class Builder&lt;T, R&gt; &#123; final Retrofit retrofit; final Method method; final Annotation[] methodAnnotations; final Annotation[][] parameterAnnotationsArray; final Type[] parameterTypes; Type responseType; boolean gotField; boolean gotPart; boolean gotBody; boolean gotPath; boolean gotQuery; boolean gotUrl; String httpMethod;//GET\POST\PUT boolean hasBody; boolean isFormEncoded; boolean isMultipart; String relativeUrl;//path Headers headers;//Headers MediaType contentType; Set&lt;String&gt; relativeUrlParamNames; ParameterHandler&lt;?&gt;[] parameterHandlers;//Áî®‰∫éËß£ÊûêÊé•Âè£ÁöÑÂèÇÊï∞Ê≥®Ëß£ Converter&lt;ResponseBody, T&gt; responseConverter;//ÊØè‰∏™SeviceMethodÂØπÂ∫î‰∏Ä‰∏™ËøîÂõûÊï∞ÊçÆËΩ¨Êç¢Âô® CallAdapter&lt;T, R&gt; callAdapter;//ÊØè‰∏™SeviceMethodÂØπÂ∫î‰∏Ä‰∏™ÁΩëÁªúÈÄÇÈÖçÂô® Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; //Ëé∑ÂèñmethodÊñπÊ≥ï this.method = method; //Ëé∑ÂèñÊé•Âè£ÊñπÊ≥ïÁöÑÊ≥®Ëß£ this.methodAnnotations = method.getAnnotations(); //Ëé∑ÂèñÊé•Âè£ÊñπÊ≥ïÂèÇÊï∞ÁöÑÁ±ªÂûã this.parameterTypes = method.getGenericParameterTypes(); //Ëé∑ÂèñÊé•Âè£ÊñπÊ≥ïÂèÇÊï∞Ê≥®Ëß£ÁöÑÁ±ªÂûã this.parameterAnnotationsArray = method.getParameterAnnotations(); &#125; ...&#125; Âú®ÊûÑÈÄ†ÊñπÊ≥ï‰∏≠Ëé∑Âèñ‰∫ÜmethodÁöÑÊ≥®Ëß£ÔºåÂèÇÊï∞Á±ªÂûãÊï∞ÁªÑ„ÄÅÂèÇÊï∞Ê≥®Ëß£ÁöÑ‰∫åÁª¥Êï∞ÁªÑÔºåÁÑ∂ÂêéÁúã build() ÊñπÊ≥ïÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//ServiceMethod.java#Builder public ServiceMethod build() &#123; // Ê†πÊçÆÊé•Âè£ÊñπÊ≥ïÁöÑÊ≥®Ëß£ÂíåËøîÂõûÁ±ªÂûãÂàõÂª∫ callAdapter // Ê†πÊçÆmethodÁöÑÊ≥®Ëß£ÂíåËøîÂõûÂÄºÔºåËé∑Âèñretrofit‰∏≠ÂØπÂ∫îÁöÑCallAdapter // Â¶ÇÊûúÊ≤°ÊúâÊ∑ªÂä† CallAdapter ÈÇ£‰πàÈªòËÆ§‰ºöÁî® ExecutorCallAdapterFactoryÊèê‰æõÁöÑcallAdapter callAdapter = createCallAdapter(); // calladapter ÁöÑÂìçÂ∫îÁ±ªÂûã‰∏≠ÁöÑÊ≥õÂûãÔºåÊØîÂ¶Ç Call&lt;User&gt; ‰∏≠ÁöÑ User responseType = callAdapter.responseType();//ËøîÂõûÂÄºÁ±ªÂûã if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError("'" + Utils.getRawType(responseType).getName() + "' is not a valid response body type. Did you mean ResponseBody?"); &#125; // Ê†πÊçÆmethodÁöÑËøîÂõûÂÄºÂíåÊ≥®Ëß£Ëé∑Âèñretrofit‰∏≠ÁöÑ ËøîÂõûÊï∞ÊçÆËΩ¨Êç¢Âô® ResponseConverter responseConverter = createResponseConverter(); // Ê†πÊçÆÊé•Âè£ÊñπÊ≥ïÁöÑÊ≥®Ëß£ÊûÑÈÄ†ËØ∑Ê±ÇÊñπÊ≥ïÔºåÊØîÂ¶Ç @GET @POST @DELETE @PUT @Headers Á≠â for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; if (httpMethod == null) &#123; throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.)."); &#125; // Ëã•Êó† body Âàô‰∏çËÉΩÊúâ isMultipart Âíå isFormEncoded if (!hasBody) &#123; if (isMultipart) &#123; throw methodError( "Multipart can only be specified on HTTP methods with request body (e.g., @POST)."); &#125; if (isFormEncoded) &#123; throw methodError("FormUrlEncoded can only be specified on HTTP methods with " + "request body (e.g., @POST)."); &#125; &#125; // ‰∏ãÈù¢ÁöÑ‰ª£Á†Å‰∏ªË¶ÅÁî®Êù•Ëß£ÊûêÊé•Âè£ÊñπÊ≥ïÂèÇÊï∞‰∏≠ÁöÑÊ≥®Ëß£ÔºåÊØîÂ¶Ç @Path @Query @QueryMap @Field @BodyÁ≠âÁ≠â // Áõ∏Â∫îÁöÑÔºåÊØè‰∏™ÊñπÊ≥ïÁöÑÂèÇÊï∞ÈÉΩÂàõÂª∫‰∫Ü‰∏Ä‰∏™ ParameterHandler&lt;?&gt; ÂØπË±° int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s", parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, "No Retrofit annotation found."); &#125; //ÁúüÁöÑÁöÑËß£ÊûêÂèÇÊï∞Ê≥®Ëß£ÁöÑÂú∞Êñπ parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; // Ê£ÄÊü•ÊûÑÈÄ†Âá∫ÁöÑËØ∑Ê±ÇÊúâÊ≤°Êúâ‰∏çÂØπÁöÑÂú∞ÊñπÔºü if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError("Missing either @%s URL or @Url parameter.", httpMethod); &#125; if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError("Non-body HTTP method cannot contain @Body."); &#125; if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError("Form-encoded method must contain at least one @Field."); &#125; if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError("Multipart method must contain at least one @Part."); &#125; return new ServiceMethod&lt;&gt;(this);&#125; Âú® build() ‰∏≠‰ª£Á†ÅÊå∫ÈïøÁöÑÔºåÊÄªÁªìËµ∑Êù•Â∞±‰∏ÄÂè•ËØùÔºö Ëß£ÊûêAPI Êé•Âè£‰∏≠ÁöÑÊñπÊ≥ïÔºåÊ†πÊçÆÂÖ∂ËøîÂõûÂÄº„ÄÅÊñπÊ≥ïÊ≥®Ëß£„ÄÅÂèÇÊï∞Ê≥®Ëß£Á≠âÈÖçÁΩÆÁªÑÂêàÊàê‰∏Ä‰∏™ServiceMethodÂØπË±°„ÄÇ ÁªÜÂåñ‰∏ãÂ∞±ÊòØÔºö Ê†πÊçÆmethodÁöÑreturnTypeÂíåAnnotationsÂàõÂª∫ÁΩëÁªúÈÄÇÈÖçÂô® CallAdapter Âíå ËøîÂõûÊï∞ÊçÆËΩ¨Êç¢Âô®ConverterÔºõ Ê†πÊçÆmethodÁöÑÊ≥®Ëß£ÊûÑÈÄ†ÁΩëÁªúËØ∑Ê±ÇÊñπÊ≥ïÔºåÊØîÂ¶Ç@GET„ÄÅ@POSTÔºåÂ§¥ÈÉ®Â≠óÊÆµÔºåÁõ∏ÂØπË∑ØÂæÑÁ≠âÔºõ Ê†πÊçÆ methodÂêÑ‰∏™ÂèÇÊï∞ÁöÑÊ≥®Ëß£Â°´ÂÖÖÂà∞parameterHandlers[]ÔºåÊØîÂ¶ÇÊûÑÈÄ†ÂÖ∑‰ΩìÁöÑÁΩëÁªúËØ∑Ê±ÇÁöÑÂèÇÊï∞@Body„ÄÅ @Field„ÄÅ @Query„ÄÅ @PartÁ≠âÔºõ ‰ª£Á†Å‰∏≠ÈÉΩÊòØÊ≥®ÈáäÔºåÂú®ËøôÈáåÂ∞±‰∏çËØ¶ÁªÜÂ§öËÆ≤‰∫ÜÔºåÂà∞ËøôÈáåÁ¨¨‰∏ÄÊ≠•Â¶Ç‰ΩïÊûÑÂª∫ServiceMethodÂ∞±ÂàÜÊûêÂÆå‰∫Ü„ÄÇ 1ServiceMethod serviceMethod = loadServiceMethod(method); ‰∏ãÈù¢ÁúãÁ¨¨‰∫åÂè•ËØùÔºö 1OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); OkHttpCallÁúã‰∏Ä‰∏ã OkHttpCallÁöÑÊûÑÈÄ†ÊñπÊ≥ïÔºåÂè™ÊòØÁÆÄÂçïÁöÑÂ∞ÜServiceMethodÂíåargs‰º†ËøõÊù•ËÄåÂ∑≤Ôºö 1234567891011121314151617181920212223242526272829final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod; private final Object[] args; private volatile boolean canceled; // All guarded by this. private okhttp3.Call rawCall; //ÂéüÂßãÁöÑOkhttp.Call private Throwable creationFailure; // Either a RuntimeException or IOException. private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; ... private okhttp3.Call createRawCall() throws IOException &#123; //ÈÄöËøáServiceMethodÊûÑÂª∫‰∏Ä‰∏™OkHttpÁöÑRequest Request request = serviceMethod.toRequest(args); //ËøôÈáåÁöÑserviceMethod.callFactoryÂ∞±ÊòØOkHttpClientÂØπË±° okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException("Call.Factory returned null."); &#125; return call; &#125;&#125; ËøôÈáåÁöÑOkHttpCallÂÆûÁé∞‰∫Üretrofit2.CallÊé•Âè£Ôºå‰ΩÜÁΩëÁªúËØ∑Ê±ÇÊúÄÁªàËøòÊòØÂßîÊâòÁªô‰∫Üokhttp3.Call rawCallÊù•ÊâßË°åÔºåËøôÈáå‰πüÊúâÁÇπÈÄÇÈÖçÂô®Ê®°ÂºèÁöÑÊÑèÊÄù„ÄÇÂÖà‰∫ÜËß£‰∏ãRetrofitÁöÑCallÊé•Âè£Ôºö 12345678910package retrofit2;public interface Call&lt;T&gt; extends Cloneable &#123; //ÂêåÊ≠•ËØ∑Ê±Ç Response&lt;T&gt; execute() throws IOException; //ÂºÇÊ≠•ËØ∑Ê±Ç void enqueue(Callback&lt;T&gt; callback); ... /** The original HTTP request. */ Request request();&#125; ÂÜçÁúã‰∏Ä‰∏ãcreateRawCall()Â¶Ç‰ΩïÂàõÂª∫‰∏Ä‰∏™rawCallÔºåËøôÈáåÊàë‰ª¨ÂèàÂõûÂà∞‰∫ÜServiceMethodÈáåÈù¢ÔºåËøôÈáåÂàõÂª∫Êù•‰∏Ä‰∏™RequestBuilderËØ∑Ê±ÇÂØπË±°Âª∫ÈÄ†ËÄÖÔºåÈÖçÂêàÂèÇÊï∞Ê≥®Ëß£ParameterHandlerÂ∞ÜargsÈÖçÁΩÆÂà∞RequestBuilder‰∏≠ÔºåÊúÄÂêéÊûÑÂª∫Âá∫‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÁöÑokhttp3.RequestÂØπË±°ÔºåÂÖ∑‰ΩìÂ¶Ç‰∏ãÔºö 123456789101112131415161718192021//ServiceMethod.java /** Builds an HTTP request from method arguments. */ Request toRequest(Object... args) throws IOException &#123; //http method, url, relativeUrl, headers, body, formÂàõÂª∫‰∏Ä‰∏™ÂÆåÊï¥ÁöÑHttpÊ®°ÁâàÂØπË±° RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers; int argumentCount = args != null ? args.length : 0; if (argumentCount != handlers.length) &#123; throw new IllegalArgumentException("Argument count (" + argumentCount + ") doesn't match expected count (" + handlers.length + ")"); &#125; for (int p = 0; p &lt; argumentCount; p++) &#123; handlers[p].apply(requestBuilder, args[p]);//Â∞ÜÁî®Êà∑ÂèÇÊï∞Â°´ÂÖÖÂà∞requestBuilder &#125; return requestBuilder.build(); &#125; RequestBuilderÂØπË±°Ôºå‰ªñÁöÑÊàêÂëòÂåÖÊã¨‰∫ÜhttpÁöÑÂÆåÊï¥ÂÜÖÂÆπmethod, url, relativePath, headers, body, formÁ≠âÂèÇÊï∞Ôºö 1234567891011121314151617final class RequestBuilder &#123; private final String method;//get or post private final HttpUrl baseUrl;//url private String relativeUrl; private HttpUrl.Builder urlBuilder; private final Request.Builder requestBuilder; private MediaType contentType; //type private final boolean hasBody; private MultipartBody.Builder multipartBuilder; private FormBody.Builder formBuilder;//Ë°®Âçï private RequestBody body;//body ...&#125; ÊúÄÂêéË∞ÉÁî®requestBuilder.build()ÊûÑÂª∫‰∫Ü‰∏Ä‰∏™ÁúüÊ≠£ÁöÑËØ∑Ê±Çokhttp3.Request. Êé•ÁùÄÈÄöËøáserviceMethod.callFactory.newCall(request)Â∞±ÊûÑÂª∫Âá∫OkHttpÁöÑrawCallÔºåËøô‰∏™ÁöÑ serviceMethod.callFactoryÁΩëÁªúÊâßË°åÂô®Â∞±ÊòØRetrotifÈªòËÆ§ÁöÑOkHttpClientÂØπË±°„ÄÇ Ê¶ÇÊã¨‰∏Ä‰∏ãÔºöOkHttpCall‰∏≠‰æùËµñ‰∫ÜServiceMethodÂíårawCall,ÈÄöËøáServiceMethodÊûÑÂª∫‰∫Ü‰∏Ä‰∏™ÂéüÂßãÁöÑOkHttp RequestËØ∑Ê±ÇÔºåÂπ∂ÈÄöËøáOkHttpClientÁöÑnewCall(request)ÂàõÂª∫rawCallÊù•ÊâßË°åÁúüÊ≠£ÁöÑÁΩëÁªúËØ∑Ê±Ç„ÄÇ ExecutorCallAdapterFactoryÂú®ÂâçÈù¢RetrofitÁöÑbuildËøáÁ®ã‰∏≠Êàë‰ª¨Áü•ÈÅìPlatformÊòØAndroidÊó∂ÔºåÈªòËÆ§ÁöÑ ÁΩëÁªúÈÄÇÈÖçÂô®Â∑•ÂéÇCallAdapter.FactoryÊòØExecutorCallAdapterFactoryÔºå‰∏ãÈù¢Áúã‰∏Ä‰∏ãËøô‰∏™Â∑•ÂéÇÁöÑÂàõÂª∫ËøáÁ®ãÔºö 12345678910111213141516171819//Platform.javastatic class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; //Áî®‰∫éÂàáÊç¢Âà∞‰∏ªÁ∫øÁ®ã static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; ÂÖ∂‰∏≠ÂåÖÂê´‰∫Ü‰∏Ä‰∏™Á∫øÁ®ãÂàáÊç¢ÁöÑÊâßË°åÂô®MainThreadExecutorÁî®‰∫éÂºÇÊ≠•ÂõûË∞ÉÂàáÊç¢Âõû‰∏ªÁ∫øÁ®ãÊâßË°å„ÄÇ ÈªòËÆ§ÁöÑÁΩëÁªúÈÄÇÈÖçÂô®Â∑•ÂéÇExecutorCallAdapterFactoryÔºåÁªßÊâø‰∫ÜCallAdapter.FactoryÔºåÂÖ∂Ê∫êÁ†ÅËßÅ‰∏ãÔºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//ExecutorCallAdapterFactory.javafinal class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; //Ê†πÊçÆËøîÂõûÂÄºÂíåÊ≥®Ëß£ËøîÂõûÂØπÂ∫îÁöÑCallAdapter @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; //Call&lt;Repo&gt;ÊòØreturnTypeÁ±ªÂûãÔºå‰ªñÁöÑresponseTypeÁ±ªÂûãÊòØRepo. final Type responseType = Utils.getCallResponseType(returnType); //RetrofitÈªòËÆ§ÁöÑÁΩëÁªúÈÄÇÈÖçÂô®CallAdatperÂú®ËøôÈáåËøîÂõûÔºåÂÖ∂ÂÆûÊòØ‰∏™ÂåøÂêçÁ±ªÂØπË±° return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; //ËøôÈáåÁöÑadaptÊñπÊ≥ï‰ºöÂú®Retrofit#create()‰∏≠ÁöÑÁ¨¨‰∏âÂè•ÊúÄÊ†∏ÂøÉ‰ª£Á†ÅË¢´Ë∞ÉÁî®Âà∞‰∫ÜÔºå //ËøôÈáåÁöÑcallÂ∞±ÊòØOkHttpCallÂØπË±° @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; //ExecutorCallbackCallÂÆûÁé∞‰∫ÜÁ∫øÁ®ãÂàáÊç¢ static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate;//ËøôÈáåÁöÑdelegateÂ∞±ÊòØOkHttpCallÂØπË±° ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException("callback == null"); //ÂºÇÊ≠•ÊâßË°åÔºåÂÖ•Èòü delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; //ËøîÂõûreponseÂêéÔºåÂàáÊç¢Âà∞‰∏ªÁ∫øÁ®ãÊâßË°åÔºåÊú¨Ë¥®ÊòØÈÄöËøáhandlerÊù•ÂÆûÁé∞ÁöÑ callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; ... //ÂêåÊ≠•ÊâßË°å @Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute(); &#125; @Override public Request request() &#123; return delegate.request(); &#125; &#125;&#125; ËØ¥ÊòéÂÖ®Âú®Ê≥®ÈáäÈáåÈù¢‰∫ÜÔºåExecutorCallAdapterFactory‰∏ªË¶ÅÊòØËøîÂõû‰∫Ü‰∏Ä‰∏™ÂåøÂêçÁöÑCallAdapter,ËØ•ÈÄÇÈÖçÂô®ËÉΩÂ§üÂ∞ÜÊôÆÈÄöÁöÑCall&lt;T&gt;ÈÄöËøáadapterÈÄÇÈÖç‰∏∫ExecutorCallbackCall&lt;T&gt;ÔºåÊàë‰ª¨ÂõûËøáÂéªÁúãRetrofit#create()‰∏≠ÁöÑÁ¨¨‰∏âÂè•Ê†∏ÂøÉ‰ª£Á†ÅÔºö 1return serviceMethod.callAdapter.adapt(okHttpCall); Ê≤°ÈîôËøôÈáå‰º†ÂÖ•ÁöÑÂ∞±ÊòØOkHttpCallÔºåÈÄöËøáÁΩëÁªúÈÄÇÈÖçÂô®ËøîÂõûÁöÑÊòØ‰∏Ä‰∏™ExecutorCallbackCallÂØπË±°. ExecutorCallbackCall1return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); ÈááÁî®‰∫ÜË£ÖÈ•∞Ê®°ÂºèÔºöExecutorCallbackCall ‰∏∫Ë£ÖÈ•∞ËÄÖÔºåËÄåÈáåÈù¢ÁúüÊ≠£ÂéªÊâßË°åÁΩëÁªúËØ∑Ê±ÇÁöÑËøòÊòØOkHttpCall„ÄÇÈÄöËøá ExecutorCallbackCall ÔºåÊàë‰ª¨ÂèØ‰ª•Ë∞ÉÁî®ÂêåÊ≠•ÊñπÊ≥ï execute() ÊàñÂºÇÊ≠•ÊñπÊ≥ï enqueue(Callback&lt;T&gt; callback) Êù•ÊâßË°åËØ• callÔºåÂºÇÊ≠•Ë∞ÉÁî®ÂêéÁöÑcallback‰ºöÈÄöËøácallbackExecutorÂàáÊç¢Âõû‰∏ªÁ∫øÁ®ãÊâßË°å. ‰∫éÊòØÂßîÊâòÂÖ≥Á≥ªÊòØÔºöExecutorCallbackCall‚Äî&gt;retrofit.OkHttpCall‚Äî&gt;okhttp3.rawCall„ÄÇ Áúã‰∏Ä‰∏ãÂêåÊ≠•ÁöÑexecute()ÊñπÊ≥ïÔºåÂè™ÊòØË∞ÉÁî®‰∫Üdelegate.execute()ÊñπÊ≥ïÔºådelegateÂ∞±ÊòØOkHttpCall„ÄÇ ÂÜçÁúãOkHttpCall#execute()ÊñπÊ≥ïÁúã‰∏Ä‰∏ãÂÆÉÁöÑexecute()ÊñπÊ≥ï: 123456789101112131415161718192021222324252627282930313233343536 @Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; if (creationFailure != null) &#123; if (creationFailure instanceof IOException) &#123; throw (IOException) creationFailure; &#125; else &#123; throw (RuntimeException) creationFailure; &#125; &#125; call = rawCall; if (call == null) &#123; try &#123; // Ê†πÊçÆ serviceMethod ‰∏≠ÁöÑÈÖçÁΩÆÂèÇÊï∞ÂàõÂª∫Âá∫ Okhttp ‰∏≠ÁöÑ Request ÂØπË±° // Ê≥®ÊÑèÁöÑ‰∏ÄÁÇπÔºå‰ºöË∞ÉÁî®‰∏äÈù¢ÁöÑ ParameterHandler.apply ÊñπÊ≥ïÊù•Â°´ÂÖÖÁΩëÁªúËØ∑Ê±ÇÂèÇÊï∞ // ÁÑ∂ÂêéÂÜçÊ†πÊçÆ OkhttpClient ÁöÑnewCall(request) ÂàõÂª∫Âá∫ OkhttpÁ±ªÂûãÁöÑrawCall // Ëøô‰∏ÄÊ≠•‰πüËØ¥Êòé‰∫ÜÂú® Retrofit ‰∏≠ÁöÑ OkHttpCall ÂÜÖÈÉ®ËØ∑Ê±ÇÊúÄÂêé‰ºöËΩ¨Êç¢‰∏∫ OkHttp ÁöÑ Call call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException e) &#123; creationFailure = e; throw e; &#125; &#125; &#125; // Ê£ÄÊü• call ÊòØÂê¶ÂèñÊ∂à if (canceled) &#123; call.cancel(); &#125;// ÊâßË°å call Âπ∂ËΩ¨Êç¢ÂìçÂ∫îÁöÑ response return parseResponse(call.execute()); &#125; Âú® execute() ÂÅöÁöÑÂ∞±ÊòØÂ∞Ü Retrofit ‰∏≠ÁöÑ call ËΩ¨Âåñ‰∏∫ OkHttp ‰∏≠ÁöÑ rawCall „ÄÇ ÊúÄÂêéËÆ© OkHttp ÁöÑ call ÂéªÊâßË°å, ËøîÂõûÂìçÂ∫îokhttp3.Response„ÄÇ ResponseËß£ÊûêÊàë‰ª¨ÂèØ‰ª•ÁúãÂà∞ OkHttpCall.execute() ‰∏≠ÁöÑÊúÄÂêé‰∏ÄÂè•ÔºöparseResponse(call.execute())ÔºåÂØπÂìçÂ∫îÁöÑÂ§ÑÁêÜÂ∞±ÊòØËøô‰∏™ÊñπÊ≥ï‰∫Ü„ÄÇ ÂÜçÁúãOkHttpCall#parseResponse()OkHttpCallÁöÑexecute()ÂßîÊâòÁªô‰∫Üokhttp3.Call rawCallÊù•ÊâßË°åÔºåÂõ†Ê≠§ËøîÂõûÁöÑReponseÊï∞ÊçÆ‰πüÊòØÂú®ËøôÈáåËøõ‰∏ÄÊ≠•Â§ÑÁêÜÔºö 123456789101112131415161718192021222324252627282930313233343536//OkHttpCall.javaResponse&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); // Â¶ÇÊûúËøîÂõûÁöÑÂìçÂ∫îÁ†Å‰∏çÊòØÊàêÂäüÁöÑËØùÔºåËøîÂõûÈîôËØØ Response int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; // Â¶ÇÊûúËøîÂõûÁöÑÂìçÂ∫îÁ†ÅÊòØ204ÊàñËÄÖ205ÔºåËøîÂõûÊ≤°Êúâ body ÁöÑÊàêÂäü Response if (code == 204 || code == 205) &#123; return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; // Â∞Ü body ËΩ¨Êç¢‰∏∫ÂØπÂ∫îÁöÑÊ≥õÂûãÔºåÁÑ∂ÂêéËøîÂõûÊàêÂäü Response T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125;&#125; ÂÖ≥ÈîÆÊòØËøôÂè•‰ª£Á†ÅÔºöT body = serviceMethod.toResponse(catchingBody); Â∞Ü ResponseBody Áõ¥Êé•ËΩ¨Âåñ‰∏∫‰∫ÜÊ≥õÂûãÔºåÂèØ‰ª•ÁåúÂà∞Ëøô‰πüÊòØ ËøîÂõûÊï∞ÊçÆËΩ¨Êç¢Âô®Converter ÁöÑÂäüÂä≥„ÄÇ 12345//ServiceMethod.java/** Builds a method return value from an HTTP response body. */T toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body);&#125; ÊûúÁÑ∂Ê≤°ÈîôÔºåÂÜÖÈÉ®ÊòØË∞ÉÁî®‰∫Ü responseConverter ÁöÑÔºåÈÇ£‰πàresponseConverterÂÖ∑‰ΩìÊòØ‰ªÄ‰πàÔºü BuiltInConvertersÂú®ÂâçÈù¢RetrofitÁöÑbuild()ÈÉ®ÂàÜÊàë‰ª¨ÂàÜÊûê‰∫ÜBuiltInConvertersÊòØRetrofitÈªòËÆ§ÁöÑÊï∞ÊçÆËΩ¨Êç¢Âô®Â∑•ÂéÇÔºå ÂÆÉÂÜÖÁΩÆ‰∫Ü responseBodyConverter„ÄÅrequestBodyConverter„ÄÅToStringConverter‰∏âÂ§ßÁ±ªÔºåÁúã‰∏ãConverterÁöÑÊé•Âè£ÂÆö‰πâÔºö 1234567891011121314151617181920212223242526//ConvertÂØπË±°Ë¢´FactoryÂ∑•ÂéÇÂàõÂª∫ÔºåFactoryÂú®Retrofit.Builder#addConverterFactory(factory)Ê∑ªÂä†public interface Converter&lt;F, T&gt; &#123; T convert(F value) throws IOException; abstract class Factory &#123; //Áî®‰∫éÂ∞ÜOkHttpÁöÑResponseBodyËΩ¨‰∏∫‰ªªÊÑèÁ±ªÂûãTÔºåÊØîÂ¶ÇCall&lt;SimpleResponse&gt; public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; //Áî®‰∫éÂ∞Ü‰ªªÊÑèÁ±ªÂûãTËΩ¨‰∏∫OkHttpÁöÑRequestBodyÔºåÊØîÂ¶ÇËØ¥Á±ªÂûã@Body @Part public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; return null; &#125; //Object to String Converter public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; &#125;&#125; Converter.FactoryÂ∑•ÂéÇÊã•Êúâ3ÁßçConverter Á±ªÂûãÔºö Converter ÔºöÁî®‰∫éÂ∞ÜOkHttpÁöÑResponseBodyËΩ¨‰∏∫‰ªªÊÑèÁ±ªÂûãT„ÄÇ Converter&lt;?, RequestBody&gt; ÔºöÁî®‰∫éÂ∞Ü‰ªªÊÑèÁ±ªÂûãTËΩ¨‰∏∫OkHttpÁöÑRequestBody„ÄÇ Converter&lt;?, String&gt;ÔºöËΩ¨Êç¢ÊàêStringÁ±ªÂûãÁöÑConverter„ÄÇ ÂÜçÁúãBuiltInConverters‰∏≠ÁöÑresponseBodyConverterÔºö 123456789101112131415161718192021222324252627282930313233//BuiltInConverters.javafinal class BuiltInConverters extends Converter.Factory &#123; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; if (type == ResponseBody.class) &#123; return Utils.isAnnotationPresent(annotations, Streaming.class) ? StreamingResponseBodyConverter.INSTANCE : BufferingResponseBodyConverter.INSTANCE;//ÈªòËÆ§ÊòØËøô‰∏™ÂñΩ &#125; if (type == Void.class) &#123; return VoidResponseBodyConverter.INSTANCE; &#125; return null; &#125; ... static final class BufferingResponseBodyConverter implements Converter&lt;ResponseBody, ResponseBody&gt; &#123; static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter(); @Override public ResponseBody convert(ResponseBody value) throws IOException &#123; try &#123; // Buffer the entire body to avoid future I/O. return Utils.buffer(value); &#125; finally &#123; value.close(); &#125; &#125; &#125;&#125; ÈªòËÆ§ÊòØÁî®‰∫Ü BufferingResponseBodyConverterÂè™ÊòØÂ∞ÜResponseBody ÁºìÂ≠ò‰∫ÜÔºåËøîÂõûÁöÑËøòÊòØResponseBodyÁ±ªÂûã„ÄÇÊâÄ‰ª•OkHttpCallÁöÑexecute()ÈªòËÆ§ËøîÂõûÁöÑËøòÊòØResponseÁ±ªÂûã„ÄÇ GsonConverterFactoryÂ¶ÇÊûúÊòØ GsonConverterFactory Âë¢ÔºüËØ•Â∑•ÂéÇËá™ÁÑ∂ÊòØÊûÑÂª∫‰∫Ü‰∏Ä‰∏™ GsonResponseBodyConverterGsonÊï∞ÊçÆËΩ¨Êç¢Âô®ÔºåÁõÆÁöÑÊòØÊääResponseBody ÂÄüÁî®gson ËΩ¨Âåñ‰∏∫Áî®Êà∑ÂÆö‰πâÁöÑJavaBean-TypeÔºåÂÖ∂Ê∫êÁ†ÅÂ¶Ç‰∏ãÔºö 12345678//GsonConverterFactory.java@Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; //ËøôÈáåÁöÑTypeÂ∞±ÊòØresponseTypeÔºåÊØîÂ¶ÇCall&lt;SimpleResponse&gt;‰∏≠ÁöÑSimpleResponseÁ±ªÂûã TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter); &#125; ÂÖ∂‰∏≠GsonResponseBodyConvertersÂÆö‰πâ‰∏∫: 123456789101112131415161718final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123; this.gson = gson; this.adapter = adapter; &#125; @Override public T convert(ResponseBody value) throws IOException &#123; JsonReader jsonReader = gson.newJsonReader(value.charStream()); try &#123; return adapter.read(jsonReader); &#125; finally &#123; value.close(); &#125; &#125;&#125; ÊòæÁÑ∂‰πüÊòØÂú®convert‰∏≠Â∞ÜResponseBodyÂà©Áî®GsonËΩ¨Êç¢‰∏∫Áî®Êà∑ÂÆö‰πâÁöÑÁ±ªÂûãTÔºåÊØîÂ¶ÇCall‰∏≠ÁöÑTÂ∞±ÊòØUserInfo„ÄÇ ÂëºÂëºÔºåÁªà‰∫éÂÜôÂÆå‰∫ÜÔºåÂø´Êôï‰∫Üüò∑‚Ä¶ ÊúÄÂêéRetrofitÂè™ÊòØÊääËØ∑Ê±ÇÂèëÈÄÅÂíåÂìçÂ∫îÂ∞ÅË£Ö‰∫Ü‰∏Ä‰∏ãÔºåÂÜÖÈÉ®ËÆøÈóÆÁΩëÁªú‰ªçÁÑ∂ÊòØÈÄöËøá OkHttp ÔºåÂÖ∂ÁâπÂà´‰πãÂ§ÑÊòØËÉΩÈÄöËøáÊ≥®Ëß£ÁöÑÊñπÂºèÊûÑÂª∫ÁΩëÁªúËØ∑Ê±ÇÔºåÂ§ßÂ§ßÂ¢ûÂä†‰∫ÜÂèØËØªÊÄß„ÄÇ RetrofitÊ∫êÁ†ÅËÆæËÆ°‰∏≠ËøêÁî®‰∫ÜÂæàÂ§öËÆæËÆ°Ê®°ÂºèÔºåÂÄºÂæóÊàë‰ª¨Ê∑±ÂÖ•ÊÄùËÄÉÔºåÊØîÂ¶ÇÂ§ñËßÇÊ®°ÂºèÔºàÂÆö‰πâApiServiceÊé•Âè£Ôºâ„ÄÅ‰ª£ÁêÜÊ®°ÂºèÔºàRetrofit#create‰∏≠ÁöÑProxyÔºâ„ÄÅÂª∫ÈÄ†ËÄÖÊ®°ÂºèÔºàRetrofit#BuilderÔºåServiceMethod#BuilderÔºâ„ÄÅÁ≠ñÁï•Ê®°Âºè(ÂêÑÁßçPlatform)„ÄÅÈÄÇÈÖçÂô®Ê®°ÂºèÔºàCallAdapter.adaptÔºâ„ÄÅË£ÖÈ•∞ËÄÖÊ®°ÂºèÔºàExecutorCallbackCallÔºàOkHttpCallÔºâÔºâ„ÄÅÂ∑•ÂéÇÊ®°ÂºèÔºàCallAdapter.FactoryÔºå Converter.FactoryÔºâÁ≠âÔºåËøô‰ΩøÂæóRetrofitËÉΩÂ§üÂæàÂ•ΩÁöÑËß£ËÄ¶ÔºåÈÖçÂêàOkHttpÂíåRxjavaÂèëÊå•Âá∫ÊúÄÂ§ßÁöÑ‰ºòÂäø„ÄÇ]]></content>
      <categories>
        <category>ÊãÜËΩÆÂ≠ê</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttpÊ∫êÁ†ÅËß£Êûê]]></title>
    <url>%2F2018%2F04%2F04%2FOkHttp%203.7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[‰ª•‰∏ãÂÜÖÂÆπ‰∏∫ËΩ¨ËΩΩËá™Ôºö OkHttpÊ∫êÁ†ÅÂàÜÊûê‚Äî‚ÄîÊï¥‰ΩìÊû∂ÊûÑ OkHttpÊòØ‰∏Ä‰∏™Â§ÑÁêÜÁΩëÁªúËØ∑Ê±ÇÁöÑÂºÄÊ∫êÈ°πÁõÆ,ÊòØAndroidÁ´ØÊúÄÁÅ´ÁÉ≠ÁöÑËΩªÈáèÁ∫ßÊ°ÜÊû∂,Áî±ÁßªÂä®ÊîØ‰ªòSquareÂÖ¨Âè∏Ë¥°ÁåÆÁî®‰∫éÊõø‰ª£HttpUrlConnectionÂíåApache HttpClient„ÄÇÈöèÁùÄOkHttpÁöÑ‰∏çÊñ≠ÊàêÁÜüÔºåË∂äÊù•Ë∂äÂ§öÁöÑAndroidÂºÄÂèëËÄÖ‰ΩøÁî®OkHttp‰Ωú‰∏∫ÁΩëÁªúÊ°ÜÊû∂„ÄÇ ‰πãÊâÄ‰ª•ÂèØ‰ª•Ëµ¢ÂæóÂ¶ÇÊ≠§Â§öÂºÄÂèëËÄÖÁöÑÂñúÁà±Ôºå‰∏ªË¶ÅÂæóÁõä‰∫éÂ¶Ç‰∏ãÁâπÁÇπÔºö ÊîØÊåÅHTTPS/HTTP2/WebSocketÔºàÂú®OkHttp3.7‰∏≠Â∑≤ÁªèÂâ•Á¶ªÂØπSpdyÁöÑÊîØÊåÅÔºåËΩ¨ËÄåÂ§ßÂäõÊîØÊåÅHTTP2Ôºâ ÂÜÖÈÉ®Áª¥Êä§‰ªªÂä°ÈòüÂàóÁ∫øÁ®ãÊ±†ÔºåÂèãÂ•ΩÊîØÊåÅÂπ∂ÂèëËÆøÈóÆ ÂÜÖÈÉ®Áª¥Êä§ËøûÊé•Ê±†ÔºåÊîØÊåÅÂ§öË∑ØÂ§çÁî®ÔºåÂáèÂ∞ëËøûÊé•ÂàõÂª∫ÂºÄÈîÄ socketÂàõÂª∫ÊîØÊåÅÊúÄ‰Ω≥Ë∑ØÁî± Êèê‰æõÊã¶Êà™Âô®ÈìæÔºàInterceptorChainÔºâÔºåÂÆûÁé∞request‰∏éresponseÁöÑÂàÜÂ±ÇÂ§ÑÁêÜ(Â¶ÇÈÄèÊòéGZIPÂéãÁº©ÔºåloggingÁ≠â) ‰∏∫‰∫Ü‰∏ÄÊé¢OkHttpÊòØÂ¶Ç‰ΩïÂÖ∑Â§á‰ª•‰∏ãÁâπÁÇπÁöÑÔºåÁ¨îËÄÖÂèçÂ§çÁ†îÁ©∂OkHttpÊ°ÜÊû∂Ê∫êÁ†ÅÔºåÂäõÊ±ÇÈÄöËøáÊ∫êÁ†ÅÂàÜÊûêÂêëÂêÑ‰ΩçËß£Èáä‰∏Ä‰∫å„ÄÇÊâÄ‰ª•ÁâπÊÑèÂáÜÂ§á‰∫ÜÂá†ÁØáÂçöÂÆ¢Ë∑üÂ§ßÂÆ∂‰∏ÄËµ∑Êé¢ËÆ®‰∏ãOkHttpÁöÑÊñπÊñπÈù¢Èù¢Ôºå‰ªäÂ§©È¶ñÂÖà‰ªéÊï¥‰ΩìÊû∂ÊûÑ‰∏äÂàÜÊûê‰∏ãOkHttp„ÄÇ ÁÆÄÂçï‰ΩøÁî®È¶ñÂÖàÊù•Áúã‰∏ãOkHttpÁöÑÁÆÄÂçï‰ΩøÁî®ÔºåOkHttpÊèê‰æõ‰∫Ü‰∏§ÁßçË∞ÉÁî®ÊñπÂºèÔºö ÂêåÊ≠•Ë∞ÉÁî® ÂºÇÊ≠•Ë∞ÉÁî® ÂêåÊ≠•Ë∞ÉÁî®1234567891011121314@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(false); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; È¶ñÂÖàÂä†ÈîÅÁΩÆÊ†áÂøó‰ΩçÔºåÊé•ÁùÄ‰ΩøÁî®ÂàÜÈÖçÂô®ÁöÑexecutedÊñπÊ≥ïÂ∞ÜcallÂä†ÂÖ•Âà∞ÂêåÊ≠•ÈòüÂàó‰∏≠ÔºåÁÑ∂ÂêéË∞ÉÁî®getResponseWithInterceptorChainÊñπÊ≥ïÔºàÁ®çÂêéÂàÜÊûêÔºâÊâßË°åhttpËØ∑Ê±ÇÔºåÊúÄÂêéË∞ÉÁî®finishiedÊñπÊ≥ïÂ∞Ücall‰ªéÂêåÊ≠•ÈòüÂàó‰∏≠Âà†Èô§ ÂºÇÊ≠•ËØ∑Ê±Ç1234567void enqueue(Callback responseCallback, boolean forWebSocket) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));&#125; ÂêåÊ†∑ÂÖàÁΩÆÊ†áÂøó‰ΩçÔºåÁÑ∂ÂêéÂ∞ÜÂ∞ÅË£ÖÁöÑ‰∏Ä‰∏™ÊâßË°å‰ΩìÊîæÂà∞ÂºÇÊ≠•ÊâßË°åÈòüÂàó‰∏≠„ÄÇËøôÈáåÈù¢ÂºïÂÖ•‰∫Ü‰∏Ä‰∏™Êñ∞ÁöÑÁ±ªAsyncCallÔºåËøô‰∏™Á±ªÁªßÊâø‰∫éNamedRunnableÔºåÂÆûÁé∞‰∫ÜRunnableÊé•Âè£„ÄÇNamedRunnableÂèØ‰ª•ÁªôÂΩìÂâçÁöÑÁ∫øÁ®ãËÆæÁΩÆÂêçÂ≠óÔºåÂπ∂‰∏îÁî®Ê®°ÊùøÊñπÊ≥ïÂ∞ÜÁ∫øÁ®ãÁöÑÊâßË°å‰ΩìÊîæÂà∞‰∫ÜexecuteÊñπÊ≥ï‰∏≠ Êã¶Êà™Âô®Èô§‰∫ÜÂêåÊ≠•Ë∞ÉÁî®ÂíåÂºÇÊ≠•Ë∞ÉÁî®ÔºåOkHttpËøòÊèê‰æõ‰∫Ü‰∏Ä‰∏™Êã¶Êà™Âô®ÁöÑÊ¶ÇÂøµ„ÄÇÊã¶Êà™Âô®Êèê‰æõ‰∫ÜÊã¶Êà™ËØ∑Ê±ÇÂíåÊã¶Êà™ÊúçÂä°Âô®Â∫îÁ≠îÁöÑÊé•Âè£„ÄÇOkHttpÊèê‰æõ‰∫Ü‰∏Ä‰∏™Êã¶Êà™Âô®ÈìæÁöÑÊ¶ÇÂøµÔºåÈÄöËøáÂ∞Ü‰∏Ä‰∏™‰∏™Êã¶Êà™Âô®ÁªÑÂêàÊàê‰∏Ä‰∏™Êã¶Êà™Âô®ÈìæÔºåÂèØ‰ª•ËææÂà∞Âú®‰∏çÂêåÂ±ÇÈù¢ÂÅö‰∏çÂêåÊã¶Êà™Êìç‰ΩúÁöÑÊïàÊûúÔºåÊúâÁÇπAOPÁöÑÊÑèÊÄù„ÄÇÂÖ∑‰ΩìÊã¶Êà™Âô®ÁöÑ‰ΩøÁî®ÂèØ‰ª•ÂèÇËÄÉÔºöOkhttp-wiki ‰πã Interceptors Êã¶Êà™Âô® ÊÄª‰ΩìÊû∂ÊûÑ ‰∏äÂõæÊòØOkHttpÁöÑÊÄª‰ΩìÊû∂ÊûÑÔºåÂ§ßËá¥ÂèØ‰ª•ÂàÜ‰∏∫‰ª•‰∏ãÂá†Â±ÇÔºö Interface‚Äî‚ÄîÊé•Âè£Â±ÇÔºöÊé•ÂèóÁΩëÁªúËÆøÈóÆËØ∑Ê±Ç Protocol‚Äî‚ÄîÂçèËÆÆÂ±ÇÔºöÂ§ÑÁêÜÂçèËÆÆÈÄªËæë Connection‚Äî‚ÄîËøûÊé•Â±ÇÔºöÁÆ°ÁêÜÁΩëÁªúËøûÊé•ÔºåÂèëÈÄÅÊñ∞ÁöÑËØ∑Ê±ÇÔºåÊé•Êî∂ÊúçÂä°Âô®ËÆøÈóÆ Cache‚Äî‚ÄîÁºìÂ≠òÂ±ÇÔºöÁÆ°ÁêÜÊú¨Âú∞ÁºìÂ≠ò I/O‚Äî‚ÄîI/OÂ±ÇÔºöÂÆûÈôÖÊï∞ÊçÆËØªÂÜôÂÆûÁé∞ Inteceptor‚Äî‚ÄîÊã¶Êà™Âô®Â±ÇÔºöÊã¶Êà™ÁΩëÁªúËÆøÈóÆÔºåÊèíÂÖ•Êã¶Êà™ÈÄªËæë Êï¥‰ΩìÊµÅÁ®ãÂõæÔºö Interface‚Äî‚ÄîÊé•Âè£Â±ÇÔºöÊé•Âè£Â±ÇÊé•Êî∂Áî®Êà∑ÁöÑÁΩëÁªúËÆøÈóÆËØ∑Ê±ÇÔºàÂêåÊ≠•ËØ∑Ê±Ç/ÂºÇÊ≠•ËØ∑Ê±ÇÔºâÔºåÂèëËµ∑ÂÆûÈôÖÁöÑÁΩëÁªúËÆøÈóÆ„ÄÇOkHttpClientÊòØOkHttpÊ°ÜÊû∂ÁöÑÂÆ¢Êà∑Á´ØÔºåÊõ¥Á°ÆÂàáÁöÑËØ¥ÊòØ‰∏Ä‰∏™Áî®Êà∑Èù¢Êùø„ÄÇÁî®Êà∑‰ΩøÁî®OkHttpËøõË°åÂêÑÁßçËÆæÁΩÆÔºåÂèëËµ∑ÂêÑÁßçÁΩëÁªúËØ∑Ê±ÇÈÉΩÊòØÈÄöËøáOkHttpClientÂÆåÊàêÁöÑ„ÄÇÊØè‰∏™OkHttpClientÂÜÖÈÉ®ÈÉΩÁª¥Êä§‰∫ÜÂ±û‰∫éËá™Â∑±ÁöÑ‰ªªÂä°ÈòüÂàóÔºåËøûÊé•Ê±†ÔºåCacheÔºåÊã¶Êà™Âô®Á≠âÔºåÊâÄ‰ª•Âú®‰ΩøÁî®OkHttp‰Ωú‰∏∫ÁΩëÁªúÊ°ÜÊû∂Êó∂Â∫îËØ•ÂÖ®Â±ÄÂÖ±‰∫´‰∏Ä‰∏™OkHttpClientÂÆû‰æã„ÄÇ CallÊèèËø∞‰∏Ä‰∏™ÂÆûÈôÖÁöÑËÆøÈóÆËØ∑Ê±ÇÔºåÁî®Êà∑ÁöÑÊØè‰∏Ä‰∏™ÁΩëÁªúËØ∑Ê±ÇÈÉΩÊòØ‰∏Ä‰∏™CallÂÆû‰æã„ÄÇCallÊú¨Ë∫´Âè™ÊòØ‰∏Ä‰∏™Êé•Âè£ÔºåÂÆö‰πâ‰∫ÜCallÁöÑÊé•Âè£ÊñπÊ≥ïÔºåÂÆûÈôÖÊâßË°åËøáÁ®ã‰∏≠ÔºåOkHttp‰ºö‰∏∫ÊØè‰∏Ä‰∏™ËØ∑Ê±ÇÂàõÂª∫‰∏Ä‰∏™RealCall,ÊØè‰∏Ä‰∏™RealCallÂÜÖÈÉ®Êúâ‰∏Ä‰∏™AsyncCall: 12345678910111213141516171819202122232425 final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super("OkHttp %s", redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; @Override protected void execute() &#123; ... &#125; ...&#125; AsyncCallÁªßÊâøÁöÑNamedRunnableÁªßÊâøËá™RunnableÊé•Âè£Ôºö 12345678910111213141516171819public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; ÊâÄ‰ª•ÊØè‰∏Ä‰∏™CallÂ∞±ÊòØ‰∏Ä‰∏™Á∫øÁ®ãÔºåËÄåÊâßË°åCallÁöÑËøáÁ®ãÂ∞±ÊòØÊâßË°åÂÖ∂executeÊñπÊ≥ïÁöÑËøáÁ®ã„ÄÇ DispatcherÊòØOkHttpÁöÑ‰ªªÂä°ÈòüÂàóÔºåÂÖ∂ÂÜÖÈÉ®Áª¥Êä§‰∫Ü‰∏Ä‰∏™Á∫øÁ®ãÊ±†ÔºåÂΩìÊúâÊé•Êî∂Âà∞‰∏Ä‰∏™CallÊó∂ÔºåDispatcherË¥üË¥£Âú®Á∫øÁ®ãÊ±†‰∏≠ÊâæÂà∞Á©∫Èó≤ÁöÑÁ∫øÁ®ãÂπ∂ÊâßË°åÂÖ∂executeÊñπÊ≥ï„ÄÇËøôÈÉ®ÂàÜÂ∞Ü‰ºöÂçïÁã¨Êãø‰∏ÄÁØáÂçöÂÆ¢ËøõË°å‰ªãÁªçÔºåËØ¶ÁªÜÂÜÖÂÆπÂèØÂèÇËÄÉÊú¨Á≥ªÂàóÊé•‰∏ãÊù•ÁöÑÊñáÁ´†„ÄÇ Protocol‚Äî‚ÄîÂçèËÆÆÂ±ÇÔºöÂ§ÑÁêÜÂçèËÆÆÈÄªËæëProtocolÂ±ÇË¥üË¥£Â§ÑÁêÜÂçèËÆÆÈÄªËæëÔºåOkHttpÊîØÊåÅHttp1/Http2/WebSocketÂçèËÆÆÔºåÂπ∂Âú®3.7ÁâàÊú¨‰∏≠ÊîæÂºÉ‰∫ÜÂØπSpdyÂçèËÆÆÔºåÈºìÂä±ÂºÄÂèëËÄÖ‰ΩøÁî®Http/2„ÄÇ Connection‚Äî‚ÄîËøûÊé•Â±ÇÔºöÁÆ°ÁêÜÁΩëÁªúËøûÊé•ÔºåÂèëÈÄÅÊñ∞ÁöÑËØ∑Ê±ÇÔºåÊé•Êî∂ÊúçÂä°Âô®ËÆøÈóÆËøûÊé•Â±ÇÈ°æÂêçÊÄù‰πâÂ∞±ÊòØË¥üË¥£ÁΩëÁªúËøûÊé•„ÄÇÂú®ËøûÊé•Â±Ç‰∏≠Êúâ‰∏Ä‰∏™ËøûÊé•Ê±†ÔºåÁªü‰∏ÄÁÆ°ÁêÜÊâÄÊúâÁöÑSocketËøûÊé•ÔºåÂΩìÁî®Êà∑Êñ∞ÂèëËµ∑‰∏Ä‰∏™ÁΩëÁªúËØ∑Ê±ÇÊó∂ÔºåOkHttp‰ºöÈ¶ñÂÖà‰ªéËøûÊé•Ê±†‰∏≠Êü•ÊâæÊòØÂê¶ÊúâÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑËøûÊé•ÔºåÂ¶ÇÊûúÊúâÂàôÁõ¥Êé•ÈÄöËøáËØ•ËøûÊé•ÂèëÈÄÅÁΩëÁªúËØ∑Ê±ÇÔºõÂê¶ÂàôÊñ∞ÂàõÂª∫‰∏Ä‰∏™ÁΩëÁªúËøûÊé•„ÄÇ RealConnectionÊèèËø∞‰∏Ä‰∏™Áâ©ÁêÜSocketËøûÊé•ÔºåËøûÊé•Ê±†‰∏≠Áª¥Êä§Â§ö‰∏™RealConnectionÂÆû‰æã„ÄÇÁî±‰∫éHttp/2ÊîØÊåÅÂ§öË∑ØÂ§çÁî®Ôºå‰∏Ä‰∏™RealConnectionÂèØ‰ª•ÊîØÊåÅÂ§ö‰∏™ÁΩëÁªúËÆøÈóÆËØ∑Ê±ÇÔºåÊâÄ‰ª•OkHttpÂèàÂºïÂÖ•‰∫ÜStreamAllocationÊù•ÊèèËø∞‰∏Ä‰∏™ÂÆûÈôÖÁöÑÁΩëÁªúËØ∑Ê±ÇÂºÄÈîÄÔºà‰ªéÈÄªËæë‰∏ä‰∏Ä‰∏™StreamÂØπÂ∫î‰∏Ä‰∏™CallÔºå‰ΩÜÂú®ÂÆûÈôÖÁΩëÁªúËØ∑Ê±ÇËøáÁ®ã‰∏≠‰∏Ä‰∏™CallÂ∏∏Â∏∏Ê∂âÂèäÂà∞Â§öÊ¨°ËØ∑Ê±Ç„ÄÇÂ¶ÇÈáçÂÆöÂêëÔºåAuthenticateÁ≠âÂú∫ÊôØ„ÄÇÊâÄ‰ª•ÂáÜÁ°ÆÂú∞ËØ¥Ôºå‰∏Ä‰∏™StreamÂØπÂ∫î‰∏ÄÊ¨°ËØ∑Ê±ÇÔºåËÄå‰∏Ä‰∏™CallÂØπÂ∫î‰∏ÄÁªÑÊúâÈÄªËæëÂÖ≥ËÅîÁöÑStreamÔºâÔºå‰∏Ä‰∏™RealConnectionÂØπÂ∫î‰∏Ä‰∏™ÊàñÂ§ö‰∏™StreamAllocation,ÊâÄ‰ª•StreamAllocationÂèØ‰ª•ÁúãÂÅöÊòØRealConenctionÁöÑËÆ°Êï∞Âô®ÔºåÂΩìRealConnectionÁöÑÂºïÁî®ËÆ°Êï∞Âèò‰∏∫0Ôºå‰∏îÈïøÊó∂Èó¥Ê≤°ÊúâË¢´ÂÖ∂‰ªñËØ∑Ê±ÇÈáçÊñ∞Âç†Áî®Â∞±Â∞ÜË¢´ÈáäÊîæ„ÄÇ ËøûÊé•Â±ÇÊòØOkHttpÁöÑÊ†∏ÂøÉÈÉ®ÂàÜÔºåËøôÈÉ®ÂàÜÂΩìÁÑ∂‰πü‰ºöÂçïÁã¨Êãø‰∏ÄÁØáÂçöÂÆ¢ËØ¶ÁªÜËÆ≤Ëß£ÔºåËØ¶ÁªÜÂÜÖÂÆπÂèØÂèÇËÄÉÊú¨‰∏ìÈ¢òÁõ∏ÂÖ≥ÊñáÁ´†„ÄÇ Cache‚Äî‚ÄîÁºìÂ≠òÂ±ÇÔºöÁÆ°ÁêÜÊú¨Âú∞ÁºìÂ≠òCacheÂ±ÇË¥üË¥£Áª¥Êä§ËØ∑Ê±ÇÁºìÂ≠òÔºåÂΩìÁî®Êà∑ÁöÑÁΩëÁªúËØ∑Ê±ÇÂú®Êú¨Âú∞Â∑≤ÊúâÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑÁºìÂ≠òÊó∂ÔºåOkHttp‰ºöÁõ¥Êé•‰ªéÁºìÂ≠ò‰∏≠ËøîÂõûÁªìÊûúÔºå‰ªéËÄåËäÇÁúÅÁΩëÁªúÂºÄÈîÄ„ÄÇËøôÈÉ®ÂàÜÂÜÖÂÆπ‰πü‰ºöÂçïÁã¨Êãø‰∏ÄÁØáÂçöÂÆ¢ËøõË°å‰ªãÁªçÔºåËØ¶ÁªÜÂÜÖÂÆπÂèØÂèÇËÄÉÊú¨‰∏ìÈ¢òÁõ∏ÂÖ≥ÊñáÁ´†„ÄÇ I/O‚Äî‚ÄîI/OÂ±ÇÔºöÂÆûÈôÖÊï∞ÊçÆËØªÂÜôÂÆûÁé∞I/OÂ±ÇË¥üË¥£ÂÆûÈôÖÁöÑÊï∞ÊçÆËØªÂÜô„ÄÇOkHttpÁöÑÂè¶‰∏ÄÂ§ßÊúâÁÇπÂ∞±ÊòØÂÖ∂È´òÊïàÁöÑI/OÊìç‰ΩúÔºåËøôÂΩíÂõ†‰∫éÂÖ∂È´òÊïàÁöÑI/OÂ∫ìokio ËøôÈÉ®ÂàÜÂÜÖÂÆπÁ¨îËÄÖ‰πüÊâìÁÆóÂè¶ÂºÄ‰∏Ä‰∏™‰∏ìÈ¢òËøõË°å‰ªãÁªç„ÄÇËØ¶ÁªÜÂÜÖÂÆπÂèØ‰ª•ÂèÇËÄÉÊú¨ÂçöÂÆ¢Áõ∏ÂÖ≥ÂÜÖÂÆπ„ÄÇ Inteceptor‚Äî‚ÄîÊã¶Êà™Âô®Â±ÇÔºöÊã¶Êà™ÁΩëÁªúËÆøÈóÆÔºåÊèíÂÖ•Êã¶Êà™ÈÄªËæëÊã¶Êà™Âô®Â±ÇÊèê‰æõ‰∫Ü‰∏Ä‰∏™Á±ªAOPÊé•Âè£ÔºåÊñπ‰æøÁî®Êà∑ÂèØ‰ª•ÂàáÂÖ•Âà∞ÂêÑ‰∏™Â±ÇÈù¢ÂØπÁΩëÁªúËÆøÈóÆËøõË°åÊã¶Êà™Âπ∂ÊâßË°åÁõ∏ÂÖ≥ÈÄªËæë„ÄÇÂú®‰∏ã‰∏ÄÁØáÂçöÂÆ¢‰∏≠ÔºåÁ¨îËÄÖÂ∞ÜÈÄöËøá‰ªãÁªç‰∏Ä‰∏™ÂÆûÈôÖÁöÑÁΩëÁªúËÆøÈóÆËØ∑Ê±ÇÂÆû‰æãÊù•‰ªãÁªçÊã¶Êà™Âô®ÁöÑÂéüÁêÜ„ÄÇ OkHttpÊ∫êÁ†ÅÂàÜÊûê‚Äî‚ÄîÊã¶Êà™Âô® Ââç‰∏ÄÁØáÂçöÂÆ¢‰∏≠Êàë‰ª¨‰ªãÁªç‰∫ÜOkHttpÁöÑÊÄª‰ΩìÊû∂ÊûÑÔºåÊé•‰∏ãÊù•Êàë‰ª¨‰ª•‰∏Ä‰∏™ÂÖ∑‰ΩìÁöÑÁΩëÁªúËØ∑Ê±ÇÊù•ËÆ≤Ëø∞OkHttpËøõË°åÁΩëÁªúËÆøÈóÆÁöÑÂÖ∑‰ΩìËøáÁ®ã„ÄÇÁî±‰∫éËØ•ÈÉ®ÂàÜ‰∏éOkHttpÁöÑÊã¶Êà™Âô®Ê¶ÇÂøµÁ¥ßÂØÜËÅîÁ≥ªÂú®‰∏ÄËµ∑ÔºåÊâÄ‰ª•Â∞ÜËøô‰∏§ÈÉ®ÂàÜÊîæÂú®‰∏ÄËµ∑ËøõË°åËÆ≤Ëß£„ÄÇ 1.ÊûÑÈÄ†DemoÈ¶ñÂÖàÊûÑÈÄ†‰∏Ä‰∏™ÁÆÄÂçïÁöÑÂºÇÊ≠•ÁΩëÁªúËÆøÈóÆDemo: 12345678910111213141516OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d("OkHttp", "Call Failed:" + e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d("OkHttp", "Call succeeded:" + response.message()); &#125;&#125;); 2. ÂèëËµ∑ËØ∑Ê±ÇOkHttpClient.newCallÂÆûÈôÖÊòØÂàõÂª∫‰∏Ä‰∏™RealCallÂÆû‰æãÔºö 123456/** * Prepares the &#123;@code request&#125; to be executed at some point in the future. */@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */);&#125; RealCall.enqueueÂÆûÈôÖÂ∞±ÊòØËÆ≤‰∏Ä‰∏™RealCallÊîæÂÖ•Âà∞‰ªªÂä°ÈòüÂàó‰∏≠ÔºåÁ≠âÂæÖÂêàÈÄÇÁöÑÊú∫‰ºöÊâßË°å: 12345678@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; ‰ªé‰ª£Á†Å‰∏≠ÂèØ‰ª•ÁúãÂà∞ÊúÄÁªàRealCallË¢´ËΩ¨ÂåñÊàê‰∏Ä‰∏™AsyncCallÂπ∂Ë¢´ÊîæÂÖ•Âà∞‰ªªÂä°ÈòüÂàó‰∏≠Ôºå‰ªªÂä°ÈòüÂàó‰∏≠ÁöÑÂàÜÂèëÈÄªËæëËøôÈáåÂÖà‰∏çËØ¥ÔºåÁõ∏ÂÖ≥ÂÆûÁé∞‰ºöÊîæÂú®OkHttpÊ∫êÁ†ÅÂàÜÊûê‚Äî‚Äî‰ªªÂä°ÈòüÂàóÁñëÈóÆËøõË°å‰ªãÁªç„ÄÇËøôÈáåÂè™ÈúÄË¶ÅÁü•ÈÅìAsyncCallÁöÑexcuteÊñπÊ≥ïÊúÄÁªàÂ∞Ü‰ºöË¢´ÊâßË°å: 123456789101112131415161718192021222324[RealCall.java] @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; &#125; executeÊñπÊ≥ïÁöÑÈÄªËæëÂπ∂‰∏çÂ§çÊùÇÔºåÁÆÄÂçïÁöÑËØ¥Â∞±ÊòØÔºö Ë∞ÉÁî®getResponseWithInterceptorChainËé∑ÂèñÊúçÂä°Âô®ËøîÂõû ÈÄöÁü•‰ªªÂä°ÂàÜÂèëÂô®(client.dispatcher)ËØ•‰ªªÂä°Â∑≤ÁªìÊùü getResponseWithInterceptorChainÊûÑÂª∫‰∫Ü‰∏Ä‰∏™Êã¶Êà™Âô®ÈìæÔºåÈÄöËøá‰æùÊ¨°ÊâßË°åËØ•Êã¶Êà™Âô®Èìæ‰∏≠ÁöÑÊØè‰∏Ä‰∏™Êã¶Êà™Âô®ÊúÄÁªàÂæóÂà∞ÊúçÂä°Âô®ËøîÂõû„ÄÇ 3. ÊûÑÂª∫Êã¶Êà™Âô®ÈìæÈ¶ñÂÖàÊù•Áúã‰∏ãgetResponseWithInterceptorChainÁöÑÂÆûÁé∞Ôºö 123456789101112131415161718[RealCall.java] Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; ÂÖ∂ÈÄªËæëÂ§ßËá¥ÂàÜ‰∏∫‰∏§ÈÉ®ÂàÜÔºö ÂàõÂª∫‰∏ÄÁ≥ªÂàóÊã¶Êà™Âô®ÔºåÂπ∂Â∞ÜÂÖ∂ÊîæÂÖ•‰∏Ä‰∏™Êã¶Êà™Âô®Êï∞ÁªÑ‰∏≠„ÄÇËøôÈÉ®ÂàÜÊã¶Êà™Âô®Âç≥ÂåÖÊã¨Áî®Êà∑Ëá™ÂÆö‰πâÁöÑÊã¶Êà™Âô®‰πüÂåÖÊã¨Ê°ÜÊû∂ÂÜÖÈÉ®Êã¶Êà™Âô® ÂàõÂª∫‰∏Ä‰∏™Êã¶Êà™Âô®ÈìæRealInterceptorChain,Âπ∂ÊâßË°åÊã¶Êà™Âô®ÈìæÁöÑproceedÊñπÊ≥ï Êé•‰∏ãÊù•Áúã‰∏ãRealInterceptorChainÁöÑÂÆûÁé∞ÈÄªËæëÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[RealInterceptorChain.java]public final class RealInterceptorChain implements Interceptor.Chain &#123; private final List&lt;Interceptor&gt; interceptors; private final StreamAllocation streamAllocation; private final HttpCodec httpCodec; private final RealConnection connection; private final int index; private final Request request; private int calls; public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection, int index, Request request) &#123; this.interceptors = interceptors; this.connection = connection; this.streamAllocation = streamAllocation; this.httpCodec = httpCodec; this.index = index; this.request = request; &#125; @Override public Connection connection() &#123; return connection; &#125; public StreamAllocation streamAllocation() &#123; return streamAllocation; &#125; public HttpCodec httpStream() &#123; return httpCodec; &#125; @Override public Request request() &#123; return request; &#125; @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; ...... // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); ...... return response; &#125;&#125; Âú®proceedÊñπÊ≥ï‰∏≠ÁöÑÊ†∏ÂøÉ‰ª£Á†ÅÂèØ‰ª•ÁúãÂà∞ÔºåproceedÂÆûÈôÖ‰∏ä‰πüÂÅö‰∫Ü‰∏§‰ª∂‰∫ãÔºö ÂàõÂª∫‰∏ã‰∏Ä‰∏™Êã¶Êà™Èìæ„ÄÇ‰º†ÂÖ•index + 1‰ΩøÂæó‰∏ã‰∏Ä‰∏™Êã¶Êà™Âô®ÈìæÂè™ËÉΩ‰ªé‰∏ã‰∏Ä‰∏™Êã¶Êà™Âô®ÂºÄÂßãËÆøÈóÆ ÊâßË°åÁ¥¢Âºï‰∏∫indexÁöÑinterceptÊñπÊ≥ïÔºåÂπ∂Â∞Ü‰∏ã‰∏Ä‰∏™Êã¶Êà™Âô®Èìæ‰º†ÂÖ•ËØ•ÊñπÊ≥ï Êé•‰∏ãÊù•ÂÜçÁúã‰∏ãÁ¨¨‰∏Ä‰∏™Êã¶Êà™Âô®RetryAndFollowUpInterceptorÁöÑinterceptÊñπÊ≥ïÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[RetryAndFollowUpInterceptor.java]public final class RetryAndFollowUpInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); streamAllocation = new StreamAllocation( client.connectionPool(), createAddress(request.url()), callStackTrace); int followUpCount = 0; Response priorResponse = null; while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException("Canceled"); &#125; Response response = null; boolean releaseConnection = true; try &#123; //ÊâßË°å‰∏ã‰∏Ä‰∏™Êã¶Êà™Âô®ÈìæÁöÑproceedÊñπÊ≥ï response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), false, request)) &#123; throw e.getLastConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. ...... Request followUp = followUpRequest(response); closeQuietly(response.body()); ... &#125; &#125;&#125; ËøôÊÆµ‰ª£Á†ÅÊúÄÂÖ≥ÈîÆÁöÑ‰ª£Á†ÅÊòØ: 1response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); ËøôË°å‰ª£Á†ÅÂ∞±ÊòØÊâßË°å‰∏ã‰∏Ä‰∏™Êã¶Êà™Âô®ÈìæÁöÑproceedÊñπÊ≥ï„ÄÇËÄåÊàë‰ª¨Áü•ÈÅìÂú®‰∏ã‰∏Ä‰∏™Êã¶Êà™Âô®Èìæ‰∏≠Âèà‰ºöÊâßË°å‰∏ã‰∏Ä‰∏™Êã¶Êà™Âô®ÁöÑinterceptÊñπÊ≥ï„ÄÇÊâÄ‰ª•Êï¥‰∏™ÊâßË°åÈìæÂ∞±Âú®Êã¶Êà™Âô®‰∏éÊã¶Êà™Âô®Èìæ‰∏≠‰∫§ÊõøÊâßË°åÔºåÊúÄÁªàÂÆåÊàêÊâÄÊúâÊã¶Êà™Âô®ÁöÑÊìç‰Ωú„ÄÇËøô‰πüÊòØOkHttpÊã¶Êà™Âô®ÁöÑÈìæÂºèÊâßË°åÈÄªËæë„ÄÇËÄå‰∏Ä‰∏™Êã¶Êà™Âô®ÁöÑinterceptÊñπÊ≥ïÊâÄÊâßË°åÁöÑÈÄªËæëÂ§ßËá¥ÂàÜ‰∏∫‰∏âÈÉ®ÂàÜÔºö Âú®ÂèëËµ∑ËØ∑Ê±ÇÂâçÂØπrequestËøõË°åÂ§ÑÁêÜ Ë∞ÉÁî®‰∏ã‰∏Ä‰∏™Êã¶Êà™Âô®ÔºåËé∑Âèñresponse ÂØπresponseËøõË°åÂ§ÑÁêÜÔºåËøîÂõûÁªô‰∏ä‰∏Ä‰∏™Êã¶Êà™Âô® ËøôÂ∞±ÊòØOkHttpÊã¶Êà™Âô®Êú∫Âà∂ÁöÑÊ†∏ÂøÉÈÄªËæë„ÄÇÊâÄ‰ª•‰∏Ä‰∏™ÁΩëÁªúËØ∑Ê±ÇÂÆûÈôÖ‰∏äÂ∞±ÊòØ‰∏Ä‰∏™‰∏™Êã¶Êà™Âô®ÊâßË°åÂÖ∂interceptÊñπÊ≥ïÁöÑËøáÁ®ã„ÄÇËÄåËøôÂÖ∂‰∏≠Èô§‰∫ÜÁî®Êà∑Ëá™ÂÆö‰πâÁöÑÊã¶Êà™Âô®Â§ñËøòÊúâÂá†‰∏™Ê†∏ÂøÉÊã¶Êà™Âô®ÂÆåÊàê‰∫ÜÁΩëÁªúËÆøÈóÆÁöÑÊ†∏ÂøÉÈÄªËæëÔºåÊåâÁÖßÂÖàÂêéÈ°∫Â∫è‰æùÊ¨°ÊòØÔºö RetryAndFollowUpInterceptor BridgeInterceptor CacheInterceptor ConnectIntercetot CallServerInterceptor 4 RetryAndFollowUpInterceptorÂ¶Ç‰∏äÊñá‰ª£Á†ÅÊâÄÁ§∫ÔºåRetryAndFollowUpInterceptorË¥üË¥£‰∏§ÈÉ®ÂàÜÈÄªËæëÔºö Âú®ÁΩëÁªúËØ∑Ê±ÇÂ§±Ë¥•ÂêéËøõË°åÈáçËØï ÂΩìÊúçÂä°Âô®ËøîÂõûÂΩìÂâçËØ∑Ê±ÇÈúÄË¶ÅËøõË°åÈáçÂÆöÂêëÊó∂Áõ¥Êé•ÂèëËµ∑Êñ∞ÁöÑËØ∑Ê±ÇÔºåÂπ∂Âú®Êù°‰ª∂ÂÖÅËÆ∏ÊÉÖÂÜµ‰∏ãÂ§çÁî®ÂΩìÂâçËøûÊé• 5 BridgeInterceptor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public final class BridgeInterceptor implements Interceptor &#123; private final CookieJar cookieJar; public BridgeInterceptor(CookieJar cookieJar) &#123; this.cookieJar = cookieJar; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "BridgeInterceptor.intercept"); Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header("Content-Type", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header("Content-Length", Long.toString(contentLength)); requestBuilder.removeHeader("Transfer-Encoding"); &#125; else &#123; requestBuilder.header("Transfer-Encoding", "chunked"); requestBuilder.removeHeader("Content-Length"); &#125; &#125; if (userRequest.header("Host") == null) &#123; requestBuilder.header("Host", hostHeader(userRequest.url(), false)); &#125; if (userRequest.header("Connection") == null) &#123; requestBuilder.header("Connection", "Keep-Alive"); &#125; // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header("Accept-Encoding") == null &amp;&amp; userRequest.header("Range") == null) &#123; transparentGzip = true; requestBuilder.header("Accept-Encoding", "gzip"); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header("Cookie", cookieHeader(cookies)); &#125; if (userRequest.header("User-Agent") == null) &#123; requestBuilder.header("User-Agent", Version.userAgent()); &#125; Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll("Content-Encoding") .removeAll("Content-Length") .build(); responseBuilder.headers(strippedHeaders); responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125;&#125; BridgeInterceptor‰∏ªË¶ÅË¥üË¥£‰ª•‰∏ãÂá†ÈÉ®ÂàÜÂÜÖÂÆπÔºö ËÆæÁΩÆÂÜÖÂÆπÈïøÂ∫¶ÔºåÂÜÖÂÆπÁºñÁ†Å ËÆæÁΩÆgzipÂéãÁº©ÔºåÂπ∂Âú®Êé•Êî∂Âà∞ÂÜÖÂÆπÂêéËøõË°åËß£Âéã„ÄÇÁúÅÂéª‰∫ÜÂ∫îÁî®Â±ÇÂ§ÑÁêÜÊï∞ÊçÆËß£ÂéãÁöÑÈ∫ªÁÉ¶ Ê∑ªÂä†cookie ËÆæÁΩÆÂÖ∂‰ªñÊä•Â§¥ÔºåÂ¶ÇUser-Agent,Host,Keep-aliveÁ≠â„ÄÇÂÖ∂‰∏≠Keep-AliveÊòØÂÆûÁé∞Â§öË∑ØÂ§çÁî®ÁöÑÂøÖË¶ÅÊ≠•È™§ 6. CacheInterceptor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697[CacheInterceptor.intercept] @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "CacheInterceptor.intercept"); Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don't need the network, we're done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; CacheInterceptorÁöÑËÅåË¥£ÂæàÊòéÁ°ÆÔºåÂ∞±ÊòØË¥üË¥£CacheÁöÑÁÆ°ÁêÜ ÂΩìÁΩëÁªúËØ∑Ê±ÇÊúâÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑCacheÊó∂Áõ¥Êé•ËøîÂõûCache ÂΩìÊúçÂä°Âô®ËøîÂõûÂÜÖÂÆπÊúâÊîπÂèòÊó∂Êõ¥Êñ∞ÂΩìÂâçcache Â¶ÇÊûúÂΩìÂâçcacheÂ§±ÊïàÔºåÂà†Èô§ 7 ConnectInterceptor12345678910111213141516171819202122[ConnectInterceptor.java]public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "ConnectInterceptor.intercept"); RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals("GET"); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125; ConnectInterceptorÁöÑinterceptÊñπÊ≥ïÂè™Êúâ‰∏ÄË°åÂÖ≥ÈîÆ‰ª£Á†Å: 1RealConnection connection = streamAllocation.connection(); Âç≥‰∏∫ÂΩìÂâçËØ∑Ê±ÇÊâæÂà∞ÂêàÈÄÇÁöÑËøûÊé•ÔºåÂèØËÉΩÂ§çÁî®Â∑≤ÊúâËøûÊé•‰πüÂèØËÉΩÊòØÈáçÊñ∞ÂàõÂª∫ÁöÑËøûÊé•ÔºåËøîÂõûÁöÑËøûÊé•Áî±ËøûÊé•Ê±†Ë¥üË¥£ÂÜ≥ÂÆö„ÄÇ 8. CallServerInterceptor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[CallServerInterceptor.java]@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); httpCodec.writeRequestHeaders(request); Response.Builder responseBuilder = null; ...... httpCodec.finishRequest(); if (responseBuilder == null) &#123; responseBuilder = httpCodec.readResponseHeaders(false); &#125; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if ("close".equalsIgnoreCase(response.request().header("Connection")) || "close".equalsIgnoreCase(response.header("Connection"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength()); &#125; return response; &#125; CallServerInterceptorË¥üË¥£ÂêëÊúçÂä°Âô®ÂèëËµ∑ÁúüÊ≠£ÁöÑËÆøÈóÆËØ∑Ê±ÇÔºåÂπ∂Âú®Êé•Êî∂Âà∞ÊúçÂä°Âô®ËøîÂõûÂêéËØªÂèñÂìçÂ∫îËøîÂõû„ÄÇ 8.Êï¥‰ΩìÊµÅÁ®ã‰ª•‰∏äÂ∞±ÊòØÊï¥‰∏™ÁΩëÁªúËÆøÈóÆÁöÑÊ†∏ÂøÉÊ≠•È™§ÔºåÊÄªÁªìËµ∑Êù•Â¶Ç‰∏ãÂõæÊâÄÁ§∫Ôºö OkHttpÊ∫êÁ†ÅÂàÜÊûê‚Äî‚Äî‰ªªÂä°ÈòüÂàó ÂâçÈù¢ÁöÑÂçöÂÆ¢Â∑≤ÁªèÊèêÂà∞ËøáÔºåOkHttpÁöÑ‰∏Ä‰∏™È´òÊïà‰πãÂ§ÑÂú®‰∫éÂú®ÂÜÖÈÉ®Áª¥Êä§‰∫Ü‰∏Ä‰∏™Á∫øÁ®ãÊ±†ÔºåÊñπ‰æøÈ´òÊïàÂú∞ÊâßË°åÂºÇÊ≠•ËØ∑Ê±Ç„ÄÇÊú¨ÁØáÂçöÂÆ¢Â∞ÜËØ¶ÁªÜ‰ªãÁªçOkHttpÁöÑ‰ªªÂä°ÈòüÂàóÊú∫Âà∂„ÄÇ 1. Á∫øÁ®ãÊ±†ÁöÑ‰ºòÁÇπOkHttpÁöÑ‰ªªÂä°ÈòüÂàóÂú®ÂÜÖÈÉ®Áª¥Êä§‰∫Ü‰∏Ä‰∏™Á∫øÁ®ãÊ±†Áî®‰∫éÊâßË°åÂÖ∑‰ΩìÁöÑÁΩëÁªúËØ∑Ê±Ç„ÄÇËÄåÁ∫øÁ®ãÊ±†ÊúÄÂ§ßÁöÑÂ•ΩÂ§ÑÂú®‰∫éÈÄöËøáÁ∫øÁ®ãÂ§çÁî®ÂáèÂ∞ëÈùûÊ†∏ÂøÉ‰ªªÂä°ÁöÑÊçüËÄó„ÄÇ Â§öÁ∫øÁ®ãÊäÄÊúØ‰∏ªË¶ÅËß£ÂÜ≥Â§ÑÁêÜÂô®ÂçïÂÖÉÂÜÖÂ§ö‰∏™Á∫øÁ®ãÊâßË°åÁöÑÈóÆÈ¢òÔºåÂÆÉÂèØ‰ª•ÊòæËëóÂáèÂ∞ëÂ§ÑÁêÜÂô®ÂçïÂÖÉÁöÑÈó≤ÁΩÆÊó∂Èó¥ÔºåÂ¢ûÂä†Â§ÑÁêÜÂô®ÂçïÂÖÉÁöÑÂêûÂêêËÉΩÂäõ„ÄÇ‰ΩÜÂ¶ÇÊûúÂØπÂ§öÁ∫øÁ®ãÂ∫îÁî®‰∏çÂΩìÔºå‰ºöÂ¢ûÂä†ÂØπÂçï‰∏™‰ªªÂä°ÁöÑÂ§ÑÁêÜÊó∂Èó¥„ÄÇÂèØ‰ª•‰∏æ‰∏Ä‰∏™ÁÆÄÂçïÁöÑ‰æãÂ≠êÔºö ÂÅáËÆæÂú®‰∏ÄÂè∞ÊúçÂä°Âô®ÂÆåÊàê‰∏ÄÈ°π‰ªªÂä°ÁöÑÊó∂Èó¥‰∏∫T 1234&gt; T1 ÂàõÂª∫Á∫øÁ®ãÁöÑÊó∂Èó¥&gt; T2 Âú®Á∫øÁ®ã‰∏≠ÊâßË°å‰ªªÂä°ÁöÑÊó∂Èó¥ÔºåÂåÖÊã¨Á∫øÁ®ãÈó¥ÂêåÊ≠•ÊâÄÈúÄÊó∂Èó¥&gt; T3 Á∫øÁ®ãÈîÄÊØÅÁöÑÊó∂Èó¥&gt; &gt; ÊòæÁÑ∂T Ôºù T1ÔºãT2ÔºãT3„ÄÇÊ≥®ÊÑèËøôÊòØ‰∏Ä‰∏™ÊûÅÂ∫¶ÁÆÄÂåñÁöÑÂÅáËÆæ„ÄÇÂèØ‰ª•ÁúãÂá∫T1,T3ÊòØÂ§öÁ∫øÁ®ãÊú¨Ë∫´ÁöÑÂ∏¶Êù•ÁöÑÂºÄÈîÄÔºàÂú®Java‰∏≠ÔºåÈÄöËøáÊò†Â∞ÑpTheadÔºåÂπ∂Ëøõ‰∏ÄÊ≠•ÈÄöËøá&gt;SystemCallÂÆûÁé∞nativeÁ∫øÁ®ãÔºâÔºåÊàë‰ª¨Ê∏¥ÊúõÂáèÂ∞ëT1,T3ÊâÄÁî®ÁöÑÊó∂Èó¥Ôºå‰ªéËÄåÂáèÂ∞ëTÁöÑÊó∂Èó¥„ÄÇ‰ΩÜ‰∏Ä‰∫õÁ∫ø&gt;Á®ãÁöÑ‰ΩøÁî®ËÄÖÂπ∂Ê≤°ÊúâÊ≥®ÊÑèÂà∞Ëøô‰∏ÄÁÇπÔºåÊâÄ‰ª•Âú®Á®ãÂ∫è‰∏≠È¢ëÁπÅÁöÑÂàõÂª∫ÊàñÈîÄÊØÅÁ∫øÁ®ãÔºåËøôÂØºËá¥T1ÂíåT3Âú®T‰∏≠Âç†Êúâ&gt;Áõ∏ÂΩìÊØî‰æã„ÄÇÊòæÁÑ∂ËøôÊòØÁ™ÅÂá∫‰∫ÜÁ∫øÁ®ãÁöÑÂº±ÁÇπÔºàT1ÔºåT3ÔºâÔºåËÄå‰∏çÊòØ‰ºòÁÇπÔºàÂπ∂ÂèëÊÄßÔºâ„ÄÇ Á∫øÁ®ãÊ±†ÊäÄÊúØÊ≠£ÊòØÂÖ≥Ê≥®Â¶Ç‰ΩïÁº©Áü≠ÊàñË∞ÉÊï¥T1ÔºåT3Êó∂Èó¥ÁöÑÊäÄÊúØÔºå‰ªéËÄåÊèêÈ´òÊúçÂä°Âô®Á®ãÂ∫èÊÄßËÉΩÁöÑ„ÄÇ ÈÄöËøáÂØπÁ∫øÁ®ãËøõË°åÁºìÂ≠òÔºåÂáèÂ∞ë‰∫ÜÂàõÂª∫ÈîÄÊØÅÁöÑÊó∂Èó¥ÊçüÂ§± ÈÄöËøáÊéßÂà∂Á∫øÁ®ãÊï∞ÈáèÈòÄÂÄºÔºåÂáèÂ∞ë‰∫ÜÂΩìÁ∫øÁ®ãËøáÂ∞ëÊó∂Â∏¶Êù•ÁöÑCPUÈó≤ÁΩÆÔºàÊØîÂ¶ÇËØ¥ÈïøÊó∂Èó¥Âç°Âú®I/O‰∏ä‰∫ÜÔºâ‰∏éÁ∫øÁ®ãËøáÂ§öÊó∂ÂØπJVMÁöÑÂÜÖÂ≠ò‰∏éÁ∫øÁ®ãÂàáÊç¢Êó∂Á≥ªÁªüË∞ÉÁî®ÁöÑÂéãÂäõ Á±ª‰ººÁöÑËøòÊúâSocketËøûÊé•Ê±†„ÄÅDBËøûÊé•Ê±†„ÄÅCommonPool(ÊØîÂ¶ÇJedis)Á≠âÊäÄÊúØ„ÄÇ 2. OkHttpÁöÑ‰ªªÂä°ÈòüÂàóOkHttpÁöÑ‰ªªÂä°ÈòüÂàó‰∏ªË¶ÅÁî±‰∏§ÈÉ®ÂàÜÁªÑÊàêÔºö ‰ªªÂä°ÂàÜÂèëÂô®dispatcherÔºöË¥üË¥£‰∏∫‰ªªÂä°ÊâæÂà∞ÂêàÈÄÇÁöÑÊâßË°åÁ∫øÁ®ã ÁΩëÁªúËØ∑Ê±Ç‰ªªÂä°Á∫øÁ®ãÊ±† 12345678910111213141516171819202122232425262728293031323334public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; private Runnable idleCallback; /** Executes calls. Created lazily. */ private ExecutorService executorService; /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); public Dispatcher(ExecutorService executorService) &#123; this.executorService = executorService; &#125; public Dispatcher() &#123; &#125; public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; ...&#125; ÂèÇÊï∞ËØ¥ÊòéÂ¶Ç‰∏ãÔºö readyAsyncCallsÔºöÂæÖÊâßË°åÂºÇÊ≠•‰ªªÂä°ÈòüÂàó runningAsyncCallsÔºöËøêË°å‰∏≠ÂºÇÊ≠•‰ªªÂä°ÈòüÂàó runningSyncCallsÔºöËøêË°å‰∏≠ÂêåÊ≠•‰ªªÂä°ÈòüÂàó executorServiceÔºö‰ªªÂä°ÈòüÂàóÁ∫øÁ®ãÊ±†Ôºö 123456789&gt; public ThreadPoolExecutor(int corePoolSize,&gt; int maximumPoolSize,&gt; long keepAliveTime,&gt; TimeUnit unit,&gt; BlockingQueue&lt;Runnable&gt; workQueue,&gt; ThreadFactory threadFactory) &#123;&gt; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,&gt; threadFactory, defaultHandler);&gt; &gt; int corePoolSize: ÊúÄÂ∞èÂπ∂ÂèëÁ∫øÁ®ãÊï∞ÔºåËøôÈáåÂπ∂ÂèëÂêåÊó∂ÂåÖÊã¨Á©∫Èó≤‰∏éÊ¥ªÂä®ÁöÑÁ∫øÁ®ãÔºåÂ¶ÇÊûúÊòØ0ÁöÑËØùÔºåÁ©∫Èó≤‰∏ÄÊÆµÊó∂Èó¥ÂêéÊâÄÊúâÁ∫øÁ®ãÂ∞ÜÂÖ®ÈÉ®Ë¢´ÈîÄÊØÅ int maximumPoolSize: ÊúÄÂ§ßÁ∫øÁ®ãÊï∞ÔºåÂΩì‰ªªÂä°ËøõÊù•Êó∂ÂèØ‰ª•Êâ©ÂÖÖÁöÑÁ∫øÁ®ãÊúÄÂ§ßÂÄºÔºåÂΩìÂ§ß‰∫é‰∫ÜËøô‰∏™ÂÄºÂ∞±‰ºöÊ†πÊçÆ‰∏¢ÂºÉÂ§ÑÁêÜÊú∫Âà∂Êù•Â§ÑÁêÜ long keepAliveTime: ÂΩìÁ∫øÁ®ãÊï∞Â§ß‰∫écorePoolSizeÊó∂ÔºåÂ§ö‰ΩôÁöÑÁ©∫Èó≤Á∫øÁ®ãÁöÑÊúÄÂ§ßÂ≠òÊ¥ªÊó∂Èó¥ÔºåÁ±ª‰ºº‰∫éHTTP‰∏≠ÁöÑKeep-alive TimeUnit unit: Êó∂Èó¥Âçï‰ΩçÔºå‰∏ÄËà¨Áî®Áßí BlockingQueue workQueue: Â∑•‰ΩúÈòüÂàóÔºåÂÖàËøõÂÖàÂá∫ÔºåÂèØ‰ª•ÁúãÂá∫Âπ∂‰∏çÂÉèPicassoÈÇ£Ê†∑ËÆæÁΩÆ‰ºòÂÖàÈòüÂàó ThreadFactory threadFactory: Âçï‰∏™Á∫øÁ®ãÁöÑÂ∑•ÂéÇÔºåÂèØ‰ª•ÊâìLogÔºåËÆæÁΩÆDaemon(Âç≥ÂΩìJVMÈÄÄÂá∫Êó∂ÔºåÁ∫øÁ®ãËá™Âä®ÁªìÊùü)Á≠â ÂèØ‰ª•ÁúãÂá∫ÔºåÂú®Okhttp‰∏≠ÔºåÊûÑÂª∫‰∫Ü‰∏Ä‰∏™ÈòÄÂÄº‰∏∫[0, Integer.MAX_VALUE]ÁöÑÁ∫øÁ®ãÊ±†ÔºåÂÆÉ‰∏ç‰øùÁïô‰ªª‰ΩïÊúÄÂ∞èÁ∫øÁ®ãÊï∞ÔºåÈöèÊó∂ÂàõÂª∫Êõ¥Â§öÁöÑÁ∫øÁ®ãÊï∞ÔºåÂΩìÁ∫øÁ®ãÁ©∫Èó≤Êó∂Âè™ËÉΩÊ¥ª60ÁßíÔºåÂÆÉ‰ΩøÁî®‰∫Ü‰∏Ä‰∏™‰∏çÂ≠òÂÇ®ÂÖÉÁ¥†ÁöÑÈòªÂ°ûÂ∑•‰ΩúÈòüÂàóÔºå‰∏Ä‰∏™Âè´ÂÅö‚ÄùOkHttp Dispatcher‚ÄùÁöÑÁ∫øÁ®ãÂ∑•ÂéÇ„ÄÇ ‰πüÂ∞±ÊòØËØ¥ÔºåÂú®ÂÆûÈôÖËøêË°å‰∏≠ÔºåÂΩìÊî∂Âà∞10‰∏™Âπ∂ÂèëËØ∑Ê±ÇÊó∂ÔºåÁ∫øÁ®ãÊ±†‰ºöÂàõÂª∫ÂçÅ‰∏™Á∫øÁ®ãÔºåÂΩìÂ∑•‰ΩúÂÆåÊàêÂêéÔºåÁ∫øÁ®ãÊ±†‰ºöÂú®60sÂêéÁõ∏ÁªßÂÖ≥Èó≠ÊâÄÊúâÁ∫øÁ®ã„ÄÇ 3. DispatcherÂàÜÂèëÂô®dispatcherÂàÜÂèëÂô®Á±ª‰ºº‰∫éNgnix‰∏≠ÁöÑÂèçÂêë‰ª£ÁêÜÔºåÈÄöËøáDispatcherÂ∞Ü‰ªªÂä°ÂàÜÂèëÂà∞ÂêàÈÄÇÁöÑÁ©∫Èó≤Á∫øÁ®ãÔºåÂÆûÁé∞ÈùûÈòªÂ°ûÔºåÈ´òÂèØÁî®ÔºåÈ´òÂπ∂ÂèëËøûÊé• 1.ÂêåÊ≠•ËØ∑Ê±ÇÂΩìÊàë‰ª¨‰ΩøÁî®OkHttpËøõË°åÂêåÊ≠•ËØ∑Ê±ÇÊó∂Ôºå‰∏ÄËà¨ÊûÑÈÄ†Â¶Ç‰∏ãÔºö 12345OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();Response response = client.newCall(request).execute(); Êé•‰∏ãÊù•ÁúãÁúãRealCall.execute 123456789101112131415@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; ÂêåÊ≠•Ë∞ÉÁî®ÁöÑÊâßË°åÈÄªËæëÊòØÔºö Â∞ÜÂØπÂ∫î‰ªªÂä°Âä†ÂÖ•ÂàÜÂèëÂô® ÊâßË°å‰ªªÂä° ÊâßË°åÂÆåÊàêÂêéÈÄöÁü•dispatcherÂØπÂ∫î‰ªªÂä°Â∑≤ÂÆåÊàêÔºåÂØπÂ∫î‰ªªÂä°Âá∫Èòü 2.ÂºÇÊ≠•ËØ∑Ê±ÇÂºÇÊ≠•ËØ∑Ê±Ç‰∏ÄËà¨ÊûÑÈÄ†Â¶Ç‰∏ãÔºö 12345678910111213141516OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d("OkHttp", "Call Failed:" + e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d("OkHttp", "Call succeeded:" + response.message()); &#125;&#125;); ÂΩìHttpClientÁöÑËØ∑Ê±ÇÂÖ•ÈòüÊó∂ÔºåÊ†πÊçÆ‰ª£Á†ÅÔºåÊàë‰ª¨ÂèØ‰ª•ÂèëÁé∞ÂÆûÈôÖ‰∏äÊòØDispatcherËøõË°å‰∫ÜÂÖ•ÈòüÊìç‰Ωú„ÄÇ 1234567891011synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; //Ê∑ªÂä†Ê≠£Âú®ËøêË°åÁöÑËØ∑Ê±Ç runningAsyncCalls.add(call); //Á∫øÁ®ãÊ±†ÊâßË°åËØ∑Ê±Ç executorService().execute(call); &#125; else &#123; //Ê∑ªÂä†Âà∞ÁºìÂ≠òÈòüÂàóÊéíÈòüÁ≠âÂæÖ readyAsyncCalls.add(call); &#125;&#125; Â¶ÇÊûúÊª°Ë∂≥Êù°‰ª∂Ôºö ÂΩìÂâçËØ∑Ê±ÇÊï∞Â∞è‰∫éÊúÄÂ§ßËØ∑Ê±ÇÊï∞Ôºà64Ôºâ ÂØπÂçï‰∏ÄhostÁöÑËØ∑Ê±ÇÂ∞è‰∫éÈòàÂÄºÔºà5Ôºâ Â∞ÜËØ•‰ªªÂä°ÊèíÂÖ•Ê≠£Âú®ÊâßË°å‰ªªÂä°ÈòüÂàóÔºåÂπ∂ÊâßË°åÂØπÂ∫î‰ªªÂä°„ÄÇÂ¶ÇÊûú‰∏çÊª°Ë∂≥ÂàôÂ∞ÜÂÖ∂ÊîæÂÖ•ÂæÖÊâßË°åÈòüÂàó„ÄÇ Êé•‰∏ãÊù•ÁúãÁúãAsyncCall.execute 1234567891011121314151617181920212223242526@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //ÊâßË°åËÄóÊó∂IO‰ªªÂä° Response response = getResponseWithInterceptorChain(forWebSocket); if (canceled) &#123; signalledCallback = true; //ÂõûË∞ÉÔºåÊ≥®ÊÑèËøôÈáåÂõûË∞ÉÊòØÂú®Á∫øÁ®ãÊ±†‰∏≠ÔºåËÄå‰∏çÊòØÊÉ≥ÂΩìÁÑ∂ÁöÑ‰∏ªÁ∫øÁ®ãÂõûË∞É responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; //ÂõûË∞ÉÔºåÂêå‰∏ä responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; //ÊúÄÂÖ≥ÈîÆÁöÑ‰ª£Á†Å client.dispatcher().finished(this); &#125;&#125; ÂΩì‰ªªÂä°ÊâßË°åÂÆåÊàêÂêéÔºåÊó†ËÆ∫ÊàêÂäü‰∏éÂê¶ÈÉΩ‰ºöË∞ÉÁî®dispatcher.finishedÊñπÊ≥ïÔºåÈÄöÁü•ÂàÜÂèëÂô®Áõ∏ÂÖ≥‰ªªÂä°Â∑≤ÁªìÊùüÔºö 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; Á©∫Èó≤Âá∫Â§ö‰ΩôÁ∫øÁ®ãÔºåË∞ÉÁî®promoteCallsË∞ÉÁî®ÂæÖÊâßË°åÁöÑ‰ªªÂä° Â¶ÇÊûúÂΩìÂâçÊï¥‰∏™Á∫øÁ®ãÊ±†ÈÉΩÁ©∫Èó≤‰∏ãÊù•ÔºåÊâßË°åÁ©∫Èó≤ÈÄöÁü•ÂõûË∞ÉÁ∫øÁ®ã(idleCallback) Êé•‰∏ãÊù•ÁúãÁúãpromoteCallsÔºö 12345678910111213141516private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125;&#125; promoteCallsÁöÑÈÄªËæë‰πüÂæàÁÆÄÂçïÔºöÊâ´ÊèèÂæÖÊâßË°å‰ªªÂä°ÈòüÂàóÔºåÂ∞Ü‰ªªÂä°ÊîæÂÖ•Ê≠£Âú®ÊâßË°å‰ªªÂä°ÈòüÂàóÔºåÂπ∂ÊâßË°åËØ•‰ªªÂä°„ÄÇ 4. ÊÄªÁªì‰ª•‰∏äÂ∞±ÊòØÊï¥‰∏™‰ªªÂä°ÈòüÂàóÁöÑÂÆûÁé∞ÁªÜËäÇÔºåÊÄªÁªìËµ∑Êù•Êúâ‰ª•‰∏ãÂá†‰∏™ÁâπÁÇπÔºö OkHttpÈááÁî®DispatcherÊäÄÊúØÔºåÁ±ª‰ºº‰∫éNginxÔºå‰∏éÁ∫øÁ®ãÊ±†ÈÖçÂêàÂÆûÁé∞‰∫ÜÈ´òÂπ∂ÂèëÔºå‰ΩéÈòªÂ°ûÁöÑËøêË°å OkhttpÈááÁî®Deque‰Ωú‰∏∫ÁºìÂ≠òÔºåÊåâÁÖßÂÖ•ÈòüÁöÑÈ°∫Â∫èÂÖàËøõÂÖàÂá∫ OkHttpÊúÄÂá∫ÂΩ©ÁöÑÂú∞ÊñπÂ∞±ÊòØÂú®try/finally‰∏≠Ë∞ÉÁî®‰∫ÜfinishedÂáΩÊï∞ÔºåÂèØ‰ª•‰∏ªÂä®ÊéßÂà∂Á≠âÂæÖÈòüÂàóÁöÑÁßªÂä®ÔºåËÄå‰∏çÊòØÈááÁî®ÈîÅÊàñËÄÖwait/notifyÔºåÊûÅÂ§ßÂáèÂ∞ë‰∫ÜÁºñÁ†ÅÂ§çÊùÇÊÄß OkHttpÊ∫êÁ†ÅÂàÜÊûê‚Äî‚ÄîÁºìÂ≠òÁ≠ñÁï• ÂêàÁêÜÂú∞Âà©Áî®Êú¨Âú∞ÁºìÂ≠òÂèØ‰ª•ÊúâÊïàÂú∞ÂáèÂ∞ëÁΩëÁªúÂºÄÈîÄÔºåÂáèÂ∞ëÂìçÂ∫îÂª∂Ëøü„ÄÇHTTPÊä•Â§¥‰πüÂÆö‰πâ‰∫ÜÂæàÂ§ö‰∏éÁºìÂ≠òÊúâÂÖ≥ÁöÑÂüüÊù•ÊéßÂà∂ÁºìÂ≠ò„ÄÇ‰ªäÂ§©Â∞±Êù•ËÆ≤ËÆ≤OkHttp‰∏≠ÂÖ≥‰∫éÁºìÂ≠òÈÉ®ÂàÜÁöÑÂÆûÁé∞ÁªÜËäÇ„ÄÇ 1. HTTPÁºìÂ≠òÁ≠ñÁï•È¶ñÂÖàÊù•‰∫ÜËß£‰∏ãHTTPÂçèËÆÆ‰∏≠ÁºìÂ≠òÈÉ®ÂàÜÁöÑÁõ∏ÂÖ≥Âüü„ÄÇ 1.1 ExpiresË∂ÖÊó∂Êó∂Èó¥Ôºå‰∏ÄËà¨Áî®Âú®ÊúçÂä°Âô®ÁöÑresponseÊä•Â§¥‰∏≠Áî®‰∫éÂëäÁü•ÂÆ¢Êà∑Á´ØÂØπÂ∫îËµÑÊ∫êÁöÑËøáÊúüÊó∂Èó¥„ÄÇÂΩìÂÆ¢Êà∑Á´ØÈúÄË¶ÅÂÜçÊ¨°ËØ∑Ê±ÇÁõ∏ÂêåËµÑÊ∫êÊó∂ÂÖàÊØîËæÉÂÖ∂ËøáÊúüÊó∂Èó¥ÔºåÂ¶ÇÊûúÂ∞öÊú™Ë∂ÖËøáËøáÊúüÊó∂Èó¥ÂàôÁõ¥Êé•ËøîÂõûÁºìÂ≠òÁªìÊûúÔºåÂ¶ÇÊûúÂ∑≤ÁªèË∂ÖËøáÂàôÈáçÊñ∞ËØ∑Ê±Ç„ÄÇ 1.2 Cache-ControlÁõ∏ÂØπÂÄºÔºåÂçï‰ΩçÊó∂ÁßíÔºåË°®Á§∫ÂΩìÂâçËµÑÊ∫êÁöÑÊúâÊïàÊúü„ÄÇCache-ControlÊØîExpires‰ºòÂÖàÁ∫ßÊõ¥È´òÔºö 1Cache-Control:max-age=31536000,public 1.3 Êù°‰ª∂GETËØ∑Ê±Ç1.3.1 Last-Modified-DateÂÆ¢Êà∑Á´ØÁ¨¨‰∏ÄÊ¨°ËØ∑Ê±ÇÊó∂ÔºåÊúçÂä°Âô®ËøîÂõûÔºö 1Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT ÂΩìÂÆ¢Êà∑Á´Ø‰∫åÊ¨°ËØ∑Ê±ÇÊó∂ÔºåÂèØ‰ª•Â§¥ÈÉ®Âä†‰∏äÂ¶Ç‰∏ãheader: 1If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT Â¶ÇÊûúÂΩìÂâçËµÑÊ∫êÊ≤°ÊúâË¢´‰∫åÊ¨°‰øÆÊîπÔºåÊúçÂä°Âô®ËøîÂõû304ÂëäÁü•ÂÆ¢Êà∑Á´ØÁõ¥Êé•Â§çÁî®Êú¨Âú∞ÁºìÂ≠ò„ÄÇ 1.3.2 ETagETagÊòØÂØπËµÑÊ∫êÊñá‰ª∂ÁöÑ‰∏ÄÁßçÊëòË¶ÅÔºåÂèØ‰ª•ÈÄöËøáETagÂÄºÊù•Âà§Êñ≠Êñá‰ª∂ÊòØÂê¶Êúâ‰øÆÊîπ„ÄÇÂΩìÂÆ¢Êà∑Á´ØÁ¨¨‰∏ÄÊ¨°ËØ∑Ê±ÇÊüêËµÑÊ∫êÊó∂ÔºåÊúçÂä°Âô®ËøîÂõûÔºö 1ETag: &quot;5694c7ef-24dc&quot; ÂÆ¢Êà∑Á´ØÂÜçÊ¨°ËØ∑Ê±ÇÊó∂ÔºåÂèØÂú®Â§¥ÈÉ®Âä†‰∏äÂ¶Ç‰∏ãÂüüÔºö 1If-None-Match: &quot;5694c7ef-24dc&quot; Â¶ÇÊûúÊñá‰ª∂Âπ∂Êú™ÊîπÂèòÔºåÂàôÊúçÂä°Âô®ËøîÂõû304ÂëäÁü•ÂÆ¢Êà∑Á´ØÂèØ‰ª•Â§çÁî®Êú¨Âú∞ÁºìÂ≠ò„ÄÇ 1.4 no-cache/no-store‰∏ç‰ΩøÁî®ÁºìÂ≠ò 1.5 only-if-cachedÂè™‰ΩøÁî®ÁºìÂ≠ò 2. CacheÊ∫êÁ†ÅÂàÜÊûêOkHttpÁöÑÁºìÂ≠òÂ∑•‰ΩúÈÉΩÊòØÂú®CacheInterceptor‰∏≠ÂÆåÊàêÁöÑ,CacheÈÉ®ÂàÜÊúâÂ¶Ç‰∏ãÂá†‰∏™ÂÖ≥ÈîÆÁ±ªÔºö CacheÔºöCacheÁÆ°ÁêÜÂô®ÔºåÂÖ∂ÂÜÖÈÉ®ÂåÖÂê´‰∏Ä‰∏™DiskLruCacheÂ∞ÜcacheÂÜôÂÖ•Êñá‰ª∂Á≥ªÁªü: 12345678910111213141516171819202122&gt; * &lt;h3&gt;Cache Optimization&lt;/h3&gt;&gt; *&gt; * &lt;p&gt;To measure cache effectiveness, this class tracks three statistics:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #requestCount() Request Count:&#125;&lt;/strong&gt; the number of HTTP&gt; * requests issued since this cache was created.&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #networkCount() Network Count:&#125;&lt;/strong&gt; the number of those&gt; * requests that required network use.&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #hitCount() Hit Count:&#125;&lt;/strong&gt; the number of those requests&gt; * whose responses were served by the cache.&gt; * &lt;/ul&gt;&gt; *&gt; * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of&gt; * the response, the client will issue a conditional &#123;@code GET&#125;. The server will then send either&gt; * the updated response if it has changed, or a short &apos;not modified&apos; response if the client&apos;s copy&gt; * is still valid. Such responses increment both the network count and hit count.&gt; *&gt; * &lt;p&gt;The best way to improve the cache hit rate is by configuring the web server to return&gt; * cacheable responses. Although this client honors all &lt;a&gt; * href=&quot;http://tools.ietf.org/html/rfc7234&quot;&gt;HTTP/1.1 (RFC 7234)&lt;/a&gt; cache headers, it doesn&apos;t cache&gt; * partial responses.&gt; &gt; CacheÂÜÖÈÉ®ÈÄöËøárequestCount,networkCount,hitCount‰∏â‰∏™ÁªüËÆ°ÊåáÊ†áÊù•‰ºòÂåñÁºìÂ≠òÊïàÁéá CacheStrategyÔºöÁºìÂ≠òÁ≠ñÁï•„ÄÇÂÖ∂ÂÜÖÈÉ®Áª¥Êä§‰∏Ä‰∏™requestÂíåresponseÔºåÈÄöËøáÊåáÂÆörequestÂíåresponseÊù•ÊèèËø∞ÊòØÈÄöËøáÁΩëÁªúËøòÊòØÁºìÂ≠òËé∑ÂèñresponseÔºåÊäëÊàñ‰∫åËÄÖÂêåÊó∂‰ΩøÁî® 123456789101112131415161718&gt; [CacheStrategy.java]&gt; /**&gt; * Given a request and cached response, this figures out whether to use the network, the cache, or&gt; * both.&gt; *&gt; * &lt;p&gt;Selecting a cache strategy may add conditions to the request (like the &quot;If-Modified-Since&quot;&gt; * header for conditional GETs) or warnings to the cached response (if the cached data is&gt; * potentially stale).&gt; */&gt; public final class CacheStrategy &#123;&gt; /** The request to send on the network, or null if this call doesn&apos;t use the network. */&gt; public final Request networkRequest;&gt;&gt; /** The cached response to return or validate; or null if this call doesn&apos;t use a cache. */&gt; public final Response cacheResponse;&gt; ......&gt; &#125;&gt; CacheStrategy$Factory:ÁºìÂ≠òÁ≠ñÁï•Â∑•ÂéÇÁ±ªÊ†πÊçÆÂÆûÈôÖËØ∑Ê±ÇËøîÂõûÂØπÂ∫îÁöÑÁºìÂ≠òÁ≠ñÁï• Êó¢ÁÑ∂ÂÆûÈôÖÁöÑÁºìÂ≠òÂ∑•‰ΩúÈÉΩÊòØÂú®CacheInterceptor‰∏≠ÂÆåÊàêÁöÑÔºåÈÇ£‰πàÊé•‰∏ãÊù•Áúã‰∏ãCahceInterceptorÁöÑÊ†∏ÂøÉÊñπÊ≥ïinterceptÊñπÊ≥ïÊ∫êÁ†Å: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101[CacheInterceptor.java]@Override public Response intercept(Chain chain) throws IOException &#123; //È¶ñÂÖàÂ∞ùËØïËé∑ÂèñÁºìÂ≠ò Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //Ëé∑ÂèñÁºìÂ≠òÁ≠ñÁï• CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; //Â¶ÇÊûúÊúâÁºìÂ≠òÔºåÊõ¥Êñ∞‰∏ãÁõ∏ÂÖ≥ÁªüËÆ°ÊåáÊ†áÔºöÂëΩ‰∏≠Áéá if (cache != null) &#123; cache.trackResponse(strategy); &#125; //Â¶ÇÊûúÂΩìÂâçÁºìÂ≠ò‰∏çÁ¨¶ÂêàË¶ÅÊ±ÇÔºåÂ∞ÜÂÖ∂close if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // Â¶ÇÊûú‰∏çËÉΩ‰ΩøÁî®ÁΩëÁªúÔºåÂêåÊó∂ÂèàÊ≤°ÊúâÁ¨¶ÂêàÊù°‰ª∂ÁöÑÁºìÂ≠òÔºåÁõ¥Êé•Êäõ504ÈîôËØØ if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // Â¶ÇÊûúÊúâÁºìÂ≠òÂêåÊó∂Âèà‰∏ç‰ΩøÁî®ÁΩëÁªúÔºåÂàôÁõ¥Êé•ËøîÂõûÁºìÂ≠òÁªìÊûú if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; //Â∞ùËØïÈÄöËøáÁΩëÁªúËé∑ÂèñÂõûÂ§ç Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // Â¶ÇÊûúÊó¢ÊúâÁºìÂ≠òÔºåÂêåÊó∂ÂèàÂèëËµ∑‰∫ÜËØ∑Ê±ÇÔºåËØ¥ÊòéÊ≠§Êó∂ÊòØ‰∏Ä‰∏™Conditional GetËØ∑Ê±Ç if (cacheResponse != null) &#123; // Â¶ÇÊûúÊúçÂä°Á´ØËøîÂõûÁöÑÊòØNOT_MODIFIED,ÁºìÂ≠òÊúâÊïàÔºåÂ∞ÜÊú¨Âú∞ÁºìÂ≠òÂíåÁΩëÁªúÂìçÂ∫îÂÅöÂêàÂπ∂ if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123;// Â¶ÇÊûúÂìçÂ∫îËµÑÊ∫êÊúâÊõ¥Êñ∞ÔºåÂÖ≥ÊéâÂéüÊúâÁºìÂ≠ò closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Â∞ÜÁΩëÁªúÂìçÂ∫îÂÜôÂÖ•cache‰∏≠ CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; Ê†∏ÂøÉÈÄªËæëÈÉΩ‰ª•‰∏≠ÊñáÊ≥®ÈáäÁöÑÂΩ¢ÂºèÂú®‰ª£Á†Å‰∏≠Ê†áÊ≥®Âá∫Êù•‰∫ÜÔºåÂ§ßÂÆ∂Áúã‰ª£Á†ÅÂç≥ÂèØ„ÄÇÈÄöËøá‰∏äÈù¢ÁöÑ‰ª£Á†ÅÂèØ‰ª•ÁúãÂá∫ÔºåÂá†‰πéÊâÄÊúâÁöÑÂä®‰ΩúÈÉΩÊòØ‰ª•CacheStrategyÁºìÂ≠òÁ≠ñÁï•‰∏∫‰æùÊçÆÂÅöÂá∫ÁöÑÔºåÈÇ£‰πàÊé•‰∏ãÊù•Áúã‰∏ãÁºìÂ≠òÁ≠ñÁï•ÊòØÂ¶Ç‰ΩïÁîüÊàêÁöÑÔºåÁõ∏ÂÖ≥‰ª£Á†ÅÂÆûÁé∞Âú®CacheStrategy$Factory.get()ÊñπÊ≥ï‰∏≠Ôºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[CacheStrategy$Factory] /** * Returns a strategy to satisfy &#123;@code request&#125; using the a cached response &#123;@code response&#125;. */ public CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) &#123; // We're forbidden from using the network and the cache is insufficient. return new CacheStrategy(null, null); &#125; return candidate; &#125; /** Returns a strategy to use assuming the request can use the network. */ private CacheStrategy getCandidate() &#123; // Ëã•Êú¨Âú∞Ê≤°ÊúâÁºìÂ≠òÔºåÂèëËµ∑ÁΩëÁªúËØ∑Ê±Ç if (cacheResponse == null) &#123; return new CacheStrategy(request, null); &#125; // Â¶ÇÊûúÂΩìÂâçËØ∑Ê±ÇÊòØHTTPSÔºåËÄåÁºìÂ≠òÊ≤°ÊúâTLSÊè°ÊâãÔºåÈáçÊñ∞ÂèëËµ∑ÁΩëÁªúËØ∑Ê±Ç if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123; return new CacheStrategy(request, null); &#125; // If this response shouldn't have been stored, it should never be used // as a response source. This check should be redundant as long as the // persistence store is well-behaved and the rules are constant. if (!isCacheable(cacheResponse, request)) &#123; return new CacheStrategy(request, null); &#125; //Â¶ÇÊûúÂΩìÂâçÁöÑÁºìÂ≠òÁ≠ñÁï•ÊòØ‰∏çÁºìÂ≠òÊàñËÄÖÊòØconditional getÔºåÂèëËµ∑ÁΩëÁªúËØ∑Ê±Ç CacheControl requestCaching = request.cacheControl(); if (requestCaching.noCache() || hasConditions(request)) &#123; return new CacheStrategy(request, null); &#125; //ageMillis:ÁºìÂ≠òage long ageMillis = cacheResponseAge(); //freshMillisÔºöÁºìÂ≠ò‰øùÈ≤úÊó∂Èó¥ long freshMillis = computeFreshnessLifetime(); if (requestCaching.maxAgeSeconds() != -1) &#123; freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds())); &#125; long minFreshMillis = 0; if (requestCaching.minFreshSeconds() != -1) &#123; minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds()); &#125; long maxStaleMillis = 0; CacheControl responseCaching = cacheResponse.cacheControl(); if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123; maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds()); &#125; //Â¶ÇÊûú age + min-fresh &gt;= max-age &amp;&amp; age + min-fresh &lt; max-age + max-staleÔºåÂàôËôΩÁÑ∂ÁºìÂ≠òËøáÊúü‰∫ÜÔºå //‰ΩÜÊòØÁºìÂ≠òÁªßÁª≠ÂèØ‰ª•‰ΩøÁî®ÔºåÂè™ÊòØÂú®Â§¥ÈÉ®Ê∑ªÂä† 110 Ë≠¶ÂëäÁ†Å if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123; Response.Builder builder = cacheResponse.newBuilder(); if (ageMillis + minFreshMillis &gt;= freshMillis) &#123; builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\""); &#125; long oneDayMillis = 24 * 60 * 60 * 1000L; if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123; builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\""); &#125; return new CacheStrategy(null, builder.build()); &#125; // ÂèëËµ∑conditional getËØ∑Ê±Ç String conditionName; String conditionValue; if (etag != null) &#123; conditionName = "If-None-Match"; conditionValue = etag; &#125; else if (lastModified != null) &#123; conditionName = "If-Modified-Since"; conditionValue = lastModifiedString; &#125; else if (servedDate != null) &#123; conditionName = "If-Modified-Since"; conditionValue = servedDateString; &#125; else &#123; return new CacheStrategy(request, null); // No condition! Make a regular request. &#125; Headers.Builder conditionalRequestHeaders = request.headers().newBuilder(); Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue); Request conditionalRequest = request.newBuilder() .headers(conditionalRequestHeaders.build()) .build(); return new CacheStrategy(conditionalRequest, cacheResponse); &#125; ÂèØ‰ª•ÁúãÂà∞ÂÖ∂Ê†∏ÂøÉÈÄªËæëÂú®getCandidateÂáΩÊï∞‰∏≠„ÄÇÂü∫Êú¨Â∞±ÊòØHTTPÁºìÂ≠òÂçèËÆÆÁöÑÂÆûÁé∞ÔºåÊ†∏ÂøÉ‰ª£Á†ÅÈÄªËæëÂ∑≤ÈÄöËøá‰∏≠ÊñáÊ≥®ÈáäËØ¥ÊòéÔºåÂ§ßÂÆ∂Áõ¥Êé•Áúã‰ª£Á†ÅÂ∞±Â•Ω„ÄÇ 3. DiskLruCacheCacheÂÜÖÈÉ®ÈÄöËøáDiskLruCacheÁÆ°ÁêÜcacheÂú®Êñá‰ª∂Á≥ªÁªüÂ±ÇÈù¢ÁöÑÂàõÂª∫ÔºåËØªÂèñÔºåÊ∏ÖÁêÜÁ≠âÁ≠âÂ∑•‰ΩúÔºåÊé•‰∏ãÊù•Áúã‰∏ãDiskLruCacheÁöÑ‰∏ªË¶ÅÈÄªËæëÔºö 123456789101112131415161718192021222324252627282930313233343536public final class DiskLruCache implements Closeable, Flushable &#123; final FileSystem fileSystem; final File directory; private final File journalFile; private final File journalFileTmp; private final File journalFileBackup; private final int appVersion; private long maxSize; final int valueCount; private long size = 0; BufferedSink journalWriter; final LinkedHashMap&lt;String, Entry&gt; lruEntries = new LinkedHashMap&lt;&gt;(0, 0.75f, true); // Must be read and written when synchronized on 'this'. boolean initialized; boolean closed; boolean mostRecentTrimFailed; boolean mostRecentRebuildFailed; /** * To differentiate between old and current snapshots, each entry is given a sequence number each * time an edit is committed. A snapshot is stale if its sequence number is not equal to its * entry's sequence number. */ private long nextSequenceNumber = 0; /** Used to run 'cleanupRunnable' for journal rebuilds. */ private final Executor executor; private final Runnable cleanupRunnable = new Runnable() &#123; public void run() &#123; ...... &#125; &#125;; ... &#125; 3.1 journalFileDiskLruCacheÂÜÖÈÉ®Êó•ÂøóÊñá‰ª∂ÔºåÂØπcacheÁöÑÊØè‰∏ÄÊ¨°ËØªÂÜôÈÉΩÂØπÂ∫î‰∏ÄÊù°Êó•ÂøóËÆ∞ÂΩïÔºåDiskLruCacheÈÄöËøáÂàÜÊûêÊó•ÂøóÂàÜÊûêÂíåÂàõÂª∫cache„ÄÇÊó•ÂøóÊñá‰ª∂Ê†ºÂºèÂ¶Ç‰∏ãÔºö 123456789101112131415161718192021 libcore.io.DiskLruCache 1 100 2 CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c4c6028171cfddfbaae1a9c313c52 CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342 REMOVE 335c4c6028171cfddfbaae1a9c313c52 DIRTY 1ab96a171faeeee38496d8b330771a7a CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234 READ 335c4c6028171cfddfbaae1a9c313c52 READ 3400330d1dfc7f3f7f4b8d4d803dfcf6Ââç5Ë°åÂõ∫ÂÆö‰∏çÂèòÔºåÂàÜÂà´‰∏∫ÔºöÂ∏∏ÈáèÔºölibcore.io.DiskLruCacheÔºõdiskCacheÁâàÊú¨ÔºõÂ∫îÁî®Á®ãÂ∫èÁâàÊú¨ÔºõvalueCount(ÂêéÊñá‰ªãÁªç)ÔºåÁ©∫Ë°åÊé•‰∏ãÊù•ÊØè‰∏ÄË°åÂØπÂ∫î‰∏Ä‰∏™cache entryÁöÑ‰∏ÄÊ¨°Áä∂ÊÄÅËÆ∞ÂΩïÔºåÂÖ∂Ê†ºÂºè‰∏∫Ôºö[Áä∂ÊÄÅÔºàDIRTY,CLEAN,READ,REMOVEÔºâÔºåkeyÔºåÁä∂ÊÄÅÁõ∏ÂÖ≥value(ÂèØÈÄâ)]:- DIRTY:Ë°®Êòé‰∏Ä‰∏™cache entryÊ≠£Âú®Ë¢´ÂàõÂª∫ÊàñÊõ¥Êñ∞ÔºåÊØè‰∏Ä‰∏™ÊàêÂäüÁöÑDIRTYËÆ∞ÂΩïÈÉΩÂ∫îËØ•ÂØπÂ∫î‰∏Ä‰∏™CLEANÊàñREMOVEÊìç‰Ωú„ÄÇÂ¶ÇÊûú‰∏Ä‰∏™DIRTYÁº∫Â∞ëÈ¢ÑÊúüÂåπÈÖçÁöÑCLEAN/REMOVEÔºåÂàôÂØπÂ∫îentryÊìç‰ΩúÂ§±Ë¥•ÔºåÈúÄË¶ÅÂ∞ÜÂÖ∂‰ªélruEntries‰∏≠Âà†Èô§- CLEAN:ËØ¥ÊòécacheÂ∑≤ÁªèË¢´ÊàêÂäüÊìç‰ΩúÔºåÂΩìÂâçÂèØ‰ª•Ë¢´Ê≠£Â∏∏ËØªÂèñ„ÄÇÊØè‰∏Ä‰∏™CLEANË°åËøòÈúÄË¶ÅËÆ∞ÂΩïÂÖ∂ÊØè‰∏Ä‰∏™valueÁöÑÈïøÂ∫¶- READ: ËÆ∞ÂΩï‰∏ÄÊ¨°cacheËØªÂèñÊìç‰Ωú- REMOVE:ËÆ∞ÂΩï‰∏ÄÊ¨°cacheÊ∏ÖÈô§ Êó•ÂøóÊñá‰ª∂ÁöÑÂ∫îÁî®Âú∫ÊôØ‰∏ªË¶ÅÊúâÂõõ‰∏™Ôºö DiskCacheLruÂàùÂßãÂåñÊó∂ÈÄöËøáËØªÂèñÊó•ÂøóÊñá‰ª∂ÂàõÂª∫cacheÂÆπÂô®ÔºölruEntries„ÄÇÂêåÊó∂ÈÄöËøáÊó•ÂøóËøáÊª§Êìç‰Ωú‰∏çÊàêÂäüÁöÑcacheÈ°π„ÄÇÁõ∏ÂÖ≥ÈÄªËæëÂú®DiskLruCache.readJournalLine,DiskLruCache.processJournal ÂàùÂßãÂåñÂÆåÊàêÂêéÔºå‰∏∫ÈÅøÂÖçÊó•ÂøóÊñá‰ª∂‰∏çÊñ≠ËÜ®ËÉÄÔºåÂØπÊó•ÂøóËøõË°åÈáçÂª∫Á≤æÁÆÄÔºåÂÖ∑‰ΩìÈÄªËæëÂú®DiskLruCache.rebuildJournal ÊØèÂΩìÊúâcacheÊìç‰ΩúÊó∂Â∞ÜÂÖ∂ËÆ∞ÂΩïÂÖ•Êó•ÂøóÊñá‰ª∂‰∏≠‰ª•Â§á‰∏ãÊ¨°ÂàùÂßãÂåñÊó∂‰ΩøÁî® ÂΩìÂÜó‰ΩôÊó•ÂøóËøáÂ§öÊó∂ÔºåÈÄöËøáË∞ÉÁî®cleanUpRunnableÁ∫øÁ®ãÈáçÂª∫Êó•Âøó 3.2 DiskLruCache.EntryÊØè‰∏Ä‰∏™DiskLruCache.EntryÂØπÂ∫î‰∏Ä‰∏™cacheËÆ∞ÂΩïÔºö 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private final class Entry &#123; final String key; /** Lengths of this entry's files. */ final long[] lengths; final File[] cleanFiles; final File[] dirtyFiles; /** True if this entry has ever been published. */ boolean readable; /** The ongoing edit or null if this entry is not being edited. */ Editor currentEditor; /** The sequence number of the most recently committed edit to this entry. */ long sequenceNumber; Entry(String key) &#123; this.key = key; lengths = new long[valueCount]; cleanFiles = new File[valueCount]; dirtyFiles = new File[valueCount]; // The names are repetitive so re-use the same builder to avoid allocations. StringBuilder fileBuilder = new StringBuilder(key).append('.'); int truncateTo = fileBuilder.length(); for (int i = 0; i &lt; valueCount; i++) &#123; fileBuilder.append(i); cleanFiles[i] = new File(directory, fileBuilder.toString()); fileBuilder.append(".tmp"); dirtyFiles[i] = new File(directory, fileBuilder.toString()); fileBuilder.setLength(truncateTo); &#125; &#125; ... /** * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a * single published snapshot. If we opened streams lazily then the streams could come from * different edits. */ Snapshot snapshot() &#123; if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError(); Source[] sources = new Source[valueCount]; long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out. try &#123; for (int i = 0; i &lt; valueCount; i++) &#123; sources[i] = fileSystem.source(cleanFiles[i]); &#125; return new Snapshot(key, sequenceNumber, sources, lengths); &#125; catch (FileNotFoundException e) &#123; // A file must have been deleted manually! for (int i = 0; i &lt; valueCount; i++) &#123; if (sources[i] != null) &#123; Util.closeQuietly(sources[i]); &#125; else &#123; break; &#125; &#125; // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache // size.) try &#123; removeEntry(this); &#125; catch (IOException ignored) &#123; &#125; return null; &#125; &#125;&#125; ‰∏Ä‰∏™Entry‰∏ªË¶ÅÁî±‰ª•‰∏ãÂá†ÈÉ®ÂàÜÊûÑÊàêÔºö keyÔºöÊØè‰∏™cacheÈÉΩÊúâ‰∏Ä‰∏™key‰Ωú‰∏∫ÂÖ∂Ê†áËØÜÁ¨¶„ÄÇÂΩìÂâçcacheÁöÑkey‰∏∫ÂÖ∂ÂØπÂ∫îURLÁöÑMD5Â≠óÁ¨¶‰∏≤ cleanFiles/dirtyFilesÔºöÊØè‰∏Ä‰∏™EntryÂØπÂ∫îÂ§ö‰∏™Êñá‰ª∂ÔºåÂÖ∂ÂØπÂ∫îÁöÑÊñá‰ª∂Êï∞Áî±DiskLruCache.valueCountÊåáÂÆö„ÄÇÂΩìÂâçÂú®OkHttp‰∏≠valueCount‰∏∫2„ÄÇÂç≥ÊØè‰∏™cacheÂØπÂ∫î2‰∏™cleanFilesÔºå2‰∏™dirtyFiles„ÄÇÂÖ∂‰∏≠Á¨¨‰∏Ä‰∏™cleanFiles/dirtyFilesËÆ∞ÂΩïcacheÁöÑmetaÊï∞ÊçÆÔºàÂ¶ÇURL,ÂàõÂª∫Êó∂Èó¥ÔºåSSLÊè°ÊâãËÆ∞ÂΩïÁ≠âÁ≠âÔºâÔºåÁ¨¨‰∫å‰∏™Êñá‰ª∂ËÆ∞ÂΩïcacheÁöÑÁúüÊ≠£ÂÜÖÂÆπ„ÄÇcleanFilesËÆ∞ÂΩïÂ§Ñ‰∫éÁ®≥ÂÆöÁä∂ÊÄÅÁöÑcacheÁªìÊûúÔºådirtyFilesËÆ∞ÂΩïÂ§Ñ‰∫éÂàõÂª∫ÊàñÊõ¥Êñ∞Áä∂ÊÄÅÁöÑcache currentEditorÔºöentryÁºñËæëÂô®ÔºåÂØπentryÁöÑÊâÄÊúâÊìç‰ΩúÈÉΩÊòØÈÄöËøáÂÖ∂ÁºñËæëÂô®ÂÆåÊàê„ÄÇÁºñËæëÂô®ÂÜÖÈÉ®Ê∑ªÂä†‰∫ÜÂêåÊ≠•ÈîÅ 3.3 cleanupRunnableÊ∏ÖÁêÜÁ∫øÁ®ãÔºåÁî®‰∫éÈáçÂª∫Á≤æÁÆÄÊó•ÂøóÔºö 12345678910111213141516171819202122232425private final Runnable cleanupRunnable = new Runnable() &#123; public void run() &#123; synchronized (DiskLruCache.this) &#123; if (!initialized | closed) &#123; return; // Nothing to do &#125; try &#123; trimToSize(); &#125; catch (IOException ignored) &#123; mostRecentTrimFailed = true; &#125; try &#123; if (journalRebuildRequired()) &#123; rebuildJournal(); redundantOpCount = 0; &#125; &#125; catch (IOException e) &#123; mostRecentRebuildFailed = true; journalWriter = Okio.buffer(Okio.blackhole()); &#125; &#125; &#125;&#125;; ÂÖ∂Ëß¶ÂèëÊù°‰ª∂Âú®journalRebuildRequired()ÊñπÊ≥ï‰∏≠Ôºö 123456789/** * We only rebuild the journal when it will halve the size of the journal and eliminate at least * 2000 ops. */boolean journalRebuildRequired() &#123; final int redundantOpCompactThreshold = 2000; return redundantOpCount &gt;= redundantOpCompactThreshold &amp;&amp; redundantOpCount &gt;= lruEntries.size();&#125; ÂΩìÂÜó‰ΩôÊó•ÂøóË∂ÖËøáÊó•ÂøóÊñá‰ª∂Êú¨Ë∫´ÁöÑ‰∏ÄËà¨‰∏îÊÄªÊù°Êï∞Ë∂ÖËøá2000Êó∂ÊâßË°å 3.4 SnapShotcacheÂø´ÁÖßÔºåËÆ∞ÂΩï‰∫ÜÁâπÂÆöcacheÂú®Êüê‰∏Ä‰∏™ÁâπÂÆöÊó∂ÂàªÁöÑÂÜÖÂÆπ„ÄÇÊØèÊ¨°ÂêëDiskLruCacheËØ∑Ê±ÇÊó∂ËøîÂõûÁöÑÈÉΩÊòØÁõÆÊ†ácacheÁöÑ‰∏Ä‰∏™Âø´ÁÖß,Áõ∏ÂÖ≥ÈÄªËæëÂú®DiskLruCache.get‰∏≠Ôºö 12345678910111213141516171819202122232425[DiskLruCache.java] /** * Returns a snapshot of the entry named &#123;@code key&#125;, or null if it doesn't exist is not currently * readable. If a value is returned, it is moved to the head of the LRU queue. */ public synchronized Snapshot get(String key) throws IOException &#123; initialize(); checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (entry == null || !entry.readable) return null; Snapshot snapshot = entry.snapshot(); if (snapshot == null) return null; redundantOpCount++; //Êó•ÂøóËÆ∞ÂΩï journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n'); if (journalRebuildRequired()) &#123; executor.execute(cleanupRunnable); &#125; return snapshot; &#125; 3.5 lruEntriesÁÆ°ÁêÜcache entryÁöÑÂÆπÂô®ÔºåÂÖ∂Êï∞ÊçÆÁªìÊûÑÊòØLinkedHashMap„ÄÇÈÄöËøáLinkedHashMapÊú¨Ë∫´ÁöÑÂÆûÁé∞ÈÄªËæëËææÂà∞cacheÁöÑLRUÊõøÊç¢ 3.6 FileSystem‰ΩøÁî®OkioÂØπFileÁöÑÂ∞ÅË£ÖÔºåÁÆÄÂåñ‰∫ÜI/OÊìç‰Ωú„ÄÇ 3.7 DiskLruCache.editDiskLruCacheÂèØ‰ª•ÁúãÊàêÊòØCacheÂú®Êñá‰ª∂Á≥ªÁªüÂ±ÇÁöÑÂÖ∑‰ΩìÂÆûÁé∞ÔºåÊâÄ‰ª•ÂÖ∂Âü∫Êú¨Êìç‰ΩúÊé•Âè£Â≠òÂú®‰∏Ä‰∏ÄÂØπÂ∫îÁöÑÂÖ≥Á≥ªÔºö Cache.get() ‚Äî&gt;DiskLruCache.get() Cache.put()‚Äî&gt;DiskLruCache.edit() //cacheÊèíÂÖ• Cache.remove()‚Äî&gt;DiskLruCache.remove() Cache.update()‚Äî&gt;DiskLruCache.edit()//cacheÊõ¥Êñ∞ ÂÖ∂‰∏≠getÊìç‰ΩúÂú®3.4Â∑≤Áªè‰ªãÁªç‰∫ÜÔºåremoveÊìç‰ΩúËæÉ‰∏∫ÁÆÄÂçïÔºåputÂíåupdateÂ§ßËá¥ÈÄªËæëÁõ∏‰ººÔºåÂõ†‰∏∫ÁØáÂπÖÈôêÂà∂ÔºåËøôÈáå‰ªÖ‰ªãÁªçCache.putÊìç‰ΩúÁöÑÈÄªËæëÔºåÂÖ∂‰ªñÁöÑÊìç‰ΩúÂ§ßÂÆ∂Áúã‰ª£Á†ÅÂ∞±Â•Ω: 12345678910111213141516171819202122232425262728293031323334353637[okhttp3.Cache.java] CacheRequest put(Response response) &#123; String requestMethod = response.request().method(); if (HttpMethod.invalidatesCache(response.request().method())) &#123; try &#123; remove(response.request()); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; return null; &#125; if (!requestMethod.equals("GET")) &#123; // Don't cache non-GET responses. We're technically allowed to cache // HEAD requests and some POST requests, but the complexity of doing // so is high and the benefit is low. return null; &#125; if (HttpHeaders.hasVaryAll(response)) &#123; return null; &#125; Entry entry = new Entry(response); DiskLruCache.Editor editor = null; try &#123; editor = cache.edit(key(response.request().url())); if (editor == null) &#123; return null; &#125; entry.writeTo(editor); return new CacheRequestImpl(editor); &#125; catch (IOException e) &#123; abortQuietly(editor); return null; &#125; &#125; ÂèØ‰ª•ÁúãÂà∞Ê†∏ÂøÉÈÄªËæëÂú®editor = cache.edit(key(response.request().url()));,Áõ∏ÂÖ≥‰ª£Á†ÅÂú®DiskLruCache.edit: 12345678910111213141516171819202122232425262728293031323334353637383940[okhttp3.internal.cache.DiskLruCache.java] synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; initialize(); checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // Snapshot is stale. &#125; if (entry != null &amp;&amp; entry.currentEditor != null) &#123; return null; // ÂΩìÂâçcache entryÊ≠£Âú®Ë¢´ÂÖ∂‰ªñÂØπË±°Êìç‰Ωú &#125; if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123; // The OS has become our enemy! If the trim job failed, it means we are storing more data than // requested by the user. Do not allow edits so we do not go over that limit any further. If // the journal rebuild failed, the journal writer will not be active, meaning we will not be // able to record the edit, causing file leaks. In both cases, we want to retry the clean up // so we can get out of this state! executor.execute(cleanupRunnable); return null; &#125; // Êó•ÂøóÊé•ÂÖ•DIRTYËÆ∞ÂΩï journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n'); journalWriter.flush(); if (hasJournalErrors) &#123; return null; // Don't edit; the journal can't be written. &#125; if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; return editor; &#125; editÊñπÊ≥ïËøîÂõûÂØπÂ∫îCacheEntryÁöÑeditorÁºñËæëÂô®„ÄÇÊé•‰∏ãÊù•ÂÜçÊù•Áúã‰∏ãCache.put()ÊñπÊ≥ïÁöÑentry.writeTo(editor);,ÂÖ∂Áõ∏ÂÖ≥ÈÄªËæëÔºö 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[okhttp3.internal.cache.DiskLruCache.java] public void writeTo(DiskLruCache.Editor editor) throws IOException &#123; BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA)); sink.writeUtf8(url) .writeByte('\n'); sink.writeUtf8(requestMethod) .writeByte('\n'); sink.writeDecimalLong(varyHeaders.size()) .writeByte('\n'); for (int i = 0, size = varyHeaders.size(); i &lt; size; i++) &#123; sink.writeUtf8(varyHeaders.name(i)) .writeUtf8(": ") .writeUtf8(varyHeaders.value(i)) .writeByte('\n'); &#125; sink.writeUtf8(new StatusLine(protocol, code, message).toString()) .writeByte('\n'); sink.writeDecimalLong(responseHeaders.size() + 2) .writeByte('\n'); for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123; sink.writeUtf8(responseHeaders.name(i)) .writeUtf8(": ") .writeUtf8(responseHeaders.value(i)) .writeByte('\n'); &#125; sink.writeUtf8(SENT_MILLIS) .writeUtf8(": ") .writeDecimalLong(sentRequestMillis) .writeByte('\n'); sink.writeUtf8(RECEIVED_MILLIS) .writeUtf8(": ") .writeDecimalLong(receivedResponseMillis) .writeByte('\n'); if (isHttps()) &#123; sink.writeByte('\n'); sink.writeUtf8(handshake.cipherSuite().javaName()) .writeByte('\n'); writeCertList(sink, handshake.peerCertificates()); writeCertList(sink, handshake.localCertificates()); // The handshake‚Äôs TLS version is null on HttpsURLConnection and on older cached responses. if (handshake.tlsVersion() != null) &#123; sink.writeUtf8(handshake.tlsVersion().javaName()) .writeByte('\n'); &#125; &#125; sink.close(); &#125; ÂÖ∂‰∏ªË¶ÅÈÄªËæëÂ∞±ÊòØÂ∞ÜÂØπÂ∫îËØ∑Ê±ÇÁöÑmetaÊï∞ÊçÆÂÜôÂÖ•ÂØπÂ∫îCacheEntryÁöÑÁ¥¢Âºï‰∏∫ENTRY_METADATAÔºà0ÔºâÁöÑdirtyfile‰∏≠„ÄÇ ÊúÄÂêéÂÜçÊù•ÁúãCache.put()ÊñπÊ≥ïÁöÑreturn new CacheRequestImpl(editor);: 1234567891011121314151617181920212223242526272829303132333435363738394041424344[okhttp3.Cache$CacheRequestImpl]private final class CacheRequestImpl implements CacheRequest &#123; private final DiskLruCache.Editor editor; private Sink cacheOut; private Sink body; boolean done; public CacheRequestImpl(final DiskLruCache.Editor editor) &#123; this.editor = editor; this.cacheOut = editor.newSink(ENTRY_BODY); this.body = new ForwardingSink(cacheOut) &#123; @Override public void close() throws IOException &#123; synchronized (Cache.this) &#123; if (done) &#123; return; &#125; done = true; writeSuccessCount++; &#125; super.close(); editor.commit(); &#125; &#125;; &#125; @Override public void abort() &#123; synchronized (Cache.this) &#123; if (done) &#123; return; &#125; done = true; writeAbortCount++; &#125; Util.closeQuietly(cacheOut); try &#123; editor.abort(); &#125; catch (IOException ignored) &#123; &#125; &#125; @Override public Sink body() &#123; return body; &#125; &#125; ÂÖ∂‰∏≠close,abortÊñπÊ≥ï‰ºöË∞ÉÁî®editor.abortÂíåeditor.commitÊù•Êõ¥Êñ∞Êó•ÂøóÔºåeditor.commitËøò‰ºöÂ∞ÜdirtyFileÈáçÁΩÆ‰∏∫cleanFile‰Ωú‰∏∫Á®≥ÂÆöÂèØÁî®ÁöÑÁºìÂ≠òÔºåÁõ∏ÂÖ≥ÈÄªËæëÂú®okhttp3.internal.cache.DiskLruCache$Editor.completeEdit‰∏≠: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[okhttp3.internal.cache.DiskLruCache$Editor.completeEdit] synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; if (entry.currentEditor != editor) &#123; throw new IllegalStateException(); &#125; // If this edit is creating the entry for the first time, every index must have a value. if (success &amp;&amp; !entry.readable) &#123; for (int i = 0; i &lt; valueCount; i++) &#123; if (!editor.written[i]) &#123; editor.abort(); throw new IllegalStateException("Newly created entry didn't create value for index " + i); &#125; if (!fileSystem.exists(entry.dirtyFiles[i])) &#123; editor.abort(); return; &#125; &#125; &#125; for (int i = 0; i &lt; valueCount; i++) &#123; File dirty = entry.dirtyFiles[i]; if (success) &#123; if (fileSystem.exists(dirty)) &#123; File clean = entry.cleanFiles[i]; fileSystem.rename(dirty, clean);//Â∞ÜdirtyfileÁΩÆ‰∏∫cleanfile long oldLength = entry.lengths[i]; long newLength = fileSystem.size(clean); entry.lengths[i] = newLength; size = size - oldLength + newLength; &#125; &#125; else &#123; fileSystem.delete(dirty);//Ëã•Â§±Ë¥•ÂàôÂà†Èô§dirtyfile &#125; &#125; redundantOpCount++; entry.currentEditor = null; //Êõ¥Êñ∞Êó•Âøó if (entry.readable | success) &#123; entry.readable = true; journalWriter.writeUtf8(CLEAN).writeByte(' '); journalWriter.writeUtf8(entry.key); entry.writeLengths(journalWriter); journalWriter.writeByte('\n'); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; lruEntries.remove(entry.key); journalWriter.writeUtf8(REMOVE).writeByte(' '); journalWriter.writeUtf8(entry.key); journalWriter.writeByte('\n'); &#125; journalWriter.flush(); if (size &gt; maxSize || journalRebuildRequired()) &#123; executor.execute(cleanupRunnable); &#125; &#125; CacheRequestImplÂÆûÁé∞CacheRequestÊé•Âè£ÔºåÂêëÂ§ñÈÉ®Á±ª(‰∏ªË¶ÅÊòØCacheInterceptor)ÈÄèÂá∫ÔºåÂ§ñÈÉ®ÂØπË±°ÈÄöËøáCacheRequestImplÊõ¥Êñ∞ÊàñÂÜôÂÖ•ÁºìÂ≠òÊï∞ÊçÆ„ÄÇ 3.8ÊÄªÁªìÊÄªÁªìËµ∑Êù•DiskLruCache‰∏ªË¶ÅÊúâ‰ª•‰∏ãÂá†‰∏™ÁâπÁÇπÔºö ÈÄöËøáLinkedHashMapÂÆûÁé∞LRUÊõøÊç¢ ÈÄöËøáÊú¨Âú∞Áª¥Êä§CacheÊìç‰ΩúÊó•Âøó‰øùËØÅCacheÂéüÂ≠êÊÄß‰∏éÂèØÁî®ÊÄßÔºåÂêåÊó∂‰∏∫Èò≤Ê≠¢Êó•ÂøóËøáÂàÜËÜ®ËÉÄÂÆöÊó∂ÊâßË°åÊó•ÂøóÁ≤æÁÆÄ ÊØè‰∏Ä‰∏™CacheÈ°πÂØπÂ∫î‰∏§‰∏™Áä∂ÊÄÅÂâØÊú¨ÔºöDIRTY,CLEAN„ÄÇCLEANË°®Á§∫ÂΩìÂâçÂèØÁî®Áä∂ÊÄÅCacheÔºåÂ§ñÈÉ®ËÆøÈóÆÂà∞ÁöÑcacheÂø´ÁÖßÂùá‰∏∫CLEANÁä∂ÊÄÅÔºõDIRTY‰∏∫Êõ¥Êñ∞ÊÄÅCache„ÄÇÁî±‰∫éÊõ¥Êñ∞ÂíåÂàõÂª∫ÈÉΩÂè™Êìç‰ΩúDIRTYÁä∂ÊÄÅÂâØÊú¨ÔºåÂÆûÁé∞‰∫ÜCacheÁöÑËØªÂÜôÂàÜÁ¶ª ÊØè‰∏Ä‰∏™CacheÈ°πÊúâÂõõ‰∏™Êñá‰ª∂Ôºå‰∏§‰∏™Áä∂ÊÄÅÔºàDIRTY,CLEANÔºâ,ÊØè‰∏™Áä∂ÊÄÅÂØπÂ∫î‰∏§‰∏™Êñá‰ª∂Ôºö‰∏Ä‰∏™Êñá‰ª∂Â≠òÂÇ®Cache metaÊï∞ÊçÆÔºå‰∏Ä‰∏™Êñá‰ª∂Â≠òÂÇ®CacheÂÜÖÂÆπÊï∞ÊçÆ OkHttpÊ∫êÁ†ÅÂàÜÊûê‚Äî‚ÄîÂ§öË∑ØÂ§çÁî® Êé•‰∏ãÊù•ËÆ≤‰∏ãOkHttpÁöÑËøûÊé•Ê±†ÁÆ°ÁêÜÔºåËøô‰πüÊòØOkHttpÁöÑÊ†∏ÂøÉÈÉ®ÂàÜ„ÄÇÈÄöËøáÁª¥Êä§ËøûÊé•Ê±†ÔºåÊúÄÂ§ßÈôêÂ∫¶ÈáçÁî®Áé∞ÊúâËøûÊé•ÔºåÂáèÂ∞ëÁΩëÁªúËøûÊé•ÁöÑÂàõÂª∫ÂºÄÈîÄÔºå‰ª•Ê≠§ÊèêÂçáÁΩëÁªúËØ∑Ê±ÇÊïàÁéá„ÄÇ 1. ËÉåÊôØ1.1 keep-aliveÊú∫Âà∂Âú®HTTP1.0‰∏≠HTTPÁöÑËØ∑Ê±ÇÊµÅÁ®ãÂ¶Ç‰∏ãÔºö ËøôÁßçÊñπÊ≥ïÁöÑÂ•ΩÂ§ÑÊòØÁÆÄÂçïÔºåÂêÑ‰∏™ËØ∑Ê±Ç‰∫í‰∏çÂπ≤Êâ∞„ÄÇ‰ΩÜÂú®Â§çÊùÇÁöÑÁΩëÁªúËØ∑Ê±ÇÂú∫ÊôØ‰∏ãËøôÁßçÊñπÂºèÂá†‰πé‰∏çÂèØÁî®„ÄÇ‰æãÂ¶ÇÔºöÊµèËßàÂô®Âä†ËΩΩ‰∏Ä‰∏™HTMLÁΩëÈ°µÔºåHTML‰∏≠ÂèØËÉΩÈúÄË¶ÅÂä†ËΩΩÊï∞ÂçÅ‰∏™ËµÑÊ∫êÔºåÂÖ∏ÂûãÂú∫ÊôØ‰∏ãËøô‰∫õËµÑÊ∫ê‰∏≠Â§ßÈÉ®ÂàÜÊù•Ëá™Âêå‰∏Ä‰∏™Á´ôÁÇπ„ÄÇÊåâÁÖßHTTP1.0ÁöÑÂÅöÊ≥ïÔºåËøôÈúÄË¶ÅÂª∫Á´ãÊï∞ÂçÅ‰∏™TCPËøûÊé•ÔºåÊØè‰∏™ËøûÊé•Ë¥üË¥£‰∏Ä‰∏™ËµÑÊ∫êËØ∑Ê±Ç„ÄÇÂàõÂª∫‰∏Ä‰∏™TCPËøûÊé•ÈúÄË¶Å3Ê¨°Êè°ÊâãÔºåËÄåÈáäÊîæËøûÊé•ÂàôÈúÄË¶Å2Ê¨°Êàñ4Ê¨°Êè°Êâã„ÄÇÈáçÂ§çÁöÑÂàõÂª∫ÂíåÈáäÊîæËøûÊé•ÊûÅÂ§ßÂú∞ÂΩ±Âìç‰∫ÜÁΩëÁªúÊïàÁéáÔºåÂêåÊó∂‰πüÂ¢ûÂä†‰∫ÜÁ≥ªÁªüÂºÄÈîÄ„ÄÇ ‰∏∫‰∫ÜÊúâÊïàÂú∞Ëß£ÂÜ≥Ëøô‰∏ÄÈóÆÈ¢òÔºåHTTP/1.1ÊèêÂá∫‰∫ÜKeep-AliveÊú∫Âà∂ÔºöÂΩì‰∏Ä‰∏™HTTPËØ∑Ê±ÇÁöÑÊï∞ÊçÆ‰º†ËæìÁªìÊùüÂêéÔºåTCPËøûÊé•‰∏çÁ´ãÂç≥ÈáäÊîæÔºåÂ¶ÇÊûúÊ≠§Êó∂ÊúâÊñ∞ÁöÑHTTPËØ∑Ê±ÇÔºå‰∏îÂÖ∂ËØ∑Ê±ÇÁöÑHostÈÄö‰∏äÊ¨°ËØ∑Ê±ÇÁõ∏ÂêåÔºåÂàôÂèØ‰ª•Áõ¥Êé•Â§çÁî®‰∏∫ÈáäÊîæÁöÑTCPËøûÊé•Ôºå‰ªéËÄåÁúÅÂéª‰∫ÜTCPÁöÑÈáäÊîæÂíåÂÜçÊ¨°ÂàõÂª∫ÁöÑÂºÄÈîÄÔºåÂáèÂ∞ë‰∫ÜÁΩëÁªúÂª∂Êó∂: Âú®Áé∞‰ª£ÊµèËßàÂô®‰∏≠Ôºå‰∏ÄËà¨ÂêåÊó∂ÂºÄÂêØ6ÔΩû8‰∏™keepalive connectionsÁöÑsocketËøûÊé•ÔºåÂπ∂‰øùÊåÅ‰∏ÄÂÆöÁöÑÈìæË∑ØÁîüÂëΩÔºåÂΩì‰∏çÈúÄË¶ÅÊó∂ÂÜçÂÖ≥Èó≠ÔºõËÄåÂú®ÊúçÂä°Âô®‰∏≠Ôºå‰∏ÄËà¨ÊòØÁî±ËΩØ‰ª∂Ê†πÊçÆË¥üËΩΩÊÉÖÂÜµ(ÊØîÂ¶ÇFDÊúÄÂ§ßÂÄº„ÄÅSocketÂÜÖÂ≠ò„ÄÅË∂ÖÊó∂Êó∂Èó¥„ÄÅÊ†àÂÜÖÂ≠ò„ÄÅÊ†àÊï∞ÈáèÁ≠â)ÂÜ≥ÂÆöÊòØÂê¶‰∏ªÂä®ÂÖ≥Èó≠„ÄÇ 1.2 HTTP/2Âú®HTTP/1.x‰∏≠ÔºåÂ¶ÇÊûúÂÆ¢Êà∑Á´ØÊÉ≥ÂèëËµ∑Â§ö‰∏™Âπ∂Ë°åËØ∑Ê±ÇÂøÖÈ°ªÂª∫Á´ãÂ§ö‰∏™TCPËøûÊé•ÔºåËøôÊó†ÁñëÂ¢ûÂ§ß‰∫ÜÁΩëÁªúÂºÄÈîÄ„ÄÇÂè¶Â§ñHTTP/1.x‰∏ç‰ºöÂéãÁº©ËØ∑Ê±ÇÂíåÂìçÂ∫îÊä•Â§¥ÔºåÂØºËá¥‰∫Ü‰∏çÂøÖË¶ÅÁöÑÁΩëÁªúÊµÅÈáèÔºõHTTP/1.x‰∏çÊîØÊåÅËµÑÊ∫ê‰ºòÂÖàÁ∫ßÂØºËá¥Â∫ïÂ±ÇTCPËøûÊé•Âà©Áî®Áéá‰Ωé‰∏ã„ÄÇËÄåËøô‰∫õÈóÆÈ¢òÈÉΩÊòØHTTP/2Ë¶ÅÁùÄÂäõËß£ÂÜ≥ÁöÑ„ÄÇÁÆÄÂçïÊù•ËØ¥HTTP/2‰∏ªË¶ÅËß£ÂÜ≥‰∫Ü‰ª•‰∏ãÈóÆÈ¢òÔºö Êä•Â§¥ÂéãÁº©ÔºöHTTP/2‰ΩøÁî®HPACKÂéãÁº©Ê†ºÂºèÂéãÁº©ËØ∑Ê±ÇÂíåÂìçÂ∫îÊä•Â§¥Êï∞ÊçÆÔºåÂáèÂ∞ë‰∏çÂøÖË¶ÅÊµÅÈáèÂºÄÈîÄ ËØ∑Ê±Ç‰∏éÂìçÂ∫îÂ§çÁî®ÔºöHTTP/2ÈÄöËøáÂºïÂÖ•Êñ∞ÁöÑ‰∫åËøõÂà∂ÂàÜÂ∏ßÂ±ÇÂÆûÁé∞‰∫ÜÂÆåÊï¥ÁöÑËØ∑Ê±ÇÂíåÂìçÂ∫îÂ§çÁî®ÔºåÂÆ¢Êà∑Á´ØÂíåÊúçÂä°Âô®ÂèØ‰ª•Â∞ÜHTTPÊ∂àÊÅØÂàÜËß£‰∏∫‰∫í‰∏ç‰æùËµñÁöÑÂ∏ßÔºåÁÑ∂Âêé‰∫§ÈîôÂèëÈÄÅÔºåÊúÄÂêéÂÜçÂú®Âè¶‰∏ÄÁ´ØÂ∞ÜÂÖ∂ÈáçÊñ∞ÁªÑË£Ö ÊåáÂÆöÊï∞ÊçÆÊµÅ‰ºòÂÖàÁ∫ßÔºöÂ∞Ü HTTP Ê∂àÊÅØÂàÜËß£‰∏∫ÂæàÂ§öÁã¨Á´ãÁöÑÂ∏ß‰πãÂêéÔºåÊàë‰ª¨Â∞±ÂèØ‰ª•Â§çÁî®Â§ö‰∏™Êï∞ÊçÆÊµÅ‰∏≠ÁöÑÂ∏ßÔºåÂÆ¢Êà∑Á´ØÂíåÊúçÂä°Âô®‰∫§ÈîôÂèëÈÄÅÂíå‰º†ËæìËøô‰∫õÂ∏ßÁöÑÈ°∫Â∫èÂ∞±Êàê‰∏∫ÂÖ≥ÈîÆÁöÑÊÄßËÉΩÂÜ≥ÂÆöÂõ†Á¥†„ÄÇ‰∏∫‰∫ÜÂÅöÂà∞Ëøô‰∏ÄÁÇπÔºåHTTP/2 Ê†áÂáÜÂÖÅËÆ∏ÊØè‰∏™Êï∞ÊçÆÊµÅÈÉΩÊúâ‰∏Ä‰∏™ÂÖ≥ËÅîÁöÑÊùÉÈáçÂíå‰æùËµñÂÖ≥Á≥ª ÊµÅÊéßÂà∂ÔºöHTTP/2 Êèê‰æõ‰∫Ü‰∏ÄÁªÑÁÆÄÂçïÁöÑÊûÑÂª∫ÂùóÔºåËøô‰∫õÊûÑÂª∫ÂùóÂÖÅËÆ∏ÂÆ¢Êà∑Á´ØÂíåÊúçÂä°Âô®ÂÆûÁé∞ÂÖ∂Ëá™Â∑±ÁöÑÊï∞ÊçÆÊµÅÂíåËøûÊé•Á∫ßÊµÅÊéßÂà∂ HTTP/2ÊâÄÊúâÊÄßËÉΩÂ¢ûÂº∫ÁöÑÊ†∏ÂøÉÂú®‰∫éÊñ∞ÁöÑ‰∫åËøõÂà∂ÂàÜÂ∏ßÂ±ÇÔºåÂÆÉÂÆö‰πâ‰∫ÜÂ¶Ç‰ΩïÂ∞ÅË£ÖHTTPÊ∂àÊÅØÂπ∂Âú®ÂÆ¢Êà∑Á´Ø‰∏éÊúçÂä°Âô®‰πãÈó¥ËøõË°å‰º†Ëæì: ÂêåÊó∂HTTP/2ÂºïÂÖ•‰∫Ü‰∏â‰∏™Êñ∞ÁöÑÊ¶ÇÂøµÔºö Êï∞ÊçÆÊµÅÔºöÂü∫‰∫éTCPËøûÊé•‰πã‰∏äÁöÑÈÄªËæëÂèåÂêëÂ≠óËäÇÊµÅÔºåÂØπÂ∫î‰∏Ä‰∏™ËØ∑Ê±ÇÂèäÂÖ∂ÂìçÂ∫î„ÄÇÂÆ¢Êà∑Á´ØÊØèÂèëËµ∑‰∏Ä‰∏™ËØ∑Ê±ÇÂ∞±Âª∫Á´ã‰∏Ä‰∏™Êï∞ÊçÆÊµÅÔºåÂêéÁª≠ËØ•ËØ∑Ê±ÇÂèäÂÖ∂ÂìçÂ∫îÁöÑÊâÄÊúâÊï∞ÊçÆÈÉΩÈÄöËøáËØ•Êï∞ÊçÆÊµÅ‰º†Ëæì Ê∂àÊÅØÔºö‰∏Ä‰∏™ËØ∑Ê±ÇÊàñÂìçÂ∫îÂØπÂ∫îÁöÑ‰∏ÄÁ≥ªÂàóÊï∞ÊçÆÂ∏ß Â∏ßÔºöHTTP/2ÁöÑÊúÄÂ∞èÊï∞ÊçÆÂàáÁâáÂçï‰Ωç ‰∏äËø∞Ê¶ÇÂøµ‰πãÈó¥ÁöÑÈÄªËæëÂÖ≥Á≥ªÔºö ÊâÄÊúâÈÄö‰ø°ÈÉΩÂú®‰∏Ä‰∏™ TCP ËøûÊé•‰∏äÂÆåÊàêÔºåÊ≠§ËøûÊé•ÂèØ‰ª•ÊâøËΩΩ‰ªªÊÑèÊï∞ÈáèÁöÑÂèåÂêëÊï∞ÊçÆÊµÅ ÊØè‰∏™Êï∞ÊçÆÊµÅÈÉΩÊúâ‰∏Ä‰∏™ÂîØ‰∏ÄÁöÑÊ†áËØÜÁ¨¶ÂíåÂèØÈÄâÁöÑ‰ºòÂÖàÁ∫ß‰ø°ÊÅØÔºåÁî®‰∫éÊâøËΩΩÂèåÂêëÊ∂àÊÅØ ÊØèÊù°Ê∂àÊÅØÈÉΩÊòØ‰∏ÄÊù°ÈÄªËæë HTTP Ê∂àÊÅØÔºà‰æãÂ¶ÇËØ∑Ê±ÇÊàñÂìçÂ∫îÔºâÔºåÂåÖÂê´‰∏Ä‰∏™ÊàñÂ§ö‰∏™Â∏ß Â∏ßÊòØÊúÄÂ∞èÁöÑÈÄö‰ø°Âçï‰ΩçÔºåÊâøËΩΩÁùÄÁâπÂÆöÁ±ªÂûãÁöÑÊï∞ÊçÆÔºå‰æãÂ¶Ç HTTP Ê†áÂ§¥„ÄÅÊ∂àÊÅØË¥üËΩΩÔºåÁ≠âÁ≠â„ÄÇ Êù•Ëá™‰∏çÂêåÊï∞ÊçÆÊµÅÁöÑÂ∏ßÂèØ‰ª•‰∫§ÈîôÂèëÈÄÅÔºåÁÑ∂ÂêéÂÜçÊ†πÊçÆÊØè‰∏™Â∏ßÂ§¥ÁöÑÊï∞ÊçÆÊµÅÊ†áËØÜÁ¨¶ÈáçÊñ∞ÁªÑË£Ö ÊØè‰∏™HTTPÊ∂àÊÅØË¢´ÂàÜËß£‰∏∫Â§ö‰∏™Áã¨Á´ãÁöÑÂ∏ßÂêéÂèØ‰ª•‰∫§ÈîôÂèëÈÄÅÔºå‰ªéËÄåÂú®ÂÆèËßÇ‰∏äÂÆûÁé∞‰∫ÜÂ§ö‰∏™ËØ∑Ê±ÇÊàñÂìçÂ∫îÂπ∂Ë°å‰º†ËæìÁöÑÊïàÊûú„ÄÇËøôÁ±ª‰ºº‰∫éÂ§öËøõÁ®ãÁéØÂ¢É‰∏ãÁöÑÊó∂Èó¥ÂàÜÁâáÊú∫Âà∂ 2. ËøûÊé•Ê±†ÁöÑ‰ΩøÁî®‰∏éÂàÜÊûêÊó†ËÆ∫ÊòØHTTP/1.1ÁöÑKeep-AliveÊú∫Âà∂ËøòÊòØHTTP/2ÁöÑÂ§öË∑ØÂ§çÁî®Êú∫Âà∂ÔºåÂú®ÂÆûÁé∞‰∏äÈÉΩÈúÄË¶ÅÂºïÂÖ•ËøûÊé•Ê±†Êù•Áª¥Êä§ÁΩëÁªúËøûÊé•„ÄÇÊé•‰∏ãÊù•Áúã‰∏ãOkHttp‰∏≠ÁöÑËøûÊé•Ê±†ÂÆûÁé∞„ÄÇ OkHttpÂÜÖÈÉ®ÈÄöËøáConnectionPoolÊù•ÁÆ°ÁêÜËøûÊé•Ê±†ÔºåÈ¶ñÂÖàÊù•Áúã‰∏ãConnectionPoolÁöÑ‰∏ªË¶ÅÊàêÂëòÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public final class ConnectionPool &#123; private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp ConnectionPool", true)); /** The maximum number of idle connections for each address. */ private final int maxIdleConnections; private final long keepAliveDurationNs; private final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; ...... &#125; &#125;; private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); final RouteDatabase routeDatabase = new RouteDatabase(); boolean cleanupRunning; ...... /** *ËøîÂõûÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑÂèØÈáçÁî®ËøûÊé•ÔºåÂ¶ÇÊûúÊ≤°ÊúâËøîÂõûNULL */ RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; ...... &#125; /* * ÂéªÈô§ÈáçÂ§çËøûÊé•„ÄÇ‰∏ªË¶ÅÈíàÂØπÂ§öË∑ØÂ§çÁî®Âú∫ÊôØ‰∏ã‰∏Ä‰∏™addressÂè™ÈúÄË¶Å‰∏Ä‰∏™ËøûÊé• */ Socket deduplicate(Address address, StreamAllocation streamAllocation) &#123; ...... &#125; /* * Â∞ÜËøûÊé•Âä†ÂÖ•ËøûÊé•Ê±† */ void put(RealConnection connection) &#123; ...... &#125; /* * ÂΩìÊúâËøûÊé•Á©∫Èó≤Êó∂Âî§Ëµ∑cleanupÁ∫øÁ®ãÊ∏ÖÊ¥óËøûÊé•Ê±† */ boolean connectionBecameIdle(RealConnection connection) &#123; ...... &#125; /** * Êâ´ÊèèËøûÊé•Ê±†ÔºåÊ∏ÖÈô§Á©∫Èó≤ËøûÊé• */ long cleanup(long now) &#123; ...... &#125; /* * Ê†áËÆ∞Ê≥ÑÈú≤ËøûÊé• */ private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; ...... &#125;&#125; Áõ∏ÂÖ≥Ê¶ÇÂøµÔºö CallÔºöÂØπHttpËØ∑Ê±ÇÁöÑÂ∞ÅË£Ö Connection/RealConnection:Áâ©ÁêÜËøûÊé•ÁöÑÂ∞ÅË£ÖÔºåÂÖ∂ÂÜÖÈÉ®ÊúâList&lt;WeakReference&lt;StreamAllocation&gt;&gt;ÁöÑÂºïÁî®ËÆ°Êï∞ StreamAllocation: okhttp‰∏≠ÂºïÂÖ•‰∫ÜStreamAllocationË¥üË¥£ÁÆ°ÁêÜ‰∏Ä‰∏™ËøûÊé•‰∏äÁöÑÊµÅÔºåÂêåÊó∂Âú®connection‰∏≠‰πüÈÄöËøá‰∏Ä‰∏™StreamAllocationÁöÑÂºïÁî®ÁöÑÂàóË°®Êù•ÁÆ°ÁêÜ‰∏Ä‰∏™ËøûÊé•ÁöÑÊµÅÔºå‰ªéËÄå‰ΩøÂæóËøûÊé•‰∏éÊµÅ‰πãÈó¥Ëß£ËÄ¶„ÄÇÂÖ≥‰∫éStreamAllocationÁöÑÂÆö‰πâÂèØ‰ª•Áúã‰∏ãËøôÁØáÊñáÁ´†:okhttpÊ∫êÁ†ÅÂ≠¶‰π†Á¨îËÆ∞Ôºà‰∫åÔºâ‚Äì ËøûÊé•‰∏éËøûÊé•ÁÆ°ÁêÜ connections: DequeÂèåÁ´ØÈòüÂàóÔºåÁî®‰∫éÁª¥Êä§ËøûÊé•ÁöÑÂÆπÂô® routeDatabase:Áî®Êù•ËÆ∞ÂΩïËøûÊé•Â§±Ë¥•ÁöÑRouteÁöÑÈªëÂêçÂçïÔºåÂΩìËøûÊé•Â§±Ë¥•ÁöÑÊó∂ÂÄôÂ∞±‰ºöÊääÂ§±Ë¥•ÁöÑÁ∫øË∑ØÂä†ËøõÂéª 2.1 ÂÆû‰æãÂåñÈ¶ñÂÖàÊù•Áúã‰∏ãConnectionPoolÁöÑÂÆû‰æãÂåñËøáÁ®ãÔºå‰∏Ä‰∏™OkHttpClientÂè™ÂåÖÂê´‰∏Ä‰∏™ConnectionPoolÔºåÂÖ∂ÂÆû‰æãÂåñËøáÁ®ã‰πüÂú®OkHttpClientÁöÑÂÆû‰æãÂåñËøáÁ®ã‰∏≠ÂÆûÁé∞ÔºåÂÄºÂæó‰∏ÄÊèêÁöÑÊòØConnectionPoolÂêÑ‰∏™ÊñπÊ≥ïÁöÑË∞ÉÁî®Âπ∂Ê≤°ÊúâÁõ¥Êé•ÂØπÂ§ñÊö¥Èú≤ÔºåËÄåÊòØÈÄöËøáOkHttpClientÁöÑInternalÊé•Âè£Áªü‰∏ÄÂØπÂ§ñÊö¥Èú≤Ôºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory &#123; static &#123; Internal.instance = new Internal() &#123; @Override public void addLenient(Headers.Builder builder, String line) &#123; builder.addLenient(line); &#125; @Override public void addLenient(Headers.Builder builder, String name, String value) &#123; builder.addLenient(name, value); &#125; @Override public void setCache(Builder builder, InternalCache internalCache) &#123; builder.setInternalCache(internalCache); &#125; @Override public boolean connectionBecameIdle( ConnectionPool pool, RealConnection connection) &#123; return pool.connectionBecameIdle(connection); &#125; @Override public RealConnection get(ConnectionPool pool, Address address, StreamAllocation streamAllocation, Route route) &#123; return pool.get(address, streamAllocation, route); &#125; @Override public boolean equalsNonHost(Address a, Address b) &#123; return a.equalsNonHost(b); &#125; @Override public Socket deduplicate( ConnectionPool pool, Address address, StreamAllocation streamAllocation) &#123; return pool.deduplicate(address, streamAllocation); &#125; @Override public void put(ConnectionPool pool, RealConnection connection) &#123; pool.put(connection); &#125; @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) &#123; return connectionPool.routeDatabase; &#125; @Override public int code(Response.Builder responseBuilder) &#123; return responseBuilder.code; &#125; @Override public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) &#123; tlsConfiguration.apply(sslSocket, isFallback); &#125; @Override public HttpUrl getHttpUrlChecked(String url) throws MalformedURLException, UnknownHostException &#123; return HttpUrl.getChecked(url); &#125; @Override public StreamAllocation streamAllocation(Call call) &#123; return ((RealCall) call).streamAllocation(); &#125; @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) &#123; return new RealCall(client, originalRequest, true); &#125; &#125;; ......&#125; ËøôÊ†∑ÂÅöÁöÑÂéüÂõ†ÊòØÔºö 12Escalate internal APIs in &#123;@code okhttp3&#125; so they can be used from OkHttp&apos;s implementationpackages. The only implementation of this interface is in &#123;@link OkHttpClient&#125;. InternalÁöÑÂîØ‰∏ÄÂÆûÁé∞Âú®OkHttpClient‰∏≠ÔºåOkHttpClientÈÄöËøáËøôÁßçÊñπÂºèÊö¥Èú≤ÂÖ∂APIÁªôÂ§ñÈÉ®Á±ª‰ΩøÁî®„ÄÇ 2.2 ËøûÊé•Ê±†Áª¥Êä§ConnectionPoolÂÜÖÈÉ®ÈÄöËøá‰∏Ä‰∏™ÂèåÁ´ØÈòüÂàó(dequeue)Êù•Áª¥Êä§ÂΩìÂâçÊâÄÊúâËøûÊé•Ôºå‰∏ªË¶ÅÊ∂âÂèäÂà∞ÁöÑÊìç‰ΩúÂåÖÊã¨Ôºö putÔºöÊîæÂÖ•Êñ∞ËøûÊé• getÔºö‰ªéËøûÊé•Ê±†‰∏≠Ëé∑ÂèñËøûÊé• evictAllÔºöÂÖ≥Èó≠ÊâÄÊúâËøûÊé• connectionBecameIdleÔºöËøûÊé•ÂèòÁ©∫Èó≤ÂêéË∞ÉÁî®Ê∏ÖÁêÜÁ∫øÁ®ã deduplicateÔºöÊ∏ÖÈô§ÈáçÂ§çÁöÑÂ§öË∑ØÂ§çÁî®Á∫øÁ®ã 2.2.1 StreamAllocation.findConnectiongetÊòØConnectionPool‰∏≠ÊúÄ‰∏∫ÈáçË¶ÅÁöÑÊñπÊ≥ïÔºåStreamAllocationÂú®ÂÖ∂findConnectionÊñπÊ≥ïÂÜÖÈÉ®ÈÄöËøáË∞ÉÁî®getÊñπÊ≥ï‰∏∫ÂÖ∂ÊâæÂà∞streamÊâæÂà∞ÂêàÈÄÇÁöÑËøûÊé•ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÊñ∞Âª∫‰∏Ä‰∏™ËøûÊé•„ÄÇÈ¶ñÂÖàÊù•Áúã‰∏ãfindConnectionÁöÑÈÄªËæëÔºö 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123; Route selectedRoute; synchronized (connectionPool) &#123; if (released) throw new IllegalStateException("released"); if (codec != null) throw new IllegalStateException("codec != null"); if (canceled) throw new IOException("Canceled"); // ‰∏Ä‰∏™StreamAllocationÂàªÁîªÁöÑÊòØ‰∏Ä‰∏™CallÁöÑÊï∞ÊçÆÊµÅÂä®Ôºå‰∏Ä‰∏™CallÂèØËÉΩÂ≠òÂú®Â§öÊ¨°ËØ∑Ê±Ç(ÈáçÂÆöÂêëÔºåAuthenticateÁ≠â)ÔºåÊâÄ‰ª•ÂΩìÂèëÁîüÁ±ª‰ººÈáçÂÆöÂêëÁ≠â‰∫ã‰ª∂Êó∂‰ºòÂÖà‰ΩøÁî®ÂéüÊúâÁöÑËøûÊé• RealConnection allocatedConnection = this.connection; if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123; return allocatedConnection; &#125; // ËØïÂõæ‰ªéËøûÊé•Ê±†‰∏≠ÊâæÂà∞ÂèØÂ§çÁî®ÁöÑËøûÊé• Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; return connection; &#125; selectedRoute = route; &#125; // Ëé∑ÂèñË∑ØÁî±ÈÖçÁΩÆÔºåÊâÄË∞ìË∑ØÁî±ÂÖ∂ÂÆûÂ∞±ÊòØ‰ª£ÁêÜÔºåipÂú∞ÂùÄÁ≠âÂèÇÊï∞ÁöÑ‰∏Ä‰∏™ÁªÑÂêà if (selectedRoute == null) &#123; selectedRoute = routeSelector.next(); &#125; RealConnection result; synchronized (connectionPool) &#123; if (canceled) throw new IOException("Canceled"); //ÊãøÂà∞Ë∑ØÁî±ÂêéÂèØ‰ª•Â∞ùËØïÈáçÊñ∞‰ªéËøûÊé•Ê±†‰∏≠Ëé∑ÂèñËøûÊé•ÔºåËøôÈáå‰∏ªË¶ÅÈíàÂØπhttp2ÂçèËÆÆ‰∏ãÊ∏ÖÈô§ÂüüÂêçÁ¢éÁâáÊú∫Âà∂ Internal.instance.get(connectionPool, address, this, selectedRoute); if (connection != null) return connection; //Êñ∞Âª∫ËøûÊé• route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); //‰øÆÊîπresultËøûÊé•streamËÆ°Êï∞ÔºåÊñπ‰æøconnectionÊ†áËÆ∞Ê∏ÖÁêÜ acquire(result); &#125; // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; // Â∞ÜÊñ∞Âª∫ÁöÑËøûÊé•ÊîæÂÖ•Âà∞ËøûÊé•Ê±†‰∏≠ Internal.instance.put(connectionPool, result); // Â¶ÇÊûúÂêåÊó∂Â≠òÂú®Â§ö‰∏™ËøûÂêëÂêå‰∏Ä‰∏™Âú∞ÂùÄÁöÑÂ§öË∑ØÂ§çÁî®ËøûÊé•ÔºåÂàôÂÖ≥Èó≠Â§ö‰ΩôËøûÊé•ÔºåÂè™‰øùÁïô‰∏Ä‰∏™ if (result.isMultiplexed()) &#123; socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; closeQuietly(socket); return result; &#125; ÂÖ∂‰∏ªË¶ÅÈÄªËæëÂ§ßËá¥ÂàÜ‰∏∫‰ª•‰∏ãÂá†‰∏™Ê≠•È™§Ôºö Êü•ÁúãÂΩìÂâçstreamAllocationÊòØÂê¶Êúâ‰πãÂâçÂ∑≤ÁªèÂàÜÈÖçËøáÁöÑËøûÊé•ÔºåÊúâÂàôÁõ¥Êé•‰ΩøÁî® ‰ªéËøûÊé•Ê±†‰∏≠Êü•ÊâæÂèØÂ§çÁî®ÁöÑËøûÊé•ÔºåÊúâÂàôËøîÂõûËØ•ËøûÊé• ÈÖçÁΩÆË∑ØÁî±ÔºåÈÖçÁΩÆÂêéÂÜçÊ¨°‰ªéËøûÊé•Ê±†‰∏≠Êü•ÊâæÊòØÂê¶ÊúâÂèØÂ§çÁî®ËøûÊé•ÔºåÊúâÂàôÁõ¥Êé•ËøîÂõû Êñ∞Âª∫‰∏Ä‰∏™ËøûÊé•ÔºåÂπ∂‰øÆÊîπÂÖ∂StreamAllocationÊ†áËÆ∞ËÆ°Êï∞ÔºåÂ∞ÜÂÖ∂ÊîæÂÖ•ËøûÊé•Ê±†‰∏≠ Êü•ÁúãËøûÊé•Ê±†ÊòØÂê¶ÊúâÈáçÂ§çÁöÑÂ§öË∑ØÂ§çÁî®ËøûÊé•ÔºåÊúâÂàôÊ∏ÖÈô§ 2.2.2 ConnectionPool.getÊé•‰∏ãÊù•ÂÜçÊù•ÁúãgetÊñπÊ≥ïÁöÑÊ∫êÁ†ÅÔºö 1234567891011[ConnectionPool.java] RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; if (connection.isEligible(address, route)) &#123; streamAllocation.acquire(connection); return connection; &#125; &#125; return null; &#125; ÂÖ∂ÈÄªËæëÊØîËæÉÁÆÄÂçïÔºåÈÅçÂéÜÂΩìÂâçËøûÊé•Ê±†ÔºåÂ¶ÇÊûúÊúâÁ¨¶ÂêàÊù°‰ª∂ÁöÑËøûÊé•Âàô‰øÆÊîπÂô®Ê†áËÆ∞ËÆ°Êï∞ÔºåÁÑ∂ÂêéËøîÂõû„ÄÇËøôÈáåÁöÑÂÖ≥ÈîÆÈÄªËæëÂú®RealConnection.isEligibleÊñπÊ≥ïÔºö 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[RealConnection.java]/** * Returns true if this connection can carry a stream allocation to &#123;@code address&#125;. If non-null * &#123;@code route&#125; is the resolved route for a connection. */ public boolean isEligible(Address address, Route route) &#123; // If this connection is not accepting new streams, we&apos;re done. if (allocations.size() &gt;= allocationLimit || noNewStreams) return false; // If the non-host fields of the address don&apos;t overlap, we&apos;re done. if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false; // If the host exactly matches, we&apos;re done: this connection can carry the address. if (address.url().host().equals(this.route().address().url().host())) &#123; return true; // This connection is a perfect match. &#125; // At this point we don&apos;t have a hostname match. But we still be able to carry the request if // our connection coalescing requirements are met. See also: // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/ // 1. This connection must be HTTP/2. if (http2Connection == null) return false; // 2. The routes must share an IP address. This requires us to have a DNS address for both // hosts, which only happens after route planning. We can&apos;t coalesce connections that use a // proxy, since proxies don&apos;t tell us the origin server&apos;s IP address. if (route == null) return false; if (route.proxy().type() != Proxy.Type.DIRECT) return false; if (this.route.proxy().type() != Proxy.Type.DIRECT) return false; if (!this.route.socketAddress().equals(route.socketAddress())) return false; // 3. This connection&apos;s server certificate&apos;s must cover the new host. if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false; if (!supportsUrl(address.url())) return false; // 4. Certificate pinning must match the host. try &#123; address.certificatePinner().check(address.url().host(), handshake().peerCertificates()); &#125; catch (SSLPeerUnverifiedException e) &#123; return false; &#125; return true; // The caller&apos;s address can be carried by this connection. &#125; ËøûÊé•Ê≤°ÊúâËææÂà∞ÂÖ±‰∫´‰∏äÈôê ÈùûhostÂüüÂøÖÈ°ªÂÆåÂÖ®‰∏ÄÊ†∑ Â¶ÇÊûúÊ≠§Êó∂hostÂüü‰πüÁõ∏ÂêåÔºåÂàôÁ¨¶ÂêàÊù°‰ª∂ÔºåÂèØ‰ª•Ë¢´Â§çÁî® Â¶ÇÊûúhost‰∏çÁõ∏ÂêåÔºåÂú®HTTP/2ÁöÑÂüüÂêçÂàáÁâáÂú∫ÊôØ‰∏ã‰∏ÄÊ†∑ÂèØ‰ª•Â§çÁî®ÔºåÂÖ∑‰ΩìÁªÜËäÇÂèØ‰ª•ÂèÇËÄÉÔºöhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding 2.2.3 deduplicatededuplicateÊñπÊ≥ï‰∏ªË¶ÅÊòØÈíàÂØπÂú®HTTP/2Âú∫ÊôØ‰∏ãÂ§ö‰∏™Â§öË∑ØÂ§çÁî®ËøûÊé•Ê∏ÖÈô§ÁöÑÂú∫ÊôØ„ÄÇÂ¶ÇÊûúÂΩìÂâçËøûÊé•ÊòØHTTP/2ÔºåÈÇ£‰πàÊâÄÊúâÊåáÂêëËØ•Á´ôÁÇπÁöÑËØ∑Ê±ÇÈÉΩÂ∫îËØ•Âü∫‰∫éÂêå‰∏Ä‰∏™TCPËøûÊé•Ôºö 12345678910111213141516[ConnectionPool.java] /** * Replaces the connection held by &#123;@code streamAllocation&#125; with a shared connection if possible. * This recovers when multiple multiplexed connections are created concurrently. */ Socket deduplicate(Address address, StreamAllocation streamAllocation) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; if (connection.isEligible(address, null) &amp;&amp; connection.isMultiplexed() &amp;&amp; connection != streamAllocation.connection()) &#123; return streamAllocation.releaseAndAcquire(connection); &#125; &#125; return null; &#125; putÂíåevictAllÊØîËæÉÁÆÄÂçïÔºåÂú®ËøôÈáåÂ∞±‰∏çÂÜô‰∫ÜÔºåÂ§ßÂÆ∂Ëá™Ë°åÁúãÊ∫êÁ†Å„ÄÇ 2.3 Ëá™Âä®ÂõûÊî∂ËøûÊé•Ê±†‰∏≠ÊúâsocketÂõûÊî∂ÔºåËÄåËøô‰∏™ÂõûÊî∂ÊòØ‰ª•RealConnectionÁöÑÂº±ÂºïÁî®List&lt;Reference&lt;StreamAllocation&gt;&gt;ÊòØÂê¶‰∏∫0Êù•‰∏∫‰æùÊçÆÁöÑ„ÄÇConnectionPoolÊúâ‰∏Ä‰∏™Áã¨Á´ãÁöÑÁ∫øÁ®ãcleanupRunnableÊù•Ê∏ÖÁêÜËøûÊé•Ê±†ÔºåÂÖ∂Ëß¶ÂèëÊó∂Êú∫Êúâ‰∏§‰∏™Ôºö ÂΩìËøûÊé•Ê±†‰∏≠putÊñ∞ÁöÑËøûÊé•Êó∂ ÂΩìconnectionBecameIdleÊé•Âè£Ë¢´Ë∞ÉÁî®Êó∂ ÂÖ∂‰ª£Á†ÅÂ¶Ç‰∏ãÔºö 1234567891011121314while (true) &#123; //ÊâßË°åÊ∏ÖÁêÜÂπ∂ËøîÂõû‰∏ãÂú∫ÈúÄË¶ÅÊ∏ÖÁêÜÁöÑÊó∂Èó¥ long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; synchronized (ConnectionPool.this) &#123; try &#123; //Âú®timeoutÂÜÖÈáäÊîæÈîÅ‰∏éÊó∂Èó¥Áâá ConnectionPool.this.wait(TimeUnit.NANOSECONDS.toMillis(waitNanos)); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125;&#125; ËøôÊÆµÊ≠ªÂæ™ÁéØÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™ÈòªÂ°ûÁöÑÊ∏ÖÁêÜ‰ªªÂä°ÔºåÈ¶ñÂÖàËøõË°åÊ∏ÖÁêÜ(clean)ÔºåÂπ∂ËøîÂõû‰∏ãÊ¨°ÈúÄË¶ÅÊ∏ÖÁêÜÁöÑÈó¥ÈöîÊó∂Èó¥ÔºåÁÑ∂ÂêéË∞ÉÁî®wait(timeout)ËøõË°åÁ≠âÂæÖ‰ª•ÈáäÊîæÈîÅ‰∏éÊó∂Èó¥ÁâáÔºåÂΩìÁ≠âÂæÖÊó∂Èó¥Âà∞‰∫ÜÂêéÔºåÂÜçÊ¨°ËøõË°åÊ∏ÖÁêÜÔºåÂπ∂ËøîÂõû‰∏ãÊ¨°Ë¶ÅÊ∏ÖÁêÜÁöÑÈó¥ÈöîÊó∂Èó¥‚Ä¶ Êé•‰∏ãÊù•Áúã‰∏ãcleanupÂáΩÊï∞: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[ConnectionPool.java]long cleanup(long now) &#123; int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; //ÈÅçÂéÜ`Deque`‰∏≠ÊâÄÊúâÁöÑ`RealConnection`ÔºåÊ†áËÆ∞Ê≥ÑÊºèÁöÑËøûÊé• synchronized (this) &#123; for (RealConnection connection : connections) &#123; // Êü•ËØ¢Ê≠§ËøûÊé•ÂÜÖÈÉ®StreamAllocationÁöÑÂºïÁî®Êï∞Èáè if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; inUseConnectionCount++; continue; &#125; idleConnectionCount++; //ÈÄâÊã©ÊéíÂ∫èÊ≥ïÔºåÊ†áËÆ∞Âá∫Á©∫Èó≤ËøûÊé• long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) &#123; longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; &#125; &#125; if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) &#123; //Â¶ÇÊûú(`Á©∫Èó≤socketËøûÊé•Ë∂ÖËøá5‰∏™` //‰∏î`keepaliveÊó∂Èó¥Â§ß‰∫é5ÂàÜÈíü`) //Â∞±Â∞ÜÊ≠§Ê≥ÑÊºèËøûÊé•‰ªé`Deque`‰∏≠ÁßªÈô§ connections.remove(longestIdleConnection); &#125; else if (idleConnectionCount &gt; 0) &#123; //ËøîÂõûÊ≠§ËøûÊé•Âç≥Â∞ÜÂà∞ÊúüÁöÑÊó∂Èó¥Ôºå‰æõ‰∏ãÊ¨°Ê∏ÖÁêÜ //ËøôÈáå‰æùÊçÆÊòØÂú®‰∏äÊñá`connectionBecameIdle`‰∏≠ËÆæÂÆöÁöÑËÆ°Êó∂ return keepAliveDurationNs - longestIdleDurationNs; &#125; else if (inUseConnectionCount &gt; 0) &#123; //ÂÖ®ÈÉ®ÈÉΩÊòØÊ¥ªË∑ÉÁöÑËøûÊé•Ôºå5ÂàÜÈíüÂêéÂÜçÊ¨°Ê∏ÖÁêÜ return keepAliveDurationNs; &#125; else &#123; //Ê≤°Êúâ‰ªª‰ΩïËøûÊé•ÔºåË∑≥Âá∫Âæ™ÁéØ cleanupRunning = false; return -1; &#125; &#125; //ÂÖ≥Èó≠ËøûÊé•ÔºåËøîÂõû`0`Ôºå‰πüÂ∞±ÊòØÁ´ãÂàªÂÜçÊ¨°Ê∏ÖÁêÜ closeQuietly(longestIdleConnection.socket()); return 0;&#125; ÂÖ∂Âü∫Êú¨ÈÄªËæëÂ¶Ç‰∏ãÔºö ÈÅçÂéÜËøûÊé•Ê±†‰∏≠ÊâÄÊúâËøûÊé•ÔºåÊ†áËÆ∞Ê≥ÑÈú≤ËøûÊé• Â¶ÇÊûúË¢´Ê†áËÆ∞ÁöÑËøûÊé•Êª°Ë∂≥(Á©∫Èó≤socketËøûÊé•Ë∂ÖËøá5‰∏™&amp;&amp;keepaliveÊó∂Èó¥Â§ß‰∫é5ÂàÜÈíü)ÔºåÂ∞±Â∞ÜÊ≠§ËøûÊé•‰ªéDeque‰∏≠ÁßªÈô§ÔºåÂπ∂ÂÖ≥Èó≠ËøûÊé•ÔºåËøîÂõû0Ôºå‰πüÂ∞±ÊòØÂ∞ÜË¶ÅÊâßË°åwait(0)ÔºåÊèêÈÜíÁ´ãÂàªÂÜçÊ¨°Êâ´Êèè Â¶ÇÊûú(ÁõÆÂâçËøòÂèØ‰ª•Â°ûÂæó‰∏ã5‰∏™ËøûÊé•Ôºå‰ΩÜÊòØÊúâÂèØËÉΩÊ≥ÑÊºèÁöÑËøûÊé•(Âç≥Á©∫Èó≤Êó∂Èó¥Âç≥Â∞ÜËææÂà∞5ÂàÜÈíü))ÔºåÂ∞±ËøîÂõûÊ≠§ËøûÊé•Âç≥Â∞ÜÂà∞ÊúüÁöÑÂâ©‰ΩôÊó∂Èó¥Ôºå‰æõ‰∏ãÊ¨°Ê∏ÖÁêÜ Â¶ÇÊûú(ÂÖ®ÈÉ®ÈÉΩÊòØÊ¥ªË∑ÉÁöÑËøûÊé•)ÔºåÂ∞±ËøîÂõûÈªòËÆ§ÁöÑkeep-aliveÊó∂Èó¥Ôºå‰πüÂ∞±ÊòØ5ÂàÜÈíüÂêéÂÜçÊâßË°åÊ∏ÖÁêÜ ËÄåpruneAndGetAllocationCountË¥üË¥£Ê†áËÆ∞Âπ∂ÊâæÂà∞‰∏çÊ¥ªË∑ÉËøûÊé•: 1234567891011121314151617181920212223242526272829[ConnnecitonPool.java]//Á±ª‰ºº‰∫éÂºïÁî®ËÆ°Êï∞Ê≥ïÔºåÂ¶ÇÊûúÂºïÁî®ÂÖ®ÈÉ®‰∏∫Á©∫ÔºåËøîÂõûÁ´ãÂàªÊ∏ÖÁêÜprivate int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; //ËôöÂºïÁî®ÂàóË°® List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations; //ÈÅçÂéÜÂº±ÂºïÁî®ÂàóË°® for (int i = 0; i &lt; references.size(); ) &#123; Reference&lt;StreamAllocation&gt; reference = references.get(i); //Â¶ÇÊûúÊ≠£Âú®Ë¢´‰ΩøÁî®ÔºåË∑≥ËøáÔºåÊé•ÁùÄÂæ™ÁéØ //ÊòØÂê¶ÁΩÆÁ©∫ÊòØÂú®‰∏äÊñá`connectionBecameIdle`ÁöÑ`release`ÊéßÂà∂ÁöÑ if (reference.get() != null) &#123; //ÈùûÂ∏∏ÊòéÊòæÁöÑÂºïÁî®ËÆ°Êï∞ i++; continue; &#125; //Âê¶ÂàôÁßªÈô§ÂºïÁî® references.remove(i); connection.noNewStreams = true; //Â¶ÇÊûúÊâÄÊúâÂàÜÈÖçÁöÑÊµÅÂùáÊ≤°‰∫ÜÔºåÊ†áËÆ∞‰∏∫Â∑≤ÁªèË∑ùÁ¶ªÁé∞Âú®Á©∫Èó≤‰∫Ü5ÂàÜÈíü if (references.isEmpty()) &#123; connection.idleAtNanos = now - keepAliveDurationNs; return 0; &#125; &#125; return references.size();&#125; OkHttpÁöÑËøûÊé•Ê±†ÈÄöËøáËÆ°Êï∞+Ê†áËÆ∞Ê∏ÖÁêÜÁöÑÊú∫Âà∂Êù•ÁÆ°ÁêÜËøûÊé•Ê±†Ôºå‰ΩøÂæóÊó†Áî®ËøûÊé•ÂèØ‰ª•Ë¢´‰ºöÂõûÊî∂ÔºåÂπ∂‰øùÊåÅÂ§ö‰∏™ÂÅ•Â∫∑ÁöÑkeep-aliveËøûÊé•„ÄÇËøô‰πüÊòØOkHttpÁöÑËøûÊé•Ê±†ËÉΩ‰øùÊåÅÈ´òÊïàÁöÑÂÖ≥ÈîÆÂéüÂõ†„ÄÇ]]></content>
      <categories>
        <category>ÊãÜËΩÆÂ≠ê</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap„ÄÅLinkedHashMap„ÄÅConcurrentHashMap]]></title>
    <url>%2F2018%2F03%2F27%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMapHashMap ÊòØÂü∫‰∫éÂìàÂ∏åË°®ÁöÑ Map Êé•Âè£ÁöÑÂÆûÁé∞Ôºå‰ª• Key-Value ÁöÑÂΩ¢ÂºèÂ≠òÂú®ÔºåÂç≥Â≠òÂÇ®ÁöÑÂØπË±°ÊòØ Entry (ÂêåÊó∂ÂåÖÂê´‰∫Ü Key Âíå Value) „ÄÇÂú®HashMap‰∏≠ÔºåÂÖ∂‰ºöÊ†πÊçÆhashÁÆóÊ≥ïÊù•ËÆ°ÁÆókey-valueÁöÑÂ≠òÂÇ®‰ΩçÁΩÆÂπ∂ËøõË°åÂø´ÈÄüÂ≠òÂèñ„ÄÇÁâπÂà´Âú∞ÔºåHashMapÊúÄÂ§öÂè™ÂÖÅËÆ∏‰∏ÄÊù°EntryÁöÑÈîÆ‰∏∫Null(Â§öÊù°‰ºöË¶ÜÁõñ)Ôºå‰ΩÜÂÖÅËÆ∏Â§öÊù°EntryÁöÑÂÄº‰∏∫Null„ÄÇÊ≠§Â§ñÔºåHashMap ÊòØ Map ÁöÑ‰∏Ä‰∏™ÈùûÂêåÊ≠•ÁöÑÂÆûÁé∞„ÄÇ Êàë‰ª¨Áü•ÈÅìÔºåÂú®Java‰∏≠ÊúÄÂ∏∏Áî®ÁöÑ‰∏§ÁßçÁªìÊûÑÊòØÊï∞ÁªÑÂíåÈìæË°®ÔºåÂá†‰πéÊâÄÊúâÁöÑÊï∞ÊçÆÁªìÊûÑÈÉΩÂèØ‰ª•Âà©Áî®Ëøô‰∏§ÁßçÊù•ÁªÑÂêàÂÆûÁé∞ÔºåHashMap Â∞±ÊòØËøôÁßçÂ∫îÁî®ÁöÑ‰∏Ä‰∏™ÂÖ∏Âûã„ÄÇÂÆûÈôÖ‰∏äÔºåHashMap Â∞±ÊòØ‰∏Ä‰∏™ÈìæË°®Êï∞ÁªÑÔºåÂ¶Ç‰∏ãÊòØÂÆÉÊï∞ÊçÆÁªìÊûÑÔºö Êàë‰ª¨ÂèØ‰ª•ÂΩ¢Ë±°Âú∞ÁúãÂá∫HashMapÂ∫ïÂ±ÇÂÆûÁé∞ËøòÊòØÊï∞ÁªÑÔºåÂè™ÊòØÊï∞ÁªÑÁöÑÊØè‰∏ÄÈ°πÈÉΩÊòØ‰∏ÄÊù°Èìæ„ÄÇÂÖ∂‰∏≠ÂèÇÊï∞initialCapacity Â∞±‰ª£Ë°®‰∫ÜËØ•Êï∞ÁªÑÁöÑÈïøÂ∫¶Ôºå‰πüÂ∞±ÊòØÊ°∂ÁöÑ‰∏™Êï∞„ÄÇÂú®Á¨¨‰∏âËäÇÊàë‰ª¨Â∑≤Áªè‰∫ÜËß£‰∫ÜHashMap ÁöÑÈªòËÆ§ÊûÑÈÄ†ÂáΩÊï∞ÁöÑÊ∫êÁ†ÅÔºö 1234567891011121314/** * Constructs an empty HashMap with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; //Ë¥üËΩΩÂõ†Â≠ê:Áî®‰∫éË°°ÈáèÁöÑÊòØ‰∏Ä‰∏™Êï£ÂàóË°®ÁöÑÁ©∫Èó¥ÁöÑ‰ΩøÁî®Á®ãÂ∫¶ this.loadFactor = DEFAULT_LOAD_FACTOR; //HashMapËøõË°åÊâ©ÂÆπÁöÑÈòàÂÄºÔºåÂÆÉÁöÑÂÄºÁ≠â‰∫é HashMap ÁöÑÂÆπÈáè‰πò‰ª•Ë¥üËΩΩÂõ†Â≠ê threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // HashMapÁöÑÂ∫ïÂ±ÇÂÆûÁé∞‰ªçÊòØÊï∞ÁªÑÔºåÂè™ÊòØÊï∞ÁªÑÁöÑÊØè‰∏ÄÈ°πÈÉΩÊòØ‰∏ÄÊù°Èìæ table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); &#125; ÊØèÊ¨°Êñ∞Âª∫‰∏Ä‰∏™HashMapÊó∂ÔºåÈÉΩ‰ºöÂàùÂßãÂåñ‰∏Ä‰∏™EntryÁ±ªÂûãÁöÑtableÊï∞ÁªÑÔºåÂÖ∂‰∏≠ EntryÁ±ªÂûãÁöÑÂÆö‰πâÂ¶Ç‰∏ãÔºö 1234567891011121314151617181920static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; // ÈîÆÂÄºÂØπÁöÑÈîÆ V value; // ÈîÆÂÄºÂØπÁöÑÂÄº Entry&lt;K,V&gt; next; // ‰∏ã‰∏Ä‰∏™ËäÇÁÇπ final int hash; // hash(key.hashCode())ÊñπÊ≥ïÁöÑËøîÂõûÂÄº /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; // Entry ÁöÑÊûÑÈÄ†ÂáΩÊï∞ value = v; next = n; key = k; hash = h; &#125; ......&#125; LinkedHashMapÂêëÈìæË°®Âêà‰∫å‰∏∫‰∏ÄÂç≥ÊòØLinkedHashMap„ÄÇÊâÄË∞ìLinkedHashMapÔºåÂÖ∂ËêΩËÑöÁÇπÂú®HashMapÔºåÂõ†Ê≠§Êõ¥ÂáÜÁ°ÆÂú∞ËØ¥ÔºåÂÆÉÊòØ‰∏Ä‰∏™Â∞ÜÊâÄÊúâEntryËäÇÁÇπÈìæÂÖ•‰∏Ä‰∏™ÂèåÂêëÈìæË°®ÂèåÂêëÈìæË°®ÁöÑHashMap„ÄÇÂú®LinkedHashMapMap‰∏≠ÔºåÊâÄÊúâputËøõÊù•ÁöÑEntryÈÉΩ‰øùÂ≠òÂú®Â¶Ç‰∏ãÈù¢Á¨¨‰∏Ä‰∏™ÂõæÊâÄÁ§∫ÁöÑÂìàÂ∏åË°®‰∏≠Ôºå‰ΩÜÁî±‰∫éÂÆÉÂèàÈ¢ùÂ§ñÂÆö‰πâ‰∫Ü‰∏Ä‰∏™‰ª•head‰∏∫Â§¥ÁªìÁÇπÁöÑÂèåÂêëÈìæË°®(Â¶Ç‰∏ãÈù¢Á¨¨‰∫å‰∏™ÂõæÊâÄÁ§∫)ÔºåÂõ†Ê≠§ÂØπ‰∫éÊØèÊ¨°putËøõÊù•EntryÔºåÈô§‰∫ÜÂ∞ÜÂÖ∂‰øùÂ≠òÂà∞ÂìàÂ∏åË°®‰∏≠ÂØπÂ∫îÁöÑ‰ΩçÁΩÆ‰∏ä‰πãÂ§ñÔºåËøò‰ºöÂ∞ÜÂÖ∂ÊèíÂÖ•Âà∞ÂèåÂêëÈìæË°®ÁöÑÂ∞æÈÉ®„ÄÇ Êõ¥Áõ¥ËßÇÂú∞Ôºå‰∏ãÂõæÂæàÂ•ΩÂú∞ËøòÂéü‰∫ÜLinkedHashMapÁöÑÂéüË≤åÔºöHashMapÂíåÂèåÂêëÈìæË°®ÁöÑÂØÜÂàáÈÖçÂêàÂíåÂàÜÂ∑•Âêà‰ΩúÈÄ†Â∞±‰∫ÜLinkedHashMap„ÄÇÁâπÂà´ÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÔºånextÁî®‰∫éÁª¥Êä§HashMapÂêÑ‰∏™Ê°∂‰∏≠ÁöÑEntryÈìæÔºåbefore„ÄÅafterÁî®‰∫éÁª¥Êä§LinkedHashMapÁöÑÂèåÂêëÈìæË°®ÔºåËôΩÁÑ∂ÂÆÉ‰ª¨ÁöÑ‰ΩúÁî®ÂØπË±°ÈÉΩÊòØEntryÔºå‰ΩÜÊòØÂêÑËá™ÂàÜÁ¶ªÔºåÊòØ‰∏§Á†Å‰∫ãÂÑø„ÄÇ ÂÖ∂‰∏≠ÔºåHashMap‰∏éLinkedHashMapÁöÑEntryÁªìÊûÑÁ§∫ÊÑèÂõæÂ¶Ç‰∏ãÂõæÊâÄÁ§∫Ôºö Âü∫Êú¨ÂÖÉÁ¥† Entry LinkedHashMapÈááÁî®ÁöÑhashÁÆóÊ≥ïÂíåHashMapÁõ∏ÂêåÔºå‰ΩÜÊòØÂÆÉÈáçÊñ∞ÂÆö‰πâ‰∫ÜEntry„ÄÇLinkedHashMap‰∏≠ÁöÑEntryÂ¢ûÂä†‰∫Ü‰∏§‰∏™ÊåáÈíà before Âíå afterÔºåÂÆÉ‰ª¨ÂàÜÂà´Áî®‰∫éÁª¥Êä§ÂèåÂêëÈìæÊé•ÂàóË°®„ÄÇÁâπÂà´ÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÔºånextÁî®‰∫éÁª¥Êä§HashMapÂêÑ‰∏™Ê°∂‰∏≠EntryÁöÑËøûÊé•È°∫Â∫èÔºåbefore„ÄÅafterÁî®‰∫éÁª¥Êä§EntryÊèíÂÖ•ÁöÑÂÖàÂêéÈ°∫Â∫èÁöÑÔºåÊ∫ê‰ª£Á†ÅÂ¶Ç‰∏ãÔºö 12345678910private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; ...&#125; ÁâπÂà´Âú∞ÔºåÁî±‰∫éLinkedHashMapÊòØHashMapÁöÑÂ≠êÁ±ªÔºåÊâÄ‰ª•LinkedHashMapËá™ÁÑ∂‰ºöÊã•ÊúâHashMapÁöÑÊâÄÊúâÁâπÊÄß„ÄÇÊØîÂ¶ÇÔºåLinkedHashMap‰πüÊúÄÂ§öÂè™ÂÖÅËÆ∏‰∏ÄÊù°EntryÁöÑÈîÆ‰∏∫Null(Â§öÊù°‰ºöË¶ÜÁõñ)Ôºå‰ΩÜÂÖÅËÆ∏Â§öÊù°EntryÁöÑÂÄº‰∏∫Null„ÄÇÊ≠§Â§ñÔºåLinkedHashMap ‰πüÊòØ Map ÁöÑ‰∏Ä‰∏™ÈùûÂêåÊ≠•ÁöÑÂÆûÁé∞„ÄÇÊ≠§Â§ñÔºåLinkedHashMapËøòÂèØ‰ª•Áî®Êù•ÂÆûÁé∞LRU (Least recently used, ÊúÄËøëÊúÄÂ∞ë‰ΩøÁî®)ÁÆóÊ≥ï„ÄÇ ConcurrentHashMapÁ∫øÁ®ã‰∏çÂÆâÂÖ®ÁöÑHashMap Âõ†‰∏∫Â§öÁ∫øÁ®ãÁéØÂ¢É‰∏ãÔºå‰ΩøÁî®HashMapËøõË°åputÊìç‰Ωú‰ºöÂºïËµ∑Ê≠ªÂæ™ÁéØÔºåÂØºËá¥CPUÂà©Áî®ÁéáÊé•Ëøë100%ÔºåÊâÄ‰ª•Âú®Âπ∂ÂèëÊÉÖÂÜµ‰∏ã‰∏çËÉΩ‰ΩøÁî®HashMap. ÊïàÁéá‰Ωé‰∏ãÁöÑHashTableÂÆπÂô® HashTableÂÆπÂô®‰ΩøÁî®synchronizedÊù•‰øùËØÅÁ∫øÁ®ãÂÆâÂÖ®Ôºå‰ΩÜÂú®Á∫øÁ®ãÁ´û‰∫âÊøÄÁÉàÁöÑÊÉÖÂÜµ‰∏ãHashTableÁöÑÊïàÁéáÈùûÂ∏∏‰Ωé‰∏ã„ÄÇÂõ†‰∏∫ÂΩì‰∏Ä‰∏™Á∫øÁ®ãËÆøÈóÆHashTableÁöÑÂêåÊ≠•ÊñπÊ≥ïÊó∂ÔºåÂÖ∂‰ªñÁ∫øÁ®ãËÆøÈóÆHashTableÁöÑÂêåÊ≠•ÊñπÊ≥ïÊó∂ÔºåÂèØËÉΩ‰ºöËøõÂÖ•ÈòªÂ°ûÊàñËΩÆËØ¢Áä∂ÊÄÅ„ÄÇÂ¶ÇÁ∫øÁ®ã1‰ΩøÁî®putËøõË°åÊ∑ªÂä†ÂÖÉÁ¥†ÔºåÁ∫øÁ®ã2‰∏ç‰ΩÜ‰∏çËÉΩ‰ΩøÁî®putÊñπÊ≥ïÊ∑ªÂä†ÂÖÉÁ¥†ÔºåÂπ∂‰∏î‰πü‰∏çËÉΩ‰ΩøÁî®getÊñπÊ≥ïÊù•Ëé∑ÂèñÂÖÉÁ¥†ÔºåÊâÄ‰ª•Á´û‰∫âË∂äÊøÄÁÉàÊïàÁéáË∂ä‰Ωé„ÄÇ ÈîÅÂàÜÊÆµÊäÄÊúØ HashTableÂÆπÂô®Âú®Á´û‰∫âÊøÄÁÉàÁöÑÂπ∂ÂèëÁéØÂ¢É‰∏ãË°®Áé∞Âá∫ÊïàÁéá‰Ωé‰∏ãÁöÑÂéüÂõ†ÊòØÊâÄÊúâËÆøÈóÆHashTableÁöÑÁ∫øÁ®ãÈÉΩÂøÖÈ°ªÁ´û‰∫âÂêå‰∏ÄÊääÈîÅÔºåÈÇ£ÂÅáÂ¶ÇÂÆπÂô®ÈáåÊúâÂ§öÊääÈîÅÔºåÊØè‰∏ÄÊääÈîÅÁî®‰∫éÈîÅÂÆπÂô®ÂÖ∂‰∏≠‰∏ÄÈÉ®ÂàÜÊï∞ÊçÆÔºåÈÇ£‰πàÂΩìÂ§öÁ∫øÁ®ãËÆøÈóÆÂÆπÂô®Èáå‰∏çÂêåÊï∞ÊçÆÊÆµÁöÑÊï∞ÊçÆÊó∂ÔºåÁ∫øÁ®ãÈó¥Â∞±‰∏ç‰ºöÂ≠òÂú®ÈîÅÁ´û‰∫âÔºå‰ªéËÄåÂèØ‰ª•ÊúâÊïàÁöÑÊèêÈ´òÂπ∂ÂèëËÆøÈóÆÊïàÁéáÔºåËøôÂ∞±ÊòØConcurrentHashMapÊâÄ‰ΩøÁî®ÁöÑÈîÅÂàÜÊÆµÊäÄÊúØÔºåÈ¶ñÂÖàÂ∞ÜÊï∞ÊçÆÂàÜÊàê‰∏ÄÊÆµ‰∏ÄÊÆµÁöÑÂ≠òÂÇ®ÔºåÁÑ∂ÂêéÁªôÊØè‰∏ÄÊÆµÊï∞ÊçÆÈÖç‰∏ÄÊääÈîÅÔºåÂΩì‰∏Ä‰∏™Á∫øÁ®ãÂç†Áî®ÈîÅËÆøÈóÆÂÖ∂‰∏≠‰∏Ä‰∏™ÊÆµÊï∞ÊçÆÁöÑÊó∂ÂÄôÔºåÂÖ∂‰ªñÊÆµÁöÑÊï∞ÊçÆ‰πüËÉΩË¢´ÂÖ∂‰ªñÁ∫øÁ®ãËÆøÈóÆ„ÄÇ ConcurrentHashMapÁöÑÁªìÊûÑ Êàë‰ª¨ÈÄöËøáConcurrentHashMapÁöÑÁ±ªÂõæÊù•ÂàÜÊûêConcurrentHashMapÁöÑÁªìÊûÑ„ÄÇ ConcurrentHashMapÊòØÁî±SegmentÊï∞ÁªÑÁªìÊûÑÂíåHashEntryÊï∞ÁªÑÁªìÊûÑÁªÑÊàê„ÄÇSegmentÊòØ‰∏ÄÁßçÂèØÈáçÂÖ•ÈîÅReentrantLockÔºåÂú®ConcurrentHashMapÈáåÊâÆÊºîÈîÅÁöÑËßíËâ≤ÔºåHashEntryÂàôÁî®‰∫éÂ≠òÂÇ®ÈîÆÂÄºÂØπÊï∞ÊçÆ„ÄÇ‰∏Ä‰∏™ConcurrentHashMapÈáåÂåÖÂê´‰∏Ä‰∏™SegmentÊï∞ÁªÑÔºåSegmentÁöÑÁªìÊûÑÂíåHashMapÁ±ª‰ººÔºåÊòØ‰∏ÄÁßçÊï∞ÁªÑÂíåÈìæË°®ÁªìÊûÑÔºå ‰∏Ä‰∏™SegmentÈáåÂåÖÂê´‰∏Ä‰∏™HashEntryÊï∞ÁªÑÔºåÊØè‰∏™HashEntryÊòØ‰∏Ä‰∏™ÈìæË°®ÁªìÊûÑÁöÑÂÖÉÁ¥†Ôºå ÊØè‰∏™SegmentÂÆàÊä§ËÄÖ‰∏Ä‰∏™HashEntryÊï∞ÁªÑÈáåÁöÑÂÖÉÁ¥†,ÂΩìÂØπHashEntryÊï∞ÁªÑÁöÑÊï∞ÊçÆËøõË°å‰øÆÊîπÊó∂ÔºåÂøÖÈ°ªÈ¶ñÂÖàËé∑ÂæóÂÆÉÂØπÂ∫îÁöÑSegmentÈîÅ„ÄÇ SparseArray SparseArrayÊòØ‰ΩøÁî®‰∏§‰∏™Êï∞ÁªÑÊù•ÂÆûÁé∞ÁöÑÔºå‚ºÄ‰∏™intÁ±ªÂûãÁöÑmKeysÔºå‚ºÄ‰∏™ObjectÁ±ªÂûãmValuesÔºåÂÖ∂‰∏≠mKeys ÊòØ‰∏Ä‰∏™Â≠òÂÇ®keyÁöÑÊï∞ÁªÑÔºåÂÆÉÊòØÊúâÂ∫èÊéíÂàóÁöÑÔºåÊâÄ‰ª•ÂèØ‰ª•‰ΩøÁî®‰∫åÂàÜÊü•ÊâæÂæàÂø´Âú∞Á°ÆËÆ§key Âú®mKeysÊâÄÂ§Ñ‰ΩçÁΩÆindexÔºåÁÑ∂ÂêéÂπ∂ÊäävalueÊèíÂÖ•Âà∞ValuesÁöÑindexÂØπÂ∫î‰ΩçÁΩÆ„ÄÇ SparseArrayÊõ¥Âä†ËäÇÁ∫¶ÂÜÖÂ≠òÔºå‰∏Ä‰∏™int[]Êï∞ÁªÑÂ≠òÂÇ®ÊâÄÊúâÁöÑkeyÔºå‰∏Ä‰∏™object[] Êï∞ÁªÑÂ≠òÂÇ®ÊâÄÊúâÁöÑvalue. HashMapÈÅáÂà∞ÂÜ≤Á™ÅÊó∂,Êó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(n)„ÄÇËÄåSparseArray‰∏ç‰ºöÊúâÂÜ≤Á™ÅÔºåÈááÁî®‰∫åÂàÜÊêúÁ¥¢ÁÆóÊ≥ïÔºåÊó∂Èó¥Â§çÊùÇÂ∫¶‰∏∫O(lgn). ArrayMapArrayMap‰πüÊòØÁî®Áî®‰∏§‰∏™Êï∞ÁªÑÊù•Ê®°ÊãüMapÔºåÁ¨¨‰∏Ä‰∏™Êï∞ÁªÑÂ≠òÊîæÂ≠òÊîæitemÁöÑhashÂÄºÔºåÁ¨¨‰∫åÊï∞ÁªÑÊòØÊääkeyÔºåvalueËøûÁª≠ÁöÑÂ≠òÊîæÂú®Êï∞ÁªÑÈáåÔºåÈÄöËøáÂÖàÁÆóhashÂú®Á¨¨‰∏Ä‰∏™Êï∞ÁªÑÈáåÊâæÂà∞ÂÆÉÁöÑhash indexÔºåÊ†πÊçÆËøô‰∏™indexÂú®ÂéªÁ¨¨‰∫å‰∏™Êï∞ÁªÑÈáåÊâæÂà∞Ëøô‰∏™key-value„ÄÇÂú®ËøôÈáåÔºåÂú®Á¨¨‰∏Ä‰∏™Êï∞ÁªÑÈáåÊü•Êâæhash indexÁöÑÊñπÊ≥ïÂΩìÁÑ∂ÊòØÁî®‰∫åÂàÜÊü•ÊâæÂï¶Ôºàbinary searchÔºâ„ÄÇ]]></content>
      <categories>
        <category>ÂÆπÂô®</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BitmapÁöÑÂä†ËΩΩÂíåCache]]></title>
    <url>%2F2018%2F03%2F21%2FBitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache%2F</url>
    <content type="text"><![CDATA[BitmapÁöÑÈ´òÊïàÂä†ËΩΩÂÖàÊù•ÁÆÄÂçï‰ªãÁªç‰∏Ä‰∏ãÂ¶Ç‰ΩïÂä†ËΩΩ‰∏Ä‰∏™Bitmap, BitmapÂú®android‰∏≠ÊåáÁöÑÊòØ‰∏ÄÂº†ÂõæÁâá, ÂèØ‰ª•ÊòØpngÊ†ºÂºè‰πüÂèØ‰ª•ÊòØjpgÁ≠âÂÖ∂‰ªñÂ∏∏ËßÅÁöÑÂõæÁâáÊ†ºÂºè. ÈÇ£‰πàÂ¶Ç‰ΩïÂä†ËΩΩ‰∏Ä‰∏™ÂõæÁâá?È¶ñÂÖàBitmapFactoryÁ±ªÊèê‰æõ‰∫ÜÂõõÁßçÊñπÊ≥ï: decodeFile(), decodeResource(), decodeStream(), decodeByteArray(). ÂàÜÂà´Áî®‰∫é‰ªéÊñá‰ª∂Á≥ªÁªü, ËµÑÊ∫êÊñá‰ª∂, ËæìÂÖ•ÊµÅ‰ª•ÂèäÂ≠óËäÇÊï∞ÁªÑÂä†ËΩΩÂá∫‰∏Ä‰∏™BitmapÂØπË±°. ÂÖ∂‰∏≠decodeFileÂíådecodeResourceÂèàÈó¥Êé•Ë∞ÉÁî®‰∫ÜdecodeStream()ÊñπÊ≥ï, ËøôÂõõÁ±ªÊñπÊ≥ïÊúÄÁªàÊòØÂú®AndroidÁöÑÂ∫ïÂ±ÇÂÆûÁé∞ÁöÑ, ÂØπÂ∫îÁùÄBitmapFactoryÁ±ªÁöÑÂá†‰∏™nativeÊñπÊ≥ï. È´òÊïàÂä†ËΩΩÁöÑBitmapÁöÑÊ†∏ÂøÉÊÄùÊÉ≥:ÈááÁî®BitmapFactory.OptionsÊù•Âä†ËΩΩÊâÄÈúÄÂ∞∫ÂØ∏ÁöÑÂõæÁâá. ÊØîÂ¶ÇËØ¥‰∏Ä‰∏™ImageViewÊéß‰ª∂ÁöÑÂ§ßÂ∞è‰∏∫300*300. ËÄåÂõæÁâáÁöÑÂ§ßÂ∞è‰∏∫800*800. Ëøô‰∏™Êó∂ÂÄôÂ¶ÇÊûúÁõ¥Êé•Âä†ËΩΩÈÇ£‰πàÂ∞±ÊØîËæÉÊµ™Ë¥πËµÑÊ∫ê, ÈúÄË¶ÅÊõ¥Â§öÁöÑÂÜÖÂ≠òÁ©∫Èó¥Êù•Âä†ËΩΩÂõæÁâá, Ëøô‰∏çÊòØÂæàÂøÖË¶ÅÁöÑ. ËøôÈáåÊàë‰ª¨Â∞±ÂèØ‰ª•ÂÖàÊääÂõæÁâáÊåâ‰∏ÄÂÆöÁöÑÈááÊ†∑ÁéáÊù•Áº©Â∞èÂõæÁâáÂú®ËøõË°åÂä†ËΩΩ. ‰∏ç‰ªÖÈôç‰Ωé‰∫ÜÂÜÖÂ≠òÂç†Áî®,ËøòÂú®‰∏ÄÂÆöÁ®ãÂ∫¶‰∏äÈÅøÂÖç‰∫ÜOOMÂºÇÂ∏∏. ‰πüÊèêÈ´ò‰∫ÜÂä†ËΩΩbitmapÊó∂ÁöÑÊÄßËÉΩ. ËÄåÈÄöËøáOptionsÂèÇÊï∞Êù•Áº©ÊîæÂõæÁâá: ‰∏ªË¶ÅÊòØÁî®Âà∞‰∫ÜinSampleSizeÂèÇÊï∞, Âç≥ÈááÊ†∑Áéá. Â¶ÇÊûúÊòØinSampleSize=1ÈÇ£‰πàÂíåÂéüÂõæÂ§ßÂ∞è‰∏ÄÊ†∑, Â¶ÇÊûúÊòØinSampleSize=2ÈÇ£‰πàÂÆΩÈ´òÈÉΩ‰∏∫ÂéüÂõæ1/2, ËÄåÂÉèÁ¥†‰∏∫ÂéüÂõæÁöÑ1/4, Âç†Áî®ÁöÑÂÜÖÂ≠òÂ§ßÂ∞è‰πü‰∏∫ÂéüÂõæÁöÑ1/4 Â¶ÇÊûúÊòØinSampleSize=3ÈÇ£‰πàÂÆΩÈ´òÈÉΩ‰∏∫ÂéüÂõæ1/3, ËÄåÂÉèÁ¥†‰∏∫ÂéüÂõæÁöÑ1/9, Âç†Áî®ÁöÑÂÜÖÂ≠òÂ§ßÂ∞è‰πü‰∏∫ÂéüÂõæÁöÑ1/9 ‰ª•Ê≠§Á±ªÊé®‚Ä¶.. Ë¶ÅÁü•ÈÅìAndroid‰∏≠Âä†ËΩΩÂõæÁâáÂÖ∑‰ΩìÂú®ÂÜÖÂ≠ò‰∏≠ÁöÑÂç†ÊúâÁöÑÂ§ßÂ∞èÊòØÊ†πÊçÆÂõæÁâáÁöÑÂÉèÁ¥†ÂÜ≥ÂÆöÁöÑ, ËÄå‰∏éÂõæÁâáÁöÑÂÆûÈôÖÂç†Áî®Á©∫Èó¥Â§ßÂ∞èÊ≤°ÊúâÂÖ≥Á≥ª.ËÄå‰∏îÂ¶ÇÊûúË¶ÅÂä†ËΩΩmipmap‰∏ãÁöÑÂõæÁâá, Ëøò‰ºöÊ†πÊçÆ‰∏çÂêåÁöÑÂàÜËæ®Áéá‰∏ãÁöÑÊñá‰ª∂Â§πËøõË°å‰∏çÂêåÁöÑÊîæÂ§ßÁº©Â∞è. Âàó‰∏æÁé∞Âú®Êúâ‰∏ÄÂº†ÂõæÁâáÂÉèÁ¥†‰∏∫:1024*1024, Â¶ÇÊûúÈááÁî®ARGB8888(Âõõ‰∏™È¢úËâ≤ÈÄöÈÅìÊØè‰∏™Âç†Êúâ‰∏Ä‰∏™Â≠óËäÇ,Áõ∏ÂΩì‰∫é1ÁÇπÂÉèÁ¥†Âç†Áî®4‰∏™Â≠óËäÇÁöÑÁ©∫Èó¥)ÁöÑÊ†ºÂºèÊù•Â≠òÂÇ®.(ËøôÈáå‰∏çËÄÉËôë‰∏çÂêåÁöÑËµÑÊ∫êÊñá‰ª∂‰∏ãÊÉÖÂÜµÂàÜÊûê) ÈÇ£‰πàÂõæÁâáÁöÑÂç†ÊúâÂ§ßÂ∞èÂ∞±ÊòØ1024*1024*4ÈÇ£Áé∞Âú®ËøôÂº†ÂõæÁâáÂú®ÂÜÖÂ≠ò‰∏≠Âç†Áî®4MB. Â¶ÇÊûúÈíàÂØπÂàöÊâçÁöÑÂõæÁâáËøõË°åinSampleSize=2, ÈÇ£‰πàÊúÄÂêéÂç†Áî®ÂÜÖÂ≠òÂ§ßÂ∞è‰∏∫512*512*4, ‰πüÂ∞±ÊòØ1MB ÈááÊ†∑ÁéáÁöÑÊï∞ÂÄºÂøÖÈ°ªÊòØÂ§ß‰∫é1ÁöÑÊï¥Êï∞ÊòØÊâç‰ºöÊúâÁº©ÊîæÊïàÊûú, Âπ∂‰∏îÈááÊ†∑ÁéáÂêåÊó∂‰ΩúÁî®‰∫éÂÆΩ/È´ò, ËøôÂ∞ÜÂØºËá¥Áº©ÊîæÂêéÁöÑÂõæÁâá‰ª•Ëøô‰∏™ÈááÊ†∑ÁéáÁöÑ2Ê¨°ÊñπÈÄíÂáè, Âç≥ÂÜÖÂ≠òÂç†Áî®Áº©ÊîæÂ§ßÂ∞è‰∏∫1/(inSampleSizeÁöÑ‰∫åÊ¨°Êñπ). Â¶ÇÊûúÂ∞è‰∫é1ÈÇ£‰πàÁõ∏ÂΩì‰∫é=1ÁöÑÊó∂ÂÄô. Âú®ÂÆòÊñπÊñáÊ°£‰∏≠ÊåáÂá∫, inSampleSizeÁöÑÂèñÂÄºÂ∫îËØ•ÊÄªÊòØ‰∏∫2ÁöÑÊåáÊï∞, ÊØîÂ¶Ç1,2,4,8,16,32‚Ä¶Â¶ÇÊûúÂ§ñÁïå‰º†ÈÄíinSampleSize‰∏ç‰∏∫2ÁöÑÊåáÊï∞, ÈÇ£‰πàÁ≥ªÁªü‰ºöÂêë‰∏ãÂèñÊï¥Âπ∂ÈÄâÊã©‰∏Ä‰∏™ÊúÄÊé•ËøëÁöÑ2ÁöÑÊåáÊï∞Êù•‰ª£Êõø. ÊØîÂ¶ÇÂ¶ÇÊûúinSampleSize=3,ÈÇ£‰πàÁ≥ªÁªü‰ºöÈÄâÊã©2Êù•‰ª£Êõø. ‰ΩÜÊòØËøôÊù°ËßÑÂàôÂπ∂‰∏ç‰ΩúÁî®‰∫éÊâÄÊúâÁöÑandroidÁâàÊú¨, ÊâÄ‰ª•ÂèØ‰ª•ÂΩìÊàê‰∏Ä‰∏™ÂºÄÂèëÂª∫ËÆÆ Êï¥ÁêÜ‰∏Ä‰∏ãÂºÄÂèë‰∏≠‰ª£Á†ÅÊµÅÁ®ã: Â∞ÜBitmapFactory.OptionsÁöÑinJustDecodeBoundsÂèÇÊï∞ËÆæÁΩÆ‰∏∫trueÂπ∂Âä†ËΩΩÂõæÁâá. ‰ªéBitmapFactory.OptionsÂèñÂá∫ÂõæÁâáÁöÑÂéüÂßãÂÆΩÈ´ò‰ø°ÊÅØ, ‰ªñ‰ª¨ÂØπÂ∫î‰∫éoutWidthÂíåoutHeightÂèÇÊï∞ Ê†πÊçÆÈááÊ†∑ÁéáÁöÑËßÑÂàôÂπ∂ÁªìÂêàÁõÆÊ†áViewÁöÑÊâÄÈúÄÂ§ßÂ∞èËÆ°ÁÆóÂá∫ÈááÊ†∑ÁéáinSampleSize Â∞ÜBitmapFactory.OptionsÁöÑinJustDecodeBoundsÂèÇÊï∞ËÆæ‰∏∫false, ÁÑ∂ÂêéÈáçÊñ∞Âä†ËΩΩ. Á¨¨‰∏Ä‰∏™Ê≠•È™§ËÆæÁΩÆ‰∫Ü‰∏Ä‰∏™ÂèÇÊï∞, Ëøô‰∏™ÂèÇÊï∞ÁöÑ‰ΩúÁî®Â∞±ÊòØÂú®Âä†ËΩΩÂõæÁâáÁöÑÊó∂ÂÄôÊòØÂê¶Âè™ÊòØÂä†ËΩΩÂõæÁâáÂÆΩÈ´ò‰ø°ÊÅØËÄå‰∏çÊääÂõæÁâáÂÖ®ÈÉ®Âä†ËΩΩÂà∞ÂÜÖÂ≠ò. ÊâÄ‰ª•Ëøô‰∏™Êìç‰ΩúÊòØ‰∏™ËΩªÈáèÁ∫ßÁöÑ. ÈÄöËøáËøô‰∫õÊ≠•È™§Â∞±ÂèØ‰ª•Êï¥ÁêÜÂá∫‰ª•‰∏ãÁöÑÂ∑•ÂÖ∑Âä†ËΩΩÂõæÁâáÁ±ªË∞ÉÁî®decodeFixedSizeForResource()Âç≥ÂèØ. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyBitmapLoadUtil &#123; /** * ÂØπ‰∏Ä‰∏™ResourcesÁöÑËµÑÊ∫êÊñá‰ª∂ËøõË°åÊåáÂÆöÈïøÂÆΩÊù•Âä†ËΩΩËøõÂÜÖÂ≠ò, Âπ∂ÊääËøô‰∏™bitmapÂØπË±°ËøîÂõû * * @param res ËµÑÊ∫êÊñá‰ª∂ÂØπË±° * @param resId Ë¶ÅÊìç‰ΩúÁöÑÂõæÁâáid * @param reqWidth ÊúÄÁªàÊÉ≥Ë¶ÅÂæóÂà∞bitmapÁöÑÂÆΩÂ∫¶ * @param reqHeight ÊúÄÁªàÊÉ≥Ë¶ÅÂæóÂà∞bitmapÁöÑÈ´òÂ∫¶ * @return ËøîÂõûÈááÊ†∑‰πãÂêéÁöÑbitmapÂØπË±° */ public static Bitmap decodeFixedSizeForResource(Resources res, int resId, int reqWidth, int reqHeight)&#123; // È¶ñÂÖàÂÖàÊåáÂÆöÂä†ËΩΩÁöÑÊ®°Âºè ‰∏∫Âè™ÊòØËé∑ÂèñËµÑÊ∫êÊñá‰ª∂ÁöÑÂ§ßÂ∞è BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); //Calculate Size ËÆ°ÁÆóË¶ÅËÆæÁΩÆÁöÑÈááÊ†∑Áéá Âπ∂ÊääÂÄºËÆæÁΩÆÂà∞option‰∏ä options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // ÂÖ≥Èó≠Âè™Âä†ËΩΩÂ±ûÊÄßÊ®°Âºè, Âπ∂ÈáçÊñ∞Âä†ËΩΩÁöÑÊó∂ÂÄô‰º†ÂÖ•Ëá™ÂÆö‰πâÁöÑoptionsÂØπË±° options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options); &#125; /** * ‰∏Ä‰∏™ËÆ°ÁÆóÂ∑•ÂÖ∑Á±ªÁöÑÊñπÊ≥ï, ‰º†ÂÖ•ÂõæÁâáÁöÑÂ±ûÊÄßÂØπË±°Âíå ÊÉ≥Ë¶ÅÂÆûÁé∞ÁöÑÁõÆÊ†áÂ§ßÂ∞è. ÈÄöËøáËÆ°ÁÆóÂæóÂà∞ÈááÊ†∑ÂÄº */ private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; //Raw height and width of image //ÂéüÂßãÂõæÁâáÁöÑÂÆΩÈ´òÂ±ûÊÄß final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; // Â¶ÇÊûúÊÉ≥Ë¶ÅÂÆûÁé∞ÁöÑÂÆΩÈ´òÊØîÂéüÂßãÂõæÁâáÁöÑÂÆΩÈ´òÂ∞èÈÇ£‰πàÂ∞±ÂèØ‰ª•ËÆ°ÁÆóÂá∫ÈááÊ†∑Áéá, Âê¶Âàô‰∏çÈúÄË¶ÅÊîπÂèòÈááÊ†∑Áéá if (reqWidth &lt; height || reqHeight &lt; width)&#123; int halfWidth = width/2; int halfHeight = height/2; // Âà§Êñ≠ÂéüÂßãÈïøÂÆΩÁöÑ‰∏ÄÂçäÊòØÂê¶ÊØîÁõÆÊ†áÂ§ßÂ∞èÂ∞è, Â¶ÇÊûúÂ∞èÈÇ£‰πàÂ¢ûÂ§ßÈááÊ†∑Áéá2ÂÄç, Áõ¥Âà∞Âá∫Áé∞‰øÆÊîπÂêéÂéüÂßãÂÄº‰ºöÊØîÁõÆÊ†áÂÄºÂ§ßÁöÑÊó∂ÂÄô while((halfHeight/inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth/inSampleSize) &gt;= reqWidth)&#123; inSampleSize *= 2; &#125; &#125; return inSampleSize; &#125;&#125; ÂΩìÁªôImageViewËÆæÁΩÆÁöÑÊó∂ÂÄô‰º†ÂÖ•Êéß‰ª∂ÁöÑÂ§ßÂ∞è, Â∞±‰ºöËá™Âä®ËΩ¨Êç¢ËøîÂõû. ÂèØ‰ª•Áúã‰∏Ä‰∏ã‰∏ãÈù¢ÁöÑ‰∏§Âº†Âõæ, ÂΩìÂä†ËΩΩ‰∏Ä‰∏™ÂàÜËæ®ÁéáÂæàÂ§ßÁöÑÂõæÁâáÂ¶ÇÊûú‰∏ç‰ΩøÁî®Ê≠§ÊñπÊ≥ïÈÇ£‰πàÂ∞±Âá∫Á®ãÂ∫èÂ¥©Ê∫É ‰∫ÜËß£‰∏Ä‰∏ã‰∏Ä‰∏™ÂéüÂßãÂõæÁâáÂà∞ÊâãÊú∫ÊòæÁ§∫ÁöÑÊúÄÁªàÂç†Áî®ÂÜÖÂ≠òÂ§ßÂ∞è Android‰∏≠ÁöÑÁºìÂ≠òÁ≠ñÁï•ÁõÆÂâçÂ∏∏Áî®ÁöÑ‰∏ÄÁßçÁºìÂ≠òÁÆóÊ≥ïÊòØLRU(Least Recently Used), ÊúÄËøëÊúÄÂ∞ë‰ΩøÁî®ÁÆóÊ≥ï. Ê†∏ÂøÉÊÄùÊÉ≥: ÂΩìÁºìÂ≠òÂ≠òÊª°Êó∂, ‰ºö‰ºòÂÖàÊ∑òÊ±∞ÈÇ£‰∫õËøëÊúüÊúÄÂ∞ë‰ΩøÁî®ÁöÑÁºìÂ≠òÂØπË±°. ÈááÁî®LRUÁÆóÊ≥ïÁöÑÁºìÂ≠òÊúâ‰∏§Áßç: LruCacheÂíåDiskLruCache„ÄÇLruCacheÁî®‰∫éÂÆûÁé∞ÂÜÖÂ≠òÁºìÂ≠ò, DiskLruCacheÂàôÂÖÖÂΩì‰∫ÜÂ≠òÂÇ®ËÆæÂ§áÁºìÂ≠ò, ÂΩìÁªÑÂêà‰ΩøÁî®ÂêéÂ∞±ÂèØ‰ª•ÂÆûÁé∞‰∏Ä‰∏™Á±ª‰ººImageLoaderËøôÊ†∑ÁöÑÁ±ªÂ∫ì. LruCacheLruCacheÊòØAndroid 3.1ÊâÄÊèê‰æõÁöÑ‰∏Ä‰∏™ÁºìÂ≠òÁ±ª, ÈÄöËøásupport-v4ÂÖºÂÆπÂåÖÂèØ‰ª•ÂÖºÂÆπÂà∞Êó©ÊúüÁöÑAndroidÁâàÊú¨ LruCacheÊòØ‰∏Ä‰∏™Ê≥õÂûãÁ±ª, ÂÆÉÂÜÖÈÉ®ÈááÁî®‰∫Ü‰∏Ä‰∏™LinkedHashMap‰ª•Âº∫ÂºïÁî®ÁöÑÊñπÂºèÂ≠òÂÇ®Â§ñÁïåÁöÑÁºìÂ≠òÂØπË±°, ÂÖ∂Êèê‰æõ‰∫ÜgetÂíåputÊñπÊ≥ïÊù•ÂÆåÊàêÁºìÂ≠òÁöÑËé∑ÂèñÂíåÊ∑ªÂä†ÁöÑÊìç‰Ωú. ÂΩìÁºìÂ≠òÊª°‰∫ÜÊó∂, LruCache‰ºöÁßªÈô§ËæÉÊó©‰ΩøÁî®ÁöÑÁºìÂ≠òÂØπË±°, ÁÑ∂ÂêéÂú®Ê∑ªÂä†Êñ∞ÁöÑÁºìÂ≠òÂØπË±°. ÊôÆÂèä‰∏Ä‰∏ãÂêÑÁßçÂºïÁî®ÁöÑÂå∫Âà´: Âº∫ÂºïÁî®: Áõ¥Êé•ÁöÑÂØπË±°ÂºïÁî® ËΩØÂºïÁî®: ÂΩì‰∏Ä‰∏™ÂØπË±°Âè™ÊúâËΩØÂºïÁî®Â≠òÂú®Êó∂, Á≥ªÁªüÂÜÖÂ≠ò‰∏çË∂≥Êó∂Ê≠§ÂØπË±°‰ºöË¢´gcÂõûÊî∂ Âº±ÂºïÁî®: ÂΩì‰∏Ä‰∏™ÂØπË±°Âè™ÊúâÂº±ÂºïÁî®Â≠òÂú®Êó∂, ÂØπË±°‰ºöÈöè‰∏ã‰∏ÄÊ¨°gcÊó∂Ë¢´ÂõûÊî∂ ÂàõÂª∫ÁöÑÁºìÂ≠òÂØπË±°Â§ßÂ∞èÈÄöËøáÂèØÁî®ÂÜÖÂ≠òÁöÑ1/8Êù•ËøõË°åÂàÜÈÖç, Âπ∂ÈúÄË¶ÅÈáçÂÜôsizeOf()ÊñπÊ≥ï, sizeOf()ÊòØËÆ°ÁÆóÁºìÂ≠òÂØπË±°ÁöÑÂ§ßÂ∞è, Â¶ÇÊûúÊúâÈúÄË¶ÅËøòÂèØ‰ª•ÈáçÂÜôentryRemoved(),Âú®LruÁßªÈô§ÊóßÁºìÂ≠òÁöÑÊó∂ÂÄôÂõûË∞ÉÁî®Ê≠§ÊñπÊ≥ï. 12345678int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);int cacheSize = maxMemory / 8;mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @override protected int sizeof(String key, Bitmap bitmap) &#123; return bitmap.getRowBytes() * bitmap.getHeight() / 1024; &#125;&#125; Ëé∑Âèñ„ÄÅÊ∑ªÂä†„ÄÅ Âà†Èô§‰∏Ä‰∏™ÁºìÂ≠òÂØπË±°Ôºö 123mMemoryCache.get(key);mMemoryCache.put(key);mMemoryCache.remove(key); DiskLruCacheDiskLruCacheÁî®‰∫éÂÆûÁé∞Â≠òÂÇ®ËÆæÂ§áÁºìÂ≠ò, Âç≥Á£ÅÁõòÁºìÂ≠ò. ÂÆÉÈÄöËøáÂ∞ÜÁºìÂ≠òÂØπË±°ÂÜôÂÖ•Êñá‰ª∂Á≥ªÁªü‰ªéËÄåÂÆûÁé∞ÁºìÂ≠òÁöÑÊïàÊûú. ÂèÇËÄÉÔºö Android DiskLruCacheÂÆåÂÖ®Ëß£ÊûêÔºåÁ°¨ÁõòÁºìÂ≠òÁöÑÊúÄ‰Ω≥ÊñπÊ°à 1. DiskLruCacheÁöÑÂàõÂª∫ DiskLruCacheÂπ∂‰∏çËÉΩÈÄöËøáÊûÑÈÄ†ÊñπÊ≥ïÊù•ÂàõÂª∫, ‰ªñÊèê‰æõ‰∫Üopen()ÊñπÊ≥ïÁî®‰∫éÂàõÂª∫Ëá™Ë∫´, Â¶Ç‰∏ãÊâÄÁ§∫ 1public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) Ëøô‰∏™ÊñπÊ≥ïÊúâÂõõ‰∏™ÂèÇÊï∞: File directory: Ë°®Á§∫Á£ÅÁõòÁºìÂ≠òÂú®Êñá‰ª∂Á≥ªÁªü‰∏≠ÁöÑÂ≠òÂÇ®Ë∑ØÂæÑ. ÂèØ‰ª•ÈÄâÊã©SDÂç°‰∏äÁöÑÁºìÂ≠òÁõÆÂΩï, ÂÖ∑‰ΩìÊòØÊåá/sdcard/Andriod/data/package_name/cacheÁõÆÂΩï, package_nameË°®Á§∫ÂΩìÂâçÂ∫îÁî®ÁöÑÂåÖÂêç, ÂΩìÂ∫îÁî®Ë¢´Âç∏ËΩΩÂêé, Ê≠§ÁõÆÂΩï‰ºö‰∏ÄÂπ∂Âà†Èô§Êéâ. ‰πüÂèØ‰ª•ÈÄâÊã©dataÁõÆÂΩï‰∏ã. ÊàñËÄÖÂÖ∂‰ªñÂú∞Êñπ. ËøôÈáåÁªôÂá∫ÁöÑÂª∫ËÆÆ:Â¶ÇÊûúÂ∫îÁî®Âç∏ËΩΩÂêéÂ∞±Â∏åÊúõÂà†Èô§ÁºìÂ≠òÊñá‰ª∂ÁöÑËØù , ÈÇ£‰πàÂ∞±ÈÄâÊã©SDÂç°‰∏äÁöÑÁºìÂ≠òÁõÆÂΩï, Â¶ÇÊûúÂ∏åÊúõ‰øùÁïôÁºìÂ≠òÊï∞ÊçÆÈÇ£Â∞±Â∫îËØ•ÈÄâÊã©SDÂç°‰∏äÁöÑÂÖ∂‰ªñÁõÆÂΩï. int appVersion: Ë°®Á§∫Â∫îÁî®ÁöÑÁâàÊú¨Âè∑, ‰∏ÄËà¨ËÆæ‰∏∫1Âç≥ÂèØ. ÂΩìÁâàÊú¨Âè∑ÂèëÁîüÊîπÂèòÁöÑÊó∂ÂÄôDiskLruCache‰ºöÊ∏ÖÁ©∫‰πãÂâçÊâÄÊúâÁöÑÁºìÂ≠òÊñá‰ª∂, Âú®ÂÆûÈôÖÂºÄÂèë‰∏≠Ëøô‰∏™ÂÆûÁî®ÊÄß‰∏çÂ§ß. int valueCount: Ë°®Á§∫Âçï‰∏™ËäÇÁÇπÊâÄÂØπÂ∫îÁöÑÊï∞ÊçÆÁöÑ‰∏™Êï∞, ‰∏ÄËà¨ËÆæ‰∏∫1. long maxSize: Ë°®Á§∫ÁºìÂ≠òÁöÑÊÄªÂ§ßÂ∞è, ÊØîÂ¶Ç50MB, ÂΩìÁºìÂ≠òÂ§ßÂ∞èË∂ÖÂá∫Ëøô‰∏™ËÆæÂÆöÂÄºÂêé, DiskLruCache‰ºöÊ∏ÖÈô§‰∏Ä‰∫õÁºìÂ≠òËÄå‰øùËØÅÊÄªÂ§ßÂ∞è‰∏çÂ§ß‰∫éËøô‰∏™ËÆæÂÆöÂÄº. 2. DiskLruCacheÁöÑÁºìÂ≠òÊ∑ªÂä† DiskLruCacheÁöÑÁºìÂ≠òÊ∑ªÂä†ÁöÑÊìç‰ΩúÊòØÈÄöËøáEditorÂÆåÊàêÁöÑ, EditorË°®Á§∫‰∏Ä‰∏™ÁºìÂ≠òÂØπË±°ÁöÑÁºñËæëÂØπË±°. Â¶ÇÊûúËøòÊòØÁºìÂ≠òÂõæÁâá‰∏∫‰æãÂ≠ê, ÊØè‰∏ÄÂº†ÂõæÁâáÈÉΩÈÄöËøáÂõæÁâáÁöÑurl‰∏∫key, ËøôÈáåÁî±‰∫éurlÂèØËÉΩ‰ºöÊúâÁâπÊÆäÂ≠óÁ¨¶ÊâÄ‰ª•ÈááÁî®urlÁöÑmd5ÂÄº‰Ωú‰∏∫key. Ê†πÊçÆËøô‰∏™keyÂ∞±ÂèØ‰ª•ÈÄöËøáedit()Êù•Ëé∑ÂèñEditorÂØπË±°, Â¶ÇÊûúËøô‰∏™ÁºìÂ≠òÂØπË±°Ê≠£Âú®Ë¢´ÁºñËæë, ÈÇ£‰πàedit()Â∞±‰ºöËøîÂõûnull. Âç≥DiskLruCache‰∏çÂÖÅËÆ∏ÂêåÊó∂ÁºñËæë‰∏Ä‰∏™ÁºìÂ≠òÂØπË±°. ÂΩìÁî®.edit(key)Ëé∑Âæó‰∫ÜEditorÂØπË±°‰πãÂêé. ÈÄöËøáeditor.newOutputStream(0)Â∞±ÂèØ‰ª•ÂæóÂà∞‰∏Ä‰∏™Êñá‰ª∂ËæìÂá∫ÊµÅ. Áî±‰∫é‰πãÂâçopen()ÊñπÊ≥ïËÆæÁΩÆ‰∫Ü‰∏Ä‰∏™ËäÇÁÇπÂè™ËÉΩÊúâ‰∏Ä‰∏™Êï∞ÊçÆ. ÊâÄ‰ª•Âú®Ëé∑ÂæóËæìÂá∫ÊµÅÁöÑÊó∂ÂÄô‰º†ÂÖ•Â∏∏Èáè0Âç≥ÂèØ. Êúâ‰∫ÜÊñá‰ª∂ËæìÂá∫ÊµÅ, ÂèØ‰ª•ÂΩìÁΩëÁªú‰∏ãËΩΩÂõæÁâáÊó∂, ÂõæÁâáÂ∞±ÂèØ‰ª•ÈÄöËøáËøô‰∏™Êñá‰ª∂ËæìÂá∫ÊµÅÂÜôÂÖ•Âà∞Êñá‰ª∂Á≥ªÁªü‰∏ä. Âà´Âøò‰∫Ü‰ΩøÁî®BufferedxxxxxÂÜôÂÆå‰πãÂêé, Ë¶ÅÈÄöËøáEditor‰∏≠commit()Êù•Êèê‰∫§ÂÜôÊìç‰Ωú, Â¶ÇÊûú‰∏ãËΩΩ‰∏≠ÂèëÁîüÂºÇÂ∏∏, ÈÇ£‰πà‰ΩøÁî®Editor‰∏≠abort()Êù•ÂõûÈÄÄÊï¥‰∏™Êìç‰Ωú. 3. DiskLruCacheÁöÑÁºìÂ≠òÊü•Êâæ ÂíåÁºìÂ≠òÁöÑÊ∑ªÂä†ËøáÁ®ãÁ±ª‰ºº, ÁºìÂ≠òÊü•ÊâæËøáÁ®ã‰πüÈúÄË¶ÅÂ∞ÜurlËΩ¨Êç¢Êàêkey, ÁÑ∂ÂêéÈÄöËøáDiskLruCache#get()ÊñπÊ≥ïÂèØ‰ª•ÂæóÂà∞‰∏Ä‰∏™SnapshotÂØπË±°, Êé•ÁùÄÂú®ÈÄöËøáSnapshotÂØπË±°Âç≥ÂèØÂæóÂà∞ÁºìÂ≠òÁöÑÊñá‰ª∂ËæìÂÖ•ÊµÅ, Êúâ‰∫ÜÊñá‰ª∂ËæìÂÖ•ÊµÅ, Ëá™ÁÑ∂Â∞±ÂèØ‰ª•ÂæóÂà∞BitmapÂØπË±°. ‰∏∫‰∫ÜÈÅøÂÖçÂä†ËΩΩÂõæÁâáÂá∫Áé∞OOMÊâÄ‰ª•ÈááÁî®ÂéãÁº©ÁöÑÊñπÂºè. Âú®ÂâçÈù¢ÂØπBitmapFactory.OptionsÁöÑ‰ΩøÁî®ËØ¥Êòé‰∫Ü. ‰ΩÜÊòØËøô‰∏≠ÊñπÊ≥ïÂØπFileInputStreamÁöÑÁº©ÊîæÂ≠òÂú®ÈóÆÈ¢ò. ÂéüÂõ†ÊòØFileInputStreamÊòØ‰∏ÄÁßçÊúâÂ∫èÁöÑÊñá‰ª∂ÊµÅ, ËÄå‰∏§Ê¨°decodeStreamË∞ÉÁî®‰ºöÂΩ±ÂìçÊñá‰ª∂ÁöÑ‰ΩçÁΩÆÂ±ûÊÄß, ËøôÊ†∑Âú®Á¨¨‰∫åÊ¨°decodeStreamÁöÑÊó∂ÂÄôÂæóÂà∞ÁöÑ‰ºöÊòØnull. ÈíàÂØπËøô‰∏Ä‰∏™ÈóÆÈ¢ò, ÂèØ‰ª•ÈÄöËøáÊñá‰ª∂ÊµÅÊù•ÂæóÂà∞ÂÆÉÊâÄÂØπÂ∫îÁöÑÊñá‰ª∂ÊèèËø∞Á¨¶, ÁÑ∂ÂêéÈÄöËøáBitmapFactory.decodeFileDescription()Êù•Âä†ËΩΩ‰∏ÄÂº†Áº©ÊîæÂêéÁöÑÂõæÁâá. ImageLoaderÁöÑÂÆûÁé∞‰∏Ä‰∏™Â•ΩÁöÑImageLoaderÂ∫îËØ•ÂÖ∑Â§á‰ª•‰∏ãÂá†ÁÇπ: ÂõæÁâáÁöÑÂéãÁº© ÁΩëÁªúÊãâÂèñ ÂÜÖÂ≠òÁºìÂ≠ò Á£ÅÁõòÁºìÂ≠ò ÂõæÁâáÁöÑÂêåÊ≠•Âä†ËΩΩ ÂõæÁâáÁöÑÂºÇÊ≠•Âä†ËΩΩ ‰πüÂèØ‰ª•Âà©Áî®picassoÂíåglideËøôÁßçÂõæÁâáÂä†ËΩΩÁ±ªÂ∫ì, ‰ΩøÁî®ÊûÑÂª∫ËÄÖÊ®°ÂºèÊèê‰æõ‰ΩøÁî®. Êú¨ÊñáÁªÉ‰π†demoÂÆûÁé∞‰∫ÜÈìæÂºèË∞ÉÁî®ËÆæÁΩÆÊéß‰ª∂,Âπ∂Âà∂ÂÆöurlÁÑ∂ÂêéËá™Âä®ÂéªËé∑Âèñ. Áõ∏ÂÖ≥ËÅîÁöÑÁ±ªÂú®loadÂåÖ‰∏≠ ÂèØ‰ª•ÁúãÁúãÊúâ‰∫ÜÁºìÂ≠òÁöÑÂå∫Âà´ ImageLoaderÁöÑ‰ΩøÁî®ÁÖßÁâáÂ¢ôÊïàÊûúËøôÈáåÂÆö‰πâ‰∏Ä‰∏™Ëá™ÂÆö‰πâÁöÑImageView‰Ωú‰∏∫GridViewÁöÑitemÂ∏ÉÂ±ÄÊéß‰ª∂, ‰πãÊâÄ‰ª•ËøôÊ†∑ÊòØÊÉ≥ËÆ©ÂõæÁâáÁöÑÊéß‰ª∂Ëá™Âä®Âéª‰ΩøÁî®ËÆæÂ§áËææÂà∞ÂÆΩÈ´òÁõ∏Á≠âÁöÑÊïàÊûúÊØîËæÉÂ•ΩÁúã‰∫õ 1234567891011121314151617181920public class SquareImageView extends ImageView &#123; public SquareImageView(Context context) &#123; super(context); &#125; public SquareImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // Áî±‰∫éËøôÈáåÂáÜÂ§áÊèê‰æõÁªôGridViewÊéß‰ª∂‰ΩøÁî®, ÂØπ‰∫é‰∏Ä‰∏™Ê∞¥Âπ≥Á∫øÊúâÂá†‰∏™ÊòØÊú™Áü•ÁöÑ // ÈÇ£‰πàÈÄöËøáÁà∂Êéß‰ª∂ÁöÑÊµãÈáè‰º†Âà∞ËøôÈáåÁöÑÂÆΩÂ∫¶ËßÑÊ†º, ‰πüÂΩìÂÅöÈ´òÂ∫¶Âç≥ÂèØ super.onMeasure(widthMeasureSpec, widthMeasureSpec); &#125;&#125; Ëøô‰∏™ÂÆûÁé∞ÂæàÁÆÄÂçï, Âà©Áî®Âä®ÊÄÅÁöÑÂÆΩÂ∫¶ÂêåÊó∂‰πüÂΩìÂÅöÈ´òÂ∫¶Âç≥ÂèØÂÆûÁé∞È¢ÑÊúüÁöÑÊïàÊûú. Ëøô‰∏™Â∞±ÊòØÁªìÊûú, ÊàñËÆ∏Â∫îËØ•ÂØπÁΩëÁªúÂä†‰∏äÂà§Êñ≠ÈùûwifiÁªô‰∏Ä‰∏™ÊèêÁ§∫, ÂèØËÉΩÈ¶ñÊ¨°Âä†ËΩΩ‰ºöÈúÄË¶ÅÊØîËæÉÂ§öÁöÑÊµÅÈáè. 1234567891011121314151617181920212223242526272829303132333435 // Ê†πÊçÆËøûÊé•ÁΩëÁªúÁöÑÊÉÖÂÜµÂà§Êñ≠ÊòØÂê¶Âä†ËΩΩÂõæÁâáif (!NetWorkUtil.isWifi(getApplicationContext())) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage("È¶ñÊ¨°‰ΩøÁî®‰ºö‰ªéÊâãÊú∫ÁΩëÁªú‰∏ãËΩΩÂõæÁâá, ÊòØÂê¶Á°ÆËÆ§‰∏ãËΩΩ?") .setTitle("ÂèãÊÉÖÊèêÁ§∫") .setPositiveButton("Â•ΩÁöÑ.", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; mCanLoadForPhoneNet = true; imageAdapter.notifyDataSetChanged(); &#125; &#125;) .setNegativeButton("‰∏çË°å!", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(getApplicationContext(), "ÁûÖ‰Ω†Êâ£ÈÇ£Ê†∑!!!", Toast.LENGTH_LONG).show(); &#125; &#125;).show();&#125;else&#123; mCanLoadForPhoneNet = true;&#125;// NetWorkUtilÁ±ªpublic class NetWorkUtil &#123; public static boolean isWifi(Context context) &#123; ConnectivityManager connectivityManager = (ConnectivityManager) context .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetInfo = connectivityManager.getActiveNetworkInfo(); if (activeNetInfo != null &amp;&amp; activeNetInfo.getType() == ConnectivityManager.TYPE_WIFI) &#123; return true; &#125; return false; &#125;&#125; ÁÑ∂Âêé‰ºòÂåñÂàóË°® Âè™ÊúâÂú®GridViewÈùôÊ≠¢ÁöÑÊó∂ÂÄôÊâçËøõË°åÂõæÁâáÂä†ËΩΩ, ÈÅøÂÖçÊªëÂä®Êó∂ÂÄôÁöÑÊó†Ë∞ìÁöÑÁ∫øÁ®ãÂä†ËΩΩÊ∂àËÄó(Âç≥‰ΩøImageLoaderÂÜÖÈÉ®‰ΩøÁî®‰∫ÜÁ∫øÁ®ãÊ±†, ‰Ω†‰ªçÁÑ∂ÊúâËøô‰πàÂÅöÁöÑÂøÖË¶Å) 12345678910111213141516171819GridView gv_main = (GridView) findViewById(R.id.gv_main);// ÁõëÂê¨GridViewÁöÑÊªëÂä®Áä∂ÊÄÅ gv_main.setOnScrollListener(new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE)&#123; mIsGridViewIdle = true; // Âπ∂Ëß¶ÂèëÊõ¥Êñ∞adapter imageAdapter.notifyDataSetChanged(); &#125;else&#123; mIsGridViewIdle = false; &#125; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; &#125; &#125;); ÊúÄÂêéÂú®adapter‰∏≠ÁöÑgetView()ËÆæÁΩÆÊ†áËÆ∞‰ΩçÁöÑÂà§Êñ≠, Âè™ÊúâÂú®wifiÂíåÈùôÊ≠¢ÁöÑÁä∂ÊÄÅ‰∏ãÊâçËøõË°åÂä†ËΩΩËØ∑Ê±Ç‰∏ãÈù¢ÊòØgetView()‰ª£Á†Å 123456789101112131415161718192021222324252627@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null)&#123; convertView = View.inflate(mContext, R.layout.item_photo_wall, null); holder = new ViewHolder(); holder.mImageView = (ImageView) convertView.findViewById(R.id.iv_square); convertView.setTag(holder); &#125;else&#123; holder = (ViewHolder) convertView.getTag(); &#125; // ËÆæÁΩÆÈªòËÆ§ÂõæÁâá ImageView mImageView = holder.mImageView; mImageView.setImageResource(android.R.drawable.screen_background_dark_transparent); // Ê£ÄÊµãÊòØÂê¶wifi Âíå ÊòØÂê¶ÊòØÊªëÂä®Áä∂ÊÄÅ // ‰ºòÂåñÈáçÁÇπ if (mCanLoadForPhoneNet &amp;&amp; mIsGridViewIdle)&#123; // Âä†ËΩΩÂõæÁâá mImageLoader.setImageView(mImageView).url(mUrls.get(position)); &#125; return convertView;&#125;]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
        <tag>ÂõæÁâáÁºìÂ≠ò</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FutureTask & Callable]]></title>
    <url>%2F2018%2F03%2F19%2FCallable%E5%92%8CFutureTask%2F</url>
    <content type="text"><![CDATA[Âú®ÈòÖËØªAsyncTaskÊ∫êÁ†ÅÊó∂ÂÄôÔºåÊúâÁúãÂà∞FutureTaskÁöÑÊ¶ÇÂøµÔºåÂΩìÊó∂Âè™Áü•ÈÅìÂÆÉ‰∏éÁ∫øÁ®ãÂàõÂª∫ÊúâÂÖ≥Á≥ª„ÄÇ‰ªäÂ§©Êù•Êé¢Á©∂‰∏Ä‰∏ãÂÆÉÁöÑÊ∫êÁ†ÅÁªìÊûÑ„ÄÇ ÂêåÊó∂‰πüÊúâ‰∏Ä‰∫õÈù¢ËØïÈ¢òÔºåËØ¢ÈóÆJava‰∏≠ÂàõÂª∫Á∫øÁ®ãÁöÑÂá†ÁßçÊñπÂºèÔºåÈô§‰∫ÜThreadÂíåRunnable‰πãÂ§ñÔºåÊèêÂà∞‰∫ÜCallableÁöÑÊ¶ÇÂøµ„ÄÇÊú¨ÊñáÈáçÁÇπÂàÜÊûê‰∏Ä‰∏ãËøô‰∏§‰∏™Ê¶ÇÂøµÁöÑÁî®Ê≥ï„ÄÇ RunnableÁÇπËøõÂéªÁúã‰∏Ä‰∏ãRunnableÊé•Âè£ÁöÑÂÆö‰πâÔºö 1234 @FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; RunnableÁöÑ‰ª£Á†ÅÈùûÂ∏∏ÁÆÄÂçïÔºåÂÆÉÊòØ‰∏Ä‰∏™Êé•Âè£‰∏îÂè™Êúâ‰∏Ä‰∏™run()ÔºåÂàõÂª∫‰∏Ä‰∏™Á±ªÂÆûÁé∞ÂÆÉÔºåÊää‰∏Ä‰∫õË¥πÊó∂Êìç‰ΩúÂÜôÂú®ÂÖ∂‰∏≠ÔºåÁÑ∂Âêé‰ΩøÁî®Êüê‰∏™Á∫øÁ®ãÂéªÊâßË°åËØ•RunnableÂÆûÁé∞Á±ªÂç≥ÂèØÂÆûÁé∞Â§öÁ∫øÁ®ã„ÄÇ CallableË∑üÁùÄIDE‰∏≠ÁöÑÊ∫êÁ†ÅËøõÂÖ•Âà∞CallableÁöÑÂ£∞Êòé‰∏≠‰∫ÜËß£‰∏Ä‰∏ãÂÖ∂ÁªìÊûÑÔºö 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; CallableÁöÑ‰ª£Á†Å‰πüÈùûÂ∏∏ÁÆÄÂçïÔºå‰∏çÂêåÁöÑÊòØÂÆÉÊòØ‰∏Ä‰∏™Ê≥õÂûãÊé•Âè£Ôºåcall()ÂáΩÊï∞ËøîÂõûÁöÑÁ±ªÂûãÂ∞±ÊòØÂàõÂª∫Callable‰º†ËøõÊù•ÁöÑVÁ±ªÂûã„ÄÇCallable‰∏éRunnableÁöÑÂäüËÉΩÂ§ßËá¥Áõ∏‰ººÔºåÂîØ‰∏ÄÁöÑÂå∫Âà´ÊòØCallableÂú®Á∫øÁ®ãÊâßË°åÂÆåÂêéÔºåÂèØ‰ª•ËøîÂõûÂÄºÔºåÂπ∂‰∏îËÉΩÊäõÂá∫ÂºÇÂ∏∏„ÄÇ FutureFutureÊ†πÊçÆÊ∫ê‰ª£Á†ÅËß£ÈáäÂÖ∂‰ΩúÁî®ÊòØÂØπCallableÊàñËÄÖRunnableËøõË°åÁÆ°ÁêÜÔºåÂèñÊ∂à„ÄÅÊ£ÄÊµãÂÆåÊàê‰∏éÂê¶Ëé∑ÂèñÊúÄÁªàÁªìÊûúÁ≠â„ÄÇ 123456789public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; cancelÊñπÊ≥ïÁî®Êù•ÂèñÊ∂à‰ªªÂä°ÔºåÂ¶ÇÊûúÂèñÊ∂à‰ªªÂä°ÊàêÂäüÂàôËøîÂõûtrueÔºåÂ¶ÇÊûúÂèñÊ∂à‰ªªÂä°Â§±Ë¥•ÂàôËøîÂõûfalse„ÄÇÂèÇÊï∞mayInterruptIfRunningË°®Á§∫ÊòØÂê¶ÂÖÅËÆ∏ÂèñÊ∂àÊ≠£Âú®ÊâßË°åÂç¥Ê≤°ÊúâÊâßË°åÂÆåÊØïÁöÑ‰ªªÂä°ÔºåÂ¶ÇÊûúËÆæÁΩÆtrueÔºåÂàôË°®Á§∫ÂèØ‰ª•ÂèñÊ∂àÊ≠£Âú®ÊâßË°åËøáÁ®ã‰∏≠ÁöÑ‰ªªÂä°„ÄÇÂ¶ÇÊûú‰ªªÂä°Â∑≤ÁªèÂÆåÊàêÔºåÂàôÊó†ËÆ∫mayInterruptIfRunning‰∏∫trueËøòÊòØfalseÔºåÊ≠§ÊñπÊ≥ïËÇØÂÆöËøîÂõûfalseÔºåÂç≥Â¶ÇÊûúÂèñÊ∂àÂ∑≤ÁªèÂÆåÊàêÁöÑ‰ªªÂä°‰ºöËøîÂõûfalseÔºõÂ¶ÇÊûú‰ªªÂä°Ê≠£Âú®ÊâßË°åÔºåËã•mayInterruptIfRunningËÆæÁΩÆ‰∏∫trueÔºåÂàôËøîÂõûtrueÔºåËã•mayInterruptIfRunningËÆæÁΩÆ‰∏∫falseÔºåÂàôËøîÂõûfalseÔºõÂ¶ÇÊûú‰ªªÂä°ËøòÊ≤°ÊúâÊâßË°åÔºåÂàôÊó†ËÆ∫mayInterruptIfRunning‰∏∫trueËøòÊòØfalseÔºåËÇØÂÆöËøîÂõûtrue„ÄÇ isCancelledÊñπÊ≥ïË°®Á§∫‰ªªÂä°ÊòØÂê¶Ë¢´ÂèñÊ∂àÊàêÂäüÔºåÂ¶ÇÊûúÂú®‰ªªÂä°Ê≠£Â∏∏ÂÆåÊàêÂâçË¢´ÂèñÊ∂àÊàêÂäüÔºåÂàôËøîÂõû true„ÄÇ isDoneÊñπÊ≥ïË°®Á§∫‰ªªÂä°ÊòØÂê¶Â∑≤ÁªèÂÆåÊàêÔºåËã•‰ªªÂä°ÂÆåÊàêÔºåÂàôËøîÂõûtrueÔºõ get()ÊñπÊ≥ïÁî®Êù•Ëé∑ÂèñÊâßË°åÁªìÊûúÔºåËøô‰∏™ÊñπÊ≥ï‰ºö‰∫ßÁîüÈòªÂ°ûÔºå‰ºö‰∏ÄÁõ¥Á≠âÂà∞‰ªªÂä°ÊâßË°åÂÆåÊØïÊâçËøîÂõûÔºõ get(long timeout, TimeUnit unit) Ëé∑ÂèñÂºÇÊ≠•ÊâßË°åÁªìÊûúÔºåÂ¶ÇÊûúÊ≤°ÊúâÁªìÊûúÂèØÁî®ÔºåÊ≠§ÊñπÊ≥ï‰ºöÈòªÂ°ûÔºå‰ΩÜÊòØ‰ºöÊúâÊó∂Èó¥ÈôêÂà∂ÔºåÂ¶ÇÊûúÈòªÂ°ûÊó∂Èó¥Ë∂ÖËøáËÆæÂÆöÁöÑtimeoutÊó∂Èó¥ÔºåËØ•ÊñπÊ≥ïÂ∞ÜÊäõÂá∫ÂºÇÂ∏∏„ÄÇ ‚Äã FutureÂíåCallableÁöÑÂü∫Êú¨Áî®Ê≥ï123456789101112131415161718192021class MyCallable implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; System.out.println("ÂÅö‰∏Ä‰∫õËÄóÊó∂ÁöÑ‰ªªÂä°..."); Thread.sleep(5000); return "OK"; &#125;&#125;public class FutureSimpleDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable()); System.out.println("dosomething..."); System.out.println("ÂæóÂà∞ÂºÇÊ≠•‰ªªÂä°ËøîÂõûÁªìÊûúÔºö" + future.get()); System.out.println("Completed!"); &#125;&#125; ‰∏äÈù¢ÊòØFutureÂü∫Êú¨Áî®Ê≥ïÁöÑ‰ª£Á†Å‰ª•ÂèäÂπ∂ËøêË°åÔºåÊàë‰ª¨ÂèØ‰ª•Áü•ÈÅìÔºö Á∫øÁ®ãÊòØÂ±û‰∫éÂºÇÊ≠•ËÆ°ÁÆóÊ®°ÂûãÔºåÊâÄ‰ª•‰Ω†‰∏çÂèØËÉΩÁõ¥Êé•‰ªéÂà´ÁöÑÁ∫øÁ®ã‰∏≠ÂæóÂà∞ÊñπÊ≥ïËøîÂõûÂÄº„ÄÇ ËøôÊó∂ÂÄôÔºåFutureÂ∞±Âá∫Âú∫‰∫Ü„ÄÇ FutrueÂèØ‰ª•ÁõëËßÜÁõÆÊ†áÁ∫øÁ®ãË∞ÉÁî®callÁöÑÊÉÖÂÜµÔºåÂΩì‰Ω†Ë∞ÉÁî®FutureÁöÑget()ÊñπÊ≥ï‰ª•Ëé∑ÂæóÁªìÊûúÊó∂ÔºåÂΩìÂâçÁ∫øÁ®ãÂ∞±ÂºÄÂßãÈòªÂ°ûÔºåÁõ¥Êé•callÊñπÊ≥ïÁªìÊùüËøîÂõûÁªìÊûú„ÄÇ FutureÂºïÁî®ÂØπË±°ÊåáÂêëÁöÑÂÆûÈôÖÊòØFutureTask„ÄÇ ‰πüÂ∞±ÊòØËØ¥ÔºåÊÄªÁªì‰∏ÄÂè•ËØùÔºåFutureÂèØ‰ª•ÂæóÂà∞Âà´ÁöÑÁ∫øÁ®ã‰ªªÂä°ÊñπÊ≥ïÁöÑËøîÂõûÂÄº„ÄÇ FutureTaskÊé•‰∏ãÊù•ÈáçÁÇπÁúã‰∏Ä‰∏ãÁ§∫‰æã‰∏≠taskÁöÑÂåÖË£ÖÁ±ªFutureTask„ÄÇÂ¶Ç‰∏ãÊâÄÁ§∫ÂèëÁé∞RutureTaskÊòØÂÆûÁé∞RunnableFutureÊé•Âè£ÁöÑ‰∏Ä‰∏™Á±ªÔºö 1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; ËÄåËøô‰∏™RunnableFutureÊé•Âè£ÁªìÊûÑÔºö 1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; FutureTaskÊûÑÈÄ†ÊñπÊ≥ï 123456public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; 1234public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; Âú®ËøôÈáåÊàë‰ª¨ÂèØ‰ª•‰∫ÜËß£Âà∞Ôºö FutureTaskÊúÄÁªàÈÉΩÊòØÊâßË°åCallableÁ±ªÂûãÁöÑ‰ªªÂä°„ÄÇ Â¶ÇÊûúÊûÑÈÄ†ÂáΩÊï∞ÂèÇÊï∞ÊòØRunnableÔºå‰ºöË¢´Executors.callableÊñπÊ≥ïËΩ¨Êç¢‰∏∫CallableÁ±ªÂûã„ÄÇ Êé•‰∏ãÊù•Êàë‰ª¨ÁúãÁúãExecutors.callableÊñπÊ≥ï‰ª£Á†Å 12345public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125; ‰ª£Á†ÅÂæàÁÆÄÂçïÔºåÁõ¥Êé•ËøîÂõû‰∏Ä‰∏™RunnableAdapterÂÆû‰æã„ÄÇ Êé•‰∏ãÊù•Êàë‰ª¨ÁúãÁúãRunnableAdapterÊñπÊ≥ï‰ª£Á†Å 123456789101112131415/** * A callable that runs given task and returns given result */static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125;&#125; ÂèØ‰ª•‰∫ÜËß£Âà∞Ôºö RunnableAdapterÊòØExcutorsÁöÑ‰∏Ä‰∏™ÈùôÊÄÅÂÜÖÈÉ®Á±ªÂπ∂‰∏îÂÆûÁé∞‰∫ÜCallableÔºå‰πüÂ∞±ÊòØËØ¥RunnableAdapterÊòØCallableÂ≠êÁ±ª„ÄÇ callÊñπÊ≥ïÂÆûÁé∞‰ª£Á†ÅÊòØÔºåÊâßË°åRunnableÁöÑrunÊñπÊ≥ïÔºåÂπ∂ËøîÂõûÊûÑÈÄ†FutureTask‰º†ÂÖ•resultÂèÇÊï∞„ÄÇ FutureTaskÊÄªÁªìFutureTaskÂÆûÁé∞‰∫Ü‰∏§‰∏™Êé•Âè£ÔºåRunnableÂíåFutureÔºåÊâÄ‰ª•ÂÆÉÊó¢ÂèØ‰ª•‰Ωú‰∏∫RunnableË¢´Á∫øÁ®ãÊâßË°åÔºåÂèàÂèØ‰ª•‰Ωú‰∏∫FutureÂæóÂà∞CallableÁöÑËøîÂõûÂÄºÔºåÈÇ£‰πàËøô‰∏™ÁªÑÂêàÁöÑ‰ΩøÁî®Êúâ‰ªÄ‰πàÂ•ΩÂ§ÑÂë¢ÔºüÂÅáËÆæÊúâ‰∏Ä‰∏™ÂæàË¥πÊó∂ÈÄªËæëÈúÄË¶ÅËÆ°ÁÆóÂπ∂‰∏îËøîÂõûËøô‰∏™ÂÄºÔºåÂêåÊó∂Ëøô‰∏™ÂÄº‰∏çÊòØÈ©¨‰∏äÈúÄË¶ÅÔºåÈÇ£‰πàÂ∞±ÂèØ‰ª•‰ΩøÁî®Ëøô‰∏™ÁªÑÂêàÔºåÁî®Âè¶‰∏Ä‰∏™Á∫øÁ®ãÂéªËÆ°ÁÆóËøîÂõûÂÄºÔºåËÄåÂΩìÂâçÁ∫øÁ®ãÂú®‰ΩøÁî®Ëøô‰∏™ËøîÂõûÂÄº‰πãÂâçÂèØ‰ª•ÂÅöÂÖ∂ÂÆÉÁöÑÊìç‰ΩúÔºåÁ≠âÂà∞ÈúÄË¶ÅËøô‰∏™ËøîÂõûÂÄºÊó∂ÔºåÂÜçÈÄöËøáFutureÂæóÂà∞ÔºÅ FutureTaskÂü∫Êú¨Áî®Ê≥ï 12345678910111213141516171819public class CallableAndFuture &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; public Integer call() throws Exception &#123; return new Random().nextInt(100); &#125; &#125;; FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable); new Thread(future).start(); try &#123; Thread.sleep(3000);// ‰∏ªÁ∫øÁ®ãÂèØËÉΩÂÅö‰∏Ä‰∫õ‰∫ãÊÉÖ System.out.println(future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ÁªìÂêàÁ∫øÁ®ãÊ±†‰ΩøÁî®12345678910111213141516171819202122232425262728293031323334public class FutureTaskDemo &#123; public static void main(String[] args) &#123; // ÂàõÂª∫‰∏Ä‰∏™ExecutorServiceÂØπË±° ExecutorService executor = Executors.newCachedThreadPool(); // new ‰∏Ä‰∏™CallableÂÆû‰æã Task task = new Task(); // new‰∏Ä‰∏™ FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task); // Êèê‰∫§futureTaskÂØπË±°ËøõÂÖ•Á∫øÁ®ãÊ±† executor.submit(futureTask); // ÂÖ≥Èó≠Á∫øÁ®ãÊ±† executor.shutdown(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println("‰∏ªÁ∫øÁ®ãÂú®ÊâßË°å‰ªªÂä°"); try &#123; // Ëé∑ÂèñfuturetaskÁªìÊûú System.out.println("taskËøêË°åÁªìÊûú" + futureTask.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println("ÊâÄÊúâ‰ªªÂä°ÊâßË°åÂÆåÊØï"); &#125;&#125; ÂêåÊó∂ÂÆö‰πâ‰∏Ä‰∏™ÂÆûÁé∞CallableÊé•Âè£ÁöÑTaskÁ±ªÂ¶Ç‰∏ãÊâÄÁ§∫Ôºö 1234567891011public static class Task implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println("Â≠êÁ∫øÁ®ãÂú®ËøõË°åËÆ°ÁÆó"); Thread.sleep(3000); int sum = 0; for (int i = 0; i &lt; 100; i++) sum += i; return sum; &#125; &#125; ÁªìÊûúËæìÂá∫Ôºö 1234Â≠êÁ∫øÁ®ãÂú®ËøõË°åËÆ°ÁÆó‰∏ªÁ∫øÁ®ãÂú®ÊâßË°å‰ªªÂä°taskËøêË°åÁªìÊûú4950ÊâÄÊúâ‰ªªÂä°ÊâßË°åÂÆåÊØï ‰ªéFutureTaskÁî®Ê≥ï‰ª•ÂèäËøîÂõûÁöÑÁªìÊûúÂèØËßÅFutureTaskÊòØÂèØ‰ª•ÂéªÊâßË°åCallableÁöÑÔºåÂπ∂‰∏îCallableÁã¨Á´ãÁöÑÁ∫øÁ®ãÂèØ‰ª•ËøîÂõûËá™Â∑±ÁöÑÊâßË°åÁªìÊûú„ÄÇ]]></content>
      <categories>
        <category>Â§öÁ∫øÁ®ã</category>
      </categories>
      <tags>
        <tag>Callable</tag>
        <tag>FutureTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidÁöÑÁ∫øÁ®ãÂíåÁ∫øÁ®ãÊ±†]]></title>
    <url>%2F2018%2F03%2F15%2FAndroid%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[Á¨¨11Á´†: ‰∏ç‰ªÖ‰ªÖÊòØÂú®Android‰∏≠, Â∞±ÁÆójava‰∏≠Á∫øÁ®ãÈÉΩÊòØ‰∏ÄÂùóÂæàÈáçË¶ÅÁöÑÁü•ËØÜ, Âç†Êúâ‰∏çÂ∞èÁöÑÊØîÈáç. Èô§‰∫ÜÊúÄÂ∏∏‰ΩøÁî®ÁöÑThread‰πãÂ§ñ, Âú®Android‰πã‰∏≠ÂèØ‰ª•ÊâÆÊºîÁ∫øÁ®ãËßíËâ≤ÁöÑËøòÊúâÂæàÂ§ö: Â¶ÇAsyncTaskÂíåIntentService, ÂêåÊó∂HandlerThread‰πüÊòØ‰∏ÄÁßçÁâπÊÆäÁöÑÁ∫øÁ®ã. ËôΩÁÑ∂Ëøô‰∫õÁ∫øÁ®ãÁöÑË°®Áé∞ÂΩ¢ÂºèÊúâÂà´‰∫éÂü∫Á°ÄÁ∫øÁ®ã. ‰ΩÜÊòØÊú¨Ë¥®‰∏äËøòÊòØ‰º†ÁªüÁöÑÁ∫øÁ®ã. ‰æãÂ¶ÇAsyncTaskÂÆÉÁöÑÂ∫ïÂ±Ç‰ΩøÁî®‰∫ÜÁ∫øÁ®ãÊ±†. ËÄåÂØπ‰∫éIntentServiceÂíåHandlerThreadÊù•ËØ¥, ‰ªñ‰ª¨ÁöÑÂ∫ïÂ±ÇÂàôÁõ¥Êé•‰ΩøÁî®‰∫ÜÁ∫øÁ®ã. Ê†πÊçÆ‰∏çÂêåÁöÑÁâπÊÄßÊù•ÂÆûÁé∞‰∏çÂêåÁöÑÂú∫ÊôØ AsyncTask: Â∞ÅË£Ö‰∫ÜÁ∫øÁ®ãÊ±†ÂíåHandler, ÂÆÉ‰∏ªË¶ÅÊòØ‰∏∫‰∫ÜÊñπ‰æøÂºÄÂèëËÄÖÂú®Â≠êÁ∫øÁ®ã‰∏≠Êõ¥Êñ∞UI. HandlerThread: ÊòØ‰∏ÄÁßçÂÖ∑ÊúâÊ∂àÊÅØÂæ™ÁéØÁöÑÁ∫øÁ®ã, Âú®ÂÆÉÁöÑÂÜÖÈÉ®ÂèØ‰ª•‰ΩøÁî®Handler. IntentService: ÊòØ‰∏Ä‰∏™ÊúçÂä°, Á≥ªÁªüÂØπÂÖ∂ËøõË°å‰∫ÜÂ∞ÅË£Ö‰ΩøÂÖ∂ÂèØ‰ª•Êõ¥Êñπ‰æøÂú∞ÊâßË°åÂêéÂè∞‰ªªÂä°, IntentServiceÂÜÖÈÉ®ÈááÁî®‰∫ÜHandlerThreadÊù•ÊâßË°å‰ªªÂä°, ÂΩì‰ªªÂä°ÊâßË°åÂÆåÊØïÂêéIntentService‰ºöËá™Âä®ÈÄÄÂá∫. ‰ªéÊâßË°å‰ªªÂä°ÁöÑËßíÂ∫¶Êù•Áúã, Êõ¥ÂÉè‰∏Ä‰∏™ÂêéÂè∞ÁöÑÁ∫øÁ®ã. ‰ΩÜÊòØÂõ†‰∏∫ÂÖ∂Êú¨Ë∫´ÊòØ‰∏ÄÁßçÊúçÂä°, ÊâÄ‰ª•ÂØºËá¥‰∏çÂÆπÊòìË¢´Á≥ªÁªüÊùÄÊ≠ª‰ªéËÄå‰øùËØÅ‰ªªÂä°ÁöÑÊâßË°å. ËÄåÂ¶ÇÊûúÊòØ‰∏Ä‰∏™ÂêéÂè∞Á∫øÁ®ã, Áî±‰∫éËøô‰∏™Êó∂ÂÄôËøõË°å‰∏≠Ê≤°ÊúâÊ¥ªÂä®ÁöÑÂõõÂ§ßÁªÑ‰ª∂, ÈÇ£‰πàËøô‰∏™ËøõÁ®ãÁöÑ‰ºòÂÖàÁ∫ß‰ºöÂæà‰Ωé, ÂæàÂÆπÊòìË¢´Á≥ªÁªüÊùÄÊ≠ª, ËøôÂ∞±ÊòØIntentServiceÁöÑ‰ºòÁÇπ. Á∫øÁ®ãÁöÑÁÆÄÂçïÊ¶ÇËø∞ Âú®Êìç‰ΩúÁ≥ªÁªü‰∏≠, Á∫øÁ®ãÊòØÊìç‰ΩúÁ≥ªÁªüË∞ÉÂ∫¶ÁöÑÊúÄÂ∞èÂçïÂÖÉ, ÂêåÊó∂Á∫øÁ®ãÂèàÊòØ‰∏ÄÁßçÂèóÈôêÁöÑÁ≥ªÁªüËµÑÊ∫ê, Âç≥Á∫øÁ®ã‰∏çÂèØËÉΩÊó†ÈôêÂà∂ÁöÑ‰∫ßÁîü, Âπ∂‰∏îÁ∫øÁ®ãÁöÑÂàõÂª∫ÂíåÈîÄÊØÅÈÉΩ‰ºöÊúâÁõ∏Â∫îÁöÑÂºÄÈîÄ. ÂΩìÁ≥ªÁªü‰∏≠Â≠òÂú®Â§ßÈáèÁöÑÁ∫øÁ®ãÊó∂, Á≥ªÁªü‰ºöÈÄöËøáÊó∂Èó¥ÁâáËΩ¨ËΩÆÁöÑÊñπÂºèË∞ÉÂ∫¶ÊØè‰∏™Á∫øÁ®ã, Âõ†Ê≠§Á∫øÁ®ã‰∏çÂèØËÉΩÂÅöÂà∞ÁªùÂØπÁöÑÂπ∂Ë°å, Èô§ÈùûÁ∫øÁ®ãÊï∞ÈáèÂ∞è‰∫éÁ≠â‰∫écpuÁöÑÊ†∏ÂøÉÊï∞. ‰ΩÜËøôÁßçÊÉÖÂÜµÂ§™Â∞ë‰∫Ü, ÊâÄ‰ª•Á∫øÁ®ãÊ±†ÁöÑÊ¶ÇÂøµÂ∞±Áî±Ê≠§Âá∫Áé∞. ÈÄöËøáÁ∫øÁ®ãÊ±†Â∞±ÂèØ‰ª•ÈÅøÂÖçÂõ†‰∏∫È¢ëÁπÅÂàõÂª∫ÂíåÈîÄÊØÅÁ∫øÁ®ãÊâÄÂ∏¶Êù•ÁöÑÁ≥ªÁªüÂºÄÈîÄ. ‰∏ªÁ∫øÁ®ãÂíåÂ≠êÁ∫øÁ®ã‰∏ªÁ∫øÁ®ãÊòØÊåáËøõÁ®ãÊâÄÊã•ÊúâÁöÑÁ∫øÁ®ã, Âú®Java‰∏≠ÈªòËÆ§ÊÉÖÂÜµ‰∏ã‰∏Ä‰∏™ËøõÁ®ãÂè™Êúâ‰∏Ä‰∏™Á∫øÁ®ã, Ëøô‰∏™Á∫øÁ®ãÂ∞±ÊòØ‰∏ªÁ∫øÁ®ã. ‰∏ªÁ∫øÁ®ã‰∏ªË¶ÅÂ§ÑÁêÜÁïåÈù¢‰∫§‰∫íÁõ∏ÂÖ≥ÁöÑÈÄªËæë, Âõ†‰∏∫Áî®Êà∑ÈöèÊó∂‰ºöÂíåÁïåÈù¢ÂèëÁîü‰∫§‰∫í, Âõ†Ê≠§‰∏ªÁ∫øÁ®ãÂú®‰ªª‰ΩïÊó∂ÂÄôÈÉΩÂøÖÈ°ªÊúâËæÉÈ´òÁöÑÂìçÂ∫îÈÄüÂ∫¶, Âê¶ÂàôÂ∞±‰ºö‰∫ßÁîü‰∏ÄÁßçÁïåÈù¢Âç°È°øÁöÑÊÑüËßâ. ‰∏∫‰∫Ü‰øùÊåÅËæÉÈ´òÁöÑÂìçÂ∫îÈÄüÂ∫¶, ËøôÂ∞±Ë¶ÅÊ±Ç‰∏ªÁ∫øÁ®ã‰∏≠‰∏çËÉΩÊâßË°åËÄóÊó∂ÁöÑ‰ªªÂä°, Ëøô‰∏™Êó∂ÂÄôÂ≠êÁ∫øÁ®ãÂ∞±Ê¥æ‰∏äÁî®Âú∫. Â≠êÁ∫øÁ®ã‰πüÂè´‰ΩúÂ∑•‰ΩúÁ∫øÁ®ã, Èô§‰∫Ü‰∏ªÁ∫øÁ®ã‰ª•Â§ñÁöÑÁ∫øÁ®ãÈÉΩÂè´ÂÅöÂ≠êÁ∫øÁ®ã AndroidÊ≤øÁî®‰∫ÜJavaÁöÑÁ∫øÁ®ãÊ®°Âûã, ÂÖ∂‰∏≠ÁöÑÁ∫øÁ®ã‰πüÂàÜ‰∏∫‰∏ªÁ∫øÁ®ãÂíåÂ≠êÁ∫øÁ®ã, ÂÖ∂‰∏≠‰∏ªÁ∫øÁ®ã‰πüÂè´UIÁ∫øÁ®ã. ‰∏ªÁ∫øÁ®ãÁöÑ‰ΩúÁî®ÊòØËøêË°åÂõõÂ§ßÁªÑ‰ª∂‰ª•ÂèäÂ§ÑÁêÜÂÆÉ‰ª¨ÂíåÁî®Êà∑ÁöÑ‰∫§‰∫í. ËÄåÂ≠êÁ∫øÁ®ãÁöÑ‰ΩúÁî®ÂàôÊòØÊâßË°åËÄóÊó∂‰ªªÂä°, ÊØîÂ¶ÇÁΩëÁªúËØ∑Ê±Ç, I/OÊìç‰ΩúÁ≠â. ‰ªéAndroid 3.0 ÂºÄÂßãÁ≥ªÁªüË¶ÅÊ±ÇÁΩëÁªúËÆøÈóÆÂøÖÈ°ªÂú®Â≠êÁ∫øÁ®ã‰∏≠ËøõË°å, Âê¶ÂàôÁΩëÁªúËÆøÈóÆÂ∞Ü‰ºöÂ§±Ë¥•Âπ∂ÊäõÂá∫NetworkOnMainThreadExceptionËøô‰∏™ÂºÇÂ∏∏, ËøôÊ†∑ÂÅöÊòØ‰∏∫‰∫ÜÈÅøÂÖç‰∏ªÁ∫øÁ®ãÁî±‰∫éËÄóÊó∂Êìç‰ΩúÊâÄÈòªÂ°û‰ªéËÄåÂá∫Áé∞ANRÁé∞Ë±°. Android‰∏≠ÁöÑÁ∫øÁ®ãÂΩ¢ÊÄÅAsyncTask AsyncTaskÊòØ‰∏ÄÁßçËΩªÈáèÁ∫ßÁöÑÂºÇÊ≠•‰ªªÂä°Á±ª, ‰ªñÂèØ‰ª•Âú®Á∫øÁ®ãÊ±†‰∏≠ÊâßË°åÂêéÂè∞‰ªªÂä°, ÁÑ∂ÂêéÊääÊâßË°åÁöÑËøõÂ∫¶ÂíåÊúÄÁªàÁöÑÁªìÊûú‰º†ÈÄíÁªô‰∏ªÁ∫øÁ®ãÂπ∂Âú®‰∏ªÁ∫øÁ®ãÊõ¥Êñ∞UI. ‰ªéÂÆûÁé∞‰∏äÊù•ËØ¥. AsyncTaskÂ∞ÅË£Ö‰∫ÜThreadÂíåHandler, ÈÄöËøáAsyncTaskÂèØ‰ª•Êõ¥Âä†Êñπ‰æøÂú∞ÊâßË°åÂêéÂè∞‰ªªÂä°, ÂØπ‰∫éÁâπÂà´ËÄóÊó∂ÁöÑ‰ªªÂä°Êù•ËØ¥, Âª∫ËÆÆ‰ΩøÁî®Á∫øÁ®ãÊ±†. 123public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; // ÁúÅÁï•‰∏ÄÂ§ßÂù®‰ª£Á†Å&#125; AsyncTaskÂ∞±ÊòØ‰∏Ä‰∏™ÊäΩË±°ÁöÑÊ≥õÂûãÁ±ª. Ëøô‰∏â‰∏™Ê≥õÂûãÁöÑÊÑè‰πâ. Params: Ë°®Á§∫ÂèÇÊï∞ÁöÑÁ±ªÂûã Progress: Ë°®Á§∫ÂêéÂè∞‰ªªÂä°ÁöÑÊâßË°åËøõÂ∫¶ÁöÑÁ±ªÂûã Result: ÂàôË°®Á§∫ÂêéÂè∞‰ªªÂä°ÁöÑËøîÂõûÁªìÊûúÁöÑÁ±ªÂûã Â¶ÇÊûú‰∏çÈúÄË¶Å‰º†ÈÄíÂÖ∑‰ΩìÁöÑÂèÇÊï∞, ÈÇ£‰πàËøô‰∏â‰∏™Ê≥õÂûãÂèÇÊï∞ÂèØ‰ª•Áî®VoidÊù•‰ª£Êõø. AsyncTaskÊèê‰æõ‰∫Ü4‰∏™Ê†∏ÂøÉÊñπÊ≥ï, Âê´‰πâÂ¶Ç‰∏ã onPreExecute(): Âú®‰∏ªÁ∫øÁ®ãÊâßË°å, Âú®ÂºÇÊ≠•‰ªªÂä°ÊâßË°å‰πãÂâç, Ê≠§ÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®, ‰∏ÄËà¨ÂèØ‰ª•Áî®‰∫éÂÅö‰∏Ä‰∫õÂáÜÂ§áÂ∑•‰Ωú protected abstract Result doInBackground(Params... params): Âú®Á∫øÁ®ãÊ±†‰∏≠ÊâßË°å, Ê≠§ÊñπÊ≥ïÁî®‰∫éÊâßË°åÂºÇÊ≠•‰ªªÂä°, ÂèÇÊï∞paramsË°®Á§∫ÂºÇÊ≠•‰ªªÂä°ÁöÑËæìÂÖ•ÂèÇÊï∞. Âú®Ê≠§ÊñπÊ≥ï‰∏≠ÂèØ‰ª•ÈÄöËøápublishProgress()ÊñπÊ≥ïÊù•Êõ¥Êñ∞‰ªªÂä°ÁöÑËøõÂ∫¶, publishProgress()ÊñπÊ≥ï‰ºöË∞ÉÁî®onProgressUpdate()ÊñπÊ≥ï. Âè¶Â§ñÊ≠§ÊñπÊ≥ïÈúÄË¶ÅËøîÂõûËÆ°ÁÆóÁªìÊûúÁªôonPostExecute() onProgressUpdate(Progress... values): Âú®‰∏ªÁ∫øÁ®ãÊâßË°å,Âú®ÂºÇÊ≠•‰ªªÂä°ÊâßË°å‰πãÂêé, Ê≠§ÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®, ÂÖ∂‰∏≠resultÂèÇÊï∞ÊòØÂêéÂè∞‰ªªÂä°ÁöÑËøîÂõûÂÄº, Âç≥doInBackground()ÁöÑËøîÂõûÂÄº. onPostExecute(Result result): Âú®‰∏ªÁ∫øÁ®ãÊâßË°å, Âú®ÂºÇÊ≠•‰ªªÂä°ÊâßË°å‰πãÂêé, Ê≠§ÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®, ÂÖ∂‰∏≠resultÂèÇÊï∞ÊòØÂêéÂè∞‰ªªÂä°ÁöÑËøîÂõûÂÄº, Âç≥doInBackgroundÁöÑËøîÂõûÂÄº. Èô§‰∫Ü‰∏äËø∞ÁöÑÂõõÁßçÊñπÊ≥ï,ËøòÊúâonCancelled(), ÂÆÉÂêåÊ†∑Âú®‰∏ªÁ∫øÁ®ãÊâßË°å, ÂΩìÂºÇÊ≠•‰ªªÂä°Ë¢´ÂèñÊ∂àÊó∂, onCancelled()ÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®, Ëøô‰∏™Êó∂ÂÄôonPostExecute()Âàô‰∏ç‰ºöË¢´Ë∞ÉÁî®. AsyncTaskÂú®‰ΩøÁî®ËøáÁ®ã‰∏≠Êúâ‰∏Ä‰∫õÊù°‰ª∂ÈôêÂà∂ AsyncTaskÁöÑÁ±ªÂøÖÈ°ªÂú®‰∏ªÁ∫øÁ®ãË¢´Âä†ËΩΩ, ËøôÂ∞±ÊÑèÂë≥ÁùÄÁ¨¨‰∏ÄÊ¨°ËÆøÈóÆAsyncTaskÂøÖÈ°ªÂèëÁîüÂú®‰∏ªÁ∫øÁ®ã, Ëøô‰∏™ÈóÆÈ¢ò‰∏çÊòØÁªùÂØπ, Âõ†‰∏∫Âú®Android 4.1Âèä‰ª•‰∏äÁöÑÁâàÊú¨Â∑≤ÁªèË¢´Á≥ªÁªüËá™Âä®ÂÆåÊàê. Âú®Android 5.0ÁöÑÊ∫êÁ†Å‰∏≠, ÂèØ‰ª•ÁúãÂà∞ActivityThread#main()‰ºöË∞ÉÁî®AsyncTask#init()ÊñπÊ≥ï. AsyncTaskÁöÑÂØπË±°ÂøÖÈ°ªÂú®‰∏ªÁ∫øÁ®ã‰∏≠ÂàõÂª∫. executeÊñπÊ≥ïÂøÖÈ°ªÂú®UIÁ∫øÁ®ãË∞ÉÁî®. ‰∏çË¶ÅÂú®Á®ãÂ∫è‰∏≠Áõ¥Êé•Ë∞ÉÁî®onPreExecute(), onPostExecute(), doInBackgroundÂíåonProgressUpdate() ‰∏Ä‰∏™AsyncTaskÂØπË±°Âè™ËÉΩÊâßË°å‰∏ÄÊ¨°, Âç≥Âè™ËÉΩË∞ÉÁî®‰∏ÄÊ¨°execute()ÊñπÊ≥ï, Âê¶Âàô‰ºöÊä•ËøêË°åÊó∂ÂºÇÂ∏∏. Âú®Android 1.6‰πãÂâç, AsyncTaskÊòØ‰∏≤Ë°åÊâßË°å‰ªªÂä°ÁöÑ; Android 1.6ÁöÑÊó∂ÂÄôAsyncTaskÂºÄÂßãÈááÁî®Á∫øÁ®ãÊ±†ÈáåÂ§ÑÁêÜÂπ∂Ë°å‰ªªÂä°; ‰ΩÜÊòØAndroid 3.0ÂºÄÂßã, ‰∏∫‰∫ÜÈÅøÂÖçAsyncTaskÂ∏¶Êù•ÁöÑÂπ∂ÂèëÈîôËØØ, AsyncTaskÂèàÈááÁî®‰∫Ü‰∏Ä‰∏™Á∫øÁ®ãÊù•‰∏≤Ë°åÁöÑÊâßË°å‰ªªÂä°. Â∞ΩÁÆ°Â¶ÇÊ≠§Âú®3.0‰ª•Âêé, ‰ªçÁÑ∂ÂèØ‰ª•ÈÄöËøáAsyncTask#executeOnExecutor()ÊñπÊ≥ïÊù•Âπ∂Ë°åÊâßË°å‰ªªÂä°. AsyncTaskÁöÑÂ∑•‰ΩúÂéüÁêÜËøôÈáå‰ª•Ê∫êÁ†Å5.0Êù•ÂàÜÊûê, ‰∏çÂêåÁöÑÁâàÊú¨Ê∫êÁ†ÅÂÖ∑‰ΩìÂÆûÁé∞ÊòØ‰∏çÂêåÁöÑ. ‰∏∫‰∫ÜÂàÜÊûêAsyncTaskÁöÑÂ∑•‰ΩúÂéüÁêÜ, ÂèØ‰ª•‰ªéÂÆÉÁöÑexecute()ÊñπÊ≥ïÂºÄÂßãÂàÜÊûê, execute()ÊñπÊ≥ïÂèà‰ºöË∞ÉÁî®executeOnExecutor()ÊñπÊ≥ï. 123456789101112131415161718192021222324252627public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; sDefaultExecutorÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™‰∏≤Ë°åÁöÑÁ∫øÁ®ãÊ±†, ‰∏Ä‰∏™ËøõÁ®ã‰∏≠ÊâÄÊúâÁöÑAsyncTaskÂÖ®ÈÉΩÂú®Ëøô‰∏™‰∏≤Ë°åÁöÑÁ∫øÁ®ãÊ±†‰∏≠ÊéíÈòüÊâßË°å, ÁÑ∂Âêé‰ºöÂÖàË∞ÉÁî®AsyncTask#onPreExecute()ÊñπÊ≥ï, ÁÑ∂ÂêéÁ∫øÁ®ãÊ±†ÂºÄÂßãÊâßË°å. ÁúãÁúãSerialExecutor()ÁöÑÊ∫êÁ†ÅÂÆûÁé∞: 123456789101112131415161718192021222324252627public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; Âú®SerialExecutorÁöÑÂÆûÁé∞ÂèØ‰ª•ÂàÜÊûêAsyncTaskÁöÑÊéíÈòüÊâßË°åÁöÑËøáÁ®ã. È¶ñÂÖàÁ≥ªÁªü‰ºöÊääAsyncTask#ParamsÂèÇÊï∞Â∞ÅË£ÖÊàêFutureTaskÂØπË±°, FutureTaskÊòØ‰∏Ä‰∏™Âπ∂ÂèëÁ±ª, Âú®ËøôÈáåÂÖÖÂΩì‰∫ÜRunnableÁöÑ‰ΩúÁî®. Êé•ÁùÄËøô‰∏™FutureTask‰ºö‰∫§ÁªôSerialExecutor#execute()ÊñπÊ≥ïÂéªÂ§ÑÁêÜ. Ëøô‰∏™ÊñπÊ≥ïÈ¶ñÂÖà‰ºöÊääFutureTaskÂØπË±°ÊèíÂÖ•Âà∞‰ªªÂä°ÈòüÂàómTasks‰∏≠, Â¶ÇÊûúËøô‰∏™Êó∂ÂÄôÊ≤°ÊúâÊ≠£Âú®Ê¥ªÂä®AsyncTask‰ªªÂä°, ÈÇ£‰πàÂ∞±‰ºöË∞ÉÁî®SerialExecutor#scheduleNext()ÊñπÊ≥ïÊù•ÊâßË°å‰∏ã‰∏Ä‰∏™AsyncTask‰ªªÂä°. ÂêåÊó∂ÂΩì‰∏Ä‰∏™AsyncTask‰ªªÂä°ÊâßË°åÂÆåÂêé, AsyncTask‰ºöÁªßÁª≠ÊâßË°åÂÖ∂‰ªñ‰ªªÂä°Áõ¥Âà∞ÊâÄÊúâÁöÑ‰ªªÂä°ÈÉΩÊâßË°åÂÆåÊØï‰∏∫Ê≠¢, ‰ªéËøô‰∏ÄÁÇπÂèØ‰ª•ÁúãÂá∫, Âú®ÈªòËÆ§ÊÉÖÂÜµ‰∏ã, AsyncTaskÊòØ‰∏≤Ë°åÊâßË°åÁöÑ AsyncTask‰∏≠Êúâ‰∏§‰∏™Á∫øÁ®ãÊ±†(SerialExecutor‰∏≤Ë°åÂíåTHREAD_POOL_EXECUTORÂπ∂Âèë)Âíå‰∏Ä‰∏™Handler(InternalHandler), ÂÖ∂‰∏≠Á∫øÁ®ãÊ±†SerialExecutorÁî®‰∫é‰ªªÂä°ÁöÑÊéíÂàó, ËÄåÁ∫øÁ®ãÊ±†THREAD_POOL_EXECUTORÁî®‰∫éÁúüÊ≠£ÁöÑÊâßË°å‰ªªÂä°, ËÄåInternalHandlerÁî®‰∫éÂ∞ÜÊâßË°åÁéØÂ¢É‰ªéÁ∫øÁ®ãÂàáÊç¢Âà∞‰∏ªÁ∫øÁ®ã, ÂÖ∂Êú¨Ë¥®‰ªçÁÑ∂ÊòØÁ∫øÁ®ãÁöÑË∞ÉÁî®ËøáÁ®ã. Âú®AsyncTaskÁöÑÊûÑÈÄ†ÊñπÊ≥ï‰∏≠ÊúâÂ¶Ç‰∏ãËøôÊÆµ‰ª£Á†Å, Áî±‰∫éFutureTask#run()ÊñπÊ≥ï‰ºöË∞ÉÁî®mWorker.call()ÊñπÊ≥ï, Âõ†Ê≠§mWorkerÁöÑcallÊñπÊ≥ïÊúÄÁªà‰ºöÂú®Á∫øÁ®ãÊ±†‰∏≠ÊâßË°å. 123456789mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); &#125; &#125;; Âú®mWorker.call()ÊñπÊ≥ï‰∏≠, È¶ñÂÖàÂ∞ÜmTaskInvokedËÆæ‰∏∫‰∫Ütrue. Ë°®Á§∫ÂΩìÂâç‰ªªÂä°Â∑≤ÁªèË¢´Ë∞ÉÁî®Ëøá‰∫Ü. ÁÑ∂ÂêéÊâßË°åAsyncTask#doInBackground()ÊñπÊ≥ï, Êé•ÁùÄÂ∞ÜÂÖ∂ËøîÂõûÂÄº‰º†ÈÄíÁªôpostResult(), Ëøô‰∏™ÊñπÊ≥ïÁöÑÂÆûÁé∞: 1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; ËøôÈáå, postResult()‰ºöÈÄöËøásHandlerÂèëÈÄÅ‰∏Ä‰∏™MESSAGE_POST_RESULTÊ∂àÊÅØ, ËÄåsHandlerÁöÑÂÆö‰πâÂ¶Ç‰∏ã: 123456789101112131415161718private static final InternalHandler sHandler = new InternalHandler();private static class InternalHandler extends Handler &#123; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; ÂèØ‰ª•ÁúãÂá∫sHandlerÊòØ‰∏Ä‰∏™ÈùôÊÄÅÁöÑHandlerÂØπË±°, ‰∏∫‰∫ÜËÉΩÂ§üÂ∞ÜÊâßË°åÁéØÂ¢ÉÂàáÊç¢Âà∞‰∏ªÁ∫øÁ®ã, ËøôÂ∞±Ë¶ÅÊ±ÇsHandlerËøô‰∏™ÂØπË±°ÂøÖÈ°ªÂú®‰∏ªÁ∫øÁ®ã‰∏≠ÂàõÂª∫. Áî±‰∫éÈùôÊÄÅÊàêÂëò‰ºöÂú®Âä†ËΩΩÁ±ªÁöÑÊó∂ÂÄôËøõË°åÂàùÂßãÂåñ, Âõ†Ê≠§ËøôÂ∞±ÂèòÁõ∏Ë¶ÅÊ±ÇAsyncTaskÁöÑÁ±ªÂøÖÈ°ªÂú®‰∏ªÁ∫øÁ®ã‰∏≠Âä†ËΩΩ, Âê¶ÂàôÂêå‰∏Ä‰∏™ËøõÁ®ã‰∏≠ÁöÑAsyncTaskÈÉΩÊó†Ê≥ïÊ≠£Â∏∏Â∑•‰Ωú.sHandlerÊî∂Âà∞‰∫ÜÊ∂àÊÅØÂêé‰ºöË∞ÉÁî®AsyncTask#finish()ÊñπÊ≥ï, Â¶Ç‰∏ã: 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; Ëøô‰∏™finish()ÊñπÊ≥ïÂæàÁÆÄÂçï, Â¶ÇÊûúAsyncTaskË¢´ÂèñÊ∂à‰∫Ü, ÈÇ£‰πàÂ∞±Ë∞ÉÁî®onCancelled()ÊñπÊ≥ï, Âê¶ÂàôÂ∞±‰ºöË∞ÉÁî®onPostExecute()ÊñπÊ≥ï, ÂèØ‰ª•ÁúãÂà∞doInBackgroundÁöÑÂèçÈ¶àÁªìÊûú‰ºö‰º†ÈÄíÁªôonPostExecute()ÊñπÊ≥ï. ÈÄöËøáÊ∫êÁ†ÅÂàÜÊûê, ÂèØ‰ª•Á°ÆÂÆö‰ªé3.0ÂºÄÂßã, ÈªòËÆ§ÊÉÖÂÜµ‰∏ãAsyncTaskÂ∞±ÊòØ‰∏≤Ë°åÁöÑ. ÈÄöËøá‰∏ÄÊÆµ‰ª£Á†ÅÊµãËØï. 1234567891011121314151617181920212223242526272829303132333435 @Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_main: new MyAsync("‰ªªÂä°_1").execute(""); new MyAsync("‰ªªÂä°_2").execute(""); new MyAsync("‰ªªÂä°_3").execute(""); new MyAsync("‰ªªÂä°_4").execute(""); new MyAsync("‰ªªÂä°_5").execute(""); break; &#125;&#125;private static class MyAsync extends AsyncTask&lt;String, Integer, String&gt;&#123; private static final String TAG = MyAsync.class.getSimpleName(); private final String mTaskName; public MyAsync(String taskName)&#123; mTaskName = taskName; &#125; @Override protected String doInBackground(String... params) &#123; SystemClock.sleep(3000); return mTaskName; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss"); Log.e(TAG, s+" onPostExecute finish time: " +df.format(new Date())); &#125;&#125; ÁªôÊåâÈíÆÊ∑ªÂä†‰∏Ä‰∏™ÁÇπÂáªËß¶Âèë, ÁÇπÂáªÁöÑÊó∂ÂÄô‰ºöËß¶Âèë‰∫î‰∏™AsyncTaskÁöÑÂàõÂª∫ÂíåÊâßË°å , Áúã‰∏Ä‰∏ãÁªìÊûú Âú®5.0Êú∫Âô®‰∏äÊµãËØïÊâÄÊúâÁöÑ‰ªªÂä°ÊòØ‰∏≤Ë°åÊâßË°åÁöÑ. ÊÄªÂÖ±ËÄóË¥π‰∫Ü15Áßí. ËÄåÂú®2.xÁöÑÁâàÊú¨ÊâÄÊúâÁöÑÁªìÊùüÊó∂Èó¥Âç¥ÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑ. ‰∏∫‰∫ÜËÆ©AsyncTaskÂèØ‰ª•Âú®Android 3.0Âèä‰ª•‰∏äÁâàÊú¨Âπ∂Ë°åÔºåÂèØ‰ª•‰ΩøÁî®executeOnExecutor()ÈÇ£‰πàÁªìÊûúÁúã‰∏Ä‰∏ã: 12345678910/*** Âú®ÁâàÊú¨3.0‰ª•‰∏ä‰ΩøÁî®Âπ∂Ë°åÁöÑÊñπÂºèÂºÄÂêØ*/private void checkConcurrent() &#123; new MyAsync("‰ªªÂä°_1").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("‰ªªÂä°_2").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("‰ªªÂä°_3").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("‰ªªÂä°_4").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("‰ªªÂä°_5").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,"");&#125; ok, ÊåâÁÖß‰Ω†ÁöÑÈúÄÊ±ÇÂèØ‰ª•ÈÄâÊã©‰ΩøÁî®Âì™ÁßçÂÆûÁé∞ÊñπÂºè. HandlerThreadHandlerThreadÁªßÊâø‰∫ÜThread, ÂÆÉÊòØ‰∏ÄÁßçÂèØ‰ª•‰ΩøÁî®HandlerÁöÑThread, ÂÆÉÁöÑÂÆûÁé∞‰πüÂæàÁÆÄÂçï, Â∞±ÊòØrunÊñπÊ≥ï‰∏≠ÈÄöËøáLooper.prepare()Êù•ÂàõÂª∫Ê∂àÊÅØÈòüÂàó, Âπ∂ÈÄöËøáLooper.loop()Êù•ÂºÄÂêØÊ∂àÊÅØÂæ™ÁéØ, ËøôÊ†∑Âú®ÂÆûÈôÖÁöÑ‰ΩøÁî®‰∏≠Â∞±ÂÖÅËÆ∏Âú®HandlerThread‰∏≠ÂàõÂª∫Handler, Áúã‰∏Ä‰∏ãrun()ÊñπÊ≥ï. 12345678910111213@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; ‰ªéHandlerThreadÁöÑÂÆûÁé∞Êù•Áúã, ÂÆÉÂíåÊôÆÈÄöÁöÑThreadÊúâÊòæËëóÁöÑ‰∏çÂêå‰πãÂ§Ñ. ÊôÆÈÄöÁöÑThread‰∏ªË¶ÅÁî®‰∫éÂú®runÊñπÊ≥ï‰∏≠ÊâßË°å‰∏Ä‰∏™ËÄóÊó∂‰ªªÂä°; ËÄåHandlerThreadÂú®ÂÜÖÈÉ®ÂàõÂª∫‰∫ÜÊ∂àÊÅØÈòüÂàó, Â§ñÁïåÈúÄË¶ÅÈÄöËøáHandlerÁöÑÊ∂àÊÅØÊñπÂºèÊù•ÈÄöÁü•HandlerThreadÊâßË°å‰∏Ä‰∏™ÂÖ∑‰ΩìÁöÑ‰ªªÂä°. HandlerThreadÊòØ‰∏Ä‰∏™ÂæàÊúâÁî®ÁöÑÁ±ª, Âú®Android‰∏≠‰∏Ä‰∏™ÂÖ∑‰Ωì‰ΩøÁî®Âú∫ÊôØÂ∞±ÊòØIntentService. Áî±‰∫éHandlerThread#run()ÊòØ‰∏Ä‰∏™Êó†Á∫øÂæ™ÁéØÊñπÊ≥ï, Âõ†Ê≠§ÂΩìÊòéÁ°Æ‰∏çÈúÄË¶ÅÂÜç‰ΩøÁî®HandlerThreadÊó∂, ÊúÄÂ•ΩÈÄöËøáquit()ÊàñËÄÖquitSafely()ÊñπÊ≥ïÊù•ÁªàÊ≠¢Á∫øÁ®ãÁöÑÊâßË°å. IntentServiceIntentServiceÊòØ‰∏ÄÁßçÁâπÊÆäÁöÑService, ÂÆÉÁªßÊâø‰∫ÜServiceÂπ∂‰∏îÂÆÉÊòØ‰∏Ä‰∏™ÊäΩË±°Á±ª, Âõ†Ê≠§ÈúÄË¶ÅÂàõÂª∫Â≠êÁ±ªÊâçËÉΩ‰ΩøÁî®. IntentServiceÂèØ‰ª•Áî®‰∫éÊâßË°åÂêéÂè∞ËÄóÊó∂‰ªªÂä°, ÂΩì‰ªªÂä°ÊâßË°åÂêé‰ºöËá™Âä®ÂÅúÊ≠¢, ÂêåÊó∂Áî±‰∫éÊú¨Ë¥®ÊòØÊúçÂä°ÁöÑÂéüÂõ†, ËøôÂØºËá¥‰∫ÜÂÆÉÁöÑ‰ºòÂÖàÁ∫ßÊØîÂçïÁ∫ØÁöÑÁ∫øÁ®ãË¶ÅÈ´òÂæàÂ§ö, ÊâÄ‰ª•IntentServiceÊØîËæÉÈÄÇÂêàÊâßË°å‰∏Ä‰∫õÈ´ò‰ºòÂÖàÁ∫ßÁöÑÂêéÂè∞‰ªªÂä°. IntentServiceÂ∞ÅË£Ö‰∫ÜHandlerÂíåHandlerThread. ËøôÊòØÂú®onCreate()Êù•ÂÆûÁé∞ÁöÑ. 12345678910111213@Overridepublic void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; ÂΩìÁ¨¨‰∏ÄÊ¨°ÂêØÂä®ÁöÑÊó∂ÂÄô, onCreate()Â∞±‰ºöË¢´Ë∞ÉÁî®, ÂÜÖÈÉ®Â∞±‰ºöÂàõÂª∫‰∏Ä‰∏™HandlerThread, ÁÑ∂Âêé‰ΩøÁî®ÂÆÉÁöÑLooperÊù•ÊûÑÈÄ†‰∏Ä‰∏™HandlerÂØπË±°mServiceHandler. ËøôÊ†∑ÈÄöËøá mServiceHandlerÂèëÈÄÅÁöÑÊ∂àÊÅØÊúÄÁªàÈÉΩ‰ºöÂú®HandlerThread‰∏≠ÊâßË°å, ‰ªéËøô‰∏™ËßíÂ∫¶ÁúãIntentService‰πüÂèØ‰ª•Áî®‰∫éÊâßË°åÂêéÂè∞‰ªªÂä°. ÊØèÊ¨°ÂêØÂä®IntentServiceÁöÑÊó∂ÂÄô, ÂÆÉÁöÑonStartCommand()ÊñπÊ≥ïÂ∞±‰ºöË¢´Ë∞ÉÁî®‰∏ÄÊ¨°, IntentServiceÂú®onStartCommand()‰∏≠Â§ÑÁêÜÊØè‰∏™ÂêéÂè∞‰ªªÂä°ÁöÑIntent. ÁúãÁúãÊ∫êÁ†ÅÊòØÂ¶Ç‰ΩïÂ§ÑÁêÜÂ§ñÁïåÁöÑIntentÁöÑ. È¶ñÂÖàonStartCommand()Ë∞ÉÁî®‰∫ÜonStart() 1234567@Overridepublic void onStart(Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; Ëøô‰∏™ÊñπÊ≥ïÂè™ÊòØÈÄöËøámServiceHandlerÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™Ê∂àÊÅØ, ÊâÄ‰ª•Ëøô‰∏™Ê∂àÊÅØ‰ºöÂú®HandlerThread‰∏≠Ë¢´Â§ÑÁêÜ. Ê∂àÊÅØÊî∂Âà∞Âêé, ‰ºöÂ∞ÜIntentÂØπË±°‰º†ÈÄíÁªôonHandlerIntent()ÊñπÊ≥ïÂéªÂ§ÑÁêÜ. Ê≥®ÊÑèËøô‰∏™IntentÂØπË±°ÂíåÂ§ñÁïåstartService()ÂèÇÊï∞‰º†ÈÄíÂÜÖÂÆπÊòØ‰∏ÄÊ†∑ÁöÑ. ÈÄöËøáIntentÁöÑÂèÇÊï∞Â∞±ÂèØ‰ª•Âå∫ÂàÜÂÖ∑‰ΩìÁöÑÂêéÂè∞‰ªªÂä°, ËøôÊ†∑Âú®onHandlerIntent()ÊñπÊ≥ï‰∏≠Â∞±ÂèØ‰ª•ÂØπ‰∏çÂêåÁöÑÂêéÂè∞‰ªªÂä°ÂÅöÂ§ÑÁêÜ‰∫Ü. ÂΩìonHandlerIntent()ÊñπÊ≥ïÊâßË°åÂÆåÊØïÂêé, IntentService‰ºöÈÄöËøástopSelf()ÊñπÊ≥ïÊù•ÂÅúÊ≠¢ÊúçÂä°. ËøôÈáå‰ΩøÁî®ÁöÑÊñπÊ≥ïÊòØÊúâÂèÇÊï∞ÁöÑ, ‰∏ç‰ΩøÁî®Êó†ÂèÇÊï∞ÁöÑstopSelf()ÊòØÂõ†‰∏∫Êó†ÂèÇÂáΩÊï∞‰ºöÁ´ãÂàªÂÅúÊ≠¢ÊúçÂä°, ÂèØËÉΩ‰ºöÂØºËá¥ËøòÊúâÊ≤°ÊâßË°åÂÆåÁöÑ‰ªªÂä°Â§±Êïà. ÊúâÂèÇÁöÑstopSelf(int startId)Âú®Â∞ùËØï ÂÅúÊ≠¢ÊúçÂä°‰πãÂâç‰ºöÂà§Êñ≠ÊúÄËøëÂêØÂä®ÁöÑÊúçÂä°Ê¨°Êï∞ÊòØÂê¶ÂíåstartIdËøô‰∏™ÂèÇÊï∞ÂÄºÁõ∏Á≠â, Â¶ÇÊûúÁõ∏Á≠âÂ∞±Á´ãÂàªÂÅúÊ≠¢ÊúçÂä°, Âê¶ÂàôÂèç‰πã. Ëøô‰∏™Á≠ñÁï•ÂèØ‰ª•‰ªéAMS#stopServiceToken()ÊñπÊ≥ïÁöÑÂÆûÁé∞‰∏≠ÊâæÂà∞‰æùÊçÆ. IntentService#onHandleIntent()ÊñπÊ≥ïÊòØ‰∏Ä‰∏™ÊäΩË±°ÊñπÊ≥ï, ‰ªñÈúÄË¶ÅÊàë‰ª¨Âú®Â≠êÁ±ª‰∏≠ÂÆûÁé∞, ÂÆÉÁöÑ‰ΩúÁî®ÊòØ‰ªéIntentÂèÇÊï∞‰∏≠Âå∫ÂàÜÂÖ∑‰ΩìÁöÑ‰ªªÂä°Âπ∂ÊâßË°åËøô‰∫õ‰ªªÂä°. Â¶ÇÊûúÁõÆÂâçÂè™Â≠òÂú®‰∏Ä‰∏™ÂêéÂè∞‰ªªÂä°, ÈÇ£‰πàonHandleIntent()ÊñπÊ≥ïÊâßË°åÂÆåÊàêÂêé, stopSelf(int startId)‰ºöÁ´ãÂç≥ÂÅúÊ≠¢ÊúçÂä°; Â¶ÇÊûúÁõÆÂâçÂ≠òÂú®Â§ö‰∏™ÂêéÂè∞‰ªªÂä°, ÈÇ£‰πàÂΩìonHandleIntent()ÊñπÊ≥ïÊâßË°åÂÆåÊúÄÂêé‰∏Ä‰∏™‰ªªÂä°Êó∂, stopSelf(int startId)Êâç‰ºöÂÅúÊ≠¢‰ªªÂä°. Âè¶Â§ñÁî±‰∫éÊØèÊ¨°ÊâßË°å‰∏Ä‰∏™ÂêéÂè∞‰ªªÂä°ÈÉΩÂøÖÈ°ªÂêØÂä®‰∏ÄÊ¨°IntentService, ËÄåÂÖ∂ÂÜÖÈÉ®ÂàôÈÄöËøáÊ∂àÊÅØÁöÑÊñπÂºèÂêëHandlerThreadËØ∑Ê±ÇÊâßË°å‰ªªÂä°, Handler‰∏≠ÁöÑLooperÊòØÈ°∫Â∫èÂ§ÑÁêÜÊ∂àÊÅØÁöÑ, ËøôÂ∞±ÊÑèÂë≥ÁùÄIntentService‰πüÊòØÈ°∫Â∫èÊâßË°åÂêéÂè∞‰ªªÂä°ÁöÑ, ÂΩìÊúâÂ§ö‰∏™ÂêéÂè∞‰ªªÂä°ÂêåÊó∂Â≠òÂú®Êó∂, Ëøô‰∫õÂêéÂè∞‰ªªÂä°‰ºöÊåâÁÖßÂ§ñÁïåÂèëËµ∑ÁöÑÈ°∫Â∫èÊéíÈòüÊâßË°å. Áî®‰ª£Á†ÅÊù•ÊºîÁ§∫‰∏ÄÈÅç: 123456789101112131415161718192021222324252627282930313233// Ê¥æÁîü‰∏Ä‰∏™IntentService ÁöÑÂ≠êÁ±ªpublic static class LocalIntentService extends IntentService &#123; private static final String TAG = LocalIntentService.class.getSimpleName(); public LocalIntentService() &#123; super(TAG); &#125; @Override protected void onHandleIntent(Intent intent) &#123; String task = intent.getStringExtra("task"); Log.d(TAG, "receiver task :"+task); SystemClock.sleep(2000); &#125; @Override public void onDestroy() &#123; Log.w(TAG, "onDestroy: ÂáÜÂ§áÂÖ≥Èó≠" ); super.onDestroy(); &#125;&#125;// ÂºÄÂêØ3‰∏™ÊúçÂä°Intent service = new Intent(this, LocalIntentService.class);service.putExtra("task", "hi, ÊàëÊòØÊï∞ÊçÆ1");startService(service);service.putExtra("task", "hi, ÊàëÊòØÊï∞ÊçÆ2");startService(service);service.putExtra("task", "hi, ÊàëÊòØÊï∞ÊçÆ3");startService(service); ÂèØ‰ª•ÁúãÂá∫, ‰∏â‰∏™ÂêéÂè∞‰ªªÂä°ÊòØ‰∏≤Ë°åÊâßË°åÁöÑ, ‰ªñ‰ª¨ÁöÑÊâßË°åÈ°∫Â∫èÂ∞±ÊòØÂèëËµ∑ËØ∑Ê±ÇÁöÑÈ°∫Â∫è. ÂΩì‰ªªÂä°3ÂÆåÊàê‰∫Ü‰πãÂêé. LocalIntentServiceÊâçÁúüÊ≠£ÁöÑÂÅúÊ≠¢, Âõ†‰∏∫ËøôÊòØÊó∂ÂÄôÊâßË°å‰∫ÜonDestroy(). Android‰∏≠ÁöÑÁ∫øÁ®ãÊ±†Ê¶ÇÊã¨‰∏Ä‰∏ãÁ∫øÁ®ãÊ±†ÁöÑ‰ºòÁÇπ: ÈáçÁî®Á∫øÁ®ãÊ±†‰∏≠ÁöÑÁ∫øÁ®ã, ÈÅøÂÖçÂõ†‰∏∫Á∫øÁ®ãÁöÑÂàõÂª∫ÂíåÈîÄÊØÅÊâÄÂ∏¶Êù•ÁöÑÊÄßËÉΩÂºÄÈîÄ. ËÉΩÊúâÊïàÊéßÂà∂Á∫øÁ®ãÁöÑÊúÄÂ§ßÂπ∂Â§ßÊï∞, ÈÅøÂÖçÂ§ßÈáèÁöÑÁ∫øÁ®ã‰πãÈó¥Âõ†‰∫íÁõ∏Êä¢Âç†Á≥ªÁªüËµÑÊ∫êËÄåÂØºËá¥ÁöÑÈòªÂ°ûÁé∞Ë±°. ËÉΩÂ§üÂØπÁ∫øÁ®ãËøõË°åÁÆÄÂçïÁöÑÁÆ°ÁêÜ, Âπ∂Êèê‰æõÂÆöÊó∂ÊâßË°å‰ª•ÂèäÊåáÂÆöÈó¥ÈöîÂæ™ÁéØÊâßË°åÁ≠âËÉΩÂäõ. Android‰∏≠ÁöÑÁ∫øÁ®ãÊ±†ÁöÑÊ¶ÇÂøµÊù•Ê∫ê‰∫éJava‰∏≠ÁöÑExecutor, ExecutorÊòØ‰∏Ä‰∏™Êé•Âè£, ÁúüÊ≠£ÁöÑÁ∫øÁ®ãÊ±†ÁöÑÂÆûÁé∞‰∏∫ThreadPoolExecutor. ThreadPoolExecutorÊèê‰æõ‰∫Ü‰∏ÄÁ≥ªÂàóÂèÇÊï∞Êù•ÈÖçÂà∂Á∫øÁ®ãÊ±†, ÈÄöËøá‰∏çÂêåÁöÑÂèÇÊï∞ÂèØ‰ª•ÂàõÂª∫‰∏çÂêåÁöÑÁ∫øÁ®ãÊ±†. ËÄå‰ªéÂäüËÉΩÁöÑÁâπÊÄßÊù•ÂàÜÁöÑËØùÂèØ‰ª•ÂàÜÊàêÂõõÁ±ª. ‰∏ãÈù¢ËØ¥Êòé. ThreadPoolExecutorThreadPoolExecutorÊòØÁ∫øÁ®ãÊ±†ÁöÑÁúüÊ≠£ÂÆûÁé∞, ÂÆÉÁöÑÊûÑÈÄ†ÊñπÊ≥ïÊèê‰æõ‰∫Ü‰∏ÄÁ≥ªÂàóÂèÇÊï∞Êù•ÈÖçÁΩÆÁ∫øÁ®ãÊ±†, ‰∏ãÈù¢ÂØπÊûÑÈÄ†ÊñπÊ≥ï‰∏≠ÂèÇÊï∞ËøõË°å‰∏Ä‰∏ãËØ¥Êòé, Ëøô‰∫õÂèÇÊï∞Â∞Ü‰ºöÁõ¥Êé•ÂΩ±ÂìçÂà∞Á∫øÁ®ãÊ±†ÁöÑÂäüËÉΩÁâπÊÄß. 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize: Á∫øÁ®ãÊ±†ÁöÑÊ†∏ÂøÉÁ∫øÁ®ãÊï∞, ÈªòËÆ§ÊÉÖÂÜµ‰∏ã, Ê†∏ÂøÉÁ∫øÁ®ã‰ºöÂú®Á∫øÁ®ãÊ±†‰∏≠‰∏ÄÁõ¥Â≠òÊ¥ª, Âç≥‰ΩøÈÉΩÂ§Ñ‰∫éÈó≤ÁΩÆÁä∂ÊÄÅ. Â¶ÇÊûúÂ∞ÜThreadPoolExecutor#allowCoreThreadTimeOutÂ±ûÊÄßËÆæÁΩÆ‰∏∫true, ÈÇ£‰πàÈó≤ÁΩÆÁöÑÊ†∏ÂøÉÁ∫øÁ®ãÂú®Á≠âÂæÖÊñ∞‰ªªÂä°Âà∞Êù•Êó∂‰ºöÊúâË∂ÖÊó∂ÁöÑÁ≠ñÁï•, Ëøô‰∏™Êó∂Èó¥Èó¥ÈöîÁî±keepAliveTimeÂ±ûÊÄßÊù•ÂÜ≥ÂÆö. ÂΩìÁ≠âÂæÖÊó∂Èó¥Ë∂ÖËøá‰∫ÜkeepAliveTimeËÆæÂÆöÁöÑÂÄºÈÇ£‰πàÊ†∏ÂøÉÁ∫øÁ®ãÂ∞Ü‰ºöÁªàÊ≠¢. maximumPoolSize: Á∫øÁ®ãÊ±†ÊâÄËÉΩÂÆπÁ∫≥ÁöÑÊúÄÂ§ßÁ∫øÁ®ãÊï∞, ÂΩìÊ¥ªÂä®Á∫øÁ®ãÊï∞ËææÂà∞Ëøô‰∏™Êï∞ÂÄº‰πãÂêé, ÂêéÁª≠ÁöÑ‰ªªÂä°Â∞Ü‰ºöË¢´ÈòªÂ°û. keepAliveTime: ÈùûÊ†∏ÂøÉÁ∫øÁ®ãÈó≤ÁΩÆÁöÑË∂ÖÊó∂Êó∂Èïø, Ë∂ÖËøáËøô‰∏™Êó∂Èïø, ÈùûÊ†∏ÂøÉÁ∫øÁ®ãÂ∞±‰ºöË¢´ÂõûÊî∂. allowCoreThreadTimeOutËøô‰∏™Â±ûÊÄß‰∏∫trueÁöÑÊó∂ÂÄô, Ëøô‰∏™Â±ûÊÄßÂêåÊ†∑‰ºö‰ΩúÁî®‰∫éÊ†∏ÂøÉÁ∫øÁ®ã. unit: Áî®‰∫éÊåáÂÆökeepAliveTimeÂèÇÊï∞ÁöÑÊó∂Èó¥Âçï‰Ωç, ËøôÊòØ‰∏Ä‰∏™Êûö‰∏æ, Â∏∏Áî®ÁöÑÊúâTimeUtil.MILLISECONDS(ÊØ´Áßí), TimeUtil.SECONDS(Áßí)‰ª•ÂèäTimeUtil.MINUTES(ÂàÜ) workQueue: Á∫øÁ®ãÊ±†‰∏≠ÁöÑ‰ªªÂä°ÈòüÂàó, ÈÄöËøáÁ∫øÁ®ãÊ±†ÁöÑexecuteÊñπÊ≥ïÊèê‰∫§ÁöÑRunnableÂØπË±°‰ºöÂ≠òÂÇ®Âú®Ëøô‰∏™ÂèÇÊï∞‰∏≠. threadFactory: Á∫øÁ®ãÂ∑•ÂéÇ, ‰∏∫Á∫øÁ®ãÊ±†Êèê‰æõÂàõÂª∫Êñ∞Á∫øÁ®ãÁöÑÂäüËÉΩ. ThreadFactoryÊòØ‰∏Ä‰∏™Êé•Âè£. Á∫øÁ®ãÊ±†ÊâßË°å‰ªªÂä°Êó∂Â§ßËá¥ÈÅµÂæ™Â¶Ç‰∏ãËßÑÂàô: Â¶ÇÊûúÁ∫øÁ®ãÊ±†‰∏≠ÁöÑÁ∫øÁ®ãÊï∞ÈáèÊú™ËææÂà∞Ê†∏ÂøÉÁ∫øÁ®ãÁöÑÊï∞Èáè, ÈÇ£‰πà‰ºöÁõ¥Êé•ÂêØÂä®‰∏Ä‰∏™Ê†∏ÂøÉÁ∫øÁ®ãÊù•ÊâßË°å‰ªªÂä°. Â¶ÇÊûúÁ∫øÁ®ãÊ±†‰∏≠ÁöÑÁ∫øÁ®ãÊï∞ÈáèÂ∑≤ÁªèËææÂà∞ÊàñËÄÖË∂ÖËøáÊ†∏ÂøÉÁ∫øÁ®ãÁöÑÊï∞Èáè, ÈÇ£‰πà‰ªªÂä°‰ºöË¢´ÊèíÂÖ•Âà∞‰ªªÂä°ÈòüÂàó‰∏≠ÊéíÈòüÁ≠âÂæÖÊâßË°å. Â¶ÇÊûúÂú®Ê≠•È™§2‰∏≠Êó†Ê≥ïÂ∞Ü‰ªªÂä°ÊèíÂÖ•Âà∞‰ªªÂä°ÈòüÂàó‰∏≠, ËøôÈÄöÂ∏∏ÊòØÂõ†‰∏∫‰ªªÂä°ÈòüÂàóÂ∑≤Êª°, Ëøô‰∏™Êó∂ÂÄôÂ¶ÇÊûúÁ∫øÁ®ãÊï∞ÈáèÊú™ËææÂà∞Á∫øÁ®ãÊ±†ÁöÑËßÑÂÆöÁöÑÊúÄÂ§ßÂÄº, ÈÇ£‰πà‰ºöÁ´ãÂàªÂêØÂä®‰∏Ä‰∏™ÈùûÊ†∏ÂøÉÁ∫øÁ®ãÊù•ÊâßË°å‰ªªÂä°. Â¶ÇÊûúÊ≠•È™§3‰∏≠ÁöÑÁ∫øÁ®ãÊï∞ÈáèÂ∑≤ÁªèËææÂà∞ÊúÄÂ§ßÂÄºÁöÑÊó∂ÂÄô, ÈÇ£‰πà‰ºöÊãíÁªùÊâßË°åÊ≠§‰ªªÂä°, ThreadPoolExecutor‰ºöË∞ÉÁî®RejectedExecutionÊñπÊ≥ïÊù•ÈÄöÁü•Ë∞ÉÁî®ËÄÖ. ThreadPoolExecutorÁöÑÂèÇÊï∞ÈÖçÁΩÆÂú®AsyncTask‰∏≠ÊúâÊòéÊòæÁöÑ‰ΩìÁé∞, ‰∏ãÈù¢ÊòØAndroid 5.0Ê∫êÁ†ÅÁöÑÈÖçÁΩÆÊÉÖÂÜµÔºö 12345678910111213141516171819202122private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/*** An &#123;@link Executor&#125; that can be used to execute tasks in parallel.*/public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); Ëøô‰∏™ÈÖçÁΩÆÂêéÁöÑËßÑÊ†ºÊòØËøôÊ†∑ÁöÑ Ê†∏ÂøÉÁ∫øÁ®ãÊï∞Á≠â‰∫éCPUÊ†∏ÂøÉÊï∞ + 1; Á∫øÁ®ãÊ±†ÁöÑÊúÄÂ§ßÁ∫øÁ®ãÊï∞‰∏∫CPUÊ†∏ÂøÉÊï∞ÁöÑ2ÂÄç + 1; Ê†∏ÂøÉÁ∫øÁ®ãÊó†Ë∂ÖÊó∂Êú∫Âà∂, ÈùûÊ†∏ÂøÉÁ∫øÁ®ãÂú®Èó≤ÁΩÆÊó∂ÊúâË∂ÖÊó∂Êú∫Âà∂,Ë∂ÖÊó∂Êó∂Èó¥‰∏∫1Áßí. ‰ªªÂä°ÈòüÂàóÁöÑÂÆπÈáè‰∏∫128 Á∫øÁ®ãÊ±†ÁöÑÂàÜÁ±ª1. FixedThreadPool ÈÄöËøáExecutors#newFixedThreadPool()ÊñπÊ≥ïÊù•ÂàõÂª∫. ÂÆÉÊòØ‰∏ÄÁßçÁ∫øÁ®ãÊï∞ÈáèÂõ∫ÂÆöÁöÑÁ∫øÁ®ãÊ±†, ÂΩìÁ∫øÁ®ãÂ§Ñ‰∫éÁ©∫Èó≤Áä∂ÊÄÅÊó∂, ÂÆÉ‰ª¨Âπ∂‰∏ç‰ºöË¢´ÂõûÊî∂, Èô§ÈùûÁ∫øÁ®ãÊ±†ÂÖ≥Èó≠‰∫Ü. ÂΩìÊâÄÊúâÁöÑÁ∫øÁ®ãÈÉΩÂ§Ñ‰∫éÊ¥ªÂä®Áä∂ÊÄÅÊó∂, Êñ∞‰ªªÂä°ÈÉΩ‰ºöÂ§Ñ‰∫éÁ≠âÂæÖÁä∂ÊÄÅ, Áõ¥Âà∞ÊúâÁ∫øÁ®ãÁ©∫Èó≤Âá∫Êù•. Áî±‰∫éFixedThreadPoolÂè™ÊúâÊ†∏ÂøÉÁ∫øÁ®ãÂπ∂‰∏îËøô‰∫õÊ†∏ÂøÉÁ∫øÁ®ã‰∏ç‰ºöË¢´ÂõûÊî∂, ËøôÊÑèÂë≥ÁùÄÂÆÉËÉΩÂ§üÊõ¥Âä†Âø´ÈÄüÂú∞ÂìçÂ∫îÂ§ñÁïåÁöÑËØ∑Ê±Ç. 1234567891011121314151617181920/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 2. CachedThreadPoolÈÄöËøáExecutors#newCachedThreadPool()ÊñπÊ≥ïÊù•ÂàõÂª∫. ÂÆÉÊòØ‰∏ÄÁßçÁ∫øÁ®ãÊï∞Èáè‰∏çÂÆöÁöÑÁ∫øÁ®ãÊ±†, ÂÆÉÂè™ÊúâÈùûÊ†∏ÂøÉÁ∫øÁ®ã, Âπ∂‰∏îÂÖ∂ÊúÄÂ§ßÂÄºÁ∫øÁ®ãÊï∞‰∏∫Integer.MAX_VALUE. ËøôÂ∞±ÂèØ‰ª•ËÆ§‰∏∫Ëøô‰∏™ÊúÄÂ§ßÁ∫øÁ®ãÊï∞‰∏∫‰ªªÊÑèÂ§ß‰∫Ü. ÂΩìÁ∫øÁ®ãÊ±†‰∏≠ÁöÑÁ∫øÁ®ãÈÉΩÂ§Ñ‰∫éÊ¥ªÂä®ÁöÑÊó∂ÂÄô, Á∫øÁ®ãÊ±†‰ºöÂàõÂª∫Êñ∞ÁöÑÁ∫øÁ®ãÊù•Â§ÑÁêÜÊñ∞‰ªªÂä°, Âê¶ÂàôÂ∞±‰ºöÂà©Áî®Á©∫Èó≤ÁöÑÁ∫øÁ®ãÊù•Â§ÑÁêÜÊñ∞‰ªªÂä°. Á∫øÁ®ãÊ±†‰∏≠ÁöÑÁ©∫Èó≤Á∫øÁ®ãÈÉΩÊúâË∂ÖÊó∂Êú∫Âà∂, Ëøô‰∏™Ë∂ÖÊó∂Êó∂Èïø‰∏∫60S, Ë∂ÖËøáËøô‰∏™Êó∂Èó¥ÈÇ£‰πàÁ©∫Èó≤Á∫øÁ®ãÂ∞±‰ºöË¢´ÂõûÊî∂. ÂíåFixedThreadPool‰∏çÂêåÁöÑÊòØ, CachedThreadPoolÁöÑ‰ªªÂä°ÈòüÂàóÂÖ∂ÂÆûÁõ∏ÂΩì‰∫é‰∏Ä‰∏™Á©∫ÈõÜÂêà, ËøôÂ∞ÜÂØºËá¥‰ªª‰Ωï‰ªªÂä°ÈÉΩ‰ºöÁ´ãÂç≥Ë¢´ÊâßË°å, Âõ†‰∏∫Âú®ËøôÁßçÂú∫ÊôØ‰∏ãSynchronousQueueÊòØÊó†Ê≥ïÊèíÂÖ•‰ªªÂä°ÁöÑ. SynchronousQueueÊòØ‰∏Ä‰∏™ÈùûÂ∏∏ÁâπÊÆäÁöÑÈòüÂàó, Âú®ÂæàÂ§öÊÉÖÂÜµ‰∏ãÂèØ‰ª•ÊääÂÆÉÁÆÄÂçïÁêÜËß£‰∏∫‰∏Ä‰∏™Êó†Ê≥ïÂ≠òÂÇ®ÂÖÉÁ¥†ÁöÑÈòüÂàó. Âú®ÂÆûÈôÖ‰ΩøÁî®‰∏≠ÂæàÂ∞ë‰ΩøÁî®.ËøôÁ±ªÁ∫øÁ®ãÊØîËæÉÈÄÇÂêàÊâßË°åÂ§ßÈáèÁöÑËÄóÊó∂ËæÉÂ∞ëÁöÑ‰ªªÂä° 123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 3. ScheduledThreadPool ÈÄöËøáExecutors#newScheduledThreadPool()ÊñπÊ≥ïÊù•ÂàõÂª∫. ÂÆÉÁöÑÊ†∏ÂøÉÁ∫øÁ®ãÊï∞ÈáèÊòØÂõ∫ÂÆöÁöÑ, ËÄåÈùûÊ†∏ÂøÉÁ∫øÁ®ãÊï∞ÊòØÊ≤°ÊúâÈôêÂà∂ÁöÑ, Âπ∂‰∏îÂΩìÈùûÊ†∏ÂøÉÁ∫øÁ®ãÈó≤ÁΩÆÊó∂‰ºöÁ´ãÂàªË¢´ÂõûÊî∂Êéâ. ËøôÁ±ªÁ∫øÁ®ãÊ±†Áî®‰∫éÊâßË°åÂÆöÊó∂‰ªªÂä°ÂíåÂÖ∑ÊúâÂõ∫ÂÆöÂë®ÊúüÁöÑÈáçÂ§ç‰ªªÂä° 12345678910111213141516171819202122232425 /** * Creates a thread pool that can schedule commands to run after a * given delay, or to execute periodically. * @param corePoolSize the number of threads to keep in the pool, * even if they are idle * @return a newly created scheduled thread pool * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */ public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;/** * Creates a new &#123;@code ScheduledThreadPoolExecutor&#125; with the * given core pool size. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */ public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; 4. SingleThreadExecutor ÈÄöËøáExecutors#newSingleThreadPool()ÊñπÊ≥ïÊù•ÂàõÂª∫. ËøôÁ±ªÁ∫øÁ®ãÊ±†ÂÜÖÈÉ®Âè™Êúâ‰∏Ä‰∏™Ê†∏ÂøÉÁ∫øÁ®ã, ÂÆÉÁ°Æ‰øùÊâÄÊúâÁöÑ‰ªªÂä°ÈÉΩÂú®Âêå‰∏Ä‰∏™Á∫øÁ®ã‰∏≠ÊåâÈ°∫Â∫èÊâßË°å. ËøôÁ±ªÁ∫øÁ®ãÊ±†ÊÑè‰πâÂú®‰∫éÁªü‰∏ÄÊâÄÊúâÁöÑÂ§ñÁïå‰ªªÂä°Âà∞‰∏Ä‰∏™Á∫øÁ®ã‰∏≠, Ëøô‰ΩøÂæóÂú®Ëøô‰∫õ‰ªªÂä°‰πãÈó¥‰∏çÈúÄË¶ÅÂ§ÑÁêÜÁ∫øÁ®ãÂêåÊ≠•ÁöÑÈóÆÈ¢ò 12345678910111213141516171819/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.) Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */ public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>Á∫øÁ®ãÂíåÁ∫øÁ®ãÊ±†</tag>
        <tag>AsyncTask</tag>
        <tag>HandlerThread</tag>
        <tag>IntentService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActivityÂêØÂä®ÂàÜÊûê]]></title>
    <url>%2F2018%2F03%2F14%2FActivity%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Âü∫‰∫éAndroid 6.0ÁöÑÊ∫êÁ†ÅÂâñÊûêÔºå ÂàÜÊûêandroid ActivityÂêØÂä®ÊµÅÁ®ãÔºåÁõ∏ÂÖ≥Ê∫êÁ†ÅÔºö 1234567891011121314151617frameworks/base/services/core/java/com/android/server/am/ - ActivityManagerService.java - ActivityStackSupervisor.java - ActivityStack.java - ActivityRecord.java - ProcessRecord.javaframeworks/base/core/java/android/app/ - IActivityManager.java - ActivityManagerNative.java (ÂÜÖÂê´AMP) - ActivityManager.java - IApplicationThread.java - ApplicationThreadNative.java (ÂÜÖÂê´ATP) - ActivityThread.java (ÂÜÖÂê´ApplicationThread) - ContextImpl.java ‰∏Ä. Ê¶ÇËø∞startActivityÁöÑÊï¥‰ΩìÊµÅÁ®ã‰∏éstartServiceÂêØÂä®ËøáÁ®ãÂàÜÊûêÈùûÂ∏∏Áõ∏ËøëÔºå‰ΩÜÊØîServiceÂêØÂä®Êõ¥‰∏∫Â§çÊùÇÔºåÂ§ö‰∫Üstack/task‰ª•ÂèäUIÁöÑÁõ∏ÂÖ≥ÂÜÖÂÆπ‰ª•ÂèäActivityÁöÑÁîüÂëΩÂë®ÊúüÊõ¥‰∏∫‰∏∞ÂØå„ÄÇ ActivityÂêØÂä®ÂèëËµ∑ÂêéÔºåÈÄöËøáBinderÊúÄÁªà‰∫§Áî±systemËøõÁ®ã‰∏≠ÁöÑAMSÊù•ÂÆåÊàêÔºåÂàôÂêØÂä®ÊµÅÁ®ãÂ¶Ç‰∏ãÂõæÔºö Êé•‰∏ãÊù•Ôºå‰ªéÊ∫êÁ†ÅÊù•ËØ¥ËØ¥ÊØè‰∏™ËøáÁ®ã„ÄÇ ‰∫å. ÂêØÂä®ÊµÅÁ®ã2.1 Activity.startActivity[-&gt; Activity.java] 123456789101112public void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; //[ËßÅÂ∞èËäÇ2.2] startActivityForResult(intent, -1); &#125;&#125; 2.2 startActivityForResult[-&gt; Activity.java] 12345678910111213141516171819202122232425public void startActivityForResult(Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null);&#125;public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; //[ËßÅÂ∞èËäÇ2.3] Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; //Ê≠§Êó∂requestCode =-1 if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); &#125; else &#123; ... &#125;&#125; execStartActivity()ÊñπÊ≥ïÁöÑÂèÇÊï∞: mAppThread: Êï∞ÊçÆÁ±ªÂûã‰∏∫ApplicationThreadÔºåÈÄöËøámMainThread.getApplicationThread()ÊñπÊ≥ïËé∑Âèñ„ÄÇ mToken: Êï∞ÊçÆÁ±ªÂûã‰∏∫IBinder. 2.3 execStartActivity[-&gt; Instrumentation.java] 12345678910111213141516171819202122232425262728293031323334353637public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ... if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; //ÂΩìËØ•monitorÈòªÂ°ûactivityÂêØÂä®,ÂàôÁõ¥Êé•ËøîÂõû if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); //[ËßÅÂ∞èËäÇ2.4] int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //Ê£ÄÊü•activityÊòØÂê¶ÂêØÂä®ÊàêÂäü checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null;&#125; ÂÖ≥‰∫é ActivityManagerNative.getDefault()ËøîÂõûÁöÑÊòØActivityManagerProxyÂØπË±°(Ë∑®ËøõÁ®ãËøîÂõûStub.ProxyÂØπË±°). Ê≠§Â§ÑstartActivity()ÁöÑÂÖ±Êúâ10‰∏™ÂèÇÊï∞, ‰∏ãÈù¢ËØ¥ËØ¥ÊØè‰∏™ÂèÇÊï∞‰º†ÈÄíAMP.startActivity()ÊØè‰∏ÄÈ°πÁöÑÂØπÂ∫îÂÄº: caller: ÂΩìÂâçÂ∫îÁî®ÁöÑApplicationThreadÂØπË±°mAppThread; callingPackage: Ë∞ÉÁî®ÂΩìÂâçContextImpl.getBasePackageName(),Ëé∑ÂèñÂΩìÂâçActivityÊâÄÂú®ÂåÖÂêç; intent: Ëøô‰æøÊòØÂêØÂä®ActivityÊó∂,‰º†ÈÄíËøáÊù•ÁöÑÂèÇÊï∞; resolvedType: Ë∞ÉÁî®intent.resolveTypeIfNeededËÄåËé∑Âèñ; resultTo: Êù•Ëá™‰∫éÂΩìÂâçActivity.mToken resultWho: Êù•Ëá™‰∫éÂΩìÂâçActivity.mEmbeddedID requestCode = -1; startFlags = 0; profilerInfo = null; options = null; 2.4 AMP.startActivity[-&gt; ActivityManagerNative.java :: ActivityManagerProxy] 123456789101112131415161718192021222324252627282930313233343536class ActivityManagerProxy implements IActivityManager &#123; ... public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; if (options != null) &#123; data.writeInt(1); options.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; //[ËßÅÊµÅÁ®ã2.5] mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; ...&#125; AMPÁªèËøábinder IPC,ËøõÂÖ•ActivityManagerNative(ÁÆÄÁß∞AMN)„ÄÇÊé•‰∏ãÊù•Á®ãÂ∫èËøõÂÖ•‰∫Üsystem_severËøõÁ®ãÔºåÂºÄÂßãÁªßÁª≠ÊâßË°å„ÄÇ 2.5 AMN.onTransact[-&gt; ActivityManagerNative.java] 123456789101112131415161718192021222324252627public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); String callingPackage = data.readString(); Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); IBinder resultTo = data.readStrongBinder(); String resultWho = data.readString(); int requestCode = data.readInt(); int startFlags = data.readInt(); ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; Bundle options = data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null; //[ËßÅÊµÅÁ®ã2.6] int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125; ... &#125; &#125; 2.6 AMS.startActivity[-&gt; ActivityManagerService.java] 123456789101112131415public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); //[ËßÅÂ∞èËäÇ2.7] return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null);&#125; Ê≠§Â§ÑmStackSupervisorÁöÑÊï∞ÊçÆÁ±ªÂûã‰∏∫ActivityStackSupervisor 2.7 ASS.startActivityMayWaitÂΩìÁ®ãÂ∫èËøêË°åÂà∞ËøôÈáåÊó∂, ASS.startActivityMayWaitÁöÑÂêÑ‰∏™ÂèÇÊï∞ÂèñÂÄºÂ¶Ç‰∏ã: caller = ApplicationThreadProxy, Áî®‰∫éË∑üË∞ÉÁî®ËÄÖËøõÁ®ãApplicationThreadËøõË°åÈÄö‰ø°ÁöÑbinder‰ª£ÁêÜÁ±ª. callingUid = -1; callingPackage = ContextImpl.getBasePackageName(),Ëé∑ÂèñË∞ÉÁî®ËÄÖActivityÊâÄÂú®ÂåÖÂêç intent: ËøôÊòØÂêØÂä®ActivityÊó∂‰º†ÈÄíËøáÊù•ÁöÑÂèÇÊï∞; resolvedType = intent.resolveTypeIfNeeded voiceSession = null; voiceInteractor = null; resultTo = Activity.mToken, ÂÖ∂‰∏≠ActivityÊòØÊåáË∞ÉÁî®ËÄÖÊâÄÂú®Activity, mTokenÂØπË±°‰øùÂ≠òËá™Â∑±ÊâÄÂ§ÑÁöÑActivityRecord‰ø°ÊÅØ resultWho = Activity.mEmbeddedID, ÂÖ∂‰∏≠ActivityÊòØÊåáË∞ÉÁî®ËÄÖÊâÄÂú®Activity requestCode = -1; startFlags = 0; profilerInfo = null; outResult = null; config = null; options = null; ignoreTargetSecurity = false; userId = AMS.handleIncomingUser, ÂΩìË∞ÉÁî®ËÄÖuserIdË∑üÂΩìÂâçÂ§Ñ‰∫éÂêå‰∏Ä‰∏™userId,ÂàôÁõ¥Êé•ËøîÂõûËØ•userId;ÂΩì‰∏çÁõ∏Á≠âÊó∂ÂàôÊ†πÊçÆË∞ÉÁî®ËÄÖuserIdÊù•ÂÜ≥ÂÆöÊòØÂê¶ÈúÄË¶ÅÂ∞ÜcallingUserIdËΩ¨Êç¢‰∏∫mCurrentUserId. iContainer = null; inTask = null; ÂÜçÊù•ÁúãÁúãËøô‰∏™ÊñπÊ≥ïÁöÑÊ∫êÁ†Å: [-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; ... boolean componentSpecified = intent.getComponent() != null; //ÂàõÂª∫Êñ∞ÁöÑIntentÂØπË±°ÔºåÂç≥‰æøintentË¢´‰øÆÊîπ‰πü‰∏çÂèóÂΩ±Âìç intent = new Intent(intent); //Êî∂ÈõÜIntentÊâÄÊåáÂêëÁöÑActivity‰ø°ÊÅØ, ÂΩìÂ≠òÂú®Â§ö‰∏™ÂèØ‰æõÈÄâÊã©ÁöÑActivity,ÂàôÁõ¥Êé•ÂêëÁî®Êà∑ÂºπÂá∫resolveActivity [ËßÅ2.7.1] ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId); ActivityContainer container = (ActivityContainer)iContainer; synchronized (mService) &#123; if (container != null &amp;&amp; container.mParentActivity != null &amp;&amp; container.mParentActivity.state != RESUMED) &#123; ... //‰∏çËøõÂÖ•ËØ•ÂàÜÊîØ, container == nul &#125; final int realCallingPid = Binder.getCallingPid(); final int realCallingUid = Binder.getCallingUid(); int callingPid; if (callingUid &gt;= 0) &#123; callingPid = -1; &#125; else if (caller == null) &#123; callingPid = realCallingPid; callingUid = realCallingUid; &#125; else &#123; callingPid = callingUid = -1; &#125; final ActivityStack stack; if (container == null || container.mStack.isOnHomeDisplay()) &#123; stack = mFocusedStack; // ËøõÂÖ•ËØ•ÂàÜÊîØ &#125; else &#123; stack = container.mStack; &#125; //Ê≠§Êó∂mConfigWillChange = false stack.mConfigWillChange = config != null &amp;&amp; mService.mConfiguration.diff(config) != 0; final long origId = Binder.clearCallingIdentity(); if (aInfo != null &amp;&amp; (aInfo.applicationInfo.privateFlags &amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; // heavy-weightËøõÁ®ãÂ§ÑÁêÜÊµÅÁ®ã, ‰∏ÄËà¨ÊÉÖÂÜµ‰∏ã‰∏çËøõÂÖ•ËØ•ÂàÜÊîØ if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123; ... &#125; &#125; //[ËßÅÊµÅÁ®ã2.8] int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); Binder.restoreCallingIdentity(origId); if (stack.mConfigWillChange) &#123; ... //‰∏çËøõÂÖ•ËØ•ÂàÜÊîØ &#125; if (outResult != null) &#123; ... //‰∏çËøõÂÖ•ËØ•ÂàÜÊîØ &#125; return res; &#125;&#125; ËØ•ËøáÁ®ã‰∏ªË¶ÅÂäüËÉΩÔºöÈÄöËøáresolveActivityÊù•Ëé∑ÂèñActivityInfo‰ø°ÊÅØ, ÁÑ∂ÂêéÂÜçËøõÂÖ•ASS.startActivityLocked().ÂÖàÊù•ÁúãÁúã 2.7.1 ASS.resolveActivity12345678910111213141516171819// startFlags = 0; profilerInfo = null; userId‰ª£Ë°®caller UserIdActivityInfo resolveActivity(Intent intent, String resolvedType, int startFlags, ProfilerInfo profilerInfo, int userId) &#123; ActivityInfo aInfo; ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent( intent, resolvedType, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS, userId); aInfo = rInfo != null ? rInfo.activityInfo : null; if (aInfo != null) &#123; intent.setComponent(new ComponentName( aInfo.applicationInfo.packageName, aInfo.name)); if (!aInfo.processName.equals("system")) &#123; ... //ÂØπ‰∫éÈùûsystemËøõÁ®ãÔºåÊ†πÊçÆflagsÊù•ËÆæÁΩÆÁõ∏Â∫îÁöÑdebug‰ø°ÊÅØ &#125; &#125; return aInfo;&#125; ActivityManagerÁ±ªÊúâÂ¶Ç‰∏ã4‰∏™flagsÁî®‰∫éË∞ÉËØïÔºö START_FLAG_DEBUGÔºöÁî®‰∫éË∞ÉËØïdebug app START_FLAG_OPENGL_TRACESÔºöÁî®‰∫éË∞ÉËØïOpenGL tracing START_FLAG_NATIVE_DEBUGGINGÔºöÁî®‰∫éË∞ÉËØïnative START_FLAG_TRACK_ALLOCATION: Áî®‰∫éË∞ÉËØïallocation tracking 2.7.2 PKMS.resolveIntentAppGlobals.getPackageManager()ÁªèËøáÂáΩÊï∞Â±ÇÂ±ÇË∞ÉÁî®ÔºåËé∑ÂèñÁöÑÊòØApplicationPackageManagerÂØπË±°„ÄÇÁªèËøábinder IPCË∞ÉÁî®ÔºåÊúÄÁªà‰ºöË∞ÉÁî®PackageManagerServiceÂØπË±°„ÄÇÊïÖÊ≠§Êó∂Ë∞ÉÁî®ÊñπÊ≥ï‰∏∫PMS.resolveIntent(). [-&gt; PackageManagerService.java] 12345678public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return null; enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "resolve intent"); //[ËßÅÊµÅÁ®ã2.7.3] List&lt;ResolveInfo&gt; query = queryIntentActivities(intent, resolvedType, flags, userId); //Ê†πÊçÆpriorityÔºåpreferredÈÄâÊã©ÊúÄ‰Ω≥ÁöÑActivity return chooseBestActivity(intent, resolvedType, flags, query, userId); &#125; 2.7.3 PMS.queryIntentActivities123456789101112131415161718192021222324public List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) &#123; ... ComponentName comp = intent.getComponent(); if (comp == null) &#123; if (intent.getSelector() != null) &#123; intent = intent.getSelector(); comp = intent.getComponent(); &#125; &#125; if (comp != null) &#123; final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1); //Ëé∑ÂèñActivity‰ø°ÊÅØ final ActivityInfo ai = getActivityInfo(comp, flags, userId); if (ai != null) &#123; final ResolveInfo ri = new ResolveInfo(); ri.activityInfo = ai; list.add(ri); &#125; return list; &#125; ...&#125; ASS.resolveActivity()ÊñπÊ≥ïÁöÑÊ†∏ÂøÉÂäüËÉΩÊòØÊâæÂà∞Áõ∏Â∫îÁöÑActivityÁªÑ‰ª∂ÔºåÂπ∂‰øùÂ≠òÂà∞intentÂØπË±°„ÄÇ 2.8 ASS.startActivityLocked[-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; //Ëé∑ÂèñË∞ÉÁî®ËÄÖÁöÑËøõÁ®ãËÆ∞ÂΩïÂØπË±° ProcessRecord callerApp = null; if (caller != null) &#123; callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; if (resultTo != null) &#123; //Ëé∑ÂèñË∞ÉÁî®ËÄÖÊâÄÂú®ÁöÑActivity sourceRecord = isInAnyStackLocked(resultTo); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; ... //requestCode = -1 Âàô‰∏çËøõÂÖ• &#125; &#125; &#125; final int launchFlags = intent.getFlags(); if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; ... // activityÊâßË°åÁªìÊûúÁöÑËøîÂõûÁî±Ê∫êActivityËΩ¨Êç¢Âà∞Êñ∞Activity, ‰∏çÈúÄË¶ÅËøîÂõûÁªìÊûúÂàô‰∏ç‰ºöËøõÂÖ•ËØ•ÂàÜÊîØ &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; //‰ªéIntent‰∏≠Êó†Ê≥ïÊâæÂà∞Áõ∏Â∫îÁöÑComponent err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; //‰ªéIntent‰∏≠Êó†Ê≥ïÊâæÂà∞Áõ∏Â∫îÁöÑActivityInfo err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; !isCurrentProfileLocked(userId) &amp;&amp; (aInfo.flags &amp; FLAG_SHOW_FOR_ALL_USERS) == 0) &#123; //Â∞ùËØïÂêØÂä®‰∏Ä‰∏™ÂêéÂè∞Activity, ‰ΩÜËØ•ActivityÂØπÂΩìÂâçÁî®Êà∑‰∏çÂèØËßÅ err = ActivityManager.START_NOT_CURRENT_USER_ACTIVITY; &#125; ... //ÊâßË°åÂêéresultStack = null final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack; ... //ÊùÉÈôêÊ£ÄÊü• // ActivityController‰∏ç‰∏∫Á©∫ÁöÑÊÉÖÂÜµÔºåÊØîÂ¶ÇmonkeyÊµãËØïËøáÁ®ã if (mService.mController != null) &#123; Intent watchIntent = intent.cloneFilter(); abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); &#125; if (abort) &#123; ... //ÊùÉÈôêÊ£ÄÊü•‰∏çÊª°Ë∂≥,ÊâçËøõÂÖ•ËØ•ÂàÜÊîØÂàôÁõ¥Êé•ËøîÂõûÔºõ return ActivityManager.START_SUCCESS; &#125; // ÂàõÂª∫ActivityËÆ∞ÂΩïÂØπË±° ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, this, container, options); if (outActivity != null) &#123; outActivity[0] = r; &#125; if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123; r.appTimeTracker = sourceRecord.appTimeTracker; &#125; // Â∞ÜmFocusedStackËµã‰∫àÂΩìÂâçstack final ActivityStack stack = mFocusedStack; if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123; // ÂâçÂè∞stackËøòÊ≤°ÊúâresumeÁä∂ÊÄÅÁöÑActivityÊó∂, ÂàôÊ£ÄÊü•appÂàáÊç¢ÊòØÂê¶ÂÖÅËÆ∏ [ËßÅÊµÅÁ®ã2.8.1] if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, realCallingPid, realCallingUid, "Activity start")) &#123; PendingActivityLaunch pal = new PendingActivityLaunch(r, sourceRecord, startFlags, stack); // ÂΩì‰∏çÂÖÅËÆ∏ÂàáÊç¢,ÂàôÊääË¶ÅÂêØÂä®ÁöÑActivityÊ∑ªÂä†Âà∞mPendingActivityLaunchesÂØπË±°, Âπ∂‰∏îÁõ¥Êé•ËøîÂõû. mPendingActivityLaunches.add(pal); ActivityOptions.abort(options); return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; if (mService.mDidAppSwitch) &#123; //‰ªé‰∏äÊ¨°Á¶ÅÊ≠¢appÂàáÊç¢‰ª•Êù•,ËøôÊòØÁ¨¨‰∫åÊ¨°ÂÖÅËÆ∏appÂàáÊç¢,Âõ†Ê≠§Â∞ÜÂÖÅËÆ∏ÂàáÊç¢Êó∂Èó¥ËÆæÁΩÆ‰∏∫0,ÂàôË°®Á§∫ÂèØ‰ª•‰ªªÊÑèÂàáÊç¢app mService.mAppSwitchesAllowedTime = 0; &#125; else &#123; mService.mDidAppSwitch = true; &#125; //Â§ÑÁêÜ pendind ActivityÁöÑÂêØÂä®, Ëøô‰∫õActivityÊòØÁî±‰∫éapp switchÁ¶ÅÁî®‰ªéËÄåË¢´holdÁöÑÁ≠âÂæÖÂêØÂä®activity [ËßÅÊµÅÁ®ã2.8.2] doPendingActivityLaunchesLocked(false); //[ËßÅÊµÅÁ®ã2.9] err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); if (err &lt; 0) &#123; notifyActivityDrawnForKeyguard(); &#125; return err;&#125; ÂÖ∂‰∏≠Êúâ‰∏§‰∏™ËøîÂõûÂÄº‰ª£Ë°®ÂêØÂä®ActivityÂ§±Ë¥•Ôºö START_INTENT_NOT_RESOLVED: ‰ªéIntent‰∏≠Êó†Ê≥ïÊâæÂà∞Áõ∏Â∫îÁöÑComponentÊàñËÄÖActivityInfo START_NOT_CURRENT_USER_ACTIVITYÔºöËØ•ActivityÂØπÂΩìÂâçÁî®Êà∑‰∏çÂèØËßÅ 2.8.1 AMS.checkAppSwitchAllowedLocked1234567891011121314151617181920212223boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid, int callingPid, int callingUid, String name) &#123; if (mAppSwitchesAllowedTime &lt; SystemClock.uptimeMillis()) &#123; return true; &#125; int perm = checkComponentPermission( android.Manifest.permission.STOP_APP_SWITCHES, sourcePid, sourceUid, -1, true); if (perm == PackageManager.PERMISSION_GRANTED) &#123; return true; &#125; if (callingUid != -1 &amp;&amp; callingUid != sourceUid) &#123; perm = checkComponentPermission( android.Manifest.permission.STOP_APP_SWITCHES, callingPid, callingUid, -1, true); if (perm == PackageManager.PERMISSION_GRANTED) &#123; return true; &#125; &#125; return false;&#125; ÂΩìmAppSwitchesAllowedTimeÊó∂Èó¥Â∞è‰∫éÂΩìÂâçÊó∂Èïø,ÊàñËÄÖÂÖ∑ÊúâSTOP_APP_SWITCHESÁöÑÊùÉÈôê,ÂàôÂÖÅËÆ∏appÂèëÁîüÂàáÊç¢Êìç‰Ωú. ÂÖ∂‰∏≠mAppSwitchesAllowedTime, Âú®AMS.stopAppSwitches()ÁöÑËøáÁ®ã‰∏≠‰ºöËÆæÁΩÆ‰∏∫:mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME. Á¶ÅÊ≠¢appÂàáÊç¢ÁöÑtimeoutÊó∂Èïø‰∏∫5s(APP_SWITCH_DELAY_TIME = 5s). ÂΩìÂèëÈÄÅ5ÁßíË∂ÖÊó∂ÊàñËÄÖÊâßË°åAMS.resumeAppSwitches()ËøáÁ®ã‰ºöÂ∞ÜmAppSwitchesAllowedTimeËÆæÁΩÆ0, ÈÉΩ‰ºöÂºÄÂêØÂÖÅËÆ∏appÊâßË°åÂàáÊç¢ÁöÑÊìç‰Ωú.Âè¶Â§ñ,Á¶ÅÊ≠¢AppÂàáÊç¢ÁöÑÊìç‰Ωú,ÂØπ‰∫éÂêå‰∏Ä‰∏™appÊòØ‰∏çÂèóÂΩ±ÂìçÁöÑ,ÊúâÂÖ¥Ë∂£ÂèØ‰ª•Ëøõ‰∏ÄÊ≠•Êü•ÁúãcheckComponentPermissionËøáÁ®ã. 2.8.2 ASS.doPendingActivityLaunchesLocked[-&gt; ActivityStackSupervisor.java] 123456789101112final void doPendingActivityLaunchesLocked(boolean doResume) &#123; while (!mPendingActivityLaunches.isEmpty()) &#123; PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); try &#123; //[ËßÅÊµÅÁ®ã2.9] startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags, doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null); &#125; catch (Exception e) &#123; ... &#125; &#125;&#125; mPendingActivityLaunchesËÆ∞ÂΩïÁùÄÊâÄÊúâÂ∞ÜË¶ÅÂêØÂä®ÁöÑActivity, ÊòØÁî±‰∫éÂú®startActivityLockedÁöÑËøáÁ®ãÊó∂AppÂàáÊç¢ÂäüËÉΩË¢´Á¶ÅÊ≠¢, ‰πüÂ∞±ÊòØ‰∏çËøêË°åÂàáÊç¢Activity, ÈÇ£‰πàÊ≠§Êó∂‰æø‰ºöÊääÁõ∏Â∫îÁöÑActivityÂä†ÂÖ•Âà∞mPendingActivityLaunchesÈòüÂàó. ËØ•ÈòüÂàóÁöÑÊàêÂëòÂú®ÊâßË°åÂÆådoPendingActivityLaunchesLocked‰æø‰ºöÊ∏ÖÁ©∫. ÂêØÂä®mPendingActivityLaunches‰∏≠ÊâÄÊúâÁöÑActivity, Áî±‰∫édoResume = false, ÈÇ£‰πàËøô‰∫õactivtityÂπ∂‰∏ç‰ºöËøõÂÖ•resumeÁä∂ÊÄÅ,ËÄåÊòØËÆæÁΩÆdelayedResume = true, ‰ºöÂª∂Ëøüresume. 2.9 ASS.startActivityUncheckedLocked[-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404// sourceRecordÊòØÊåáË∞ÉÁî®ËÄÖÔºå rÊòØÊåáÊú¨Ê¨°Â∞ÜË¶ÅÂêØÂä®ÁöÑActivityfinal int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, Bundle options, TaskRecord inTask) &#123; final Intent intent = r.intent; final int callingUid = r.launchedFromUid; if (inTask != null &amp;&amp; !inTask.inRecents) &#123; inTask = null; &#125; final boolean launchSingleTop = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP; final boolean launchSingleInstance = r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE; final boolean launchSingleTask = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK; int launchFlags = intent.getFlags(); // ÂΩìintentÂíåactivity manifestÂ≠òÂú®ÂÜ≤Á™ÅÔºåÂàômanifest‰ºòÂÖà if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0 &amp;&amp; (launchSingleInstance || launchSingleTask)) &#123; launchFlags &amp;= ~(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK); &#125; else &#123; ... &#125; final boolean launchTaskBehind = r.mLaunchTaskBehind &amp;&amp; !launchSingleTask &amp;&amp; !launchSingleInstance &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0; if (r.resultTo != null &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; r.resultTo.task.stack != null) &#123; r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); r.resultTo = null; &#125; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0 &amp;&amp; r.resultTo == null) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; if (launchTaskBehind || r.info.documentLaunchMode == ActivityInfo.DOCUMENT_LAUNCH_ALWAYS) &#123; launchFlags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK; &#125; &#125; mUserLeaving = (launchFlags &amp; Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0; //ÂΩìÊú¨Ê¨°‰∏çÈúÄË¶ÅresumeÔºåÂàôËÆæÁΩÆ‰∏∫Âª∂ËøüresumeÁöÑÁä∂ÊÄÅ if (!doResume) &#123; r.delayedResume = true; &#125; ActivityRecord notTop = (launchFlags &amp; Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null; if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; ActivityRecord checkedCaller = sourceRecord; if (checkedCaller == null) &#123; checkedCaller = mFocusedStack.topRunningNonDelayedActivityLocked(notTop); &#125; if (!checkedCaller.realActivity.equals(r.realActivity)) &#123; //Ë∞ÉÁî®ËÄÖ ‰∏éÂ∞ÜË¶ÅÂêØÂä®ÁöÑActivity‰∏çÁõ∏ÂêåÊó∂ÔºåËøõÂÖ•ËØ•ÂàÜÊîØ„ÄÇ startFlags &amp;= ~ActivityManager.START_FLAG_ONLY_IF_NEEDED; &#125; &#125; boolean addingToTask = false; TaskRecord reuseTask = null; //ÂΩìË∞ÉÁî®ËÄÖ‰∏çÊòØÊù•Ëá™activityÔºåËÄåÊòØÊòéÁ°ÆÊåáÂÆötaskÁöÑÊÉÖÂÜµ„ÄÇ if (sourceRecord == null &amp;&amp; inTask != null &amp;&amp; inTask.stack != null) &#123; ... //ÁõÆÂâçsourceRecord‰∏ç‰∏∫Á©∫ÔºåÂàô‰∏çËøõÂÖ•ËØ•ÂàÜÊîØ &#125; else &#123; inTask = null; &#125; if (inTask == null) &#123; if (sourceRecord == null) &#123; //Ë∞ÉÁî®ËÄÖÂπ∂‰∏çÊòØActivity context,ÂàôÂº∫Âà∂ÂàõÂª∫Êñ∞task if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; inTask == null) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; &#125; else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; //Ë∞ÉÁî®ËÄÖactivityÂ∏¶Êúâsingle instanceÔºåÂàôÂàõÂª∫Êñ∞task launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; else if (launchSingleInstance || launchSingleTask) &#123; //ÁõÆÊ†áactivityÂ∏¶Êúâsingle instanceÊàñËÄÖsingle taskÔºåÂàôÂàõÂª∫Êñ∞task launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; &#125; ActivityInfo newTaskInfo = null; Intent newTaskIntent = null; ActivityStack sourceStack; if (sourceRecord != null) &#123; if (sourceRecord.finishing) &#123; //Ë∞ÉÁî®ËÄÖÂ§Ñ‰∫éÂç≥Â∞ÜfinishÁä∂ÊÄÅÔºåÂàôÂàõÂª∫Êñ∞task if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; newTaskInfo = sourceRecord.info; newTaskIntent = sourceRecord.task.intent; &#125; sourceRecord = null; sourceStack = null; &#125; else &#123; //ÂΩìË∞ÉÁî®ËÄÖActivity‰∏ç‰∏∫Á©∫Ôºå‰∏î‰∏çÂ§Ñ‰∫éfinishingÁä∂ÊÄÅÔºåÂàôÂÖ∂ÊâÄÂú®Ê†àËµã‰∫ésourceStack sourceStack = sourceRecord.task.stack; &#125; &#125; else &#123; sourceStack = null; &#125; boolean movedHome = false; ActivityStack targetStack; intent.setFlags(launchFlags); final boolean noAnimation = (launchFlags &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0; if (((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || launchSingleInstance || launchSingleTask) &#123; if (inTask == null &amp;&amp; r.resultTo == null) &#123; //‰ªémActivityDisplaysÂºÄÂßãÊü•ËØ¢ÊòØÂê¶ÊúâÁõ∏Â∫îActivityRecord ActivityRecord intentActivity = !launchSingleInstance ? findTaskLocked(r) : findActivityLocked(intent, r.info); if (intentActivity != null) &#123; if (isLockTaskModeViolation(intentActivity.task, (launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; if (r.task == null) &#123; r.task = intentActivity.task; &#125; if (intentActivity.task.intent == null) &#123; intentActivity.task.setIntent(r); &#125; targetStack = intentActivity.task.stack; targetStack.mLastPausedActivity = null; final ActivityStack focusStack = getFocusedStack(); ActivityRecord curTop = (focusStack == null) ? null : focusStack.topRunningNonDelayedActivityLocked(notTop); boolean movedToFront = false; if (curTop != null &amp;&amp; (curTop.task != intentActivity.task || curTop.task != focusStack.topTask())) &#123; r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT); if (sourceRecord == null || (sourceStack.topActivity() != null &amp;&amp; sourceStack.topActivity().task == sourceRecord.task)) &#123; if (launchTaskBehind &amp;&amp; sourceRecord != null) &#123; intentActivity.setTaskToAffiliateWith(sourceRecord.task); &#125; movedHome = true; //Â∞ÜËØ•taskÁßªËá≥ÂâçÂè∞ targetStack.moveTaskToFrontLocked(intentActivity.task, noAnimation, options, r.appTimeTracker, "bringingFoundTaskToFront"); movedToFront = true; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; //Â∞ÜtoReturnToËÆæÁΩÆ‰∏∫home intentActivity.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; options = null; &#125; &#125; if (!movedToFront) &#123; targetStack.moveToFront("intentActivityFound"); &#125; if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; //ÈáçÁΩÆÁõÆÊ†átask intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r); &#125; if ((startFlags &amp; ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; if (doResume) &#123; resumeTopActivitiesLocked(targetStack, null, options); //ÂΩìÊ≤°ÊúâÂêØÂä®Ëá≥ÂâçÂè∞ÔºåÂàôÈÄöÁü•Keyguard if (!movedToFront) &#123; notifyActivityDrawnForKeyguard(); &#125; &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) &#123; reuseTask = intentActivity.task; //ÁßªÈô§ÊâÄÊúâË∑üÂ∑≤Â≠òÂú®ÁöÑtaskÊúâÂÖ≥ËÅîÁöÑactivity reuseTask.performClearTaskLocked(); reuseTask.setIntent(r); &#125; else if ((launchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0 || launchSingleInstance || launchSingleTask) &#123; ActivityRecord top = intentActivity.task.performClearTaskLocked(r, launchFlags); if (top != null) &#123; if (top.frontOfTask) &#123; top.task.setIntent(r); &#125; //Ëß¶ÂèëonNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); &#125; else &#123; sourceRecord = intentActivity; TaskRecord task = sourceRecord.task; if (task != null &amp;&amp; task.stack == null) &#123; targetStack = computeStackFocus(sourceRecord, false /* newTask */); targetStack.addTask( task, !launchTaskBehind /* toTop */, false /* moving */); &#125; &#125; &#125; else if (r.realActivity.equals(intentActivity.task.realActivity)) &#123; if (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop) &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) &#123; if (intentActivity.frontOfTask) &#123; intentActivity.task.setIntent(r); &#125; //Ëß¶ÂèëonNewIntent() intentActivity.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); &#125; else if (!r.intent.filterEquals(intentActivity.task.intent)) &#123; addingToTask = true; sourceRecord = intentActivity; &#125; &#125; else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) &#123; addingToTask = true; sourceRecord = intentActivity; &#125; else if (!intentActivity.task.rootWasReset) &#123; intentActivity.task.setIntent(r); &#125; if (!addingToTask &amp;&amp; reuseTask == null) &#123; if (doResume) &#123; targetStack.resumeTopActivityLocked(null, options); if (!movedToFront) &#123; notifyActivityDrawnForKeyguard(); &#125; &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_TASK_TO_FRONT; &#125; &#125; &#125; &#125; if (r.packageName != null) &#123; //ÂΩìÂêØÂä®ÁöÑactivityË∑üÂâçÂè∞ÊòæÁ§∫ÊòØÂêå‰∏Ä‰∏™ÁöÑÊÉÖÂÜµ ActivityStack topStack = mFocusedStack; ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop); if (top != null &amp;&amp; r.resultTo == null) &#123; if (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if (top.app != null &amp;&amp; top.app.thread != null) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; topStack.mLastPausedActivity = null; if (doResume) &#123; resumeTopActivitiesLocked(); &#125; ActivityOptions.abort(options); if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; &#125; //Ëß¶ÂèëonNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; &#125; &#125; &#125; else &#123; if (r.resultTo != null &amp;&amp; r.resultTo.task.stack != null) &#123; r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return ActivityManager.START_CLASS_NOT_FOUND; &#125; boolean newTask = false; boolean keepCurTransition = false; TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != null ? sourceRecord.task : null; if (r.resultTo == null &amp;&amp; inTask == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; targetStack = computeStackFocus(r, newTask); targetStack.moveToFront("startingNewTask"); if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, voiceSession, voiceInteractor, !launchTaskBehind /* toTop */), taskToAffiliate); &#125; else &#123; r.setTask(reuseTask, taskToAffiliate); &#125; if (isLockTaskModeViolation(r.task)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; if (!movedHome) &#123; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; &#125; &#125; else if (sourceRecord != null) &#123; final TaskRecord sourceTask = sourceRecord.task; if (isLockTaskModeViolation(sourceTask)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = sourceTask.stack; targetStack.moveToFront("sourceStackToFront"); final TaskRecord topTask = targetStack.topTask(); if (topTask != sourceTask) &#123; targetStack.moveTaskToFrontLocked(sourceTask, noAnimation, options, r.appTimeTracker, "sourceTaskToFront"); &#125; if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) &#123; ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags); keepCurTransition = true; if (top != null) &#123; //Ëß¶ÂèëonNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; ActivityOptions.abort(options); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) &#123; final ActivityRecord top = sourceTask.findActivityInHistoryLocked(r); if (top != null) &#123; final TaskRecord task = top.task; task.moveActivityToFrontLocked(top); top.updateOptionsLocked(options); //Ëß¶ÂèëonNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; r.setTask(sourceTask, null); &#125; else if (inTask != null) &#123; if (isLockTaskModeViolation(inTask)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = inTask.stack; targetStack.moveTaskToFrontLocked(inTask, noAnimation, options, r.appTimeTracker, "inTaskToFront"); ActivityRecord top = inTask.getTopActivity(); if (top != null &amp;&amp; top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; //Ëß¶ÂèëonNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; if (!addingToTask) &#123; ActivityOptions.abort(options); return ActivityManager.START_TASK_TO_FRONT; &#125; r.setTask(inTask, null); &#125; else &#123; targetStack = computeStackFocus(r, newTask); targetStack.moveToFront("addingToTopTask"); ActivityRecord prev = targetStack.topActivity(); r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(), r.info, intent, null, null, true), null); mWindowManager.moveTaskToTop(r.task.taskId); &#125; mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName, intent, r.getUriPermissionsLocked(), r.userId); if (sourceRecord != null &amp;&amp; sourceRecord.isRecentsActivity()) &#123; r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE); &#125; targetStack.mLastPausedActivity = null; //ÂàõÂª∫activity [ËßÅÊµÅÁ®ã2.10] targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) &#123; mService.setFocusedActivityLocked(r, "startedActivity"); &#125; return ActivityManager.START_SUCCESS;&#125; ÊâæÂà∞ÊàñÂàõÂª∫Êñ∞ÁöÑActivitÊâÄÂ±û‰∫éÁöÑTaskÂØπË±°Ôºå‰πãÂêéË∞ÉÁî®AS.startActivityLocked 2.9.1 Launch ModeÂÖàÊù•ËØ¥ËØ¥Âú®ActivityInfo.java‰∏≠ÂÆö‰πâ‰∫Ü4Á±ªLaunch ModeÔºö LAUNCH_MULTIPLE(standard)ÔºöÊúÄÂ∏∏ËßÅÁöÑÊÉÖÂΩ¢ÔºåÊØèÊ¨°ÂêØÂä®ActivityÈÉΩÊòØÂàõÂª∫Êñ∞ÁöÑActivity; LAUNCH_SINGLE_TOP: ÂΩìTaskÈ°∂ÈÉ®Â≠òÂú®Âêå‰∏Ä‰∏™ActivityÂàô‰∏çÂÜçÈáçÊñ∞ÂàõÂª∫ÔºõÂÖ∂‰ΩôÊÉÖÂÜµÂêå‰∏äÔºõ LAUNCH_SINGLE_TASKÔºöÂΩìTaskÊ†àÂ≠òÂú®Âêå‰∏Ä‰∏™Activity(‰∏çÂú®taskÈ°∂ÈÉ®)ÔºåÂàô‰∏çÈáçÊñ∞ÂàõÂª∫ÔºåËÄåÁßªÈô§ËØ•Activity‰∏äÈù¢ÂÖ∂‰ªñÁöÑActivityÔºõÂÖ∂‰ΩôÊÉÖÂÜµÂêå‰∏äÔºõ LAUNCH_SINGLE_INSTANCEÔºöÊØè‰∏™TaskÂè™Êúâ‰∏Ä‰∏™Activity. ÂÜçÊù•ËØ¥ËØ¥Âá†‰∏™Â∏∏ËßÅÁöÑflagÂê´‰πâÔºö FLAG_ACTIVITY_NEW_TASKÔºöÂ∞ÜActivityÊîæÂÖ•‰∏Ä‰∏™Êñ∞ÂêØÂä®ÁöÑTaskÔºõ FLAG_ACTIVITY_CLEAR_TASKÔºöÂêØÂä®ActivityÊó∂ÔºåÂ∞ÜÁõÆÊ†áActivityÂÖ≥ËÅîÁöÑTaskÊ∏ÖÈô§ÔºåÂÜçÂêØÂä®Êñ∞TaskÔºåÂ∞ÜËØ•ActivityÊîæÂÖ•ËØ•Task„ÄÇËØ•flagsË∑üFLAG_ACTIVITY_NEW_TASKÈÖçÂêà‰ΩøÁî®„ÄÇ FLAG_ACTIVITY_CLEAR_TOPÔºöÂêØÂä®ÈùûÊ†àÈ°∂ActivityÊó∂ÔºåÂÖàÊ∏ÖÈô§ËØ•Activity‰πã‰∏äÁöÑActivity„ÄÇ‰æãÂ¶ÇTaskÂ∑≤ÊúâA„ÄÅB„ÄÅC3‰∏™ActivityÔºåÂêØÂä®AÔºåÂàôÊ∏ÖÈô§BÔºåC„ÄÇÁ±ª‰ºº‰∫éSingleTop„ÄÇ ÊúÄÂêéÂÜçËØ¥ËØ¥ÔºöËÆæÁΩÆFLAG_ACTIVITY_NEW_TASKÁöÑÂá†‰∏™ÊÉÖÂÜµÔºö Ë∞ÉÁî®ËÄÖÂπ∂‰∏çÊòØActivity contextÔºõ Ë∞ÉÁî®ËÄÖactivityÂ∏¶Êúâsingle instanceÔºõ ÁõÆÊ†áactivityÂ∏¶Êúâsingle instanceÊàñËÄÖsingle taskÔºõ Ë∞ÉÁî®ËÄÖÂ§Ñ‰∫éfinishingÁä∂ÊÄÅÔºõ 2.10 AS.startActivityLocked[-&gt; ActivityStack.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) &#123; TaskRecord rTask = r.task; final int taskId = rTask.taskId; if (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == null || newTask)) &#123; //task‰∏≠ÁöÑ‰∏ä‰∏Ä‰∏™activityÂ∑≤Ë¢´ÁßªÈô§ÔºåÊàñËÄÖamsÈáçÁî®ËØ•task,ÂàôÂ∞ÜËØ•taskÁßªÂà∞È°∂ÈÉ® insertTaskAtTop(rTask, r); mWindowManager.moveTaskToTop(taskId); &#125; TaskRecord task = null; if (!newTask) &#123; boolean startIt = true; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; task = mTaskHistory.get(taskNdx); if (task.getTopActivity() == null) &#123; //ËØ•taskÊâÄÊúâactivityÈÉΩfinishing continue; &#125; if (task == r.task) &#123; if (!startIt) &#123; task.addActivityToTop(r); r.putInHistory(); mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); ActivityOptions.abort(options); return; &#125; break; &#125; else if (task.numFullscreen &gt; 0) &#123; startIt = false; &#125; &#125; &#125; if (task == r.task &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) &#123; mStackSupervisor.mUserLeaving = false; &#125; task = r.task; task.addActivityToTop(r); task.setFrontOfTask(); r.putInHistory(); mActivityTrigger.activityStartTrigger(r.intent, r.info, r.appInfo); if (!isHomeStack() || numActivities() &gt; 0) &#123; //ÂΩìÂàáÊç¢Âà∞Êñ∞ÁöÑtaskÔºåÊàñËÄÖ‰∏ã‰∏Ä‰∏™activityËøõÁ®ãÁõÆÂâçÂπ∂Ê≤°ÊúâËøêË°åÔºåÂàô boolean showStartingIcon = newTask; ProcessRecord proc = r.app; if (proc == null) &#123; proc = mService.mProcessNames.get(r.processName, r.info.applicationInfo.uid); &#125; if (proc == null || proc.thread == null) &#123; showStartingIcon = true; &#125; if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, keepCurTransition); mNoAnimActivities.add(r); &#125; else &#123; mWindowManager.prepareAppTransition(newTask ? r.mLaunchTaskBehind ? AppTransition.TRANSIT_TASK_OPEN_BEHIND : AppTransition.TRANSIT_TASK_OPEN : AppTransition.TRANSIT_ACTIVITY_OPEN, keepCurTransition); mNoAnimActivities.remove(r); &#125; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); boolean doShow = true; if (newTask) &#123; if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; resetTaskIfNeededLocked(r, r); doShow = topRunningNonDelayedActivityLocked(null) == r; &#125; &#125; else if (options != null &amp;&amp; new ActivityOptions(options).getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123; doShow = false; &#125; if (r.mLaunchTaskBehind) &#123; mWindowManager.setAppVisibility(r.appToken, true); ensureActivitiesVisibleLocked(null, 0); &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; ActivityRecord prev = mResumedActivity; if (prev != null) &#123; //ÂΩìÂâçactivityÊâÄÂ±û‰∏çÂêåÁöÑtask if (prev.task != r.task) &#123; prev = null; &#125; //ÂΩìÂâçactivityÂ∑≤Áªèdisplayed else if (prev.nowVisible) &#123; prev = null; &#125; &#125; mWindowManager.setAppStartingWindow( r.appToken, r.packageName, r.theme, mService.compatibilityInfoForPackageLocked( r.info.applicationInfo), r.nonLocalizedLabel, r.labelRes, r.icon, r.logo, r.windowFlags, prev != null ? prev.appToken : null, showStartingIcon); r.mStartingWindowShown = true; &#125; &#125; else &#123; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); ActivityOptions.abort(options); options = null; &#125; if (doResume) &#123; // [ËßÅÊµÅÁ®ã2.11] mStackSupervisor.resumeTopActivitiesLocked(this, r, options); &#125;&#125; 2.11 ASS.resumeTopActivitiesLocked1234567891011121314151617181920212223242526boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) &#123; if (targetStack == null) &#123; targetStack = mFocusedStack; &#125; boolean result = false; if (isFrontStack(targetStack)) &#123; //[ËßÅÊµÅÁ®ã2.12] result = targetStack.resumeTopActivityLocked(target, targetOptions); &#125; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; final ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (stack == targetStack) &#123; //‰∏äÈù¢ÂàöÂ∑≤ÂêØÂä® continue; &#125; if (isFrontStack(stack)) &#123; stack.resumeTopActivityLocked(null); &#125; &#125; &#125; return result;&#125; 2.12 AS.resumeTopActivityLocked12345678910111213141516171819final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; return false; //Èò≤Ê≠¢ÈÄíÂΩíÂêØÂä® &#125; boolean result = false; try &#123; mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; //[ËßÅÊµÅÁ®ã2.13] result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; inResumeTopActivityÁî®‰∫é‰øùËØÅÊØèÊ¨°Âè™Êúâ‰∏Ä‰∏™ActivityÊâßË°åresumeTopActivityLocked()Êìç‰Ωú. 2.13 AS.resumeTopActivityInnerLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123; ... //Á≥ªÁªüÊ≤°ÊúâËøõÂÖ•bootingÊàñbootedÁä∂ÊÄÅÔºåÂàô‰∏çÂÖÅËÆ∏ÂêØÂä®Activity ActivityRecord parent = mActivityContainer.mParentActivity; if ((parent != null &amp;&amp; parent.state != ActivityState.RESUMED) || !mActivityContainer.isAttachedLocked()) &#123; return false; &#125; //top running‰πãÂêéÁöÑ‰ªªÊÑèÂ§Ñ‰∫éÂàùÂßãÂåñÁä∂ÊÄÅ‰∏îÊúâÊòæÁ§∫StartingWindow, ÂàôÁßªÈô§StartingWindow cancelInitializingActivities(); //ÊâæÂà∞Á¨¨‰∏Ä‰∏™Ê≤°ÊúâfinishingÁöÑÊ†àÈ°∂activity final ActivityRecord next = topRunningActivityLocked(null); final boolean userLeaving = mStackSupervisor.mUserLeaving; mStackSupervisor.mUserLeaving = false; final TaskRecord prevTask = prev != null ? prev.task : null; if (next == null) &#123; final String reason = "noMoreActivities"; if (!mFullscreen) &#123; //ÂΩìËØ•Ê†àÊ≤°ÊúâÂÖ®Â±èÔºåÂàôÂ∞ùËØïËÅöÁÑ¶Âà∞‰∏ã‰∏Ä‰∏™ÂèØËßÅÁöÑstack final ActivityStack stack = getNextVisibleStackLocked(); if (adjustFocusToNextVisibleStackLocked(stack, reason)) &#123; return mStackSupervisor.resumeTopActivitiesLocked(stack, prev, null); &#125; &#125; ActivityOptions.abort(options); final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ? HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo(); //ÂêØÂä®homeÊ°åÈù¢activity return isOnHomeDisplay() &amp;&amp; mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, reason); &#125; next.delayedResume = false; if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; mWindowManager.executeAppTransition(); mNoAnimActivities.clear(); ActivityOptions.abort(options); return false; &#125; final TaskRecord nextTask = next.task; if (prevTask != null &amp;&amp; prevTask.stack == this &amp;&amp; prevTask.isOverHomeStack() &amp;&amp; prev.finishing &amp;&amp; prev.frontOfTask) &#123; if (prevTask == nextTask) &#123; prevTask.setFrontOfTask(); &#125; else if (prevTask != topTask()) &#123; final int taskNdx = mTaskHistory.indexOf(prevTask) + 1; mTaskHistory.get(taskNdx).setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; else if (!isOnHomeDisplay()) &#123; return false; &#125; else if (!isHomeStack())&#123; final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ? HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo(); return isOnHomeDisplay() &amp;&amp; mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, "prevFinished"); &#125; &#125; //Â§Ñ‰∫éÁù°Áú†ÊàñËÄÖÂÖ≥Êú∫Áä∂ÊÄÅÔºåtop activityÂ∑≤ÊöÇÂÅúÁöÑÊÉÖÂÜµ‰∏ã if (mService.isSleepingOrShuttingDown() &amp;&amp; mLastPausedActivity == next &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123; mWindowManager.executeAppTransition(); mNoAnimActivities.clear(); ActivityOptions.abort(options); return false; &#125; if (mService.mStartedUsers.get(next.userId) == null) &#123; return false; //Êã•ÊúâËØ•activityÁöÑÁî®Êà∑Ê≤°ÊúâÂêØÂä®ÂàôÁõ¥Êé•ËøîÂõû &#125; mStackSupervisor.mStoppingActivities.remove(next); mStackSupervisor.mGoingToSleepActivities.remove(next); next.sleeping = false; mStackSupervisor.mWaitingVisibleActivities.remove(next); mActivityTrigger.activityResumeTrigger(next.intent, next.info, next.appInfo); if (!mStackSupervisor.allPausedActivitiesComplete()) &#123; return false; //ÂΩìÊ≠£Â§Ñ‰∫éÊöÇÂÅúactivityÔºåÂàôÁõ¥Êé•ËøîÂõû &#125; mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid); //ÈúÄË¶ÅÁ≠âÂæÖÊöÇÂÅúÂΩìÂâçactivityÂÆåÊàêÔºåÂÜçresume top activity boolean dontWaitForPause = (next.info.flags&amp;ActivityInfo.FLAG_RESUME_WHILE_PAUSING) != 0; //ÊöÇÂÅúÂÖ∂‰ªñActivity[ËßÅÂ∞èËäÇ2.13.1] boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, true, dontWaitForPause); if (mResumedActivity != null) &#123; //ÂΩìÂâçresumdÁä∂ÊÄÅactivity‰∏ç‰∏∫Á©∫ÔºåÂàôÈúÄË¶ÅÂÖàÊöÇÂÅúËØ•Activity pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause); &#125; if (pausing) &#123; if (next.app != null &amp;&amp; next.app.thread != null) &#123; mService.updateLruProcessLocked(next.app, true, null); &#125; return true; &#125; if (mService.isSleeping() &amp;&amp; mLastNoHistoryActivity != null &amp;&amp; !mLastNoHistoryActivity.finishing) &#123; requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED, null, "resume-no-history", false); mLastNoHistoryActivity = null; &#125; if (prev != null &amp;&amp; prev != next) &#123; if (!mStackSupervisor.mWaitingVisibleActivities.contains(prev) &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123; mStackSupervisor.mWaitingVisibleActivities.add(prev); &#125; else &#123; if (prev.finishing) &#123; mWindowManager.setAppVisibility(prev.appToken, false); &#125; &#125; &#125; AppGlobals.getPackageManager().setPackageStoppedState( next.packageName, false, next.userId); boolean anim = true; if (mIsAnimationBoostEnabled == true &amp;&amp; mPerf == null) &#123; mPerf = new BoostFramework(); &#125; if (prev != null) &#123; if (prev.finishing) &#123; if (mNoAnimActivities.contains(prev)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_CLOSE : AppTransition.TRANSIT_TASK_CLOSE, false); if(prev.task != next.task &amp;&amp; mPerf != null) &#123; mPerf.perfLockAcquire(aBoostTimeOut, aBoostParamVal); &#125; &#125; mWindowManager.setAppWillBeHidden(prev.appToken); mWindowManager.setAppVisibility(prev.appToken, false); &#125; else &#123; if (mNoAnimActivities.contains(next)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_OPEN : next.mLaunchTaskBehind ? AppTransition.TRANSIT_TASK_OPEN_BEHIND : AppTransition.TRANSIT_TASK_OPEN, false); if(prev.task != next.task &amp;&amp; mPerf != null) &#123; mPerf.perfLockAcquire(aBoostTimeOut, aBoostParamVal); &#125; &#125; &#125; &#125; else &#123; if (mNoAnimActivities.contains(next)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN, false); &#125; &#125; Bundle resumeAnimOptions = null; if (anim) &#123; ActivityOptions opts = next.getOptionsForTargetActivityLocked(); if (opts != null) &#123; resumeAnimOptions = opts.toBundle(); &#125; next.applyOptionsLocked(); &#125; else &#123; next.clearOptionsLocked(); &#125; ActivityStack lastStack = mStackSupervisor.getLastStack(); //ËøõÁ®ãÂ∑≤Â≠òÂú®ÁöÑÊÉÖÂÜµ if (next.app != null &amp;&amp; next.app.thread != null) &#123; //activityÊ≠£Âú®Êàê‰∏∫ÂèØËßÅ mWindowManager.setAppVisibility(next.appToken, true); next.startLaunchTickingLocked(); ActivityRecord lastResumedActivity = lastStack == null ? null :lastStack.mResumedActivity; ActivityState lastState = next.state; mService.updateCpuStats(); //ËÆæÁΩÆActivityÁä∂ÊÄÅ‰∏∫resumed next.state = ActivityState.RESUMED; mResumedActivity = next; next.task.touchActiveTime(); mRecentTasks.addLocked(next.task); mService.updateLruProcessLocked(next.app, true, null); updateLRUListLocked(next); mService.updateOomAdjLocked(); boolean notUpdated = true; if (mStackSupervisor.isFrontStack(this)) &#123; Configuration config = mWindowManager.updateOrientationFromAppTokens( mService.mConfiguration, next.mayFreezeScreenLocked(next.app) ? next.appToken : null); if (config != null) &#123; next.frozenBeforeDestroy = true; &#125; notUpdated = !mService.updateConfigurationLocked(config, next, false, false); &#125; if (notUpdated) &#123; ActivityRecord nextNext = topRunningActivityLocked(null); if (nextNext != next) &#123; mStackSupervisor.scheduleResumeTopActivities(); &#125; if (mStackSupervisor.reportResumedActivityLocked(next)) &#123; mNoAnimActivities.clear(); return true; &#125; return false; &#125; try &#123; //ÂàÜÂèëÊâÄÊúâpendingÁªìÊûú. ArrayList&lt;ResultInfo&gt; a = next.results; if (a != null) &#123; final int N = a.size(); if (!next.finishing &amp;&amp; N &gt; 0) &#123; next.app.thread.scheduleSendResult(next.appToken, a); &#125; &#125; if (next.newIntents != null) &#123; next.app.thread.scheduleNewIntent(next.newIntents, next.appToken); &#125; next.sleeping = false; mService.showAskCompatModeDialogLocked(next); next.app.pendingUiClean = true; next.app.forceProcessStateUpTo(mService.mTopProcessState); next.clearOptionsLocked(); //Ëß¶ÂèëonResume() next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState, mService.isNextTransitionForward(), resumeAnimOptions); mStackSupervisor.checkReadyForSleepLocked(); &#125; catch (Exception e) &#123; ... return true; &#125; next.visible = true; completeResumeLocked(next); next.stopped = false; &#125; else &#123; if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; else &#123; if (SHOW_APP_STARTING_PREVIEW) &#123; mWindowManager.setAppStartingWindow( next.appToken, next.packageName, next.theme, mService.compatibilityInfoForPackageLocked( next.info.applicationInfo), next.nonLocalizedLabel, next.labelRes, next.icon, next.logo, next.windowFlags, null, true); &#125; &#125; mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true;&#125; ‰∏ªË¶ÅÂàÜÊîØÂäüËÉΩÔºö ÂΩìÊâæ‰∏çÂà∞ÈúÄË¶ÅresumeÁöÑActivityÔºåÂàôÁõ¥Êé•ÂõûÂà∞Ê°åÈù¢Ôºõ Âê¶ÂàôÔºåÂΩìmResumedActivity‰∏ç‰∏∫Á©∫ÔºåÂàôÊâßË°åstartPausingLocked()ÊöÇÂÅúËØ•activity; ÁÑ∂ÂêéÂÜçËøõÂÖ•startSpecificActivityLockedÁéØËäÇÔºåÊé•‰∏ãÊù•‰ªéËøôÈáåÁªßÁª≠ÂæÄ‰∏ãËØ¥„ÄÇ 2.13.1 ASS.pauseBackStacks123456789101112131415boolean pauseBackStacks(boolean userLeaving, boolean resuming, boolean dontWait) &#123; boolean someActivityPaused = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack) &amp;&amp; stack.mResumedActivity != null) &#123; //[ËßÅÂ∞èËäÇ2.13.2] someActivityPaused |= stack.startPausingLocked(userLeaving, false, resuming, dontWait); &#125; &#125; &#125; return someActivityPaused;&#125; ÊöÇÂÅúÊâÄÊúâÂ§Ñ‰∫éÂêéÂè∞Ê†àÁöÑÊâÄÊúâActivity„ÄÇ 2.13.2 AS.startPausingLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) &#123; if (mPausingActivity != null) &#123; if (!mService.isSleeping()) &#123; completePauseLocked(false); &#125; &#125; ActivityRecord prev = mResumedActivity; ... if (mActivityContainer.mParentActivity == null) &#123; //ÊöÇÂÅúÊâÄÊúâÂ≠êÊ†àÁöÑActivity mStackSupervisor.pauseChildStacks(prev, userLeaving, uiSleeping, resuming, dontWait); &#125; ... final ActivityRecord next = mStackSupervisor.topRunningActivityLocked(); if (prev.app != null &amp;&amp; prev.app.thread != null) &#123; EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); //ÊöÇÂÅúÁõÆÊ†áActivity prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); &#125;else &#123; ... &#125; if (!uiSleeping &amp;&amp; !mService.isSleepingOrShuttingDown()) &#123; mStackSupervisor.acquireLaunchWakelock(); //Áî≥ËØ∑wakelock &#125; if (mPausingActivity != null) &#123; if (!uiSleeping) &#123; prev.pauseKeyDispatchingLocked(); &#125; if (dontWait) &#123; completePauseLocked(false); return false; &#125; else &#123; Message msg = mHandler.obtainMessage(PAUSE_TIMEOUT_MSG); msg.obj = prev; prev.pauseTime = SystemClock.uptimeMillis(); //500msÂêéÔºåÊâßË°åÊöÇÂÅúË∂ÖÊó∂ÁöÑÊ∂àÊÅØ mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT); return true; &#125; &#125; else &#123; if (!resuming) &#123; //Ë∞ÉÂ∫¶ÊöÇÂÅúÂ§±Ë¥•ÔºåÂàôËÆ§‰∏∫Â∑≤ÊöÇÂÅúÂÆåÊàêÔºåÂºÄÂßãÊâßË°åresumeÊìç‰Ωú mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null); &#125; return false; &#125; ËØ•ÊñπÊ≥ï‰∏≠Ôºå‰∏ã‰∏ÄÊ≠•ÈÄöËøáBinderË∞ÉÁî®ÔºåËøõÂÖ•acitivityÊâÄÂú®ËøõÁ®ãÊù•ÊâßË°åschedulePauseActivity()Êìç‰Ωú„ÄÇ Êé•‰∏ãÊù•ÔºåÂØπ‰∫édontWait=trueÂàôÊâßË°åÊâßË°åcompletePauseLockedÔºåÂê¶ÂàôÁ≠âÂæÖappÈÄöÁü•ÊàñËÆ∏500msË∂ÖÊó∂ÂÜçÊâßË°åËØ•ÊñπÊ≥ï„ÄÇ 3.13.3 completePauseLocked2.14 ASS.startSpecificActivityLocked1234567891011121314151617181920212223242526void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !"android".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; //ÁúüÊ≠£ÁöÑÂêØÂä®Activity„ÄêËßÅÊµÅÁ®ã2.17„Äë realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; &#125; //ÂΩìËøõÁ®ã‰∏çÂ≠òÂú®ÂàôÂàõÂª∫ËøõÁ®ã [ËßÅÊµÅÁ®ã2.14.1] mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true);&#125; 2.15 AMS.startProcessLockedÂú®ÊñáÁ´†ÁêÜËß£AndroidËøõÁ®ãÂêØÂä®‰πãÂÖ®ËøáÁ®ã‰∏≠ÔºåËØ¶ÁªÜ‰ªãÁªç‰∫ÜAMS.startProcessLocked()Êï¥‰∏™ËøáÁ®ãÔºåÂàõÂª∫ÂÆåÊñ∞ËøõÁ®ãÂêé‰ºöÂú®Êñ∞ËøõÁ®ã‰∏≠Ë∞ÉÁî®AMP.attachApplicationÔºåËØ•ÊñπÊ≥ïÁªèËøábinder ipcÂêéË∞ÉÁî®Âà∞AMS.attachApplicationLocked„ÄÇ 1234567891011121314private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ... ////Âè™ÊúâÂΩìÁ≥ªÁªüÂêØÂä®ÂÆåÔºåÊàñËÄÖappÂÖÅËÆ∏ÂêØÂä®ËøáÁ®ãÂÖÅËÆ∏ÔºåÂàô‰ºötrue boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); thread.bindApplication(...); if (normalMode) &#123; //„ÄêËßÅÊµÅÁ®ã2.16„Äë if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; ...&#125; Âú®ÊâßË°åÂÆåbindApplication()‰πãÂêéËøõÂÖ•ASS.attachApplicationLocked() 2.16 ASS.attachApplicationLocked123456789101112131415161718192021222324252627282930313233boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) &#123; continue; &#125; //Ëé∑ÂèñÂâçÂè∞stack‰∏≠Ê†àÈ°∂Á¨¨‰∏Ä‰∏™ÈùûfinishingÁöÑActivity ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; //ÁúüÊ≠£ÁöÑÂêØÂä®Activity„ÄêËßÅÊµÅÁ®ã2.17„Äë if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (RemoteException e) &#123; throw e; &#125; &#125; &#125; &#125; &#125; if (!didSomething) &#123; //ÂêØÂä®Activity‰∏çÊàêÂäüÔºåÂàôÁ°Æ‰øùÊúâÂèØËßÅÁöÑActivity ensureActivitiesVisibleLocked(null, 0); &#125; return didSomething;&#125; 2.17 ASS.realStartActivityLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; if (andResume) &#123; r.startFreezingScreenLocked(app, 0); mWindowManager.setAppVisibility(r.appToken, true); //Ë∞ÉÂ∫¶ÂêØÂä®ticksÁî®‰ª•Êî∂ÈõÜÂ∫îÁî®ÂêØÂä®ÊÖ¢ÁöÑ‰ø°ÊÅØ r.startLaunchTickingLocked(); &#125; if (checkConfig) &#123; Configuration config = mWindowManager.updateOrientationFromAppTokens( mService.mConfiguration, r.mayFreezeScreenLocked(app) ? r.appToken : null); //Êõ¥Êñ∞Configuration mService.updateConfigurationLocked(config, r, false, false); &#125; r.app = app; app.waitingToKill = null; r.launchCount++; r.lastLaunchTime = SystemClock.uptimeMillis(); int idx = app.activities.indexOf(r); if (idx &lt; 0) &#123; app.activities.add(r); &#125; mService.updateLruProcessLocked(app, true, null); mService.updateOomAdjLocked(); final TaskRecord task = r.task; if (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV) &#123; setLockTaskModeLocked(task, LOCK_TASK_MODE_LOCKED, "mLockTaskAuth==LAUNCHABLE", false); &#125; final ActivityStack stack = task.stack; try &#123; if (app.thread == null) &#123; throw new RemoteException(); &#125; List&lt;ResultInfo&gt; results = null; List&lt;ReferrerIntent&gt; newIntents = null; if (andResume) &#123; results = r.results; newIntents = r.newIntents; &#125; if (r.isHomeActivity() &amp;&amp; r.isNotResolverActivity()) &#123; //homeËøõÁ®ãÊòØËØ•Ê†àÁöÑÊ†πËøõÁ®ã mService.mHomeProcess = task.mActivities.get(0).app; &#125; mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName()); ... if (andResume) &#123; app.hasShownUi = true; app.pendingUiClean = true; &#125; //Â∞ÜËØ•ËøõÁ®ãËÆæÁΩÆ‰∏∫ÂâçÂè∞ËøõÁ®ãPROCESS_STATE_TOP app.forceProcessStateUpTo(mService.mTopProcessState); //„ÄêËßÅÊµÅÁ®ã2.18„Äë app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); if ((app.info.privateFlags&amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; ... //Â§ÑÁêÜheavy-weightËøõÁ®ã &#125; &#125; catch (RemoteException e) &#123; if (r.launchFailed) &#123; //Á¨¨‰∫åÊ¨°ÂêØÂä®Â§±Ë¥•ÔºåÂàôÁªìÊùüËØ•activity mService.appDiedLocked(app); stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null, "2nd-crash", false); return false; &#125; //ËøôÊòØÁ¨¨‰∏Ä‰∏™ÂêØÂä®Â§±Ë¥•ÔºåÂàôÈáçÂêØËøõÁ®ã app.activities.remove(r); throw e; &#125; //Â∞ÜËØ•ËøõÁ®ãÂä†ÂÖ•Âà∞mLRUActivitiesÈòüÂàóÈ°∂ÈÉ® stack.updateLRUListLocked(r)Ôºõ if (andResume) &#123; //ÂêØÂä®ËøáÁ®ãÁöÑ‰∏ÄÈÉ®ÂàÜ stack.minimalResumeActivityLocked(r); &#125; else &#123; r.state = STOPPED; r.stopped = true; &#125; if (isFrontStack(stack)) &#123; //ÂΩìÁ≥ªÁªüÂèëÁîüÊõ¥Êñ∞Êó∂ÔºåÂè™‰ºöÊâßË°å‰∏ÄÊ¨°ÁöÑÁî®Êà∑ÂêëÂØº mService.startSetupActivityLocked(); &#125; //Êõ¥Êñ∞ÊâÄÊúâ‰∏éËØ•ActivityÂÖ∑ÊúâÁªëÂÆöÂÖ≥Á≥ªÁöÑServiceËøûÊé• mService.mServices.updateServiceConnectionActivitiesLocked(r.app); return true;&#125; 2.18 ATP.scheduleLaunchActivity[-&gt; ApplicationThreadProxy.java] 1234567891011121314151617181920212223242526272829303132333435public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); intent.writeToParcel(data, 0); data.writeStrongBinder(token); data.writeInt(ident); info.writeToParcel(data, 0); curConfig.writeToParcel(data, 0); if (overrideConfig != null) &#123; data.writeInt(1); overrideConfig.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; compatInfo.writeToParcel(data, 0); data.writeString(referrer); data.writeStrongBinder(voiceInteractor != null ? voiceInteractor.asBinder() : null); data.writeInt(procState); data.writeBundle(state); data.writePersistableBundle(persistentState); data.writeTypedList(pendingResults); data.writeTypedList(pendingNewIntents); data.writeInt(notResumed ? 1 : 0); data.writeInt(isForward ? 1 : 0); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; //„ÄêËßÅÊµÅÁ®ã2.19„Äë mRemote.transact(SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; 2.19 ATN.onTransact[-&gt; ApplicationThreadNative.java] 123456789101112131415161718192021222324252627282930313233343536public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); Intent intent = Intent.CREATOR.createFromParcel(data); IBinder b = data.readStrongBinder(); int ident = data.readInt(); ActivityInfo info = ActivityInfo.CREATOR.createFromParcel(data); Configuration curConfig = Configuration.CREATOR.createFromParcel(data); Configuration overrideConfig = null; if (data.readInt() != 0) &#123; overrideConfig = Configuration.CREATOR.createFromParcel(data); &#125; CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data); String referrer = data.readString(); IVoiceInteractor voiceInteractor = IVoiceInteractor.Stub.asInterface( data.readStrongBinder()); int procState = data.readInt(); Bundle state = data.readBundle(); PersistableBundle persistentState = data.readPersistableBundle(); List&lt;ResultInfo&gt; ri = data.createTypedArrayList(ResultInfo.CREATOR); List&lt;ReferrerIntent&gt; pi = data.createTypedArrayList(ReferrerIntent.CREATOR); boolean notResumed = data.readInt() != 0; boolean isForward = data.readInt() != 0; ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; //„ÄêËßÅÊµÅÁ®ã2.20„Äë scheduleLaunchActivity(intent, b, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, ri, pi, notResumed, isForward, profilerInfo); return true; &#125; ... &#125;&#125; 2.20 AT.scheduleLaunchActivity[-&gt; ApplicationThread.java] 1234567891011121314151617181920212223242526272829public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); //„ÄêËßÅÊµÅÁ®ã2.21„Äë sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 2.21 H.handleMessage[-&gt; ActivityThread.java ::H] 123456789101112public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); //„ÄêËßÅÊµÅÁ®ã2.22„Äë handleLaunchActivity(r, null); &#125; break; ... &#125;&#125; 2.22 ActivityThread.handleLaunchActivity[-&gt; ActivityThread.java] 12345678910111213141516171819202122232425262728private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; unscheduleGcIdler(); mSomeActivitiesChanged = true; //ÊúÄÁªàÂõûË∞ÉÁõÆÊ†áActivityÁöÑonConfigurationChanged() handleConfigurationChanged(null, null); //ÂàùÂßãÂåñwms WindowManagerGlobal.initialize(); //ÊúÄÁªàÂõûË∞ÉÁõÆÊ†áActivityÁöÑonCreate[ËßÅÊµÅÁ®ã2.23] Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //ÊúÄÁªàÂõûË∞ÉÁõÆÊ†áActivityÁöÑonStart,onResume. handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); r.paused = true; &#125; &#125; else &#123; //Â≠òÂú®errorÂàôÂÅúÊ≠¢ËØ•Activity ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); &#125;&#125; 2.23 ActivityThread.performLaunchActivity[-&gt; ActivityThread.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; //ÂàõÂª∫ApplicationÂØπË±° Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; ... &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; Âà∞Ê≠§ÔºåÊ≠£ÂºèËøõÂÖ•‰∫ÜActivityÁöÑonCreate, onStart, onResumeËøô‰∫õÁîüÂëΩÂë®ÊúüÁöÑËøáÁ®ã„ÄÇ ‰∏â. ÊÄªÁªìÊú¨ÊñáËØ¶ÁªÜstartActivityÁöÑÊï¥‰∏™ÂêØÂä®ÊµÅÁ®ãÔºå ÊµÅÁ®ã[2.1 ~2.4]:ËøêË°åÂú®Ë∞ÉÁî®ËÄÖÊâÄÂú®ËøõÁ®ãÔºåÊØîÂ¶Ç‰ªéÊ°åÈù¢ÂêØÂä®ActivityÔºåÂàôË∞ÉÁî®ËÄÖÊâÄÂú®ËøõÁ®ã‰∏∫launcherËøõÁ®ãÔºålauncherËøõÁ®ãÂà©Áî®ActivityManagerProxy‰Ωú‰∏∫Binder ClientÔºåËøõÂÖ•system_serverËøõÁ®ã(AMSÁõ∏Â∫îÁöÑServerÁ´Ø)„ÄÇ ÊµÅÁ®ã[2.5 ~2.18]:ËøêË°åÂú®system_serverÁ≥ªÁªüËøõÁ®ãÔºåÊï¥‰∏™ËøáÁ®ãÊúÄ‰∏∫Â§çÊùÇ„ÄÅÊ†∏ÂøÉÁöÑËøáÁ®ãÔºå‰∏ãÈù¢ÂÖ∂‰∏≠ÈÉ®ÂàÜÊ≠•È™§ÔºöÊµÅÁ®ã[2.7]Ôºö‰ºöË∞ÉÁî®Âà∞resolveActivity()ÔºåÂÄüÂä©PackageManagerÊù•Êü•ËØ¢Á≥ªÁªü‰∏≠ÊâÄÊúâÁ¨¶ÂêàË¶ÅÊ±ÇÁöÑActivityÔºåÂΩìÂ≠òÂú®Â§ö‰∏™Êª°Ë∂≥Êù°‰ª∂ÁöÑActivityÂàô‰ºöÂºπÊ°ÜËÆ©Áî®Êà∑Êù•ÈÄâÊã©;ÊµÅÁ®ã[2.8]ÔºöÂàõÂª∫ActivityRecordÂØπË±°ÔºåÂπ∂Ê£ÄÊü•ÊòØÂê¶ËøêË°åAppÂàáÊç¢ÔºåÁÑ∂ÂêéÂÜçÂ§ÑÁêÜmPendingActivityLaunches‰∏≠ÁöÑactivity;ÊµÅÁ®ã[2.9]Ôºö‰∏∫ActivityÊâæÂà∞ÊàñÂàõÂª∫Êñ∞ÁöÑTaskÂØπË±°ÔºåËÆæÁΩÆflags‰ø°ÊÅØÔºõÊµÅÁ®ã[2.13]ÔºöÂΩìÊ≤°ÊúâÂ§Ñ‰∫éÈùûfinishingÁä∂ÊÄÅÁöÑActivityÔºåÂàôÁõ¥Êé•ÂõûÂà∞Ê°åÈù¢Ôºõ Âê¶ÂàôÔºåÂΩìmResumedActivity‰∏ç‰∏∫Á©∫ÂàôÊâßË°åstartPausingLocked()ÊöÇÂÅúËØ•activity;ÁÑ∂ÂêéÂÜçËøõÂÖ•startSpecificActivityLocked()ÁéØËäÇ;ÊµÅÁ®ã[2.14]ÔºöÂΩìÁõÆÊ†áËøõÁ®ãÂ∑≤Â≠òÂú®ÂàôÁõ¥Êé•ËøõÂÖ•ÊµÅÁ®ã[2.17]ÔºåÂΩìËøõÁ®ã‰∏çÂ≠òÂú®ÂàôÂàõÂª∫ËøõÁ®ãÔºåÁªèËøáÂ±ÇÂ±ÇË∞ÉÁî®ËøòÊòØ‰ºöËøõÂÖ•ÊµÅÁ®ã[2.17];ÊµÅÁ®ã[2.17]Ôºösystem_serverËøõÁ®ãÂà©Áî®ÁöÑATP(Binder Client)ÔºåÁªèËøáBinderÔºåÁ®ãÂ∫èÊé•‰∏ãÊù•ËøõÂÖ•ÁõÆÊ†áËøõÁ®ã„ÄÇ ÊµÅÁ®ã[2.19 ~2.18]:ËøêË°åÂú®ÁõÆÊ†áËøõÁ®ãÔºåÈÄöËøáHandlerÊ∂àÊÅØÊú∫Âà∂ÔºåËØ•ËøõÁ®ã‰∏≠ÁöÑBinderÁ∫øÁ®ãÂêë‰∏ªÁ∫øÁ®ãÂèëÈÄÅH.LAUNCH_ACTIVITYÔºåÊúÄÁªà‰ºöÈÄöËøáÂèçÂ∞ÑÂàõÂª∫ÁõÆÊ†áActivityÔºåÁÑ∂ÂêéËøõÂÖ•onCreate()ÁîüÂëΩÂë®Êúü„ÄÇ ‰ªéÂè¶‰∏Ä‰∏™ËßíÂ∫¶‰∏ãÂõæÊù•Ê¶ÇÊã¨Ôºö ÂêØÂä®ÊµÅÁ®ãÔºö ÁÇπÂáªÊ°åÈù¢AppÂõæÊ†áÔºåLauncherËøõÁ®ãÈááÁî®Binder IPCÂêësystem_serverËøõÁ®ãÂèëËµ∑startActivityËØ∑Ê±ÇÔºõ system_serverËøõÁ®ãÊé•Êî∂Âà∞ËØ∑Ê±ÇÂêéÔºåÂêëzygoteËøõÁ®ãÂèëÈÄÅÂàõÂª∫ËøõÁ®ãÁöÑËØ∑Ê±ÇÔºõ ZygoteËøõÁ®ãforkÂá∫Êñ∞ÁöÑÂ≠êËøõÁ®ãÔºåÂç≥AppËøõÁ®ãÔºõ AppËøõÁ®ãÔºåÈÄöËøáBinder IPCÂêësytem_serverËøõÁ®ãÂèëËµ∑attachApplicationËØ∑Ê±ÇÔºõ system_serverËøõÁ®ãÂú®Êî∂Âà∞ËØ∑Ê±ÇÂêéÔºåËøõË°å‰∏ÄÁ≥ªÂàóÂáÜÂ§áÂ∑•‰ΩúÂêéÔºåÂÜçÈÄöËøábinder IPCÂêëAppËøõÁ®ãÂèëÈÄÅscheduleLaunchActivityËØ∑Ê±ÇÔºõ AppËøõÁ®ãÁöÑbinderÁ∫øÁ®ãÔºàApplicationThreadÔºâÂú®Êî∂Âà∞ËØ∑Ê±ÇÂêéÔºåÈÄöËøáhandlerÂêë‰∏ªÁ∫øÁ®ãÂèëÈÄÅLAUNCH_ACTIVITYÊ∂àÊÅØÔºõ ‰∏ªÁ∫øÁ®ãÂú®Êî∂Âà∞MessageÂêéÔºåÈÄöËøáÂèëÂ∞ÑÊú∫Âà∂ÂàõÂª∫ÁõÆÊ†áActivityÔºåÂπ∂ÂõûË∞ÉActivity.onCreate()Á≠âÊñπÊ≥ï„ÄÇ Âà∞Ê≠§ÔºåApp‰æøÊ≠£ÂºèÂêØÂä®ÔºåÂºÄÂßãËøõÂÖ•ActivityÁîüÂëΩÂë®ÊúüÔºåÊâßË°åÂÆåonCreate/onStart/onResumeÊñπÊ≥ïÔºåUIÊ∏≤ÊüìÁªìÊùüÂêé‰æøÂèØ‰ª•ÁúãÂà∞AppÁöÑ‰∏ªÁïåÈù¢„ÄÇ ÂêØÂä®ActivityËæÉ‰∏∫Â§çÊùÇÔºåÂêéÁª≠ËÆ°ÂàíÂÜçËøõ‰∏ÄÊ≠•ËÆ≤Ëß£ÁîüÂëΩÂë®ÊúüËøáÁ®ã‰∏éÁ≥ªÁªüÊòØÂ¶Ç‰Ωï‰∫§‰∫íÔºå‰ª•ÂèäUIÊ∏≤ÊüìËøáÁ®ãÔºåÊï¨ËØ∑ÊúüÂæÖ„ÄÇ]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>ActivityThread</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidÁöÑÊ∂àÊÅØÊú∫Âà∂]]></title>
    <url>%2F2018%2F03%2F13%2FAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[AndroidÁöÑÊ∂àÊÅØÊú∫Âà∂‰∏ªË¶ÅÊåáHandlerÁöÑËøêË°åÊú∫Âà∂, HandlerÁöÑËøêË°åÈúÄË¶ÅÂ∫ïÂ±ÇÁöÑMessageQueueÂíåLoopperÁöÑÊîØÊíë. MessageQueueÊ∂àÊÅØÊú∫Âà∂, ÂÜÖÈÉ®Â≠òÂÇ®‰∫Ü‰∏ÄÁªÑÊ∂àÊÅØ, ‰ª•ÈòüÂàóÁöÑÂΩ¢ÂºèÂØπÂ§ñÊèê‰æõÊèíÂÖ•ÂíåÂà†Èô§Â∑•‰Ωú. ËôΩÁÑ∂Âè´Ê∂àÊÅØÈòüÂàó,‰ΩÜÊòØÂÖ∂ÂÜÖÈÉ®Â≠òÂÇ®ÁªìÊûÑÂπ∂‰∏çÊòØÁúüÊ≠£ÁöÑÈòüÂàó,ËÄåÊòØÈááÁî®ÂçïÈìæË°®ÁöÑÊï∞ÊçÆÁªìÊûÑÊù•Â≠òÂÇ®Ê∂àÊÅØÂàóË°®. LooperÊ∂àÊÅØÂæ™ÁéØ, Âõ†‰∏∫MessageQueueÊú¨Ë¥®Âè™ÊòØ‰∏Ä‰∏™Ê∂àÊÅØÁöÑÂ≠òÂÇ®ÂçïÂÖÉ, ÂÆÉ‰∏çËÉΩÂéªÂ§ÑÁêÜÊ∂àÊÅØ, ËÄåLooperÂ∞±ÊòØ‰∏∫ÂÆûÁé∞Â§ÑÁêÜËÄå‰∫ßÁîüÁöÑ. Looper‰ºö‰ª•Êó†ÈôêÂæ™ÁéØÁöÑÂΩ¢ÂºèÂéªÊü•ÊâæÊòØÂê¶ÊúâÊñ∞Ê∂àÊÅØ, Â¶ÇÊûúÊúâÁöÑËØùÂ∞±Â§ÑÁêÜÊ∂àÊÅØ, Âê¶Âú®Â∞±‰∏ÄÁõ¥Á≠âÂæÖ. Looper‰∏≠Êúâ‰∏Ä‰∏™ÁâπÊÆäÁöÑÊ¶ÇÂøµThreadLocal, ThreadLocalÂπ∂‰∏çÊòØ‰∏Ä‰∏™Á∫øÁ®ã, ÂÆÉÂèØ‰ª•Âú®ÊØè‰∏™Á∫øÁ®ã‰∏≠ËøõË°åÊï∞ÊçÆÁöÑÂ≠òÂÇ®. Êàë‰ª¨‰ΩøÁî®ÁöÑHandlerÂàõÂª∫ÁöÑÊó∂ÂÄôÈÉΩ‰ºöÈááÁî®ÂΩìÂâçÁ∫øÁ®ãÁöÑLooperÊù•ÊûÑÈÄ†Ê∂àÊÅØÂæ™ÁéØÁ≥ªÁªü, ËÄåËøô‰∏™ÂΩìÂâçÁ∫øÁ®ãÂ∞±ÊòØÈÄöËøáThreadLocalÊù•ËøõË°åÊìç‰ΩúÁöÑ. Êúâ‰∏ÄÁÇπÈúÄË¶ÅËÆ∞‰Ωè: ‰∏Ä‰∏™Êñ∞ÁöÑÁ∫øÁ®ãÈªòËÆ§ÊòØÊ≤°ÊúâLooperÁöÑ, Â¶ÇÊûúË¶Å‰ΩøÁî®HandlerÂ∞±ÂøÖ‰∏∫Á∫øÁ®ãÂàõÂª∫Looper, ËÄåÊàë‰ª¨‰ΩøÁî®‰∏ªÁ∫øÁ®ãÁöÑÊó∂ÂÄô‰πãÊâÄ‰ª•‰∏çÈúÄË¶ÅÂàõÂª∫LooperÊòØÂõ†‰∏∫. UIÁ∫øÁ®ã‰πüÂ∞±ÊòØActivityThreadÂú®Ë¢´ÂàõÂª∫ÁöÑÊó∂ÂÄôÂ∞±‰ºöÂàùÂßãÂåñLooper, ÊâÄ‰ª•Êàë‰ª¨Âú®‰∏ªÁ∫øÁ®ã‰πüÂ∞±ÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®HandlerÁöÑÂéüÂõ†. Android ÁöÑÊ∂àÊÅØÊú∫Âà∂ÊèèËø∞Âú®Êó•Â∏∏ÂºÄÂèë‰∏≠Â¶ÇÊûú‰∏çÂ∞èÂøÉÂú®Â≠êÁ∫øÁ®ãÊõ¥Êñ∞‰∫ÜUIÈÇ£‰πàÂ∞±‰ºöÊäõÂá∫ÂºÇÂ∏∏, Ëøô‰∏ÄÊ≠•È™§ÊòØÂú®ViewRootImpl#checkThread()ÊñπÊ≥ïÂÆåÊàêÁöÑ. 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; ÈÇ£HandlerÂèØ‰ª•ËÆ§‰∏∫ÊòØ‰∏∫‰∫ÜÂú®Â≠êÁ∫øÁ®ãÂ§ÑÁêÜÂÆåÊìç‰ΩúÂèØ‰ª•ÂàáÂõûÂà∞‰∏ªÁ∫øÁ®ãËøõË°åUIÊìç‰ΩúÁöÑÁî®ÈÄî. ÈÇ£‰∏∫‰ªÄ‰πà‰∏çËÉΩÂÜçÂ≠êÁ∫øÁ®ãËøõË°åUIÂ§ÑÁêÜÂë¢? ËøôÊòØÂõ†‰∏∫AndroidÁöÑUIÁ∫øÁ®ãÊéß‰ª∂‰∏çÊòØÁ∫øÁ®ãÂÆâÂÖ®, Â¶ÇÊûúÂú®Â§öÁ∫øÁ®ã‰∏≠Âπ∂ÂèëÁöÑËÆøÈóÆÂèØËÉΩ‰ºöÂØºËá¥UIÊéß‰ª∂Â§Ñ‰∫é‰∏çÂèØÈ¢ÑÊúüÁöÑÁä∂ÊÄÅ, ËôΩÁÑ∂ÂèØ‰ª•Áî®Âä†ÈîÅÁöÑÂΩ¢ÂºèËÆ©‰∏äËø∞ÈóÆÈ¢òÊ∂àÂ§±, ‰ΩÜÊòØÊúâ‰∏§‰∏™ÂºäÁ´Ø: Âä†ÈîÅÊú∫Âà∂‰ºöËÆ©UIËÆøÈóÆÁöÑÈÄªËæëÂèòÂæóÂ§çÊùÇ ÈîÅÊú∫Âà∂‰ºöÈôç‰ΩéUIÁöÑËÆøÈóÆÁöÑÊïàÁéá, Âõ†‰∏∫ÈîÅÊú∫Âà∂‰ºöÈòªÂ°ûÊüê‰∫õÁ∫øÁ®ãÁöÑÊâßË°å. Âõ†‰∏∫ËøôÊ†∑, ÊúÄÁÆÄÂçï‰∏îÈ´òÊïàÁöÑÊñπÊ≥ïÂ∞±ÊòØÈááÁî®ÂçïÁ∫øÁ®ãÊ®°ÂûãÊù•Â§ÑÁêÜUIÊìç‰Ωú. ÂΩìHandler, Looper, MessageQueueÈÉΩÂáÜÂ§áÂ•Ω‰πãÂêé. Â∞±ÂèØ‰ª•ÈÄöËøáHandler#post()ÊñπÊ≥ïÂ∞Ü‰∏Ä‰∏™RunnableÊäïÈÄíÂà∞HandlerÂÜÖÈÉ®ÁöÑLooper‰∏≠ÂéªÂ§ÑÁêÜ, ‰πüÂèØ‰ª•ÈÄöËøásend()ÊñπÊ≥ïÊù•ÂèëÈÄÅ‰∏Ä‰∏™Ê∂àÊÅØ, Ëøô‰∏™Ê∂àÊÅØÂêåÊ†∑‰ºöÂú®Looper‰∏≠Â§ÑÁêÜ. ËÄåpost()ÂÜÖÈÉ®‰πüÊòØÈÄöËøásend()Êù•ÂèëÈÄÅÁöÑ. AndroidÊ∂àÊÅØÊú∫Âà∂ÂàÜÊûêThreadLocalÁöÑÂ∑•‰ΩúÂéüÁêÜThreadLocalÊòØ‰∏Ä‰∏™Á∫øÁ®ãÂÜÖÈÉ®ÁöÑÊï∞ÊçÆÂ≠òÂÇ®Á±ª, ÈÄöËøá‰ªñÂèØ‰ª•Âú®ÊåáÂÆöÁöÑÁ∫øÁ®ã‰∏≠Â≠òÂÇ®Êï∞ÊçÆ. Êï∞ÊçÆÂ≠òÂÇ®‰ª•Âêé, Âè™ËÉΩÂú®ÊåáÂÆöÁ∫øÁ®ã‰∏≠ÂèØ‰ª•Ëé∑ÂèñÂà∞Â≠òÂÇ®ÁöÑÊï∞ÊçÆ. ËÄåÂÖ∂‰ªñÁ∫øÁ®ãÊó†Ê≥ïËé∑Âèñ. ËÄåAndroid‰∏≠ÁöÑLooper ,ActivityThread, AMSÈÉΩÁî®Âà∞‰∫ÜThreadLocal. ÂèØ‰ª•ËøôÊ†∑Êù•ËØ¥: ÂΩìÊüê‰∫õÊï∞ÊçÆÊòØ‰ª•Á∫øÁ®ã‰∏∫‰ΩúÁî®ÂüüÂπ∂‰∏î‰∏çÂêåÁ∫øÁ®ãÂÖ∑Êúâ‰∏çÂêåÁöÑÊï∞ÊçÆÂâØÊú¨ÁöÑÊó∂ÂÄô, ÂèØ‰ª•ÈááÁî®ThreadLocal. ÂèØ‰ª•Ëá™Â∑±Áî®‰∏â‰∏™Á∫øÁ®ãÂàÜÂà´ÂØπ‰∏Ä‰∏™ThreadLocalÂØπË±°ËøõË°åÊìç‰Ωú, ËôΩÁÑ∂Êìç‰ΩúÁöÑÊòØ‰∏Ä‰∏™ÂØπË±°, ‰ΩÜÊòØÊØè‰∏™Á∫øÁ®ãÂú®Ëé∑ÂèñÂÄºÁöÑÊó∂ÂÄôÂç¥‰∏çÁõ∏Âêå. ËøôÊòØÂõ†‰∏∫: ‰∏çÂêåÁöÑÁ∫øÁ®ãËÆøÈóÆÂêå‰∏Ä‰∏™ThreadLocal#get()ÊñπÊ≥ïÁöÑÊó∂ÂÄô, ThreadLocalÂÜÖÈÉ®‰ºö‰ªéÂêÑËá™ÁöÑÁ∫øÁ®ã‰∏≠ÂèñÂá∫‰∏Ä‰∏™ThreadLocalMapÂØπË±°, ÁÑ∂ÂêéÂÜç‰ªéMap‰∏≠Ê†πÊçÆÂΩìÂâçThreadLocalÁöÑÁ¥¢ÂºïÂéªÊü•ÊâæÂá∫ÂØπÂ∫îÁöÑvalueÂÄº. ÂèØ‰ª•ÁúãÂá∫‰∏çÂêåÁöÑÁ∫øÁ®ã‰∏≠ÁöÑThreadLocalMapÊòØ‰∏çÁõ∏ÂêåÁöÑ. ÊâÄ‰ª•‰πüÂ∞±ÊòØ‰∏∫‰ªÄ‰πà‰ΩøÁî®ThreadLocalÂèØ‰ª•Âú®‰∏çÂêåÁöÑÁ∫øÁ®ã‰∏≠Áª¥Êä§‰∏ÄÂ•óÊï∞ÊçÆÁöÑÂâØÊú¨Âπ∂‰∏îÂΩºÊ≠§‰∫í‰∏çÂΩ±Âìç. ËøòÊòØÁî®Ê∫êÁ†ÅÊù•Ê¢≥ÁêÜÊµÅÁ®ã ThreadLocalÊòØ‰∏Ä‰∏™Ê≥õÂûãÁ±ª, ÂÆÉÁöÑÂÆö‰πâ‰∏∫public class ThreadLocal&lt;T&gt;, Áúã‰∏Ä‰∏ãset()ÊàñËÄÖget()Â∞±ÊòéÁôΩ‰∫Ü. 12345678910111213141516171819//ThreadLocal.javapublic void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;//Thread.java/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; È¶ñÂÖà‰ºöÈÄöËøágetMap()ÊñπÊ≥ïÊù•Ëé∑ÂèñÂΩìÂâçÁ∫øÁ®ã‰∏≠ÁöÑThreadLocalÊï∞ÊçÆ„ÄÇÂú®ThreadÁ±ªÁöÑÂÜÖÈÉ®Êúâ‰∏Ä‰∏™ÊàêÂëò‰∏ìÈó®Áî®‰∫éÂ≠òÂÇ®Á∫øÁ®ãÁöÑThreadLocalÁöÑÊï∞ÊçÆThreadLocal.ThreadLocalMap threadLocals. ÊâÄ‰ª•ÂØπThreadLocalÊâÄÂÅöÁöÑËØªÂÜôÊìç‰Ωú‰ªÖÈôê‰∫éÂΩìÂâçÁ∫øÁ®ãÁöÑÂØπÂ∫îÊï∞ÊçÆ„ÄÇ Âú®ThreadLocalMap‰∏≠Êúâ‰∏Ä‰∏™Êï∞ÁªÑprivate Entry[] tableÔºåThreadLocalËÆæÁΩÆÁöÑÂÄºÂ∞±Â≠òÂú®Ëøô‰∏™tableÊï∞ÁªÑ‰∏≠. Áúã‰∏Ä‰∏ãset()ÊñπÊ≥ï. 12345678910111213141516171819202122232425262728293031323334353637/*** Set the value associated with key.** @param key the thread local object* @param value the value to be set*/private void set(ThreadLocal key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; ËøôÈáåÂè™ËØ¥Â§ßËá¥ÁöÑËßÑÂàô, ‰∏çÈúÄË¶ÅÂÖ∑‰ΩìÁúãÂÆûÁé∞ÁöÑÁÆóÊ≥ïÔºõÂ∞±ÊòØThreadLocalÁöÑÂÄºÂú®ThreadLocalMapÁöÑtableÊï∞ÁªÑ‰∏≠Â≠òÂÇ®ÁöÑ„ÄÇ Êé•ÁùÄÁúãget()ÊñπÊ≥ï 12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; ËÄåThreadLocal#get()ÊñπÊ≥ï, ÂêåÊ†∑ÊòØÂèñÂá∫ÂΩìÂâçÁ∫øÁ®ãThreadLocalMapÂØπË±°, Êé•ÁùÄËé∑ÂèñThreadLocalMap‰∏≠ÁöÑEntry[] tableÊï∞ÁªÑÈáåÁöÑÂÄº. ÂèÇËÄÉ: ÁêÜËß£Java‰∏≠ÁöÑThreadLocal Ê∂àÊÅØÈòüÂàóÁöÑÂ∑•‰ΩúÂéüÁêÜÊ∂àÊÅØÈòüÂàóÂú®android‰∏≠ÊåáÁöÑÊòØMessageQueue, MessageQueue‰∏ªË¶ÅÂåÖÂê´‰∏§‰∏™Êìç‰Ωú: ÊèíÂÖ•ÂíåËØªÂèñ. ËØªÂèñÊìç‰ΩúÊú¨Ë∫´‰ºö‰º¥ÈöèÁùÄÂà†Èô§ÁöÑÊìç‰Ωú, ÊèíÂÖ•ÂíåËØªÂèñÂØπÂ∫îÁöÑÊñπÊ≥ïÂàÜÂà´‰∏∫enqueueMessage(),next(). ÂâçËÄÖÂ∞±ÊòØÂæÄÊ∂àÊÅØÈòüÂàó‰∏≠ÊèíÂÖ•‰∏ÄÊù°Ê∂àÊÅØ, ËÄåÂêéËÄÖÂ∞±ÊòØÂèñÂá∫‰∏ÄÊù°Ê∂àÊÅØÂπ∂Â∞ÜÂÖ∂‰ªéÊ∂àÊÅØÈòüÂàó‰∏≠Ê∂àÈô§. ‰∏äÈù¢ËØ¥ËøáËôΩÁÑ∂MessageQueueÁß∞‰∏∫Ê∂àÊÅØÈòüÂàó, ‰ΩÜÊòØÂÜÖÈÉ®ÂÆûÁé∞‰ΩøÁî®ÁöÑÊòØÂçïÈìæË°®ÁöÑÊï∞ÊçÆÁªìÊûÑÊù•Áª¥Êä§ÁöÑÊ∂àÊÅØÂàóË°®. ÂçïÈìæË°®Âú®ÊèíÂÖ•ÂíåÂà†Èô§‰∏äÊØîËæÉÊúâ‰ºòÂäø. 123456789101112131415161718192021222324252627282930313233343536373839404142boolean enqueueMessage(Message msg, long when) &#123;// ÁúÅÁï•...synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125;&#125;return true;&#125; ÂèØ‰ª•ÁúãÂà∞enqueueMessageÁöÑÂÆûÁé∞‰∏ªË¶ÅÊìç‰ΩúÂ∞±ÊòØÂçïÈìæË°®ÁöÑÊèíÂÖ•Êìç‰Ωú. ÁªßÁª≠Áúã‰∏Ä‰∏ãnext()ÊñπÊ≥ï. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091Message next() &#123; final long ptr = mPtr; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; next()ÊòØ‰∏Ä‰∏™Êó†ÈôêÂæ™ÁéØÁöÑÊñπÊ≥ï, Â¶ÇÊûúÊ∂àÊÅØÈòüÂàó‰∏≠Ê≤°ÊúâÊ∂àÊÅØ, ÈÇ£‰πànextÊñπÊ≥ï‰ºö‰∏ÄÁõ¥ÈòªÂ°ûÂú®ËøôÈáå. ÂΩìÊúâÊñ∞Ê∂àÊÅØÂà∞Êù•Êó∂, nextÊñπÊ≥ï‰ºöËøîÂõûËøôÊù°Ê∂àÊÅØÂπ∂Â∞ÜÂÖ∂‰ªéÂçïÈìæË°®‰∏≠ÁßªÈô§. LooperÁöÑÂ∑•‰ΩúÂéüÁêÜLooperÂú®AndroidÁöÑÊ∂àÊÅØÊú∫Âà∂‰∏≠ÊâÆÊºîËÄÖÊ∂àÊÅØÂæ™ÁéØÁöÑËßíËâ≤, ÂÖ∑‰ΩìÊù•ËØ¥Â∞±ÊòØ‰ªñ‰ºö‰∏çÂÅúÂú∞‰ªéMessageQueue‰∏≠Êü•ÁúãÊòØÂê¶ÊúâÊñ∞Ê∂àÊÅØ. Â¶ÇÊûúÊúâÊñ∞Ê∂àÊÅØÂ∞±‰ºöÂ§ÑÁêÜ. Âê¶ÂàôÂ∞±‰∏ÄÁõ¥ÈòªÂ°ûÂú®ÈÇ£Èáå. ÂÖà‰ªéÊûÑÈÄ†ÊñπÊ≥ïÂºÄÂßã, Âú®ÊûÑÈÄ†ÊñπÊ≥ï‰∏≠‰ªñ‰ºöÂàõÂª∫‰∏Ä‰∏™MessageQueueÂç≥Ê∂àÊÅØÈòüÂàó, ÁÑ∂ÂêéÂ∞ÜÂΩìÂâçÁ∫øÁ®ãÁöÑÂØπË±°‰øùÂ≠òËµ∑Êù•. 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();//LooperÊåáÂÆöÁöÑÁ∫øÁ®ã&#125; ÊûÑÈÄ†ÂáΩÊï∞ÊòØÁßÅÊúâÊùÉÈôê, ËÄåÂÜÖÈÉ®‰ΩøÁî®ÁöÑÂú∞ÊñπÂ∞±ÊòØLooper#prepare()ÊñπÊ≥ï. 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; Ëøô‰πüÂ∞±ÊòØ‰∏∫‰ªÄ‰πàÂú®‰ΩøÁî®Handler‰πãÂâçË¶ÅÊúâLooperÁöÑËäÇÂ•è, ËÄåÂΩìË∞ÉÁî®‰∫ÜLooper.prepare(). Â∞±‰∏ç‰ºöÂá∫Áé∞ÂºÇÂ∏∏ÁöÑÂéüÂõ†. LooperÈô§‰∫Üprepare()ÊñπÊ≥ïÂ§ñ, ËøòÊèê‰æõ‰∫ÜprepareMainLooper()ÊñπÊ≥ï, Ëøô‰∏™ÊñπÊ≥ï‰∏ªË¶ÅÊòØÁªô‰∏ªÁ∫øÁ®ã‰πüÂ∞±ÊòØActivityThreadÂàõÂª∫Looper‰ΩøÁî®ÁöÑ. Êú¨Ë¥®‰πüÊòØÈÄöËøáprepare()Êù•ÂÆûÁé∞ÁöÑ. Áî±‰∫é‰∏ªÁ∫øÁ®ãÁöÑLooperÊØîËæÉÁâπÊÆä, ÊâÄ‰ª•LooperÊèê‰æõ‰∫Ü‰∏Ä‰∏™getMainLooper()ÊñπÊ≥ï, ÈÄöËøáÂÆÉÂèØ‰ª•Âú®‰ªª‰ΩïÂú∞ÊñπËé∑ÂèñÂà∞‰∏ªÁ∫øÁ®ãÁöÑLooper. LooperÁöÑÈÄÄÂá∫: quit(): Ëøô‰∏™ÊñπÊ≥ï‰ºöÁõ¥Êé•ÈÄÄÂá∫Looper quitSafely(): ËÆæÂÆö‰∏Ä‰∏™ÈÄÄÂá∫Ê†áËÆ∞, ÁÑ∂ÂêéÊääÊ∂àÊÅØÈòüÂàó‰∏≠ÁöÑÂ∑≤ÊúâÊ∂àÊÅØÂ§ÑÁêÜÂÆåÊØïÂêéÊâçÂÆâÂÖ®ÁöÑÈÄÄÂá∫. Â¶ÇÊûúLooperÈÄÄÂá∫, ÈÄöËøáHandlerÂèëÈÄÅÁöÑÊ∂àÊÅØ‰ºöÂ§±Ë¥•, Ëøô‰∏™Êó∂ÂÄôHandlerÂèëÈÄÅÁöÑÊ∂àÊÅØ‰ºöÂ§±Ë¥•, ËÄåHandler#send()ÊñπÊ≥ïËøô‰∏™Êó∂ÂÄôÂõûËøîÂõûfalse. Âú®Â≠êÁ∫øÁ®ã‰∏≠, Â¶ÇÊûúÊâãÂä®‰∏∫ÂÖ∂ÂàõÂª∫‰∫ÜLooper, ÈÇ£‰πàÂú®ÊâÄÊúâÁöÑ‰∫ãÊÉÖÂÆåÊàê‰ª•ÂêéÂ∫îËØ•Ë∞ÉÁî®quit()ÊñπÊ≥ïÊù•ÁªàÊ≠¢Ê∂àÊÅØÂæ™ÁéØ. Âê¶ÂàôËøô‰∏™Á∫øÁ®ã‰ºö‰∏ÄÁõ¥Â§Ñ‰∫éÁ≠âÂæÖÁöÑÁä∂ÊÄÅ, ËÄåÂ¶ÇÊûúÈÄÄÂá∫‰∫ÜLooper‰ª•Âêé, Ëøô‰∏™Á∫øÁ®ãÂ∞±‰ºöÁ´ãÂàªÁªàÊ≠¢. LooperÊúÄÈáçË¶ÅÁöÑ‰∏Ä‰∏™ÊñπÊ≥ïloop()ÊñπÊ≥ï, Âè™ÊúâË∞ÉÁî®‰∫ÜloopÂêé, Ê∂àÊÅØÂæ™ÁéØÁ≥ªÁªüÊâç‰ºöÁúüÊ≠£ÁöÑËµ∑‰ΩúÁî®,Â¶Ç‰∏ã 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; È¶ñÂÖàËøô‰∏™loop()ÊñπÊ≥ïÊòØ‰∏Ä‰∏™Ê≠ªÂæ™ÁéØ, ÂîØ‰∏ÄË∑≥Âá∫Âæ™ÁéØÁöÑÊñπÂºèÂ∞±ÊòØMessageQueue#next()ÊñπÊ≥ïËøîÂõûnull. ÂΩìLooper#quit()Ë¢´Ë∞ÉÁî®Êó∂, LooperÂ∞±‰ºöË∞ÉÁî®MessageQueue#quit()ÊàñËÄÖquitSafely()ÊñπÊ≥ïÊù•ÈÄöÁü•Ê∂àÊÅØÈòüÂàóÈÄÄÂá∫, ÂΩìÊ∂àÊÅØÈòüÂàóË¢´Ê†áËØÜ‰∏∫ÈÄÄÂá∫Áä∂ÊÄÅÊó∂, ÂÆÉÁöÑnext()ÊñπÊ≥ïÂ∞±‰ºöËøîÂõûnull. ‰πüÂ∞±ÊòØËØ¥LooperÂøÖÈ°ªÈÄÄÂá∫, Âê¶ÂàôloopÊñπÊ≥ïÂ∞±‰ºöÊó†ÈôêÂæ™ÁéØ‰∏ãÂéª. loop()‰ºöË∞ÉÁî®MessageQueue#next()ÊñπÊ≥ïÊù•Ëé∑ÂèñÊñ∞Ê∂àÊÅØ. ËÄånextÊòØ‰∏Ä‰∏™ÈòªÂ°ûÊìç‰Ωú, ÂΩìÊ≤°ÊúâÊ∂àÊÅØÊó∂, nextÊñπÊ≥ïÂ∞±‰ºö‰∏ÄÁõ¥ÈòªÂ°ûÂú®ÈÇ£Èáå. Ëøô‰πüÂØºËá¥loop()‰ºö‰∏ÄÁõ¥ÈòªÂ°ûÂú®ÈÇ£Èáå. Â¶ÇÊûúMessageQueue#next()ËøîÂõû‰∫ÜÊñ∞Ê∂àÊÅØ, LooperÂ∞±‰ºöÂ§ÑÁêÜËøôÊù°Ê∂àÊÅØ: msg.target.dispatchMessage(msg), ËøôÈáåÁöÑmsg.targetÊòØÂèëÈÄÅËøôÊù°Ê∂àÊÅØÁöÑHandlerÂØπË±°, ËøôÊ†∑HandlerÂèëÈÄÅÁöÑÊ∂àÊÅØÊúÄÁªàÂèà‰∫§ÁªôÂÆÉÁöÑdispatcherMessage()Êù•Â§ÑÁêÜ. ‰ΩÜÊòØËøôÈáå‰∏çÂêåÁöÑÊòØ, Handler#dispatcherMessage()ÊñπÊ≥ïÊòØÂú®ÂàõÂª∫HandlerÊó∂ÊâÄ‰ΩøÁî®ÁöÑLooper‰∏≠ÊâßË°åÁöÑÔºåËøôÊ†∑Â∞±ÊàêÂäüÁöÑÂ∞Ü‰ª£Á†ÅÈÄªËæëÂàáÊç¢Âà∞LooperÊåáÂÆöÁöÑÁ∫øÁ®ã‰∏≠ÂéªÊâßË°å‰∫Ü. HandlerÁöÑÂ∑•‰ΩúÂéüÁêÜHandler‰∏ªË¶ÅÂåÖÂê´Ê∂àÊÅØÁöÑÂèëÈÄÅÂíåÊé•Êî∂ËøáÁ®ã. Ê∂àÊÅØÁöÑÂèëÈÄÅÂèØ‰ª•ÈÄöËøápostÁöÑ‰∏ÄÁ≥ªÂàóÊñπÊ≥ï‰ª•ÂèäsendÁöÑ‰∏ÄÁ≥ªÂàóÊñπÊ≥ïÊù•ÂÆûÁé∞. postÁöÑ‰∏ÄÁ≥ªÂàóÊñπÊ≥ïÊúÄÁªàÂ∞±ÊòØËøòÊòØÈÄöËøásendÊñπÊ≥ïÊù•ÂÆûÁé∞ÁöÑ. 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; ‰∏äÈù¢ËøôÊÆµ‰ª£Á†ÅÊòØHandler#send()Á≥ªÂàóÁöÑÊúÄÁªàË∞ÉÁî®. ÂèØ‰ª•ÁúãÂá∫, HandlerÂèëÈÄÅÊ∂àÊÅØÁöÑËøáÁ®ã‰ªÖ‰ªÖÊòØÂêëÊ∂àÊÅØÈòüÂàó‰∏≠ÊèíÂÖ•‰∫Ü‰∏ÄÊù°Ê∂àÊÅØ, MessageQueue#next()ÊñπÊ≥ïÂ∞±ÊòØËøîÂõûËøôÊù°Ê∂àÊÅØÁªôLooper, LooperÊî∂Âà∞Ê∂àÊÅØÂêéÂ∞±ÂºÄÂßãÂ§ÑÁêÜ. ÊúÄÁªàÊ∂àÊÅØÊúâLooper‰∫§Áî±HandlerÂ§ÑÁêÜ, Âç≥Handler#dispatchMessage()ÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®, Ëøô‰∏™Êó∂ÂÄôHandlerÂ∞±‰ºöËøõÂÖ•‰∫ÜÂ§ÑÁêÜÊ∂àÊÅØÁöÑÈò∂ÊÆµ. 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; Êï¥ÁêÜ‰∏Ä‰∏ã: ÂÖàÊ£ÄÊü•msg.callbackÂ±ûÊÄßÊòØÂê¶‰∏∫null, ‰∏ç‰∏∫nullÂ∞±ÈÄöËøáhandleCallback()Êù•Â§ÑÁêÜÊ∂àÊÅØ. msg.callbackÊòØ‰∏Ä‰∏™RunnableÊé•Âè£, ÂÆûÈôÖ‰∏äÂ∞±ÊòØpost()‰∏≠‰º†ÈÄíÁöÑRunnableÂèÇÊï∞. handleCallback()ÂÆûÁé∞Â¶Ç‰∏ã: 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; ÂÖ∂Ê¨°Ê£ÄÊü•mCallbackÊòØÂê¶‰∏∫null, ‰∏ç‰∏∫nullÂ∞±Ë∞ÉÁî®mCallback.handleMessage(msg)ÊñπÊ≥ïÊù•Â§ÑÁêÜÊ∂àÊÅØ. CallbackÊòØ‰∏Ä‰∏™Êé•Âè£, ÂÆö‰πâÂ¶Ç‰∏ã: 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; ÈÄöËøáCallbackÂèØ‰ª•ÈááÁî®Â¶Ç‰∏ãÊñπÂºèÊù•ÂàõÂª∫HandlerÂØπË±°: Handler handler = new Handler(callback). ÈÄöËøáÊ∫êÁ†ÅÊ≥®Èáä‰∫ÜËß£: Ëøô‰∏™Êé•Âè£ÂèØ‰ª•Áî®Êù•ÂàõÂª∫‰∏Ä‰∏™HandlerÁöÑÂÆû‰æã‰ΩÜÂπ∂‰∏çÈúÄË¶ÅÊ¥æÁîüHandlerÁöÑÂ≠êÁ±ªÂπ∂ÈáçÂÜôÂÖ∂handleMessageÊñπÊ≥ïÊù•Â§ÑÁêÜÂÖ∑‰ΩìÁöÑÊ∂àÊÅØ, ËÄåCallBackÁªôÊàë‰ª¨Êèê‰æõ‰∫ÜÂè¶Â§ñ‰∏ÄÁßçÊñπÂºè‰ΩøÁî®Handler. ÂΩìÊàë‰ª¨‰∏çÊÉ≥Ê¥æÁîüÂ≠êÁ±ªÊó∂, Â∞±ÂèØ‰ª•ÈÄöËøáCallbackÊù•ÂÆûÁé∞. ÊúÄÂêé, Ë∞ÉÁî®Handler#handleMessage()ÊñπÊ≥ïÊù•Â§ÑÁêÜÊ∂àÊÅØ. HandlerËøòÊúâ‰∏Ä‰∏™ÁâπÊÆäÁöÑÊûÑÈÄ†ÊñπÊ≥ï, ÈÇ£Â∞±ÊòØÈÄöËøá‰∏Ä‰∏™ÁâπÂÆöÁöÑLooperÊù•ÊûÑÈÄ†HandlerÔºö 123public Handler(Looper looper) &#123; this(looper, null, false);&#125; HandlerÈªòËÆ§ÁöÑÊûÑÈÄ†ÊñπÊ≥ïpublic Handler(), Ëøô‰∏™ÊûÑÈÄ†ÊñπÊ≥ï‰ºöË∞ÉÁî®‰∏ãÈù¢ÁöÑÊûÑÈÄ†ÂáΩÊï∞. ÂæàÊòéÊòæËøôÂ∞±ÊòØ‰∏∫‰ªÄ‰πàÂΩìÂâçÁ∫øÁ®ãÊ≤°ÊúâLooperÁöÑËØù, Â∞±‰ºöÊäõÂá∫Can&#39;t create handler inside thread that has not called Looper.prepare()Ëøô‰∏™ÂºÇÂ∏∏. 123456789101112public Handler(Callback callback, boolean async) &#123; //.... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; ‰∏ªÁ∫øÁ®ãÁöÑÊ∂àÊÅØÂæ™ÁéØAndroidÁöÑ‰∏ªÁ∫øÁ®ãÂ∞±ÊòØActivityThread, ‰∏ªÁ®ãÂ∫èÁöÑÂÖ•Âè£ÊñπÊ≥ï‰∏∫main(), Âú®main()‰∏≠Á≥ªÁªüÈÄöËøáLooper.prepareMainLooper()Êù•ÂàõÂª∫‰∏ªÁ∫øÁ®ãÁöÑLooper‰ª•ÂèäMessageQueue, Âπ∂ÈÄöËøáLooper.loop()Êù•ÂºÄÂêØ‰∏ªÁ∫øÁ®ãÁöÑÊ∂àÊÅØÂæ™ÁéØ. ÂΩì‰∏ªÁ∫øÁ®ãÁöÑÊ∂àÊÅØÂæ™ÁéØÂºÄÂßã‰ª•Âêé, ActivityThreadËøòÈúÄË¶Å‰∏Ä‰∏™HandlerÊù•ÂíåÊ∂àÊÅØÈòüÂàóËøõË°å‰∫§‰∫í, Ëøô‰∏™HandlerÂ∞±ÊòØActivityThread.H, ÂÆÉÁöÑÂÜÖÈÉ®ÂÆö‰πâ‰∫Ü‰∏ÄÁªÑÊ∂àÊÅØÁ±ªÂûã, ‰∏ªË¶ÅÂåÖÂê´‰∫ÜÂõõÂ§ßÁªÑ‰ª∂ÁöÑÂêØÂä®ÂíåÂÅúÊ≠¢Á≠âËøáÁ®ã. 12345678910111213141516171819202122232425private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; public static final int SHOW_WINDOW = 105; public static final int HIDE_WINDOW = 106; public static final int RESUME_ACTIVITY = 107; public static final int SEND_RESULT = 108; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int NEW_INTENT = 112; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; public static final int CONFIGURATION_CHANGED = 118; public static final int CLEAN_UP_CONTEXT = 119; public static final int GC_WHEN_IDLE = 120; public static final int BIND_SERVICE = 121; public static final int UNBIND_SERVICE = 122;&#125; ActivityThreadÈÄöËøáApplicationThreadÂíåAMSËøõË°åËøõÁ®ãÈó¥ÈÄö‰ø°, AMS‰ª•ËøõÁ®ãÈó¥ÈÄö‰ø°ÁöÑÊñπÂºèÂÆåÊàêActivityThreadÁöÑËØ∑Ê±ÇÂêéÂõûË∞ÉApplicationThread‰∏≠ÁöÑBinder()ÊñπÊ≥ï, ÁÑ∂ÂêéApplicationThread‰ºöÂêëHÂèëÈÄÅÊ∂àÊÅØ, HÊî∂Âà∞Ê∂àÊÅØÂêé‰ºöÂ∞ÜApplicationThread‰∏≠ÁöÑÈÄªËæëÂàáÊç¢Âà∞ActivityThread‰∏≠ÂéªÊâßË°å, Âç≥ÂàáÊç¢Âà∞‰∏ªÁ∫øÁ®ãÂéªÊâßË°å, Ëøô‰∏™ËøáÁ®ãÂ∞±ÊòØ‰∏ªÁ∫øÁ®ãÁöÑÊ∂àÊÅØÂæ™ÁéØÊ®°Âûã.]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>Looper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ëâ∫ÊúØÊé¢Á¥¢ËØª‰π¶Á¨îËÆ∞]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ÂõõÂ§ßÁªÑ‰ª∂ÁöÑÂ∑•‰ΩúËøáÁ®ã ÂºïÁî® AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢ËØª‰π¶Á¨îËÆ∞ ÂÖàËØ¥‰∏§Âè•ÔºåÁéâÂàöÁöÑ‰π¶‰∏≠‰∏ªË¶Å‰æßÈáçÁöÑÊòØËøáÁ®ãÂàÜÊûêÂíå‰ª£Á†ÅËÆ≤Ëß£ÔºåËøôÊ†∑‰∏ÄÈ°µ‰∏ÄÈ°µÁöÑÁøªÂÆå‰πãÂêéÊÄªÊúâ‰∏ÄÁßçÊÑèÁäπÊú™Â∞ΩÂç¥‰∏çÂ§üÊ∏ÖÊô∞ÁöÑÊÑüËßâÔºå‰∏ÄÂºÄÂßãÊàë‰æùÁÑ∂ÊòØÁî®ÊñáÂ≠ólistÁöÑÊñπÂºèÊù•Ê¢≥ÁêÜÔºåÂêéÊù•ÂèëÁé∞ÁúãËµ∑Êù•ËøòÊòØÊúâÁÇπ‰∏çÂ§üÊ∏ÖÊô∞ÔºåËææ‰∏çÂà∞ÊàëÊÉ≥Ë¶ÅÁöÑÊïàÊûúÔºåÊâÄ‰ª•Êîπ‰∫Ü‰∏§ÁâàÂêéÊàëÂÜ≥ÂÆöÁî®Âõæ + ÊñáÂ≠óËØ¥ÊòéÁöÑÊñπÂºèÊù•Ë°®Áé∞ÔºåÂ∏åÊúõÂ§ßÂÆ∂ÂèØ‰ª•ÁúãÂæóÊõ¥Ê∏ÖÊô∞„ÄÇÊ≥®ÊÑèËøôÈáåÂ∑¶‰æßÊòØÁî®UMLÁîªÁöÑÊµÅÁ®ãÂõæÔºåÂèëÁé∞ËøòÊå∫Êñπ‰æøÁöÑÔºåÁ±ª‰∏≠ÁöÑÊñπÊ≥ïÊòØÊåâÁÖßË∞ÉÁî®È°∫Â∫èÊéíÂàóÁöÑÔºåÂè≥‰æßÁöÑUMLÂõæÂàôÊòØÁúüÊ≠£ÁöÑUMLÂõæÔºå‰ºöÊ†áÊ≥®Âá∫‰∏Ä‰∫õÈáçË¶ÅÁ±ªÁöÑÁªìÊûÑÂÖ≥Á≥ªÔºåÊéíÈô§ÂêÑ‰ΩçÁúã‰π¶Êó∂ÁúãÂà∞ÂêÑÁßçAÁªßÊâøBÔºåBÁªßÊâøCÊó∂Êôï‰∫ÜÁöÑÊÑüËßâ„ÄÇ ÂõõÂ§ßÁªÑ‰ª∂Ê¶ÇËø∞Ôºö ActivityÁöÑ‰∏ªË¶Å‰ΩúÁî®ÊòØÂ±ïÁ§∫‰∏Ä‰∏™ÁïåÈù¢Âπ∂ÂíåÁî®Êà∑‰∫§‰∫íÔºåÂÆÉÊâÆÊºîÁöÑÊòØ‰∏ÄÁßçÂâçÂè∞ÁïåÈù¢ÁöÑËßíËâ≤„ÄÇ ServiceÊòØ‰∏ÄÁßçËÆ°ÁÆóÂûãÁªÑ‰ª∂ÔºåÁî®‰∫éÂú®ÂêéÂè∞ÊâßË°å‰∏ÄÁ≥ªÂàóËÆ°ÁÆó‰ªªÂä°Ôºå‰ΩÜÂõ†‰∏∫ÂÖ∂Êú¨Ë∫´ËøòÊòØËøêË°åÂú®‰∏ªÁ∫øÁ®ã‰∏≠ÁöÑÔºåÂõ†Ê≠§ËÄóÊó∂ÁöÑÂêéÂè∞ËÆ°ÁÆó‰ªçÁÑ∂ÈúÄË¶ÅÂú®ÂçïÁã¨ÁöÑÁ∫øÁ®ã‰∏≠ÂéªÂÆåÊàê„ÄÇ BroadcastReceiverÊòØ‰∏ÄÁßçÊ∂àÊÅØÂûãÁªÑ‰ª∂ÔºåÁî®‰∫éÂú®‰∏çÂêåÁöÑÁªÑ‰ª∂‰πÉËá≥‰∏çÂêåÁöÑÂ∫îÁî®‰πãÈó¥‰º†ÈÄíÊ∂àÊÅØ„ÄÇÂπøÊí≠Ê≥®ÂÜåÊúâ‰∏§ÁßçÊñπÂºèÔºåÂä®ÊÄÅÊ≥®ÂÜåÈÄöËøáContext.registerReceiver()Êù•ÂÆûÁé∞ÔºåÂøÖÈ°ªË¶ÅÂ∫îÁî®ÂêØÂä®ÊâçËÉΩÊ≥®ÂÜåÔºõÈùôÊÄÅÊ≥®ÂÜåÂàôÂú®AndroidManifestÊñá‰ª∂‰∏≠ËøõË°åÔºåÂ∫îÁî®ÂÆâË£ÖÊó∂‰ºöË¢´Á≥ªÁªüËß£ÊûêÔºå‰∏çÈúÄË¶ÅÂêØÂä®Â∫îÁî®Â∞±ÂèØÊé•Êî∂ÂπøÊí≠„ÄÇ ContentProviderÊòØ‰∏ÄÁßçÂÖ±‰∫´ÂûãÁªÑ‰ª∂ÔºåÁî®‰∫éÂêëÂÖ∂‰ªñÁªÑ‰ª∂‰πÉËá≥ÂÖ∂‰ªñÂ∫îÁî®ÂÖ±‰∫´Êï∞ÊçÆ„ÄÇ ‚Äã ActivityÁöÑÂ∑•‰ΩúËøáÁ®ã Ê≥®üòñ ÂêØÂä®ActivityÁöÑÁúüÂÆûÂÆûÁé∞ÊòØÁî±ActivityManagerNative.getDefault().startActivityÊñπÊ≥ïÊù•ÂÆåÊàêÁöÑ„ÄÇ ActivityManagerServiceÔºàAMSÔºâÁªßÊâøËá™ActivityManagerNativeÔºåËÄåActivityManagerNativeÁªßÊâøËá™BinderÂπ∂ÂÆûÁé∞‰∫ÜIActivityManagerËøô‰∏™BinderÊé•Âè£ÔºåÂõ†Ê≠§AMS‰πüÊòØ‰∏Ä‰∏™Binder„ÄÇ AMSËøô‰∏™BinderÂØπË±°ÈááÁî®Âçï‰æãÊ®°ÂºèÂØπÂ§ñÊèê‰æõÔºåÁ¨¨‰∏ÄÊ¨°Ë∞ÉÁî®ÂÆÉÁöÑgetÊñπÊ≥ïÊó∂‰ºöÈÄöËøácreateÊñπÊ≥ïÂàùÂßãÂåñÔºåÂêéÁª≠Ë∞ÉÁî®‰∏≠Áõ¥Êé•ËøîÂõû‰πãÂâçÂàõÂª∫ÁöÑÂØπË±°„ÄÇ ‰ªémakeApplicationÁöÑÂÆûÁé∞ÂèØ‰ª•ÁúãÂá∫ÔºåÂ¶ÇÊûúApplicationÂ∑≤ÁªèË¢´ÂàõÂª∫Ëøá‰∫ÜÔºåÈÇ£‰πàÂ∞±‰∏ç‰ºöÂÜçÈáçÂ§çÂàõÂª∫ÔºåËøô‰πüÊÑèÂë≥ÁùÄ‰∏Ä‰∏™Â∫îÁî®Âè™Êúâ‰∏Ä‰∏™ApplicationÂØπË±°„ÄÇApplicationÁöÑÂàõÂª∫‰πüÊòØÈÄöËøáInstrumentationÊù•ÂÆåÊàêÁöÑÔºåËøô‰∏™ËøáÁ®ãÂíåActivityÂØπË±°ÁöÑÂàõÂª∫ËøáÁ®ã‰∏ÄÊ†∑ÔºåÈÉΩÊòØÈÄöËøáÁ±ªÂä†ËΩΩÂô®Êù•ÂÆûÁé∞ÁöÑ„ÄÇ ContextImplÊòØContextÁöÑÂÖ∑‰ΩìÂÆûÁé∞ÔºåContextImplÊòØÈÄöËøáActivityÁöÑattachÊñπÊ≥ïÊù•ÂíåActivityÂª∫Á´ãÂÖ≥ËÅîÁöÑÔºåÂú®attachÊñπÊ≥ï‰∏≠ActivityËøò‰ºöÂÆåÊàêWindowÁöÑÂàõÂª∫Âπ∂Âª∫Á´ãËá™Â∑±ÂíåWindowÁöÑÂÖ≥ËÅîÔºåËøôÊ†∑ÂΩìActivityÊé•ÂèóÂà∞‰∫ã‰ª∂Â∞±ÂèØ‰ª•‰º†ÈÄíÁªôwindow‰∫Ü„ÄÇ ‚Äã ServiceÁöÑÂ∑•‰ΩúËøáÁ®ãÂêØÂä®ËøáÁ®ãÔºö ÁªëÂÆöËøáÁ®ãÊ≥® ServiceÊúâ‰∏§ÁßçÁä∂ÊÄÅÔºöÂêØÂä®Áä∂ÊÄÅÂíåÁªëÂÆöÁä∂ÊÄÅÔºå‰∏§ÁßçÁä∂ÊÄÅÊòØÂèØ‰ª•ÂÖ±Â≠òÁöÑ„ÄÇ BroadcastReceiverÁöÑÂ∑•‰ΩúËøáÁ®ãBroadcastReceiverÁöÑÂ∑•‰ΩúËøáÁ®ãÂåÖÊã¨ÂπøÊí≠Ê≥®ÂÜåËøáÁ®ã„ÄÅÂπøÊí≠ÂèëÈÄÅÂíåÊé•Êî∂ËøáÁ®ã„ÄÇ Âä®ÊÄÅÊ≥®ÂÜå ÂπøÊí≠ÂèëÈÄÅÂíåÊé•Êî∂ Ê≥®Ôºö ÈùôÊÄÅÊ≥®ÂÜåÊòØÁî±PackageManagerServiceÔºàPMSÔºâÂú®Â∫îÁî®ÂÆâË£ÖÁöÑÊó∂ÂÄôÂÆåÊàêÊï¥‰∏™Ê≥®ÂÜåËøáÁ®ãÁöÑÔºåÈô§ÂπøÊí≠‰ª•Â§ñÔºåÂÖ∂‰ªñ‰∏âÂ§ßÁªÑ‰ª∂‰πüÈÉΩÊòØÂú®Â∫îÁî®ÂÆâË£ÖÊó∂Áî±PMSËß£ÊûêÂπ∂Ê≥®ÂÜåÁöÑ„ÄÇ ÂπøÊí≠ÁöÑÂèëÈÄÅÊúâÂá†ÁßçÁ±ªÂûãÔºöÊôÆÈÄöÂπøÊí≠„ÄÅÊúâÂ∫èÂπøÊí≠ÂíåÁ≤òÊÄßÂπøÊí≠ÔºåÊúâÂ∫èÂπøÊí≠ÂíåÁ≤òÊÄßÂπøÊí≠‰∏éÊôÆÈÄöÂπøÊí≠Áõ∏ÊØîÂÖ∑Êúâ‰∏çÂêåÁöÑÁâπÊÄßÔºå‰ΩÜÊòØÂèëÈÄÅÂíåÊé•Êî∂ËøáÁ®ãÊòØÁ±ª‰ººÁöÑ„ÄÇ FLAG_INCLUDE_STOPPED_PACKAGES:ÂπøÊí≠‰ºöÂèëÈÄÅÁªôÂ∑≤ÁªèÂÅúÊ≠¢ÁöÑÂ∫îÁî®ÔºåFLAG_EXCLUDE_STOPPED_PACKAGESÂπøÊí≠‰∏ç‰ºöÂèëÈÄÅÁªôÂ∑≤ÁªèÂÅúÊ≠¢ÁöÑÂ∫îÁî® ‰ªéAndroid 3.1ÂºÄÂßãÔºåÂ§Ñ‰∫éÂÅúÊ≠¢Áä∂ÊÄÅÁöÑÂ∫îÁî®Êó†Ê≥ïÊé•ÂèóÂà∞ÂºÄÊú∫ÂπøÊí≠„ÄÇ ContentProviderÂêØÂä®ËøáÁ®ã ÂΩìContentProviderÊâÄÂú®ÁöÑËøõÁ®ãÂêØÂä®Êó∂Ôºå‰ºöÂêåÊó∂Ë¢´ÂêØÂä®Âπ∂Ë¢´ÂèëÂ∏ÉÂà∞AMS‰∏≠ÔºåÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØÔºåËøô‰∏™Êó∂ÂÄôÂÆÉÁöÑonCreateË¶ÅÂÖàÂéªApplicationÁöÑonCreateÊâßË°åÔºåËøôÂú®ÂõõÂ§ßÁªÑ‰ª∂‰∏≠ÊòØ‰∏Ä‰∏™Â∞ëÊúâÁöÑÁé∞Ë±°„ÄÇ Áî®ÂêØÂä®ÁöÑÂÖ•Âè£‰∏∫ActivityThreadÁöÑmainÊñπÊ≥ïÔºåmainÊñπÊ≥ï‰ºöÂàõÂª∫ActivityThreadÂÆû‰æãÂπ∂ÂàõÂª∫‰∏ªÁ∫øÁ®ãÊ∂àÊÅØÈòüÂàó„ÄÇ attachÊñπÊ≥ï‰∏≠ËøúÁ®ãË∞ÉÁî®AMSÁöÑattachApplicationÊñπÊ≥ïÔºåÂπ∂Êèê‰æõApplicationThreadÁî®‰∫éÂíåAMSÁöÑÈÄö‰ø°„ÄÇ attachApplicationÊñπÊ≥ï‰ºöÈÄöËøábindApplicationÊñπÊ≥ïÂíåHÊù•ActivityThreadÁöÑhandleBindApplicationÔºåËøô‰∏™ÊñπÊ≥ï‰ºöÂÖàÂàõÂª∫ApplicationÔºåÂÜçÂä†ËΩΩContentProviderÔºåÁÑ∂ÂêéÊâç‰ºöÂõûË∞ÉApplicationÁöÑonCreateÊñπÊ≥ï„ÄÇ ContentProviderÁöÑmultiprocessÂ±ûÊÄßÂÜ≥ÂÆö‰∫ÜContentProviderÊòØÂê¶ÊòØÂçï‰æãÔºàfalseÊó∂ÔºâÔºå‰∏ÄËà¨ÈÉΩÁî®Âçï‰æã„ÄÇ ontentResolverÁöÑÂÖ∑‰ΩìÁ±ªÊòØApplicationContentResolverÔºåÂΩìContentProviderÊâÄÂú®ËøõÁ®ãÊú™ÂêØÂä®Êó∂ÔºåÁ¨¨‰∏ÄÊ¨°ËÆøÈóÆÂÆÉ‰ºöËß¶ÂèëContentProviderÁöÑÂàõÂª∫‰ª•ÂèäËøõÁ®ãÂêØÂä®„ÄÇ QueryÊµÅÁ®ã insertÔºådeleteÂíåupdateÊñπÊ≥ïÁ±ª‰ººÔºåËøôÈáåÂ∞±‰∏çÂú®ÂàÜÊûê‰∫Ü„ÄÇ AndroidÁöÑÊ∂àÊÅØÊú∫Âà∂ ‰∏âÂ§ß‰ª∂ÔºöHanlderÔºåMessageQueueÔºåLooper„ÄÇ MessageQueueÂÜÖÈÉ®ÁöÑÊï∞ÊçÆÁªìÊûÑÂπ∂ÈùûÈòüÂàóÔºåËÄåÊòØÂçïÈìæË°®ÔºåÂÆÉÂè™ÊòØÁî®Êù•Â≠òÂÇ®Êï∞ÊçÆ„ÄÇ LooperÊòØÁúüÊ≠£ÁöÑÊï∞ÊçÆÂ§ÑÁêÜËÄÖÔºåÁ∫øÁ®ãÈªòËÆ§Ê≤°ÊúâLooperÔºå‰ΩøÁî®HandlerÂøÖÈ°ª‰∏∫Á∫øÁ®ãÂàõÂª∫LooperÔºåUIÁ∫øÁ®ã‰πüÂ∞±ÊòØActivityThreadÂàõÂª∫Êó∂‰ºöÂàùÂßãÂåñLooperÔºåÊâÄ‰ª•‰∏ªÁ∫øÁ®ã‰∏≠ÈªòËÆ§ÂèØ‰ª•Áõ¥Êé•‰ΩøÁî®Handler„ÄÇ UIÁ∫øÁ®ãÊ£ÄÊü•ÂΩìÂâçÁ∫øÁ®ãÁöÑÊìç‰ΩúÂú®ViewRootImplÁöÑcheckThreadÊñπÊ≥ï‰∏≠ÔºåÊàë‰ª¨Â∏∏ËßÅÁöÑ‰∏çËÉΩÂú®Â≠êÁ∫øÁ®ã‰∏≠ËÆøÈóÆviewÁöÑÂºÇÂ∏∏Â∞±ÊòØÂú®ËøôÈáåÊäõÂá∫ÁöÑ„ÄÇ ‰∏çÂÖÅËÆ∏Â≠êÁ∫øÁ®ãËÆøÈóÆ‰∏ªÁ∫øÁ®ãÁöÑÂéüÂõ†ÊòØUIÊéß‰ª∂‰∏çÊòØÁ∫øÁ®ãÂÆâÂÖ®ÁöÑÔºåËÄåÂä†ÈîÅÂèà‰ºöÂØºËá¥UIÁöÑÊìç‰ΩúËøá‰∫éÂ§çÊùÇ„ÄÇ HandlerÁöÑÂ∑•‰ΩúËøáÁ®ãÔºåÂõæÔºàpage374ÔºâÔºåÊàëÁÆÄÂçïÊ¶ÇÊã¨‰∏Ä‰∏ãÂ∞±ÊòØÔºöÂÅáËÆæÂàõÂª∫HandlerÁöÑÁ∫øÁ®ãÊòØAÔºåËÄóÊó∂Êìç‰ΩúÁöÑÁ∫øÁ®ãÊòØBÔºåBÁ∫øÁ®ã‰∏≠ÊãøÂà∞handlerÂÆû‰æãÂèëÈÄÅÊ∂àÊÅØÊàñËÄÖpost‰∏Ä‰∏™RunnableÔºåÂÆûÈôÖÊòØË∞ÉÁî®‰∫ÜMessageQueueÁöÑenqueueMessageÊñπÊ≥ïÔºåËøõÂÖ•‰∫ÜÊ∂àÊÅØÈòüÂàóÔºåÁ∫øÁ®ãA‰∏≠ÁöÑLooperÂèëÁé∞‰∫ÜËøô‰∏™Ê∂àÊÅØÔºåÂ∞±‰ºöÂ§ÑÁêÜËøô‰∏™Ê∂àÊÅØÔºå‰πüÂ∞±ÊòØÊ∂àÊÅØ‰∏≠ÁöÑRunnableÊàñËÄÖhandlerÁöÑhandleMessageÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®ÔºåËøôÊ†∑handler‰∏≠ÁöÑ‰∏öÂä°ÈÄªËæëÂ∞±Ë¢´ÂàáÊç¢Âà∞Á∫øÁ®ãA‰∏≠Âéª‰∫Ü„ÄÇ ThreadLocalÊàëÁî®‰∏ÄÂè•Â§ßÁôΩËØùÊù•ËÆ≤Ëß£ÔºåÂ∞±ÊòØÁúã‰∏äÂéªÂè™new‰∫Ü‰∏Ä‰ªΩÔºå‰ΩÜÂú®ÊØè‰∏™‰∏çÂêåÁöÑÁ∫øÁ®ã‰∏≠Âç¥ÂèØ‰ª•Êã•Êúâ‰∏çÂêåÊï∞ÊçÆÂâØÊú¨ÁöÑÁ•ûÂ•áÁ±ª„ÄÇÂÖ∂Êú¨Ë¥®ÊòØThreadLocal‰∏≠ÁöÑValuesÁ±ªÁª¥Êä§‰∫Ü‰∏Ä‰∏™Object[]ÔºåËÄåÊØè‰∏™ThreadÁ±ª‰∏≠Êúâ‰∏Ä‰∏™ThreadLocal.ValuesÊàêÂëòÔºåÂΩìË∞ÉÁî®ThreadLocalÁöÑsetÊñπÊ≥ïÊó∂ÔºåÂÖ∂ÂÆûÊòØÊ†πÊçÆ‰∏ÄÂÆöËßÑÂàôÊääËøô‰∏™Á∫øÁ®ã‰∏≠ÂØπÂ∫îÁöÑThreadLocalÂÄºÂ°ûËøõ‰∫ÜValuesÁöÑObject[]Êï∞ÁªÑ‰∏≠ÁöÑÊüê‰∏™indexÈáå„ÄÇËøô‰∏™indexÊÄªÊòØ‰∏∫ThreadLocalÁöÑreferenceÂ≠óÊÆµÊâÄÊ†áËØÜÁöÑÂØπË±°ÁöÑ‰∏ã‰∏Ä‰∏™‰ΩçÁΩÆ„ÄÇ MessageQueueÁöÑÂ∑•‰ΩúÂéüÁêÜÔºö‰∏ªË¶ÅÊñπÊ≥ï‰∏∫enqueueMessageÂíånext„ÄÇa. enqueueMessag‰∏ªË¶ÅÂ∞±ÊòØ‰∏Ä‰∏™ÂçïÈìæË°®ÁöÑÊèíÂÖ•Êìç‰ΩúÔºåb. nextÊñπÊ≥ïÊòØ‰∏Ä‰∏™Êó†ÈôêÂæ™ÁéØÔºåÂ¶ÇÊûúÊ∂àÊÅØÈòüÂàó‰∏≠Ê≤°ÊúâÊ∂àÊÅØÔºånextÊñπÊ≥ïÂ∞±ÈòªÂ°ûÔºåÊúâÊñ∞Ê∂àÊÅØÂà∞Êù•Êó∂ÔºånextÊñπÊ≥ï‰ºöËøîÂõûËøôÊù°Ê∂àÊÅØÂπ∂Â∞ÜÂÖ∂‰ªéÂçïÈìæË°®‰∏≠Âà†Èô§„ÄÇ LooperÁöÑÂ∑•‰ΩúÂéüÁêÜÔºöa. prepareÊñπÊ≥ïÔºå‰∏∫ÂΩìÂâçÊ≤°ÊúâLooperÁöÑÁ∫øÁ®ãÂàõÂª∫Looper„ÄÇb. prepareMainLooperÂíågetMainLooperÊñπÊ≥ïÁî®‰∫éÂàõÂª∫ÂíåËé∑ÂèñActivityThreadÁöÑLooper„ÄÇc. quitÂíåquitSafelyÊñπÊ≥ïÔºåÂâçËÄÖÁ´ãÂç≥ÈÄÄÂá∫ÔºåÂêéËÄÖÂè™ÊòØËÆæÂÆö‰∏Ä‰∏™Ê†áËÆ∞ÔºåÂΩìÊ∂àÊÅØÈòüÂàó‰∏≠ÁöÑÊâÄÊúâÊ∂àÊÅØÂ§ÑÁêÜÂÆåÊØïÂêé‰ºöÊâçÂÆâÂÖ®ÈÄÄÂá∫„ÄÇÂ≠êÁ∫øÁ®ã‰∏≠ÂàõÂª∫ÁöÑLooperÂª∫ËÆÆ‰∏çÈúÄË¶ÅÁöÑÊó∂ÂÄôÈÉΩË¶ÅÊâãÂä®ÁªàÊ≠¢„ÄÇd. loopÊñπÊ≥ïÔºåÊ≠ªÂæ™ÁéØÔºåÈòªÂ°ûËé∑ÂèñmsgÂπ∂‰∏¢Áªômsg.target.dispatchMessageÊñπÊ≥ïÂéªÂ§ÑÁêÜÔºåËøôÈáåÁöÑtargetÂ∞±ÊòØhandler„ÄÇ HandlerÁöÑÂ∑•‰ΩúÂéüÁêÜÔºöa. Êó†ËÆ∫sendMessageËøòÊòØpostÊúÄÁªàÈÉΩÊòØË∞ÉÁî®ÁöÑsendMessageAtTimeÊñπÊ≥ï„ÄÇb. ÂèëÈÄÅÊ∂àÊÅØÂÖ∂ÂÆûÂ∞±ÊòØÊää‰∏ÄÊù°Ê∂àÊÅØÈÄöËøáMessageQueueÁöÑenqueueMessageÊñπÊ≥ïÂä†ÂÖ•Ê∂àÊÅØÈòüÂàóÔºåLooperÊî∂Âà∞Ê∂àÊÅØÂ∞±‰ºöË∞ÉÁî®handlerÁöÑdispatchMessageÊñπÊ≥ï„ÄÇÂÆÉÁöÑÂ§ÑÁêÜËøáÁ®ãÂèÇËÄÉ‰π¶page388ÁöÑÊµÅÁ®ãÂõæÔºå‰∏ÄÁúãÂ∞±ÊáÇÔΩûc. ËøôÈáåÊàëË°•ÂÖÖ‰∏Ä‰∏™‰∏úË•øÔºåÂΩìÊàë‰ª¨Áõ¥Êé•Handler h = new Handler()Êó∂ÔºåÊú¨Ë¥®Ë∞ÉÁî®ÁöÑÊòØHandler(Callback callback, Boolean async)ÊûÑÈÄ†ÊñπÊ≥ïÔºåËøô‰∏™ÊñπÊ≥ïÈáå‰ºöË∞ÉÁî®Looper.myLooper()ÊñπÊ≥ïÔºåËøô‰∏™ÊñπÊ≥ïÂÖ∂ÂÆûÂ∞±ÊòØËøîÂõûÁöÑThreadLocalÈáå‰øùÂ≠òÁöÑÂΩìÂâçÁ∫øÁ®ãÁöÑLooperÔºåËøô‰πüÂ∞±Ëß£Èáä‰∫Ü‰∏∫‰ªÄ‰πàÊàë‰ª¨Âú®‰∏ªÁ∫øÁ®ã‰∏≠ËøôÊ†∑newÊ≤°ÊúâÈóÆÈ¢òÔºåÂ≠êÁ∫øÁ®ã‰∏≠Â¶ÇÊûú‰∏çÂÖàLooper.prepare‰ºöÊäõÂá∫ÂºÇÂ∏∏ÁöÑÂéüÂõ†ÔºåÂâçÈù¢Â§öÊ¨°ËØ¥‰∫ÜÔºåÂõ†‰∏∫ActivityThread‰ºöÂú®ÂàùÂßãÂåñÁöÑÊó∂ÂÄôÂàõÂª∫Ëá™Â∑±ÁöÑLooper„ÄÇ ‰∏ªÁ∫øÁ®ãÁöÑÊ∂àÊÅØÂæ™ÁéØÔºö WindowÂíåWindowManager ‰∏Ä‰∫õÂü∫Á°ÄÁü•ËØÜÔºö WindowÁöÑÂÆûÁé∞Á±ªÊòØPhoneWindow„ÄÇ WindowÁöÑÂÖ∑‰ΩìÂÆûÁé∞‰Ωç‰∫éWindowManagerService‰∏≠ÔºåWindowManagerÂíåWindowManagerServiceÁöÑ‰∫§‰∫íÊòØ‰∏Ä‰∏™IPCËøáÁ®ã„ÄÇ WindowÂÆûÈôÖÊòØViewÁöÑÁõ¥Êé•ÁÆ°ÁêÜËÄÖ„ÄÇ Â∏∏Áî®ÁöÑWindowManager.LayoutParamsÁöÑFlagÂíåType1Ôºâ FLAGÔºö FLAG_NOT_FOCUSABLEÔºåÂΩìÂâçWindow‰∏çËé∑ÂèñÁÑ¶ÁÇπÔºå‰πü‰∏çÊé•Êî∂ÂêÑÁßçËæìÂÖ•‰∫ã‰ª∂Ôºå‰ºöÂêåÊó∂ÂêØÁî®FLAG_NOT_TOUCH_MODALÔºå‰∫ã‰ª∂‰ºö‰º†ÈÄíÁªô‰∏ãÂ±ÇÂÖ∑ÊúâÁÑ¶ÁÇπÁöÑWindow„ÄÇ FLAG_NOT_TOUCH_MODALÔºåÂΩìÂâçWindowÂå∫ÂüüÂ§ñÁöÑÂçïÂáª‰∫ã‰ª∂‰º†ÈÄíÁªôÂ∫ïÂ±ÇÔºåÂå∫ÂüüÂÜÖÁöÑÂçïÂáª‰∫ã‰ª∂Ëá™Â∑±Â§ÑÁêÜÔºå‰∏ÄËà¨ÈÉΩÈúÄË¶ÅÂºÄÂêØ„ÄÇ FLAG_SHOW_WHEN_LOCKEDÔºåÂèØ‰ª•ËÆ©WindowÊòæÁ§∫Âú®ÈîÅÂ±èÁïåÈù¢‰∏ä„ÄÇ 2Ôºâ TypeÔºö Â∫îÁî®WindowÔºå‰∏ÄËà¨ÂØπÂ∫î‰∏Ä‰∏™Activity„ÄÇÂ±ÇÁ∫ßËåÉÂõ¥1ÔΩû99„ÄÇ Â≠êWindowÔºå‰∏çËÉΩÂçïÁã¨Â≠òÂú®ÔºåÈúÄË¶ÅÁâπÂÆöÁöÑÁà∂WindowÔºåÊØîÂ¶Ç‰∏ÄËà¨ÁöÑDialog„ÄÇÂ±ÇÁ∫ßËåÉÂõ¥1000ÔΩû1999„ÄÇ Á≥ªÁªüWindowÔºåÈúÄË¶ÅÊùÉÈôêÂ£∞ÊòéÔºåÊØîÂ¶ÇToast„ÄÇÂ±ÇÁ∫ßËåÉÂõ¥2000ÔΩû2999„ÄÇ‰∏ÄËà¨ÂèØ‰ª•ÈÄâÁî®WindowManager.LayoutParams.TYPE_SYSTEM_ERRORÔºåÂêåÊó∂Â£∞ÊòéÊùÉÈôê„ÄÇ 3Ôºâ WindowManagerÊèê‰æõÁöÑÂäüËÉΩÔºöaddViewÔºåupdateViewLayoutÔºåremoveView WindowÁöÑÂÜÖÈÉ®Êú∫Âà∂ÔºöWindowÂπ∂‰∏çÂÆûÈôÖÂ≠òÂú®Ôºå‰ª•ViewÁöÑÂΩ¢ÂºèÂ≠òÂú®„ÄÇÊØè‰∏™WindowÂØπÂ∫îÁùÄ‰∏Ä‰∏™ViewÂíåViewRootImplÔºåWindowÂíåViewÈÄöËøáViewRootImplÂª∫Á´ãËÅîÁ≥ª„ÄÇÊâÄ‰ª•Âú®ÂÆûÈôÖ‰ΩøÁî®‰∏≠ÂÖ∂ÂÆûÊàë‰ª¨Âπ∂‰∏çËÉΩËÆøÈóÆÂà∞ÁúüÊ≠£ÁöÑWindowÔºåËÄåÂè™ËÉΩÈÄöËøáWindowManager„ÄÇ1Ôºâ Âá†‰∏™ÈáçË¶ÅÁöÑwindowÁ±ªÁöÑÂÖ≥Á≥ªÔºàÂèëÁé∞‰∏ªÂ∏≠‰∏çÂ§ßÁà±ÁîªUMLÔºåÊàëÂ∞±‰ª£Â∑•‰∫ÜÔºâ2Ôºâ WindowÁöÑÊ∑ªÂä†ËøáÁ®ã WindowManagerGlobal‰∏≠ÁöÑaddViewÔºö Ê£ÄÊü•ÂèÇÊï∞ÊòØÂê¶ÂêàÊ≥ïÔºõ Â¶ÇÊûúÂ≠êWindowËøòÈúÄË¶ÅË∞ÉËäÇÂ∏ÉÂ±ÄÂèÇÊï∞Ôºõ ÂàõÂª∫ViewRootImplÂπ∂Â∞ÜViewÊ∑ªÂä†Âà∞ÂàóË°®‰∏≠Ôºõ ÈÄöËøáViewRootImplÁöÑsetViewÊù•Êõ¥Êñ∞ÁïåÈù¢Âπ∂ÂÆåÊàêWindowÁöÑÊ∑ªÂä†ËøáÁ®ãÔºörequestLayout‰∏≠ÁöÑscheduleTraversalsÊòØViewÁªòÂà∂ÁöÑÂÖ•Âè£ÔºåÊúÄÁªàÈÄöËøáWindowSessionÊù•ÂÆåÊàêWindowÁöÑÊ∑ªÂä†ËøáÁ®ãÔºåÊ≥®ÊÑèÂÖ∂ÂÆûËøôÈáåÊòØ‰∏™IPCËøáÁ®ãÔºåÊúÄÁªà‰ºöÈÄöËøáWindowManagerServiceÁöÑaddWindowÊñπÊ≥ïÊù•ÂÆûÁé∞WindowÁöÑÊ∑ªÂä†„ÄÇ 3Ôºâ WindowÁöÑÂà†Èô§ËøáÁ®ã WinodwManagerGlobal‰∏≠ÁöÑremoveViewÔºõ findViewLockedÊù•Êü•ÊâæÂæÖÂà†Èô§ÂæÖViewÁöÑÁ¥¢ÂºïÔºåÂÜçË∞ÉÁî®removeViewLockedÊù•ÂÅöËøõ‰∏ÄÊ≠•Âà†Èô§Ôºõ removeViewLockedÈÄöËøáViewRootImplÁöÑdieÊñπÊ≥ïÊù•ÂÆåÊàêÂà†Èô§Êìç‰ΩúÔºåÂåÖÊã¨ÂêåÊ≠•ÂíåÂºÇÊ≠•‰∏§ÁßçÊñπÂºèÔºåÂêåÊ≠•ÊñπÂºèÂèØËÉΩ‰ºöÂØºËá¥ÊÑèÂ§ñÁöÑÈîôËØØÔºå‰∏çÊé®ËçêÔºå‰∏ÄËà¨‰ΩøÁî®ÂºÇÊ≠•ÁöÑÊñπÂºèÔºåÂÖ∂ÂÆûÂ∞±ÊòØÈÄöËøáhandlerÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™Âà†Èô§ËØ∑Ê±ÇÔºåÂ∞ÜViewÊ∑ªÂä†Âà∞mDyingViews‰∏≠Ôºõ dieÊñπÊ≥ïÊú¨Ë¥®Ë∞ÉÁî®‰∫ÜdoDieÊñπÊ≥ïÔºåÁúüÊ≠£Âà†Èô§ViewÁöÑÈÄªËæëÂú®ËØ•ÊñπÊ≥ïÁöÑdispatchDetachedFromWindowÊñπÊ≥ï‰∏≠Ôºå‰∏ªË¶ÅÂÅö‰∫ÜÂõõ‰ª∂‰∫ãÔºöÂûÉÂúæÂõûÊî∂ÔºåÈÄöËøáSessionÁöÑremoveÊñπÊ≥ïÂà†Èô§WindowÔºåË∞ÉÁî®ViewÁöÑdispatchDetachedFromWindowÊñπÊ≥ïÂêåÊó∂‰ºöÂõûË∞ÉViewÁöÑonDetachedFromWindow‰ª•ÂèäonDetachedFromWindowInternalÔºåË∞ÉÁî®WindowManagerGlobalÁöÑdoRemoveViewÂà∑Êñ∞Êï∞ÊçÆ„ÄÇ 4Ôºâ WindowÁöÑÊõ¥Êñ∞ËøáÁ®ãWindowManagerGlobalÁöÑupdateViewLayoutÔºõÊõ¥Êñ∞ViewÁöÑLayoutParamsÔºõÊõ¥Êñ∞ViewImpleÁöÑLayoutParamsÔºåÂÆûÁé∞ÂØπViewÁöÑÈáçÊñ∞ÊµãÈáèÔºåÂ∏ÉÂ±ÄÔºåÈáçÁªòÔºõÈÄöËøáWindowSessionÊõ¥Êñ∞WindowÁöÑËßÜÂõæÔºåWindowManagerService.relayoutWindow()„ÄÇ WindowÁöÑÂàõÂª∫ËøáÁ®ã1Ôºâ Activity ActivityÁöÑattachÊñπÊ≥ï‰∏≠ÔºåÁ≥ªÁªü‰ºöÂàõÂª∫ActivityÊâÄÂ±ûÁöÑWindowÂπ∂‰∏∫ÂÖ∂ËÆæÁΩÆÂõûË∞ÉÔºõ WindowÂØπË±°ÁöÑÂàõÂª∫ÈÄöËøáPolicyManagerÁöÑmakeNewWindowÊñπÊ≥ïÔºõ WindowÁöÑÂÖ∑‰ΩìÂÆûÁé∞ÊòØPhoneWindowÁ±ªÔºõ WindowÂàõÂª∫Â•Ω‰πãÂêéÔºåÈÄöËøáPhoneWindowÁöÑsetContentViewÂ∞ÜActivity‰∏éWindowËøõË°åÂÖ≥ËÅîÔºåËøô‰∏™ÊñπÊ≥ïÂ§ßËá¥Ê≠•È™§Ôºö a. Â¶ÇÊûúÊ≤°ÊúâDecorViewÂ∞±ÂàõÂª∫ÔºåidÊòØandroid.R.id.contentÔºõb. Â∞ÜActivityËÆæÁΩÆÁöÑContentViewËÆæÁΩÆÂà∞DecorViewÁöÑmContentParent‰∏≠Ôºõc. ÂõûË∞ÉActivityÁöÑonContentChangedÊñπÊ≥ïÈÄöÁü•ActivityËßÜÂõæÂ∑≤ÁªèÂèëÁîüÊîπÂèòÔºõd. Activity onResumeÁöÑÊó∂ÂÄô‰ºöË∞ÉÁî®ActivityÁöÑmakeVisibleÊñπÊ≥ïÁúüÊ≠£ÂÆåÊàêDecorViewÁöÑÊ∑ªÂä†ÂíåÊòæÁ§∫„ÄÇ 2Ôºâ Dialog a. ÈÄöËøáPolicyManagerÁöÑmakeNewWindowÊñπÊ≥ïÂàõÂª∫WindowÔºõ b. ÂàùÂßãÂåñDecorViewÔºåÂíåActivityÁ±ª‰ººÔºõ c. DialogÁöÑshowÊñπÊ≥ï‰∏≠ÔºåÈÄöËøáWindowManagerÂ∞ÜDecorViewÊ∑ªÂä†Âà∞Window‰∏≠Ôºõ d. DialogÂÖ≥Èó≠Êó∂Ôºå‰ºöÈÄöËøáWindowManagerÊù•ÁßªÈô§DecorViewÔºåÊñπÊ≥ï‰∏∫removeViewImmediate(mDecor)Ôºõ e. ÊÉ≥Ë¶ÅÂàõÂª∫‰∏Ä‰∏™‰ΩøÁî®application contextÁöÑDialogÂèØÊåâÁÖßÊú¨Á´†2-2ÁöÑÊñπÊ≥ïËÆæÁΩÆÔºådialog.getWindow.setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)ÔºåËÆ∞ÂæóÂú®manifest‰∏≠ËÆæÁΩÆÊùÉÈôê„ÄÇ ‚Äã 3Ôºâ Toast a. ToastÂÜÖÈÉ®Êúâ‰∏§Á±ªIPCÔºöToastËÆøÈóÆNotificationManagerServiceÔºõNotificationManagerServiceÔºà‰∏ãÊñáÁÆÄÁß∞NMSÔºâËÆøÈóÆToastÁöÑTNÊé•Âè£Ôºõ b. ToastÂ±û‰∫éÁ≥ªÁªüWindowÔºåÂÜÖÈÉ®ËßÜÂõæmNextView‰∏ÄÁßç‰∏∫Á≥ªÁªüÈªòËÆ§Ê†∑ÂºèÔºåÂè¶‰∏ÄÁßçÈÄöËøásetViewÊñπÊ≥ïÊù•ÊåáÂÆö‰∏Ä‰∏™Ëá™ÂÆö‰πâView„ÄÇ c. TNÊòØ‰∏Ä‰∏™BinderÁ±ªÔºåNMSÂ§ÑÁêÜToastÁöÑÊòæÁ§∫ÈöêËóèËØ∑Ê±ÇÊó∂‰ºöË∑®ËøõÁ®ãÂõûË∞ÉTN‰∏≠ÁöÑÊñπÊ≥ïÔºåÊâÄ‰ª•TNËøêË°åÂú®BinderÁ∫øÁ®ãÊ±†‰∏≠ÔºåÊâÄ‰ª•ÈúÄË¶ÅhandlerÂàáÊç¢Âà∞ÂΩìÂâçÂèëÈÄÅToastËØ∑Ê±ÇÁöÑÁ∫øÁ®ã‰∏≠Ôºå‰πüÂ∞±ÊòØËØ¥Ê≤°ÊúâLooperÁöÑÁ∫øÁ®ãÊòØÊó†Ê≥ïÂºπÂá∫ToastÁöÑ„ÄÇ d. ToastÁöÑshowÊñπÊ≥ïË∞ÉÁî®‰∫ÜNMSÁöÑenqueueToastÊñπÊ≥ïÔºåËØ•ÊñπÊ≥ïÂÖàÂ∞ÜToastËØ∑Ê±ÇÂ∞ÅË£ÖÊàêToastRecordÂπ∂‰∏¢ÂÖ•mToastQueueÈòüÂàó‰∏≠ÔºàÈùûÁ≥ªÁªüÂ∫îÁî®ÊúÄÂ§öÂ°û50‰∏™Ôºâ„ÄÇ e. NMSÈÄöËøáshowNextToastLockedÊñπÊ≥ïÊù•ÊòæÁ§∫ÂΩìÂâçViewÔºåToastÊòæÁ§∫Áî±ToastRecordÁöÑcallbackÊñπÊ≥ï‰∏≠ÁöÑshowÊñπÊ≥ïÂÆåÊàêÔºåcallbackÂÖ∂ÂÆûÂ∞±ÊòØTNÂØπË±°ÁöÑËøúÁ®ãBinderÔºåÊâÄ‰ª•ÊúÄÁªàË∞ÉÁî®ÁöÑÊòØTN‰∏≠ÁöÑÊñπÊ≥ïÔºåÂπ∂ËøêË°åÂú®ÂèëËµ∑ToastËØ∑Ê±ÇÂ∫îÁî®ÁöÑBinderÁ∫øÁ®ãÊ±†‰∏≠„ÄÇ f. ÊòæÁ§∫‰ª•ÂêéÔºåNMSÈÄöËøáscheduleTimeoutLockedÊñπÊ≥ïÂèëÈÄÅÂª∂Êó∂Ê∂àÊÅØÔºåÂª∂Êó∂ÂêéNMSÈÄöËøácancelToastLockedÊñπÊ≥ïÊù•ÈöêËóèToastÂπ∂‰ªéÈòüÂàó‰∏≠ÁßªÈô§ÔºåÈöêËóè‰æùÁÑ∂ÈÄöËøáToastRecordÁöÑcallback‰∏≠ÁöÑhideÊñπÊ≥ïÂÆûÁé∞„ÄÇ g. callbackÂõûË∞ÉTNÁöÑshowÂíåhideÊñπÊ≥ïÂêéÔºå‰ºöÈÄöËøáhandlerÂèëÈÄÅ‰∏§‰∏™RunnableÔºåÈáåÈù¢ÁöÑhandleShowÂíåhandleHideÊñπÊ≥ïÊòØÁúüÊ≠£ÂÆåÊàêÊòæÁ§∫ÂíåÈöêËóèToastÁöÑÂú∞Êñπ„ÄÇhandleShowÊñπÊ≥ï‰∏≠Â∞ÜToastÁöÑËßÜÂõæÊ∑ªÂä†Âà∞Window‰∏≠ÔºåhandleHideÊñπÊ≥ïÂ∞ÜToastËßÜÂõæ‰ªéWindow‰∏≠ÁßªÈô§„ÄÇ]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>ÂõõÂ§ßÁªÑ‰ª∂UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÂõõÂ§ßÁªÑ‰ª∂ÁöÑÂ∑•‰ΩúËøáÁ®ã]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[ÂõõÂ§ßÁªÑ‰ª∂ÁöÑËøêË°åÁä∂ÊÄÅÂõõÂ§ßÁªÑ‰ª∂‰∏≠Èô§‰∫ÜBroadcastReceiver‰ª•Â§ñ, ÂÖ∂‰ΩôÁöÑ‰∏âÁßçÁªÑ‰ª∂ÈÉΩÂøÖÈ°ªÂú®AndroidManifest‰∏≠Ê≥®ÂÜå, ÂØπ‰∫éBroadcastReceiverÊù•ËØ¥, Êó¢ÂèØ‰ª•Âú®Ê∏ÖÂçïÊñá‰ª∂‰∏≠Ê≥®ÂÜå, ‰πüÂèØ‰ª•ÈÄöËøá‰ª£Á†ÅÊù•Ê≥®ÂÜå. Âú®Ë∞ÉÁî®ÂΩ¢Âºè‰∏äÈô§‰∫ÜContentProvider‰∏çÈúÄË¶ÅÂÄüÂä©Intent. ÂÖ∂‰ΩôÁöÑ‰∏âÂ§ßÁªÑ‰ª∂ÈÉΩÈúÄË¶ÅIntent ActivityÊòØ‰∏ÄÁßçÂ±ïÁ§∫ÂûãÁªÑ‰ª∂, Áî®‰∫éÂêëÁî®Êà∑Áõ¥Êé•Âú∞Â±ïÁ§∫‰∏Ä‰∏™ÁïåÈù¢, Âπ∂‰∏îÂèØ‰ª•Êé•Êî∂Áî®Êà∑ÁöÑËæìÂÖ•‰ø°ÊÅØ‰ªéËÄåËøõË°å‰∫§‰∫í. ActivityÊòØÊúÄÈáçË¶ÅÁöÑ‰∏ÄÁßçÁªÑ‰ª∂, ÂØπ‰∫éÁî®Êà∑Êù•ËØ¥ÂÆÉÂ∞±ÊòØÂ∫îÁî®ÁöÑÂÖ®ÈÉ®, Âõ†‰∏∫ÂÖ∂‰ªñ‰∏âÂ§ßÁªÑ‰ª∂ÂØπÁî®Êà∑Êù•ËØ¥ÊòØÊó†Ê≥ïÊÑüÁü•ÁöÑ. ActivityÁöÑÂêØÂä®Áî±IntentËß¶Âèë, ÂÖ∂‰∏≠IntentÂèØ‰ª•ÂàÜ‰∏∫ÊòæÂºèÂíåÈöêÂºè. ÊòæÂºèIntentÂèØ‰ª•ÊòéÁ°ÆÁöÑÊåáÂêë‰∏Ä‰∏™Activity, ËÄåÈöêÂºèIntentÂàôÊåáÂêë‰∏Ä‰∏™ÊàñËÄÖÂ§ö‰∏™ActivityÁªÑ‰ª∂. ÊàñËÄÖÊòØÊ≤°ÊúâActivityÁªÑ‰ª∂ÂèØ‰ª•Â§ÑÁêÜËøô‰∏™ÈöêÂºèÁöÑIntent. ‰∏Ä‰∏™ActivityÂÖ∑ÊúâÁâπÂÆöÁöÑÂêØÂä®Ê®°Âºè. ‰πüÂèØ‰ª•ÈÄöËøáfinishÊù•ÂÅúÊ≠¢. ÊÄªÁªìÊù•ËØ¥, ActivityÁªÑ‰ª∂ÁöÑ‰∏ªË¶Å‰ΩúÁî®ÊòØÂ±ïÁ§∫‰∏Ä‰∏™ÁïåÈù¢Âπ∂ÂíåÁî®Êà∑‰∫§‰∫í, ÂÆÉÊâÆÊºîÁöÑÊòØ‰∏ÄÁßçÂâçÂè∞ÁïåÈù¢ÁöÑËßíËâ≤. ServiceÊòØ‰∏ÄÁßçËÆ°ÁÆóÂûãÁªÑ‰ª∂, Áî®‰∫éÂêéÂè∞ÊâßË°å‰∏ÄÁ≥ªÂàóËÆ°ÁÆó‰ªªÂä°. ËøêË°åÂú®ÂêéÂè∞,Áî®Êà∑ÊòØÊó†Ê≥ïÊÑüÁü•ÁöÑ. ServiceÂíåActivityÁöÑ‰∏çÂêå: ActivityÁªÑ‰ª∂Âè™Êúâ‰∏ÄÁßçËøêË°åÊ®°Âºè,Âç≥ActivityÂ§Ñ‰∫éÂêØÂä®Áä∂ÊÄÅ, ‰ΩÜÊòØServiceÁªÑ‰ª∂Êúâ‰∏§ÁßçÁä∂ÊÄÅ: ÂêØÂä®Áä∂ÊÄÅÂíåÁªëÂÆöÁä∂ÊÄÅ. ÂΩìServiceÂ§Ñ‰∫éÂêØÂä®Áä∂ÊÄÅÊó∂, Ëøô‰∏™Êó∂ÂÄôServiceÂÜÖÈÉ®ÂèØ‰ª•ÂÅö‰∏Ä‰∫õÂêéÂè∞ËÆ°ÁÆó. Â∞ΩÁÆ°ServiceÁªÑ‰ª∂ÊòØÁî®‰∫éÊâßË°åÂêéÂè∞ËÆ°ÁÆóÁöÑ, ‰ΩÜÊòØÂÆÉÊú¨Ë∫´ÊòØËøêË°åÂú®‰∏ªÁ∫øÁ®ãÁöÑ. Âõ†Ê≠§ÂçïÁã¨ÁöÑËÄóÊó∂Êìç‰Ωú‰ªçÁÑ∂ÈúÄË¶ÅÂçïÁã¨ÁöÑÁ∫øÁ®ãÂéªÊâßË°å. ÂΩìServiceÂ§Ñ‰∫éÁªëÂÆöÁä∂ÊÄÅÊó∂, ÂÜÖÈÉ®ÂêåÊ†∑ÂèØ‰ª•ËøõË°åÂêéÂè∞ËÆ°ÁÆó, ‰ΩÜÊòØÂ§Ñ‰∫éËøôÁßçÁä∂ÊÄÅÊó∂, Â§ñÁïåÂèØ‰ª•ÂæàÊñπ‰æøÁöÑÂíåServiceÁªÑ‰ª∂ËøõË°åÈÄö‰ø°. ServiceÂèØ‰ª•ÂÅúÊ≠¢, ÈúÄË¶ÅÁÅµÊ¥ªÈááÁî®stopServiceÂíåunBindService BroadcastReceiverÊòØ‰∏ÄÁßçÊ∂àÊÅØÂûãÁªÑ‰ª∂, Áî®‰∫éÂú®‰∏çÂêåÁöÑÁªÑ‰ª∂‰πÉËá≥‰∏çÂêåÁöÑÂ∫îÁî®‰πãÈó¥‰º†ÈÄíÊ∂àÊÅØ. ÂêåÊ†∑Êó†Ê≥ïË¢´Áî®Êà∑ÊÑüÁü•, Âõ†‰∏∫ÊòØËøêË°åÂú®Á≥ªÁªüÂÜÖÈÉ®, ÂπøÊí≠ÁöÑÊ≥®ÂÜåÊñπÂºèÊúâ‰∏§Áßç:ÈùôÊÄÅÊ≥®ÂÜåÂíåÂä®ÊÄÅÊ≥®ÂÜå ÈùôÊÄÅÊ≥®ÂÜå: Âú®Ê∏ÖÂçïÊñá‰ª∂‰∏≠ËøõË°åÊ≥®ÂÜåÂπøÊí≠, ËøôÁßçÂπøÊí≠Âú®Â∫îÁî®ÂÆâË£ÖÊó∂‰ºöË¢´Á≥ªÁªüËß£Êûê, Ê≠§ÁßçÂΩ¢ÂºèÁöÑÂπøÊí≠‰∏çÈúÄË¶ÅÂ∫îÁî®ÂêØÂä®Â∞±ÂèØ‰ª•Êé•Êî∂Âà∞Áõ∏Â∫îÁöÑÂπøÊí≠. Âä®ÊÄÅÊ≥®ÂÜå: ÈúÄË¶ÅÈÄöËøáContext.registerReceiver()Êù•ÂÆûÁé∞, Âπ∂Âú®‰∏çÈúÄË¶ÅÁöÑÊó∂ÂÄôÈÄöËøáContext.unRegisterReceiver()Êù•Ëß£Èô§ÂπøÊí≠. Ê≠§ÁßçÂΩ¢ÊÄÅÁöÑÂπøÊí≠Ë¶ÅÂ∫îÁî®ÂêØÂä®ÊâçËÉΩÊ≥®ÂÜåÂíåÊé•Êî∂ÂπøÊí≠. Âú®ÂÆûÈôÖÂºÄÂèë‰∏≠ÈÄöËøáContextÁöÑ‰∏ÄÁ≥ªÂàóÁöÑsendÊñπÊ≥ïÊù•ÂèëÈÄÅÂπøÊí≠, Ë¢´ÂèëÈÄÅÁöÑÂπøÊí≠‰ºöË¢´Á≥ªÁªüÂèëÈÄÅÁªôÊÑüÂÖ¥Ë∂£ÁöÑÂπøÊí≠Êé•Êî∂ËÄÖ, ÂèëÈÄÅÂíåÊé•Êî∂ÁöÑËøáÁ®ãÁöÑÂåπÈÖçÊòØÈÄöËøáÂπøÊí≠Êé•Êî∂ËÄÖÁöÑ&lt;intent-filter&gt;Êù•ÊèèËø∞ÁöÑ. ÂèØ‰ª•ÂÆûÁé∞‰ΩéËÄ¶ÂêàÁöÑËßÇÂØüËÄÖÊ®°Âºè, ËßÇÂØüËÄÖÂíåË¢´ËßÇÂØüËÄÖ‰πãÈó¥ÂèØ‰ª•Ê≤°Êúâ‰ªª‰ΩïËÄ¶Âêà. ‰ΩÜÂπøÊí≠‰∏çÈÄÇÂêàÊù•ÂÅöËÄóÊó∂Êìç‰Ωú. ContentProviderÊòØ‰∏ÄÁßçÊï∞ÊçÆÂÖ±‰∫´ÁªÑ‰ª∂, Áî®‰∫éÂêëÂÖ∂‰ªñÁªÑ‰ª∂‰πÉËá≥ÂÖ∂‰ªñÂ∫îÁî®ÂÖ±‰∫´Êï∞ÊçÆ. Êó†Ê≥ïË¢´Áî®Êà∑ÊÑüÁü•. ÂØπ‰∫éÂÜÖÂÆπÊèê‰æõËÄÖÊù•ËØ¥, ÂÆÉÂè™ÈúÄË¶ÅÂÆûÁé∞Â¢ûÂà†ÊîπÊü•ÂõõÁßçÂü∫Êú¨Êìç‰Ωú, Âú®ÂÆÉÂÜÖÈÉ®Áª¥ÊåÅÁùÄ‰∏Ä‰ªΩÊï∞ÊçÆÈõÜÂêà, Ëøô‰∏™Êï∞ÊçÆÈõÜÂêàÊó¢ÂèØ‰ª•ÈÄöËøáÊï∞ÊçÆÂ∫ìÊù•ÂÆûÁé∞, ‰πüÂèØ‰ª•ÈááÁî®ÂÖ∂‰ªñ‰ªª‰ΩïÁ±ªÂûãÊù•ÂÆûÁé∞, ‰æãÂ¶ÇlistÊàñËÄÖmap. ContentProviderÂØπÊï∞ÊçÆÈõÜÂêàÁöÑÂÖ∑‰ΩìÂÆûÁé∞Âπ∂Ê≤°Êúâ‰ªª‰ΩïË¶ÅÊ±Ç. Ë¶ÅÊ≥®ÊÑèÂ§ÑÁêÜÂ•ΩÂÜÖÈÉ®ÁöÑinsert, delete, update, queryÊñπÊ≥ïÁöÑÁ∫øÁ®ãÂêåÊ≠•, Âõ†‰∏∫ËøôÂá†‰∏™ÊñπÊ≥ïÊòØÂú®BinderÁ∫øÁ®ãÊ±†Ë¢´Ë∞ÉÁî®. ActivityÁöÑÂ∑•‰ΩúËøáÁ®ãËôΩÁÑ∂Ë¶ÅÊâìÂºÄ‰∏Ä‰∏™ActivityÂæàÁÆÄÂçï, ‰ΩÜÊòØ‰∏çÂ∫îËØ•Âè™ÊòØÂ±ÄÈôê‰∫éË°®Èù¢. ‰∫ÜËß£ÂÖ∂ÂÜÖÈÉ®Ëµ∞ÂêëÊûÑÊàê.ÊâÄ‰ª•‰∏ÄÂàá‰ªéstartActivity(intent)Ëøô‰∏™ÊñπÊ≥ïÂºÄÂßã. startActivity()ÊúâÂ•ΩÂá†ÁßçÈáçËΩΩÊñπÂºè‰ΩÜÊòØÊúÄÁªàÈÉΩÊòØË∞ÉÁî®startActivityForResult()ÊñπÊ≥ï. Ê≥®ÊÑèËøôÈáåÂàÜÊûêÁöÑÊòØ5.0ÁâàÊú¨ÁöÑÊ∫êÁ†Å, Âíå6.0Ê∫êÁ†ÅÂÆûÁé∞Á®çÂæÆ‰∏çÂêå È¶ñÂÖàÁúãstartActivityForResult() 123456789101112131415161718192021222324252627282930313233public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; final View decor = mWindow != null ? mWindow.peekDecorView() : null; if (decor != null) &#123; decor.cancelPendingInputEvents(); &#125; // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; if (options != null &amp;&amp; !isTopOfTask()) &#123; mActivityTransitionState.startExitOutTransition(this, options); &#125;&#125; ÂÖ≥Ê≥®mParent==nullÁöÑÂàÜÊîØ. mParent‰ª£Ë°®ÁöÑÊòØViewGroup, ActivityGroupÊúÄÂºÄÂßãË¢´Áî®Êù•Âú®‰∏Ä‰∏™ÁïåÈù¢‰∏≠ÂµåÂÖ•Â§ö‰∏™Â≠êActivity, Âú®API13Â∑≤ÁªèË¢´Â∫üÂºÉ. Á≥ªÁªüÊé®Ëçê‰ΩøÁî®Fragment‰ª£ÊõøActivityGroup. Ê≥®ÊÑèmMainThread.getApplicationThread()Ëøô‰∏™ÂèÇÊï∞, ÂÆÉÁöÑÂèÇÊï∞Á±ªÂûãÊòØApplicationThread, ApplicationThreadÊòØActivityThreadÁöÑ‰∏Ä‰∏™ÂÜÖÈÉ®Á±ª. Áúã‰∏Ä‰∏ãInstrumentation#execStartActivity()Ëøô‰∏™ÊñπÊ≥ï 12345678910111213141516171819202122232425262728293031323334public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); // ÂêØÂä®ActivityÁöÑÁúüÊ≠£ÂÆûÁé∞ int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null;&#125; ‰ª£Á†Å‰∏≠ÁúüÊ≠£ÂêØÂä®ActivityÁöÑÁúüÊ≠£ÂÆûÁé∞ÊòØÁî±ActivityManagerNative.getDefault().startActivity()ÊñπÊ≥ïÂÆåÊàêÁöÑ. ÂêéÈù¢ÂØπActivityManagerServiceÁÆÄÁß∞AMS. AMSÁªßÊâøËá™ActivityManagerNative, ËÄåActivityManagerNativeÁªßÊâøËá™BinderÂπ∂ÂÆûÁé∞‰∫ÜIActivityManagerËøô‰∏™BinderÊé•Âè£, Âõ†Ê≠§AMS‰πüÊòØ‰∏Ä‰∏™Binder, ÂÆÉÊòØIActivityManagerÁöÑÂÖ∑‰ΩìÂÆûÁé∞. Áî±‰∫éActivityManagerNative.getDefault()Êú¨Ë¥®ÊòØ‰∏Ä‰∏™IActivityManagerÁ±ªÂûãÁöÑBinderÂØπË±°, Âõ†Ê≠§ÂÖ∑‰ΩìÂÆûÁé∞ÊòØAMS. Âú®ActivityManagerNative‰∏≠, AMSËøô‰∏™BinderÂØπË±°ÈááÁî®Âçï‰æãÊ®°ÂºèÂØπÂ§ñÊèê‰æõ, SingletonÊòØ‰∏Ä‰∏™Âçï‰æãÂ∞ÅË£ÖÁ±ª. Á¨¨‰∏ÄÊ¨°Ë∞ÉÁî®ÂÆÉÁöÑget()ÊñπÊ≥ïÊó∂‰ºöÈÄöËøácreateÊñπÊ≥ïÊù•ÂàùÂßãÂåñAMSËøô‰∏™BinderÂØπË±°, Âú®ÂêéÁª≠Ë∞ÉÁî®‰∏≠‰ºöËøîÂõûËøô‰∏™ÂØπË±°. ÂÖ∑‰ΩìÂÆûÁé∞Â¶Ç‰∏ã‰ª£Á†Å. 1234567891011121314151617static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService("activity"); if (false) &#123; Log.v("ActivityManager", "default service binder = " + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v("ActivityManager", "default service = " + am); &#125; return am; &#125;&#125;; Áî±‰∏äÂèØ‰ª•ÁúãÂà∞ÂÖ≥‰∫éActivityÁöÑÂêØÂä®ÊòØÁî±ActivityManagerNative.getDefault()Êù•ÂêØÂä®ÁöÑ, ËÄåActivityManagerNative.getDefault()ÂÆûÈôÖ‰∏äÊòØAMS, ÊâÄ‰ª•ActivityÁöÑÂêØÂä®ËøáÁ®ãÂèàË¢´ËΩ¨ÁßªÂà∞‰∫ÜAMS‰∏≠, Êé•‰∏ãÊù•Êü•ÁúãAMS‰∏≠ÁöÑstartActivity()ÊñπÊ≥ï. Âú®ÂàÜÊûêAMS#startActivity()‰πãÂâç, ÊòØÂê¶Âú®ÂºÄÂßãÊó∂ÂÄôÁ¢∞Âà∞ËøáActivityÊ≤°ÊúâÂú®Ê∏ÖÂçïÊñá‰ª∂‰∏≠Â£∞ÊòéÁÑ∂ÂêéÂ¥©Ê∫ÉÁöÑÁé∞Ë±°? Ëøô‰∏™Ê≠•È™§ÊòØÂú®Instrumentation#execStartActivity()ÂàöÊâçÂàÜÊûêActivityManagerNative.getDefault().startActivity()ÁöÑ‰∏ã‰∏ÄÊ≠•. Êúâ‰∏Ä‰∏™checkStartActivityResult(),ÁúãÂêçÂ≠óÂ∫îËØ•ÊòØÊ£ÄÊü•ÁöÑÁ±ª, Áúã‰∏Ä‰∏ãÂÆûÁé∞. 1234567891011121314151617181920212223242526272829303132public static void checkStartActivityResult(int res, Object intent) &#123; if (res &gt;= ActivityManager.START_SUCCESS) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( "Unable to find explicit activity class " + ((Intent)intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?"); throw new ActivityNotFoundException( "No Activity found to handle " + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException("Not allowed to start activity " + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( "FORWARD_RESULT_FLAG used while also requesting a result"); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( "PendingIntent is not an activity"); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( "Starting under voice control not allowed for: " + intent); default: throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent); &#125;&#125; ÁúãÂá∫Ëøô‰∏™ÊñπÊ≥ïÊòØ‰∏ÄË®Ä‰∏çÂêàÂ∞±ÊäõÂºÇÂ∏∏. ÁúãActivityManager.START_CLASS_NOT_FOUNDËøô‰∏™Âà§Êñ≠ÂàÜÊîØÊäõÂá∫ÁöÑÂºÇÂ∏∏ÊòØ‰∏çÊòØÂæàÁúºÁÜü? ÂØπÂ∞±ÊòØÊ≤°ÊúâÂú®Ê∏ÖÂçïÊñá‰ª∂‰∏≠Ê≥®ÂÜåÂ∞±Âú®ËøôÈáåÊäõÂá∫. ÊâÄ‰ª•Ëøô‰∏™ÊñπÊ≥ïÂ∞±ÊòØÊ£ÄÊü•ÂêØÂä®ActivityÁöÑÁªìÊûú. ÂõûÂà∞AMSÁöÑstartActivity() 123456789101112131415161718192021public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; // Áõ¥Êé•Ë∞ÉÁî®‰∏ãÈù¢ÊñπÊ≥ï return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, userId, null, null);&#125; ActivityÂêØÂä®ËøáÁ®ãÁªèËøá‰∏§Ê¨°ËΩ¨Áßª, ÊúÄÂêéÂèàËΩ¨ÁßªÂà∞‰∫ÜmStackSupervisor.startActivityMayWait()Ëøô‰∏™ÊñπÊ≥ï, ÊâÄÂ±ûÁ±ª‰∏∫ActivityStackSupervisor. Âú®startActivityMayWait()ÂÜÖÈÉ®ÂèàË∞ÉÁî®‰∫ÜstartActivityLocked()ËøôÈáå‰ºöËøîÂõûÁªìÊûúÁ†ÅÂ∞±ÊòØ‰πãÂâçcheckStartActivityResult()Áî®Âà∞ÁöÑ. ÁªßÁª≠Ë∑üËøõÊñπÊ≥ïÊúÄÂêé‰ºöË∞ÉÁî®startActivityUncheckedLocked(), ÁÑ∂ÂêéÂèàË∞ÉÁî®‰∫ÜActivityStack#resumeTopActivityLocked(). Ëøô‰∏™Êó∂ÂÄôÂêØÂä®ËøáÁ®ãÂ∑≤Áªè‰ªéActivityStackSupervisorËΩ¨ÁßªÂà∞‰∫ÜActivityStackÁ±ª‰∏≠. ÁúãActivityStackÁöÑresumeTopActivityLocked()ÊñπÊ≥ïÂÆûÁé∞ 1234567891011121314151617181920final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; ‰ªé‰∏äÂèØ‰ª•ÁúãÂà∞resultÊòØÊ†πÊçÆË∞ÉÁî®ÁöÑresumeTopActivityInnerLocked()ËøîÂõû, ËÄåresumeTopActivityInnerLocked()ÂèàË∞ÉÁî®‰∫ÜActivityStackSupervisor#startSpecificActivityLocked()ÊñπÊ≥ï. Áúã‰∏Ä‰∏ãËøô‰∏™ÊñπÊ≥ï: 123456789101112131415161718192021222324252627282930void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !"android".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; // ÁªßÁª≠ËøõÂÖ•!!! realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true);&#125; Ëøô‰∏™ÊñπÊ≥ïÂèàËøõÂÖ•‰∫ÜrealStartActivityLocked(). Âú®Ëøô‰∏™ÊñπÊ≥ï‰∏≠ÊúâÂ¶Ç‰∏ã‰∏ÄÊÆµ‰ª£Á†Å: 12345app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, r.launchedFromPackage, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ÂÖàÊï¥ÁêÜ‰∏Ä‰∏ãÂàöÊâçÁöÑË∞ÉÁî®ËøáÁ®ã, ÊàëÂ∑≤ÁªèÁÖßÁùÄ‰π¶‰∏äË∑üÁöÑ‰∏çÁü•ÊâÄ‰ª•ÁÑ∂‰∫Ü‚Ä¶. ActivityÁöÑÂêØÂä®ËøáÁ®ãÂú®ActivityStackSupervisorÂíåActivityStack‰πãÈó¥ÁöÑ‰º†ÈÄíÈ°∫Â∫èÂèØ‰ª•Ê¶ÇÊã¨‰∏∫‰∏ãÂõæÔºö ÁªßÁª≠ÁúãÂàöÊâçapp.thread.scheduleLaunchActivity()Ëøô‰∏™ÊñπÊ≥ï. ÂÖ∂‰∏≠app.threadÁ±ªÂûã‰∏∫IApplicationThread, Ëøô‰∏™Áé©ÊÑèÁªßÊâø‰∫ÜIInterfaceÊé•Âè£, ÊâÄ‰ª•‰ªñ‰πüÊòØ‰∏Ä‰∏™BinderÁ±ªÂûãÁöÑÊé•Âè£. ‰ªéIApplicationThreadÂ£∞ÊòéÁöÑÊé•Âè£ÊñπÊ≥ïÂèØ‰ª•ÁúãÂá∫, ÂÖ∂ÂÜÖÈÉ®ÂåÖÂê´‰∫ÜÂ§ßÈáèÂêØÂä®ÂíåÂÅúÊ≠¢Activity‰ª•ÂèäServiceÁöÑÊé•Âè£. ÈÇ£IApplicationThreadÁöÑÂÆûÁé∞ËÄÖÊòØÂì™‰∏™Á±ª? Âú®ActivityThread‰∏≠ÁöÑÂÜÖÈÉ®Á±ªÊúâ‰∏Ä‰∏™ApplicationThread,ÁúãÁúãÂÆö‰πâ 1234private class ApplicationThread extends ApplicationThreadNativepublic abstract class ApplicationThreadNative extends Binder implements IApplicationThread ÂèØ‰ª•ÁúãÂà∞ApplicationThreadÁöÑÁªßÊâøÂÖ≥Á≥ª, ËÄåÊü•ÁúãApplicationThreadNativeÁöÑ‰ΩúÁî®ÂÖ∂ÂÆûÂíåÁ≥ªÁªüAIDLÊñá‰ª∂ÁîüÊàêÁöÑÁ±ªÊòØ‰∏ÄÊ†∑ÁöÑ. Âú®ApplicationThreadNativeÁöÑÂÜÖÈÉ®, ËøòÊúâ‰∏Ä‰∏™ApplicationThreadProxyÁ±ª, ÁúºÁÜüÂêßÂú®Á¨¨‰∫åÁ´†ËÆ≤Ëß£ÁöÑÊó∂ÂÄôaidlÁîüÊàêÁöÑjavaÊñá‰ª∂‰∏≠‰πüÊúâ‰∏Ä‰∏™ÂÜÖÈÉ®ÁöÑ‰ª£ÁêÜÁ±ª. ÊâÄ‰ª•ApplicationThreadNativeÂ∞±ÊòØIApplicationThreadÁöÑÂÆûÁé∞ËÄÖ, Áî±‰∫éApplicationThreadNativeË¢´Á≥ªÁªüÂÆö‰πâ‰∏∫ÊäΩË±°Á±ª, ÊâÄ‰ª•ApplicationThreadÂ∞±Êàê‰∫ÜIApplicationThreadÁöÑÂÆûÁé∞ËÄÖ„ÄÇ Áªï‰∫Ü‰∏ÄÂ§ßÂúà, ActivityÂêØÂä®ËøáÁ®ãÊúÄÁªàÂõûÂà∞‰∫ÜApplicationThread‰∏≠, ApplicationThreadÈÄöËøáscheduleLaunchActivity()Êù•ÂêØÂä®Activity. 12345678910111213141516171819202122232425262728public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; ËøôÊÆµ‰ª£Á†ÅÂÅöÁöÑÂ∞±ÊòØÂ∞ÅË£Ö‰∏Ä‰∏™ActivityÁöÑËÆ∞ÂΩï‰ø°ÊÅØ‰∫§ÁªôÂêçÂ≠óÂè´HÁöÑ‰∏Ä‰∏™HandlerÂØπË±°ÂéªÂ§ÑÁêÜ, ÁªßÁª≠Ë∑üËøõÁúãÁúãÈáåÈù¢ÁöÑÂÆûÁé∞ 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, "SCHEDULE " + what + " " + mH.codeToString(what) + ": " + arg1 + " / " + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; È¢ù, Ê≤°Âï•Â•ΩÁûÖÁöÑÂ∞±ÊòØÂ∞ÅË£Ö‰∏Ä‰∏™messageÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™Ê∂àÊÅØ. Â•ΩÂêß ÈÇ£ÁúãÁúãHandlerÊé•Êî∂ÁöÑÊó∂ÂÄôÊòØÂ¶Ç‰ΩïÂ§ÑÁêÜÁöÑÂêß. Ëøô‰∏™Á±ªÈáåÈù¢ÂØπHandlerËøõË°å‰∫ÜÂåÖË£Ö, ÂåÖË£ÖÁöÑÁ±ªÂ∞±ÊòØ‰∏Ä‰∏™HÁöÑÂÜÖÈÉ®Á±ª. 1234567891011121314151617181920212223242526272829303132333435363738private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; //ËøôÈáåÁúÅÁï•‰∏ÄÂ†ÜÂ∏∏ÈáèÂ£∞Êòé //Âú®ÁúÅÁï•‰∏ÄÂ†ÜswitchÂàÜÊîØ, Áõ¥Êé•ÁúãÂÖ∑‰ΩìÁöÑÊ∂àÊÅØÂ§ÑÁêÜ public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case PAUSE_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityPause"); handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;2) != 0); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityPause"); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; //ËøôÈáåÂèàÁúÅÂéª‰∫Ü‰∏ÄÂ§ßÂù®ÁöÑcaseÂàÜÊîØ &#125; if (DEBUG_MESSAGES) Slog.v(TAG, "&lt;&lt;&lt; done: " + codeToString(msg.what)); &#125; Êàë‰ª¨ÁõÆÂâçÂè™ÂÖ≥ÂøÉLAUNCH_ACTIVITYËøô‰∏™Ê†áËÆ∞ÔºåActivityÁöÑÂêØÂä®ËøáÁ®ãÁî±ActivityThreadÁöÑhandleLaunchActivity()ÊñπÊ≥ïÊù•ÂÆûÁé∞„ÄÇËøô‰∏™ÊñπÊ≥ïÂÜÖÈÉ®ÈÄöËøáperformLaunchActivity()ÊñπÊ≥ïÊúÄÁªàÂÆåÊàê‰∫ÜActivityÂØπË±°ÁöÑÂàõÂª∫ÂíåÂêØÂä®ËøáÁ®ã. Âπ∂‰∏îActivityThreadÈÄöËøáhandleResumeActivity()ÊñπÊ≥ïÊù•Ë∞ÉÁî®Ë¢´ÂêØÂä®ÁöÑonResume()Ëøô‰∏ÄÁîüÂëΩÂë®ÊúüÊñπÊ≥ï. performLaunchActivity(ActivityClientRecord r, Intent customIntent)‰∏ªË¶ÅÂÆåÊàêÂ¶Ç‰∏ãÁöÑÂá†‰ª∂‰∫ãÔºö 1. ‰ªéActivityClientRecord‰∏≠Ëé∑ÂèñÂæÖÂêØÂä®ÁöÑActivity‰ø°ÊÅØ 1234567891011121314151617ActivityInfo aInfo = r.activityInfo;if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);&#125;ComponentName component = r.intent.getComponent();if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component);&#125;if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity);&#125; 2.ÈÄöËøáInstrumentationÁöÑnewActivityÊñπÊ≥ï‰ΩøÁî®Á±ªÂä†ËΩΩÂô®ÂàõÂª∫ActivityÂØπË±° 123456789java.lang.ClassLoader cl = r.packageInfo.getClassLoader();activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);StrictMode.incrementExpectedActivityCount(activity.getClass());r.intent.setExtrasClassLoader(cl);r.intent.prepareToEnterProcess();if (r.state != null) &#123; r.state.setClassLoader(cl);&#125; Ëá≥‰∫éInstrumentationÁöÑnewActivityÂÆûÁé∞Â∞±ÊòØÈÄöËøáÁ±ªÂä†ËΩΩÂô®ÂàõÂª∫‰∫Ü‰∏Ä‰∏™ActivityÂØπË±°Ôºö 123public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newIntance();&#125; 3.ÈÄöËøáLoadedApkÁöÑmakeApplication()ÊñπÊ≥ïÊù•Â∞ùËØïÂàõÂª∫ApplicationÂØπË±° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123;//Â∑≤ÁªèÊúâApplicaitonÁõ¥Êé•ËøîÂõû return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = "android.app.Application"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals("android")) &#123; initializeJavaContextClassLoader(); &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); //ÈÄöËøáInstrumentationÂàõÂª∫Application app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; if (!mActivityThread.mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( "Unable to instantiate application " + appClass + ": " + e.toString(), e); &#125; &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; try &#123; //ÂõûË∞ÉonCreate()ÊñπÊ≥ï instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!instrumentation.onException(app, e)) &#123; throw new RuntimeException( "Unable to create application " + app.getClass().getName() + ": " + e.toString(), e); &#125; &#125; &#125; // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); &#125; return app;&#125; ‰ªéËøô‰∏™ÊñπÊ≥ï‰∏≠ÂèØ‰ª•ÁúãÂà∞, Â¶ÇÊûúApplicationËøô‰∏™ÂØπË±°Â∑≤ÁªèË¢´ÂàõÂª∫Ëøá, ÈÇ£‰πàÂ∞±‰∏ç‰ºöÂÜçÈáçÂ§çÂàõÂª∫‰∫Ü, Ëøô‰πüÂ∞±ÊÑèÂë≥ÁùÄ‰∏Ä‰∏™Â∫îÁî®Âè™Êúâ‰∏Ä‰∏™ApplicationÂØπË±°ÁöÑÂéüÂõ†. ApplicationÂØπË±°ÁöÑÂàõÂª∫‰πüÊòØÈÄöËøáInstrumentationÁ±ªÊù•ÂÆåÊàê, Ëøô‰∏™ËøáÁ®ãÂíåActivityÂØπË±°ÁöÑÂàõÂª∫ÊòØ‰∏ÄËá¥ÁöÑ, ÈÉΩÊòØÈÄöËøáÁ±ªÂä†ËΩΩÂô®Êù•ÂÆûÁé∞. ApplicationÂàõÂª∫ÂÆåÊØïÂêé, Á≥ªÁªü‰ºöÈÄöËøáInstrumentationÁöÑcallApplicationOnCreate()ÊñπÊ≥ïÊù•Ë∞ÉÁî®Application#onCreate()ÊñπÊ≥ï. 4. ÂàõÂª∫ContextImplÂØπË±°Âπ∂ÈÄöËøáActivityÁöÑattachÊñπÊ≥ïÊù•ÂÆåÊàêÈáçË¶ÅÊï∞ÊçÆÁöÑÂàùÂßãÂåñ 123456789Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ContextImplÊòØ‰∏Ä‰∏™ÂæàÈáçË¶ÅÁöÑÊï∞ÊçÆÁªìÊûÑ, ÂÆÉÊòØContextÁöÑÂÖ∑‰ΩìÂÆûÁé∞, Context‰∏≠ÁöÑÂ§ßÈÉ®ÂàÜÈÄªËæëÈÉΩÊòØÁî±ContentImplÊù•ÂÆåÊàêÁöÑ. ContextImplÊòØÈÄöËøáActivityÁöÑattach()ÊñπÊ≥ïÊù•ÂíåActivityÂª∫Á´ãÂÖ≥ËÅîÁöÑ,Èô§Ê≠§‰πãÂ§ñ, Âú®attach()‰∏≠ActivityËøò‰ºöÂÆåÊàêWindowÁöÑÂàõÂª∫Âπ∂Âª∫Á´ãËá™Â∑±ÂíåWindowÁöÑÂÖ≥ËÅî, ËøôÊ†∑ÂΩìWindowÊé•Êî∂Âà∞Â§ñÈÉ®ËæìÂÖ•‰∫ã‰ª∂Êî∂Â∞±ÂèØ‰ª•Â∞Ü‰∫ã‰ª∂‰º†ÈÄíÁªôActivity. 5. Ë∞ÉÁî®ActivityÁöÑonCreate()ÊñπÊ≥ï mInstrumentation.callActivityOnCreate(activity, r.state);, Áî±‰∫éActivityÁöÑonCreate()Â∑≤ÁªèË¢´Ë∞ÉÁî®, Ëøô‰πüÊÑèÂë≥ÁùÄActivityÂ∑≤ÁªèÂÆåÊàêÊï¥‰∏™ÂêØÂä®ËøáÁ®ã. ServiceÁöÑÂ∑•‰ΩúÊµÅÁ®ãServiceÁöÑÂêØÂä®ËøáÁ®ãÂêåÊ†∑‰ªéContextImpl#startService()Ëøô‰∏™ÊñπÊ≥ï‰Ωú‰∏∫ÂÖ•Âè£. Ëøô‰∏™ÊñπÊ≥ï‰ºöË∞ÉÁî®startServiceCommon()Âπ∂ËøîÂõû. Ëøô‰∏™ÊñπÊ≥ïÂÜÖÈÉ®ÈÄöËøáActivityManagerNative.getDefault()Ëé∑Âæó‰∏Ä‰∏™AMSÂπ∂Ë∞ÉÁî®startService()ÂºÄÂêØ‰∏Ä‰∏™ÊúçÂä°. Âú®ËøôÈáåÈÄöËøáAMSÊù•ÂêØÂä®‰∏Ä‰∏™ÊúçÂä°ÁöÑË°å‰∏∫ÊòØÂ±û‰∫éËøúÁ®ãË∞ÉÁî®ÁöÑËøáÁ®ã. Áúã‰∏Ä‰∏ãAMSÁöÑstartService() 1234567891011121314151617181920public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; enforceNotIsolatedCaller("startService"); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; if (DEBUG_SERVICE) Slog.v(TAG, "startService: " + service + " type=" + resolvedType); synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; ËøôÊÆµ‰∏ªË¶ÅÂ∞±ÊòØAMSÈÄöËøámServicesËøô‰∏™ÂØπË±°Êù•ÂÆåÊàêServiceÂêéÁª≠ÁöÑÂêØÂä®ËøáÁ®ã. ËøôÈáåmServiceÁöÑÂØπË±°Á±ªÂûãÊòØActiveServices(ËøôÊòØ‰∏Ä‰∏™ËæÖÂä©AMSËøõË°åServiceÁÆ°ÁêÜÁöÑÁ±ª, ÂåÖÊã¨ServiceÁöÑÂêØÂä®,ÁªëÂÆöÂíåÂÅúÊ≠¢Á≠â). ËøôÈáåË∞ÉÁî®‰∫ÜmServices.startServiceLocked()ÁÑ∂ÂêéËøô‰∏™ÊñπÊ≥ïÊúÄÂêéÂèàË∞ÉÁî®‰∫ÜstartServiceInnerLocked(), ÂÆûÁé∞Â¶Ç‰∏ã. 1234567891011121314151617181920212223242526272829303132333435ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) &#123; ProcessStats.ServiceState stracker = r.getTracker(); if (stracker != null) &#123; stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity); &#125; r.callStart = false; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startRunningLocked(); &#125; String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false); if (error != null) &#123; return new ComponentName("!!", error); &#125; if (r.startRequested &amp;&amp; addToStarting) &#123; boolean first = smap.mStartingBackground.size() == 0; smap.mStartingBackground.add(r); r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT; if (DEBUG_DELAYED_SERVICE) &#123; RuntimeException here = new RuntimeException("here"); here.fillInStackTrace(); Slog.v(TAG, "Starting background (first=" + first + "): " + r, here); &#125; else if (DEBUG_DELAYED_STARTS) &#123; Slog.v(TAG, "Starting background (first=" + first + "): " + r); &#125; if (first) &#123; smap.rescheduleDelayedStarts(); &#125; &#125; else if (callerFg) &#123; smap.ensureNotStartingBackground(r); &#125; return r.name; &#125; ServiceRecordÊèèËø∞ÁöÑÊòØ‰∏Ä‰∏™ServiceËÆ∞ÂΩï, ServiceRecord‰∏ÄÁõ¥Ë¥ØÁ©øÁùÄÊï¥‰∏™ServiceÁöÑÂêØÂä®ËøáÁ®ã. startServiceInnerLocked()ÊñπÊ≥ïÂπ∂Ê≤°ÊúâÂÆåÊàêÂÖ∑‰ΩìÁöÑÂêØÂä®Â∑•‰Ωú, ËÄåÊòØÊääÂêéÁª≠ÁöÑÂ∑•‰Ωú‰∫§Áªô‰∫ÜbringUpServiceLocked(),Âú®bringUpServiceLocked()ÂèàË∞ÉÁî®‰∫ÜrealStartServiceLocked()ÊñπÊ≥ï. Ëøô‰∏™ÊñπÊ≥ïÁÆóÊòØÁúüÊ≠£ÁöÑÂêØÂä®‰∏Ä‰∏™Service. realStartServiceLocked()È¶ñÂÖàÈÄöËøáapp.thread.scheduleCreateService()ÊñπÊ≥ïÊù•ÂàõÂª∫ServiceÂØπË±°Âπ∂Ë∞ÉÁî®ÂÖ∂onCreate(), Êé•ÁùÄÂÜçÈÄöËøásendServiceArgsLoceked()ÊñπÊ≥ïÊù•Ë∞ÉÁî®ServiceÁöÑÂÖ∂‰ªñÊñπÊ≥ï, ÊØîÂ¶ÇonStartCommondËøô‰∏§‰∏™ËøáÁ®ãÂùáÊòØËøõÁ®ãÈó¥ÈÄö‰ø°. app.threadÂØπË±°ÊòØIApplicationThreadÁ±ªÂûãÔºåÂÆûÈôÖ‰∏äÊòØ‰∏Ä‰∏™BinderÔºå‰ªñÁöÑÂÖ∑‰ΩìÂÆûÁé∞ÊòØApplicationThread. Âú®ActivityÂêØÂä®ÊµÅÁ®ãÁöÑÊó∂ÂÄôÂ∑≤ÁªèËß£ÈáäËøá‰∫Ü. ÊâÄ‰ª•Âè™Êü•ÁúãApplicationÂØπServiceÁöÑÂêØÂä®ËøáÁ®ãÁöÑÂ§ÑÁêÜÂç≥ÂèØ. ËøôÂØπÂ∫îÁùÄÂÆÉÁöÑscheduleCreateService(). 12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125; Ëøô‰∏™ËøáÁ®ãÂíåActivityÁ±ª‰ºº, ÈÉΩÊòØÈÄöËøáHÊù•ÂÆåÊàê„ÄÇH‰ºöÊé•Êî∂Ëøô‰∏™CREATE_SERVICEÊ∂àÊÅØÂπ∂ÈÄöËøáActivityThreadÁöÑhandleCreateServiceÊñπÊ≥ïÂÆåÊàêServiceÁöÑÊúÄÁªàÂêØÂä®. 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void handleCreateService(CreateServiceData data) &#123; unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( "Unable to instantiate service " + data.info.name + ": " + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, "Creating service " + data.info.name); ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); //---------------- service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); service.onCreate(); //--------------- mServices.put(data.token, service); try &#123; ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; // nothing to do. &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( "Unable to create service " + data.info.name + ": " + e.toString(), e); &#125; &#125;&#125; handleCreateServiceÂÅö‰∫ÜÂ¶Ç‰∏ã‰∫ãÊÉÖ ÈÄöËøáÁ±ªÂä†ËΩΩÂô®ÂàõÂª∫ServiceÁöÑÂÆû‰æã ÂàõÂª∫ApplicationÂØπË±°Âπ∂Ë∞ÉÁî®ÂÖ∂onCreate(), Ê≥®ÊÑè‚ö†Ô∏èApplicationÂàõÂª∫ËøáÁ®ãÂè™‰ºöÊúâ‰∏ÄÊ¨°. Êé•ÁùÄÂàõÂª∫ContextImplÂØπË±°Âπ∂ÈÄöËøáServiceÁöÑattachÊñπÊ≥ïÂª∫Á´ã‰∫åËÄÖ‰πãÈó¥ÁöÑÂÖ≥Á≥ª, Ëøô‰∏™ËøáÁ®ãÂíåActivityÂÆûÈôÖ‰∏äÊòØÁ±ª‰ººÁöÑ. Ë∞ÉÁî®onCreate()Âπ∂Â∞ÜServiceÂØπË±°Â≠òÂÇ®Âà∞ActivityThread‰∏≠ÁöÑ‰∏Ä‰∏™ÂàóË°®. Â∞±ÊòØfinal ArrayMap&lt;IBinder, Service&gt; mServices = new ArrayMap&lt;IBinder, Service&gt;(); onCreate()ÊñπÊ≥ïË¢´ÊâßË°å‰∫Ü‰πüÂ∞±ÊÑèÂë≥ÁùÄServiceÂ∑≤ÁªèÂêØÂä®‰∫Ü. Èô§Ê≠§‰πãÂ§ñ, ActivityThread‰∏≠Ëøò‰ºöÈÄöËøáhandleServiceArgs()ÊñπÊ≥ïË∞ÉÁî®ServiceÁöÑonStartCommand()ÊñπÊ≥ï. ServiceÁöÑÁªëÂÆöËøáÁ®ãÂíåÂêØÂä®ËøáÁ®ã‰∏ÄÊ†∑, ÁªëÂÆöËøáÁ®ãÂêåÊ†∑ÊòØ‰ªéContextImplÂºÄÂßãÁöÑ. ÂÖàÊü•ÁúãbindServiceCommon(). 12345678910111213141516171819202122232425262728293031323334private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, UserHandle user) &#123; IServiceConnection sd; if (conn == null) &#123; throw new IllegalArgumentException("connection is null"); &#125; if (mPackageInfo != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags); &#125; else &#123; throw new RuntimeException("Not supported in system context"); &#125; validateServiceIntent(service); try &#123; IBinder token = getActivityToken(); if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(); int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( "Not allowed to bind to service " + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; return false; &#125;&#125; ËøôÊÆµ‰ª£Á†ÅÈ¶ñÂÖàÂ∞ÜÂÆ¢Êà∑Á´ØÁöÑServiceConnectionÂØπË±°ËΩ¨ÂåñÊàê‰∏∫ServiceDispatcher.InnerConnectionÂØπË±°. ‰∏çËÉΩÁõ¥Êé•‰ΩøÁî®ServiceConnectionÂØπË±°ÂøÖÈ°ªÂÄüÂä©‰∫éBinderÊâçËÉΩËÆ©ËøúÁ®ãÊúçÂä°ÂõûË∞ÉËá™Â∑±ÁöÑÊñπÊ≥ï. ËÄåServiceDispatcherÁöÑÂÜÖÈÉ®Á±ªInnerConnectionÂàöÂ•ΩÂÖÖÂΩì‰∫ÜBinderËøô‰∏™ËßíËâ≤. ServiceDispatcherÁöÑ‰ΩúÁî®Â∞±ÊòØËøûÊé•ServiceConnectionÂíåInnerConnectionÁöÑ‰ΩúÁî®. Ëøô‰∏™ËøáÁ®ãÁî±LoadedApkÁöÑgetServiceDispatcher()ÊñπÊ≥ïÂÆåÊàê. ÂÆûÁé∞Â¶Ç‰∏ã: 123456789101112131415161718192021public final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) &#123; synchronized (mServices) &#123; LoadedApk.ServiceDispatcher sd = null; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); if (map != null) &#123; sd = map.get(c); &#125; if (sd == null) &#123; sd = new ServiceDispatcher(c, context, handler, flags); if (map == null) &#123; map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;(); mServices.put(context, map); &#125; map.put(c, sd); &#125; else &#123; sd.validate(context, handler); &#125; return sd.getIServiceConnection(); &#125;&#125; mServiceÊòØ‰∏Ä‰∏™ArrayMap, ÂÆÉÂ≠òÂÇ®‰∫Ü‰∏Ä‰∏™Â∫îÁî®ÂΩìÂâçÊ¥ªÂä®ÁöÑServiceConnectionÂíåServiceDispatcherÁöÑÊò†Â∞ÑÂÖ≥Á≥ª. Á≥ªÁªüÈ¶ñÂÖà‰ºöÊü•ÊâæÊòØÂê¶Â≠òÂú®Áõ∏ÂêåÁöÑServiceConnection, Â¶ÇÊûú‰∏çÂ≠òÂú®Â∞±‰ºöÈáçÊñ∞ÂàõÂª∫‰∏Ä‰∏™ServiceDispatchÂØπË±°Âπ∂Â∞ÜÂÖ∂Â≠òÂÇ®Âú®mService‰∏≠, ÂÖ∂‰∏≠ÁöÑkeyÊòØServiceConnection,valueÊòØServiceDispatcher, Âú®ServiceDispatcherÁöÑÂÜÖÈÉ®Âèà‰øùÂ≠ò‰∫ÜServiceConnectionÂíåInnerConnectionÂØπË±°. ÂΩìServiceÂíåÂÆ¢Êà∑Á´ØÂª∫Á´ãËøûÊé•Âêé, Á≥ªÁªü‰ºöÈÄöËøáInnerConnectionÊù•Ë∞ÉÁî®ServiceConnection‰∏≠ÁöÑonServiceConnected()ÊñπÊ≥ï. Ëøô‰∏™ËøáÁ®ãÊòØË∑®ËøõÁ®ãÁöÑ. ÂΩìServiceDispatcherÂàõÂª∫Â•Ω‰∫Ü‰ª•Âêé, getServiceDispatcher‰ºöËøîÂõûÂÖ∂‰øùÂ≠òÁöÑInnerConnectionÂØπË±°. Êé•ÁùÄbindServiceCommonÊñπÊ≥ï‰ºöÈÄöËøáAMSÂÆåÊàêServiceÁöÑÂÖ∑‰ΩìÁªëÂÆö, ËøôÂØπÂ∫îÁùÄAMS#bindService()ÊñπÊ≥ï. 123456789101112131415public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, int userId) &#123; enforceNotIsolatedCaller("bindService"); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, userId); &#125;&#125; ÁÑ∂ÂêéAMS‰ºöË∞ÉÁî®ActivityService#bindServiceLocked()ÊñπÊ≥ï. ÁÑ∂ÂêéË∞ÉÁî®bringUpServiceLocked(), ÁªßÁª≠Ë∞ÉÁî®. ÂèëÁé∞Ë∞ÉÂà∞‰∫ÜrealStartServiceLocked. ‚ö†Ô∏èËøôÈáåÈù¢ÁöÑÈÄªËæëÂíåÂêØÂä®ËøáÁ®ãÁ±ª‰ºº. ÊúÄÁªàÈÉΩÊòØÈÄöËøáApplicationThreadÊù•ÂÆåÊàêServiceÂÆû‰æãÁöÑÂàõÂª∫Âπ∂ÊâßË°åÂÖ∂onCreate()ÊñπÊ≥ï. ËøôÈáå‰∏çÂÜçÈáçÂ§çËØ¥Êòé. ‰∏éServiceÂêØÂä®Á®çÂæÆ‰∏çÂêåÁöÑÊòØ:üò≠ ÁªëÂÆöËøáÁ®ã: ‰ºöË∞ÉÁî®Âà∞app.thread(ActivityThread)ÁöÑscheduleBindService()ÊñπÊ≥ï. ËÄåËøô‰∏™ËøáÁ®ãÁöÑÂÆûÁé∞ÊòØÂú®ActiveService#requestServiceBindingLocked()ÊñπÊ≥ï. 123456789101112131415161718192021222324private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) &#123; if (r.app == null || r.app.thread == null) &#123; // If service is not currently running, can't yet bind. return false; &#125; if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; try &#123; bumpServiceExecutingLocked(r, execInFg, "bind"); r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); if (!rebind) &#123; i.requested = true; &#125; i.hasBound = true; i.doRebind = false; &#125; catch (RemoteException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG, "Crashed while binding " + r); return false; &#125; &#125; return true;&#125; app.threadÂÆûÈôÖ‰∏äÂ∞±ÊòØApplicationThread. ApplicationThreadÁöÑ‰∏ÄÁ≥ªÂàó‰ª•scheduleÂºÄÂ§¥ÁöÑÊñπÊ≥ï, ÂÖ∂ÂÜÖÈÉ®ÈÉΩÊòØÈÄöËøáHandler HÊù•‰∏≠ËΩ¨ÁöÑ. HÁöÑÂÜÖÈÉ® Êé•Êî∂Âà∞BIND_SERVICEÊ∂àÊÅØÈúÄË¶ÅÂ§ÑÁêÜÊó∂, ‰ºö‰∫§ÁªôActivityThread#handleBindService(). Âú®handlerBindService‰∏≠, È¶ñÂÖàÊ†πÊçÆServiceÁöÑtokenÂèñÂá∫ServiceÂØπË±°. ÁÑ∂ÂêéË∞ÉÁî®Service#onBind()ÊñπÊ≥ï, ServiceÁöÑonBinderÊñπÊ≥ïËøîÂõû‰∏Ä‰∏™BinderÂØπË±°ÁªôÂÆ¢Êà∑Á´Ø‰ΩøÁî®. ÂéüÂàô‰∏äÊù•ËØ¥, Service#onBind()ÊñπÊ≥ïË¢´Ë∞ÉÁî®Âêé, ServiceÂ∞±Â§Ñ‰∫éÁªëÂÆöÁä∂ÊÄÅ, ‰ΩÜÊòØonBindÊñπÊ≥ïÊòØServiceÁöÑÊñπÊ≥ï, Ëøô‰∏™Êó∂ÂÄôÂÆ¢Êà∑Á´ØÂπ∂‰∏çÁü•ÈÅìÂ∑≤ÁªèÊàêÂäüËøûÊé•Service, ÊâÄ‰ª•ËøòÂøÖÈ°ªË∞ÉÁî®ÂÆ¢Êà∑Á´ØÁöÑServiceConnection‰∏≠ÁöÑonServiceConnected(), Ëøô‰∏™ËøáÁ®ãÁî±ÊòØActivityManagerNative.getDefault()‰πüÂ∞±ÊòØAMSÁöÑpublishSevice()Êù•ÂÆåÊàê„ÄÇ handleBindService()ÂÆûÁé∞Â¶Ç‰∏ã: 1234567891011121314151617181920212223242526272829303132//ActivityThread.javaprivate void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token); if (DEBUG_SERVICE) Slog.v(TAG, "handleBindService s=" + s + " rebind=" + data.rebind); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try &#123; if (!data.rebind) &#123; IBinder binder = s.onBind(data.intent); // ÁúãÊàëÁúãÊàë ActivityManagerNative.getDefault().publishService( data.token, data.intent, binder); &#125; else &#123; s.onRebind(data.intent); ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; ensureJitEnabled(); &#125; catch (RemoteException ex) &#123; &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( "Unable to bind to service " + s + " with " + data.intent + ": " + e.toString(), e); &#125; &#125; &#125;&#125; ËøòËÆ∞ÂæóÂ§öÊ¨°ÁªëÂÆö‰ºöÊúâ‰ªÄ‰πàÊïàÊûú‰πà? Service#onBind()ÊñπÊ≥ïÂè™‰ºöÊâßË°å‰∏ÄÊ¨°, Èô§ÈùûServiceË¢´ÁªàÊ≠¢‰∫Ü. ÂΩìServiceÁöÑonBind()ÊâßË°å‰πãÂêé, Á≥ªÁªüËøòÈúÄË¶ÅÂëäÁü•ÂÆ¢Êà∑Á´ØÂ∑≤ÁªèÊàêÂäüËøûÊé•Service‰∫Ü. Ëøô‰∫õËøáÁ®ãÊòØÂú®AMS#publishService()ÂÆûÁé∞. 12345678910111213public void publishService(IBinder token, Intent intent, IBinder service) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; throw new IllegalArgumentException("Invalid service token"); &#125; mServices.publishServiceLocked((ServiceRecord)token, intent, service); &#125;&#125; ÂèØ‰ª•ÁúãÂà∞ËøôÈáåÂ∞ÜÂÖ∑‰ΩìÁöÑÂ∑•‰Ωú‰∫§Áªô‰∫ÜmServices.publishServiceLocked()ÂÆÉÊòØ‰∏Ä‰∏™ActiveServiceÁ±ªÂûã. ÂÖ∂Ê†∏ÂøÉ‰ª£Á†ÅÂ∞±ÊòØ: 1234c.conn.connected(r.name, service);//cÁöÑÁ±ªÂûãÊòØConnectionRecord//c.connÁöÑÁ±ªÂûãÊòØServiceDispatcher.InnerConnection//serviceÂèÇÊï∞Â∞±ÊòØServiceÁöÑonBindËøîÂõûÁöÑBinderÂØπË±° 123456789101112131415//Áúã‰∏Ä‰∏ãServiceDispatcher.InnerConnectionÁöÑÂÆö‰πâprivate static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service) &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if(sd != null) &#123; sd.connected(name, service); &#125; &#125;&#125; ËÄåInnerConnection#connected()ÊñπÊ≥ïÂÜÖÂèàË∞ÉÁî®ServiceDispatcherÁöÑconnected(),Âú®ÂÜÖÈÉ®Â∞±ÊòØÂàõÂª∫‰∏Ä‰∏™RunConnection()ÂèëÈÄÅÂà∞mActivityThreadÁöÑÊ∂àÊÅØ‰∏≠. 12345678//ServiceDispatch classpublic void connected(Conponment name, IBinder service) &#123; if(mActivityThread != null) &#123; mActiivtyThread.post(new RunConnection(name, service, 0)); &#125; else &#123; doConnect(name, service); &#125;&#125; ÂØπ‰∫éServiceÁöÑÁªëÂÆöËøáÁ®ãÊù•ËØ¥, ServiceDispatcherÁöÑmActivityThreadÊòØ‰∏Ä‰∏™Handler, ‰πüÂ∞±ÊòØActivityThread#H, ‰ªéÂâçÈù¢ÁöÑServiceDispatcherÁöÑÂàõÂª∫ËøáÁ®ãÊù•ËØ¥, mActivityThread‰∏ç‰ºö‰∏∫null, ÊâÄ‰ª•RunConnectionÂ∞±ÂèØ‰ª•ÁªèÁî±HÁöÑpostÊñπÊ≥ï‰ªéËÄåËøêË°åÂú®‰∏ªÁ∫øÁ®ã. Âõ†Ê≠§ÂÆ¢Êà∑Á´ØÁöÑServiceConnection‰∏≠ÁöÑÊñπÊ≥ïÊòØÂú®‰∏ªÁ∫øÁ®ãË¢´ÂõûË∞ÉÁöÑ. RunConnectionÊòØ‰∏Ä‰∏™RunnableÊé•Âè£, run()ÊñπÊ≥ï‰πüÊòØÁÆÄÂçïË∞ÉÁî®ServiceDispatcher#doConnectedÊñπÊ≥ï, Áî±‰∫éServiceDispatcherÂÜÖÈÉ®‰øùÂ≠ò‰∫ÜÂÆ¢Êà∑Á´ØÁöÑServiceConnectionÂØπË±°, Âõ†Ê≠§‰ªñÂèØ‰ª•ÂæàÊñπ‰æøË∞ÉÁî®ServiceConnectionÂØπË±°ÁöÑonServiceConnected() Ëß£ÁªëÂíåÂÅúÊ≠¢ËøáÁ®ã, Âü∫Êú¨Á±ª‰ºº‚Ä¶ üòÑ. BroadcastReceiverÁöÑÂ∑•‰ΩúÊµÅÁ®ãÁÆÄÂçïÂõûÈ°æ‰∏Ä‰∏ãÂπøÊí≠ÁöÑ‰ΩøÁî®ÊñπÊ≥ï, È¶ñÂÖàÂÆö‰πâÂπøÊí≠Êé•Êî∂ËÄÖ, Âè™ÈúÄË¶ÅÁªßÊâøBroadcastReceiverÂπ∂ÈáçÂÜôonReceive()ÊñπÊ≥ïÂç≥ÂèØ. ÂÆö‰πâÂ•Ω‰∫ÜÂπøÊí≠Êé•Êî∂ËÄÖ, ËøòÈúÄË¶ÅÊ≥®ÂÜåÂπøÊí≠Êé•Êî∂ËÄÖ, ÂàÜ‰∏∫‰∏§ÁßçÈùôÊÄÅÊ≥®ÂÜåÊàñËÄÖÂä®ÊÄÅÊ≥®ÂÜå. Ê≥®ÂÜåÂÆåÊàê‰πãÂêéÂ∞±ÂèØ‰ª•ÂèëÈÄÅÂπøÊí≠‰∫Ü. ÂπøÊí≠ÁöÑÊ≥®ÂÜåËøáÁ®ãÂπøÊí≠ÁöÑÊ≥®ÂÜåÊúâ‰∏§ÁßçÈùôÊÄÅÊ≥®ÂÜå, Âä®ÊÄÅÊ≥®ÂÜå. ÂÖ∂‰∏≠ÈùôÊÄÅÊ≥®ÂÜåÁöÑÂπøÊí≠Âú®Â∫îÁî®ÂÆâË£ÖÊó∂Áî±Á≥ªÁªüËá™Âä®ÂÆåÊàêÊ≥®ÂÜå, ÂÖ∑‰ΩìÊù•ËØ¥ÊòØÊúâPMS(PackageManagerService)Êù•ÂÆåÊàêÊï¥‰∏™Ê≥®ÂÜåËøáÁ®ãÁöÑ. Èô§‰∫ÜÂπøÊí≠Â§ñ, ÂÖ∂‰ªñ‰∏âÂ§ßÁªÑ‰ª∂‰πüÈÉΩÊòØÂú®Â∫îÁî®ÂÆâË£ÖÊó∂Áî±PMSËß£ÊûêÂπ∂Ê≥®ÂÜåÁöÑ. Âä®ÊÄÅÊ≥®ÂÜåÁöÑËøáÁ®ãÊòØ‰ªéContextWrapper#registerReceiver()ÂºÄÂßãÁöÑ. ÂíåActivityÊàñËÄÖService‰∏ÄÊ†∑. ContextWrapperÂπ∂Ê≤°ÊúâÂÅöÂÆûÈôÖÁöÑÂ∑•‰Ωú, ËÄåÊòØÂ∞ÜÊ≥®ÂÜåÁöÑËøáÁ®ãÁõ¥Êé•‰∫§Áªô‰∫ÜContextImplÊù•ÂÆåÊàê. ContextImpl#registerReceiver()ÊñπÊ≥ïË∞ÉÁî®‰∫ÜÊú¨Á±ªÁöÑregisterReceiverInternal()ÊñπÊ≥ï. 12345678910111213141516171819202122232425262728private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; return ActivityManagerNative.getDefault().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); &#125; catch (RemoteException e) &#123; return null; &#125;&#125; ‰∏äËø∞‰ª£Á†Å‰∏≠, Á≥ªÁªüÈ¶ñÂÖà‰ªémPackageInfoËé∑ÂèñÂà∞IIntentReceiverÂØπË±°, ÁÑ∂ÂêéÂÜçÈááÁî®Ë∑®ËøõÁ®ãÁöÑÊñπÂºèÂêëAMSÂèëÈÄÅÂπøÊí≠Ê≥®ÂÜåÁöÑËØ∑Ê±Ç. ‰πãÊâÄ‰ª•ÈááÁî®IIntentReceiverËÄå‰∏çÊòØÁõ¥Êé•ÈááÁî®BroadcastReceiver, ËøôÊòØÂõ†‰∏∫‰∏äËø∞Ê≥®ÂÜåËøáÁ®ã‰∏≠ÊòØ‰∏Ä‰∏™ËøõÁ®ãÈó¥ÈÄö‰ø°ÁöÑËøáÁ®ã. ËÄåBroadcastReceiver‰Ωú‰∏∫Android‰∏≠ÁöÑ‰∏Ä‰∏™ÁªÑ‰ª∂ÊòØ‰∏çËÉΩÁõ¥Êé•Ë∑®ËøõÁ®ã‰º†ÈÄíÁöÑ. ÊâÄÊúâÈúÄË¶ÅÈÄöËøáIIntentReceiverÊù•‰∏≠ËΩ¨‰∏Ä‰∏ã. IIntentReceiver‰Ωú‰∏∫‰∏Ä‰∏™BinderÊé•Âè£, ÂÆÉÁöÑÂÖ∑‰ΩìÂÆûÁé∞ÊòØLoadedApk.ReceiverDispatcher.InnerReceiver, ReceiverDispatcherÁöÑÂÜÖÈÉ®ÂêåÊó∂‰øùÂ≠ò‰∫ÜBroadcastReceiverÂíåInnerReceiver, ËøôÊ†∑ÂΩìÊé•Êî∂Âà∞ÂπøÊí≠ÁöÑÊó∂ÂÄô, ReceiverDispatcherÂèØ‰ª•ÂæàÊñπ‰æøÁöÑË∞ÉÁî®BroadcastReceiver#onReceive()ÊñπÊ≥ï. ËøôÈáåÂíå¬∑ServiceÁöÑÂéüÁêÜÂæàÂÉè, ServiceÊúâ‰∏™ServiceDispatcherÁ±ªÔºåÂπ∂‰∏îÂÖ∂ÂÜÖÈÉ®Á±ªInnerConnectionÂêåÊ†∑‰πüÊòØ‰∏Ä‰∏™BinderÊé•Âè£. Áúã‰∏Ä‰∏ãLoadedApk.ReceiverDispatcher#getIIntentReceiver()ÁöÑÂÆûÁé∞, ÂæàÊòæÁÑ∂getReceiverDispatcher()ÈáçÊñ∞ÂàõÂª∫‰∫Ü‰∏Ä‰∏™ReceiverDispatcherÂØπË±°Âπ∂Â∞ÜÂÖ∂‰øùÂ≠òÁöÑInnerReceiverÂØπË±°‰Ωú‰∏∫ËøîÂõûÂÄºËøîÂõû, ÂÖ∂‰∏≠InnerReceiverÂØπË±°ÂíåBroadcastReceiverÈÉΩÊòØÂú®ReceiverDispatcherÁöÑÊûÑÈÄ†ÊñπÊ≥ï‰∏≠Ë¢´‰øùÂ≠òËµ∑Êù•ÁöÑ. 1234567891011121314151617181920212223242526272829public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) &#123; synchronized (mReceivers) &#123; LoadedApk.ReceiverDispatcher rd = null; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null; if (registered) &#123; map = mReceivers.get(context); if (map != null) &#123; rd = map.get(r); &#125; &#125; if (rd == null) &#123; rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); if (registered) &#123; if (map == null) &#123; map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mReceivers.put(context, map); &#125; map.put(r, rd); &#125; &#125; else &#123; rd.validate(context, handler); &#125; rd.mForgotten = false; return rd.getIIntentReceiver(); &#125;&#125; Áî±‰∫éÊ≥®ÂÜåÂπøÊí≠ÁúüÊ≠£ÂÆûÁé∞ËøáÁ®ãÊòØÂú®AMS‰∏≠, Âõ†Ê≠§Ë∑üËøõAMS‰∏≠, È¶ñÂÖàÁúãregisterReceiver()ÊñπÊ≥ï, ËøôÈáåÂè™ÂÖ≥ÂøÉÈáåÈù¢ÁöÑÊ†∏ÂøÉÈÉ®ÂàÜ. ËøôÊÆµ‰ª£Á†ÅÊúÄÁªà‰ºöÊääËøúÁ®ãÁöÑInnerReceiverÂØπË±°‰ª•ÂèäIntentFilterÂØπË±°Â≠òÂÇ®Ëµ∑Êù•, ËøôÊ†∑Êï¥‰∏™ÂπøÊí≠ÁöÑÊ≥®ÂÜåÂ∞±ÂÆåÊàê‰∫Ü. 123456789public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123; //... mRegisteredReceivers.put(receiver.asBinder(), rl); BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId); rl.add(bf); mReceiverResolver.addFilter(bf); &#125; ÂπøÊí≠ÁöÑÂèëÈÄÅÂíåÊé•Êî∂ËøáÁ®ãÂΩìÈÄöËøásend()ÂèëÈÄÅÂπøÊí≠Êó∂, AMS‰ºöÊü•ÊâæÂá∫ÂåπÈÖçÁöÑÂπøÊí≠Êé•Êî∂ËÄÖÂπ∂Â∞ÜÂπøÊí≠ÂèëÈÄÅÁªô‰ªñ‰ª¨Â§ÑÁêÜ. ÂπøÊí≠ÁöÑÂèëÈÄÅÁßçÁ±ªÊúâ: ÊôÆÈÄöÂπøÊí≠, ÊúâÂ∫èÂπøÊí≠, Á≤òÊÄßÂπøÊí≠. ËøôÈáåÂàÜÊûêÊôÆÈÄöÂπøÊí≠. ÂπøÊí≠ÁöÑÂèëÈÄÅÂíåÊé•Êî∂, Êú¨Ë¥®Â∞±ÊòØ‰∏Ä‰∏™ËøáÁ®ãÁöÑ‰∏§‰∏™Èò∂ÊÆµ. ÂπøÊí≠ÁöÑÂèëÈÄÅ‰ªçÁÑ∂ÂºÄÂßã‰∫éContextImpl#sendBroadcase()ÊñπÊ≥ï, ‰πãÊâÄ‰ª•‰∏çÊòØContext, ÈÇ£ÊòØÂõ†‰∏∫Context#sendBroad()ÊòØ‰∏Ä‰∏™ÊäΩË±°ÊñπÊ≥ï. ÂíåÂπøÊí≠ÁöÑÊ≥®ÂÜåËøáÁ®ã‰∏ÄÊ†∑, ContextWrapper#sendBroadcast()‰ªçÁÑ∂‰ªÄ‰πàÈÉΩ‰∏çÂÅö, Âè™ÊòØÊää‰∫ãÊÉÖ‰∫§Áªô‰∫ÜContextImplÂéªÂ§ÑÁêÜ, ContextImpl#sendBroadcast()Ê∫êÁ†ÅÂ¶Ç‰∏ã 1234567891011@Overridepublic void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); intent.prepareToLeaveProcess(); ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());&#125; ÁúãÂà∞ContextImplÈáåÈù¢‰πüÂá†‰πé‰ªÄ‰πàÈÉΩÊ≤°ÊúâÂÅö, ÂÜÖÈÉ®Áõ¥Êé•ÂêëAMSÂèëËµ∑‰∫Ü‰∏Ä‰∏™ÂºÇÊ≠•ËØ∑Ê±ÇÁî®‰∫éÂèëÈÄÅÂπøÊí≠. Êé•‰∏ãÊù•ÁúãAMS#broadcastIntent()ÊñπÊ≥ï. 12345678910111213141516171819202122public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller("broadcastIntent"); synchronized(this) &#123; intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, null, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; ÁúãÂà∞ËøôÈáå, ÂèàÁªßÁª≠Ë∞ÉÁî®broadcastIntentLocked()ÊñπÊ≥ï, Ëøô‰∏™ÊñπÊ≥ïÊúâÁÇπÈïø. Âú®‰ª£Á†ÅÂºÄÂßãÂ§Ñ 12// By default broadcasts do not go to stopped apps.intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); Ëøô‰∏™Ë°®Á§∫ÈªòËÆ§ÊÉÖÂÜµ‰∏ãÂπøÊí≠‰∏ç‰ºöÂèëÈÄÅÁªôÂ∑≤ÁªèÂÅúÊ≠¢ÁöÑÂ∫îÁî®, android5.0‰∏≠. ËÄåandroid 3.1ÂºÄÂßãÂ∞±Â¢ûÊ∑ª‰∫Ü‰∏§‰∏™Ê†áËÆ∞‰∏∫. ÂàÜÂà´ÊòØFLAG_INCLUDE_STOPPED_PACKAGES, FLAG_EXCLUDE_STOPPED_PACKAGES. Áî®Êù•ÊéßÂà∂ÂπøÊí≠ÊòØÂê¶Ë¶ÅÂØπÂ§Ñ‰∫éÂÅúÊ≠¢ÁöÑÂ∫îÁî®Ëµ∑‰ΩúÁî®. FLAG_INCLUDE_STOPPED_PACKAGES: ÂåÖÂê´ÂÅúÊ≠¢Â∫îÁî®, ÂπøÊí≠‰ºöÂèëÈÄÅÁªôÂ∑≤ÂÅúÊ≠¢ÁöÑÂ∫îÁî®. FLAG_EXCLUDE_STOPPED_PACKAGES: ‰∏çÂåÖÂê´Â∑≤ÂÅúÊ≠¢Â∫îÁî®, ÂπøÊí≠‰∏ç‰ºöÂèëÈÄÅÁªôÂ∑≤ÂÅúÊ≠¢ÁöÑÂ∫îÁî® Âú®android 3.1ÂºÄÂßã, Á≥ªÁªüÂ∞±‰∏∫ÊâÄÊúâÂπøÊí≠ÈªòËÆ§Ê∑ªÂä†‰∫ÜFLAG_EXCLUDE_STOPPED_PACKAGESÊ†áËØÜ, ‰∏∫‰∫ÜÈò≤Ê≠¢ÂπøÊí≠Êó†ÊÑèÈó¥ÊàñËÄÖ‰∏çÂøÖË¶ÅÁöÑÊó∂ÂÄôË∞ÉËµ∑Â∑≤ÁªèÂÅúÊ≠¢ËøêË°åÁöÑÂ∫îÁî®. ÂΩìËøô‰∏§‰∏™Ê†áËÆ∞ÂÖ±Â≠òÁöÑÊó∂ÂÄô‰ª•FLAG_INCLUDE_STOPPED_PACKAGES(ÈùûÈªòËÆ§È°π‰∏∫‰∏ª). Â∫îÁî®Â§Ñ‰∫éÂÅúÊ≠¢ÂàÜ‰∏∫‰∏§Áßç Â∫îÁî®ÂÆâË£ÖÂêéÊú™ËøêË°å Ë¢´ÊâãÂä®ÊàñËÄÖÂÖ∂‰ªñÂ∫îÁî®Âº∫ÂÅú ÂºÄÊú∫ÂπøÊí≠ÂêåÊ†∑ÂèóÂà∞‰∫ÜËøô‰∏™Ê†áÂøó‰ΩçÁöÑÂΩ±Âìç. ‰ªéAndroid 3.1ÂºÄÂßãÂ§Ñ‰∫éÂÅúÊ≠¢Áä∂ÊÄÅÁöÑÂ∫îÁî®ÂêåÊ†∑Êó†Ê≥ïÊé•ÂèóÂà∞ÂºÄÊú∫ÂπøÊí≠, ËÄåÂú®android 3.1‰πãÂâçÂ§Ñ‰∫éÂÅúÊ≠¢ÁöÑÁä∂ÊÄÅ‰πüÊòØÂèØ‰ª•Êé•Êî∂Âà∞ÁöÑÂºÄÊú∫ÂπøÊí≠ÁöÑ. Âú®broadcastIntentLocked()ÂÜÖÈÉ®, ‰ºöÊ†πÊçÆintent-filterÊü•ÊâæÂá∫ÂåπÈÖçÁöÑÂπøÊí≠Êé•Êî∂ËÄÖÂπ∂ÁªèËøá‰∏ÄÁ≥ªÂàóÁöÑÊù°‰ª∂ËøáÊª§. ÊúÄÁªà‰ºöÂ∞ÜÊª°Ë∂≥Êù°‰ª∂ÁöÑÂπøÊí≠Êé•Êî∂ËÄÖÊ∑ªÂä†Âà∞BroadcastQueue‰∏≠, Êé•ÁùÄBroadcastQueueÂ∞±‰ºöÂ∞ÜÂπøÊí≠ÂèëÈÄÅÁªôÁõ∏Â∫îÂπøÊí≠Êé•Êî∂ËÄÖ. 12345678910111213141516171819if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size()); if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction()); boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125;&#125; Ë∑üËøõBroadcastQueue#scheduleBroadcastsLocked() 1234567891011public void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Schedule broadcasts [" + mQueueName + "]: current=" + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125; ÊñπÊ≥ïÂÜÖÂπ∂Ê≤°ÊúâÁ´ãÂç≥ÂèëÈÄÅÂπøÊí≠, ËÄåÊòØÂèëÈÄÅ‰∫Ü‰∏Ä‰∏™BROADCAST_INTENT_MSGÁ±ªÂûãÁöÑÊ∂àÊÅØ, BroadcastQueueÊî∂Âà∞Ê∂àÊÅØÂêé‰ºöË∞ÉÁî®processNextBroadcast()ÊñπÊ≥ï. Ëøô‰∏™ÊñπÊ≥ïÂØπÊôÆÈÄöÂπøÊí≠ÁöÑÂ§ÑÁêÜÂ¶Ç‰∏ã: 12345678910111213141516171819// First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() &gt; 0) &#123; r = mParallelBroadcasts.remove(0);//ÂèñÂá∫ÂπøÊí≠ r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int N = r.receivers.size(); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, "Processing parallel broadcast [" + mQueueName + "] " + r); for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i);//Ëé∑ÂèñÊâÄÊúâÂπøÊí≠Êé•ÂèóËÄÖ if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Delivering non-ordered on [" + mQueueName + "] to registered " + target + ": " + r); deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, "Done with parallel broadcast [" + mQueueName + "] " + r); &#125; Êó†Â∫èÂπøÊí≠Â≠òÂÇ®Âú®mParallelBroadcasts‰∏≠, Á≥ªÁªü‰ºöÈÅçÂéÜËøô‰∏™ÈõÜÂêàÂπ∂Â∞ÜÂÖ∂‰∏≠ÁöÑÂπøÊí≠ÂèëÈÄÅÁªô‰ªñ‰ª¨ÊâÄÊúâÁöÑÊé•Êî∂ËÄÖ, ÂÖ∑‰ΩìÁöÑÂèëÈÄÅËøáÁ®ãÊòØÈÄöËøádeliverToRegisteredReceiverLocked()ÊñπÊ≥ïÂÆûÁé∞. deliverToRegisteredReceiverLocked()Ë¥üË¥£Â∞Ü‰∏Ä‰∏™ÂπøÊí≠ÂèëÈÄÅÁªô‰∏Ä‰∏™ÁâπÂÆöÁöÑÊé•Êî∂ËÄÖ, ÂÆÉÁöÑÂÜÖÈÉ®Ë∞ÉÁî®‰∫ÜperformReceiverLockedÊñπÊ≥ïÊù•ÂÆåÊàêÂÖ∑‰ΩìÂèëÈÄÅËøáÁ®ã. performReceiverLocked()ÊñπÊ≥ïÂÆûÁé∞Â¶Ç‰∏ã, Áî±‰∫éÊé•Êî∂ÂπøÊí≠‰ºöË∞ÉËµ∑Â∫îÁî®Á®ãÂ∫è, Âõ†‰∏∫app.thread‰∏ç‰∏∫null, Ê†πÊçÆÂâçÈù¢ÁöÑÊÄªÁªìapp.thread‰ªçÁÑ∂ÊåáApplicationThread. 12345678910111213141516171819private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null) &#123; if (app.thread != null) &#123; // If we have an app thread, do the call through that so it is // correctly ordered with other one-way calls. app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); &#125; else &#123; // Application has died. Receiver doesn't exist. throw new RemoteException("app.thread must not be null"); &#125; &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; &#125; ËÄåË∞ÉÁî®ÁöÑApplicationThread#scheduleRegisteredReceiver()ÂÆûÁé∞ÊØîËæÉÁÆÄÂçï, ÂÆÉÈÄöËøáInnerReceiverÊù•ÂÆûÁé∞ÂπøÊí≠ÁöÑÊé•Êî∂ 1234567public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser);&#125; ‰∏äÈù¢ÁöÑreceiver.performReceive()‰∏≠ÁöÑreceiverÂØπÂ∫îÁùÄIIntentReceiverÁ±ªÂûãÁöÑÊé•Âè£. ËÄåÂÖ∑‰ΩìÁöÑÂÆûÁé∞Â∞±ÊòØReceiverDispatcher$InnerReceiverÔºåÁúã‰∏Ä‰∏ã‰ªñÁöÑperformReceiver()ÊñπÊ≥ïÔºö 1234567891011121314151617181920212223242526272829public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; LoadedApk.ReceiverDispatcher rd = mDispatcher.get(); if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra("seq", -1); Slog.i(ActivityThread.TAG, "Receiving broadcast " + intent.getAction() + " seq=" + seq + " to " + (rd != null ? rd.mReceiver : null)); &#125; if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; else &#123; // The activity manager dispatched a broadcast to a registered // receiver in this process, but before it could be delivered the // receiver was unregistered. Acknowledge the broadcast on its // behalf so that the system's broadcast sequence can continue. if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, "Finishing broadcast to unregistered receiver"); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags()); &#125; catch (RemoteException e) &#123; Slog.w(ActivityThread.TAG, "Couldn't finish broadcast to unregistered receiver"); &#125; &#125;&#125; ‰∏äÈù¢ÂèàË∞ÉÁî®‰∫ÜLoadedApk$ReceiverDispatcher#performReceive()ÁöÑÊñπÊ≥ï. 123456789101112131415161718public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra("seq", -1); Slog.i(ActivityThread.TAG, "Enqueueing broadcast " + intent.getAction() + " seq=" + seq + " to " + mReceiver); &#125; Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); if (!mActivityThread.post(args)) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, "Finishing sync broadcast to " + mReceiver); args.sendFinished(mgr); &#125; &#125; &#125; Âú®performReceiver()Ëøô‰∏™ÊñπÊ≥ï‰∏≠, ‰ºöÂàõÂª∫‰∏Ä‰∏™ArgsÂØπË±°Âπ∂ÈÄöËøámActivityThreadÁöÑpostÊñπÊ≥ïÊâßË°åargs‰∏≠ÁöÑÈÄªËæë. ËÄåËøô‰∫õÁ±ªÁöÑÊú¨Ë¥®ÂÖ≥Á≥ªÂ∞±ÊòØ: Args: ÂÆûÁé∞‰∫ÜRunnableÊé•Âè£ mActivityThread: ÊòØ‰∏Ä‰∏™Handler, Â∞±ÊòØActivityThread‰∏≠ÁöÑmH. mHÂ∞±ÊòØActivityThread$H. Ëøô‰∏™ÂÜÖÈÉ®Á±ªH‰ª•ÂâçËØ¥Ëøá. ËÄåArgs‰∏≠ÊúâÁöÑrun()ÊñπÊ≥ïÊúâÂ¶Ç‰∏ã‰ª£Á†Å: 12345ClassLoader cl = mReceiver.getClass().getClassLoader();intent.setExtrasClassLoader(cl);setExtrasClassLoader(cl);receiver.setPendingResult(this);receiver.onReceive(mContext, intent); Ëøô‰∏™Êó∂ÂÄôBroadcastReceiver#onReceive()ÊñπÊ≥ïË¢´ÊâßË°å‰∫Ü, ‰πüÂ∞±ÊòØËØ¥Â∫îÁî®Â∑≤ÁªèÊé•Êî∂Âà∞‰∫ÜÂπøÊí≠, ÂêåÊó∂onReceive()ÊñπÊ≥ïÊòØÂú®ÂπøÊí≠Êé•Êî∂ËÄÖÁöÑ‰∏ªÁ∫øÁ®ã‰∏≠Ë¢´Ë∞ÉÁî®ÁöÑ. ContentProviderÁöÑÂ∑•‰ΩúÊú∫Âà∂ContentProviderÊòØ‰∏ÄÁßçÂÜÖÂÆπÂÖ±‰∫´ÂûãÁªÑ‰ª∂, ÂÆÉÈÄöËøáBinderÂêëÂÖ∂‰ªñÁªÑ‰ª∂‰πÉËá≥ÂÖ∂‰ªñÂ∫îÁî®Êèê‰æõÊï∞ÊçÆ. ÂΩìContentProviderÊâÄÂú®ÁöÑËøõÁ®ãÂêØÂä®Êó∂, ContentProvider‰ºöÂêåÊó∂ÂêØÂä®Âπ∂ÂèëÂ∏ÉÂà∞AMS‰∏≠. Ë¶ÅÊ≥®ÊÑè:Ëøô‰∏™Êó∂ÂÄôContentProviderÁöÑonCreate()ÊñπÊ≥ïÊòØÂÖà‰∫éApplicationÁöÑonCreate()ÊâßË°åÁöÑËøô‰∏ÄÁÇπÂú®ÂõõÂ§ßÁªÑ‰ª∂ÊòØÂ∞ëÊúâÁöÑÁé∞Ë±°. ÂΩì‰∏Ä‰∏™Â∫îÁî®ÂêØÂä®ÁöÑÊó∂ÂÄô, ÂÖ•Âè£ÁöÑÊñπÊ≥ï‰∏∫ActivityThread#main()ÊñπÊ≥ï, mainÊñπÊ≥ï‰∏∫‰∏Ä‰∏™ÈùôÊÄÅÊñπÊ≥ï, Âú®mainÊñπÊ≥ï‰∏≠‰ºöÂàõÂª∫ActivityThreadÁöÑÂÆû‰æã, Âπ∂ÂàõÂª∫‰∏ªÁ∫øÁ®ãÁöÑÊ∂àÊÅØÈòüÂàó, ÁÑ∂ÂêéÂú®ActivityThread#attach()ÊñπÊ≥ï‰∏≠‰ºöËøúÁ®ãË∞ÉÁî®AMS#attachApplication()Âπ∂Â∞ÜApplicationThreadÂØπË±°Êèê‰æõÁªôAMS. ApplicationThreadÊòØ‰∏Ä‰∏™BinderÂØπË±°, ÂÆÉÁöÑBinderÊé•Âè£ÊòØIApplicationThread, ‰∏ªË¶ÅÁî®‰∫éActivityThreadÂíåAMS‰πãÈó¥ÁöÑÈÄö‰ø°, Ëøô‰∏ÄÁÇπÂú®ÂâçÈù¢Â§öÊ¨°ÊèêÂà∞. Âú®AMSÁöÑattachApplication()‰∏≠, ‰ºöË∞ÉÁî®ApplicationThread#bindApplication(). Ëøô‰∏™ËøáÁ®ãÂêåÊ†∑ÊòØË∑®ËøõÁ®ãÁöÑ. bindApplication()‰∏≠‰ºöÁªèËøá ActivityThread‰∏≠ÁöÑmh(Handler) ÂàáÊç¢Âà∞ActivityThread‰∏≠ÂéªÊâßË°å, ÂÖ∑‰ΩìÁöÑÊñπÂºèÊòØhandleBindApplication(). Âú®handleBindApplication()ÊñπÊ≥ï‰∏≠, ActivityThread‰ºöÂàõÂª∫ApplicationÂØπË±°Âπ∂Âä†ËΩΩContentProvider. ÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØ, ActivityThread‰ºöÂÖàÂä†ËΩΩContentProvider, ÁÑ∂ÂêéÂú®Ë∞ÉÁî®Application#onCreate()ÊñπÊ≥ï ‰ª•‰∏äÂ∞±ÊòØContentProviderÁöÑÂêØÂä®ËøáÁ®ã, ContentProviderÂêØÂä®Âêé, Â§ñÁïåÂ∞±ÂèØ‰ª•ÈÄöËøáÂÆÉÊâÄÊèê‰æõÁöÑÂ¢ûÂà†ÊîπÊü•ËøôÂõõ‰∏™Êé•Âè£Êù•Êìç‰ΩúContentProvider‰∏≠ÁöÑÊï∞ÊçÆÊ∫ê, ËøôÂõõ‰∏™ÊñπÊ≥ïÈÉΩÊòØÈÄöËøáBinderÊù•Ë∞ÉÁî®ÁöÑ, Â§ñÁïåÊó†Ê≥ïÁõ¥Êé•ËÆøÈóÆContentProvider, ÂÆÉÂè™ËÉΩÈÄöËøáAMSÊ†πÊçÆURIÊù•Ëé∑ÂèñÂà∞ÂØπÂ∫îÁöÑContentProviderÁöÑBinderÊé•Âè£IContentProvider, ÁÑ∂ÂêéÂÜçÈÄöËøáIContentProviderÊù•ËÆøÈóÆContentProvider‰∏≠ÁöÑÊï∞ÊçÆÊ∫ê. ContentProviderÊòØÂê¶Â±û‰∫éÂçïÂÆû‰æã? ÂÖ∑‰ΩìContentProviderÊòØÂê¶ÊòØÂçïÂÆû‰æãÂèñÂÜ≥‰∫éandroid:multiprocessÂ±ûÊÄßÊù•ÂÜ≥ÂÆöÁöÑ, ÂΩìÂÖ∂ÂÄº‰∏∫falseÁöÑÊó∂ÂÄô, Â∞±ÊòØÂçïÂÆû‰æã‰πüÊòØÈªòËÆ§ÂÄº. Â¶ÇÊûú‰∏∫trueÈÇ£Â∞±‰∏∫Â§öÂÆû‰æã. Ëøô‰∏™Êó∂ÂÄôÂú®ÊØè‰∏Ä‰∏™Ë∞ÉÁî®ËÄÖÁöÑËøõÁ®ã‰∏≠ÈÉΩ‰ºöÂ≠òÂú®‰∏Ä‰∏™ContentProviderÂØπË±°. ÈÄöËøáÂçïÂÆû‰æãÁöÑContentProviderÊù•ÂàÜÊûê‰∏Ä‰∏ãÂêØÂä®ËøáÁ®ã È¶ñÂÖàËÆøÈóÆContentProviderÈúÄË¶ÅÈÄöËøáContentResolver, ContentResolverÊòØ‰∏Ä‰∏™ÊäΩË±°Á±ª, ÈÄöËøáContent#getContentResolver()ÊñπÊ≥ïËé∑ÂèñÁöÑÂÆûÈôÖ‰∏äÊòØApplicationContentResolverÂØπË±°, ËÄåËøô‰∏™Á±ªÁªßÊâø‰∫ÜContentProviderÂπ∂ÂÆûÁé∞‰∫ÜÂÖ∂ÊäΩË±°ÊñπÊ≥ï. ÂΩìContentProviderÊâÄÂú®ÁöÑËøõÁ®ãÊú™ÂêØÂä®Êó∂, Á¨¨‰∏ÄÊ¨°ËÆøÈóÆÂÆÉÁöÑÊó∂ÂÄôÂ∞±‰ºöËß¶ÂèëContentProviderÁöÑÂàõÂª∫, ÂΩìÁÑ∂Ëøô‰πü‰º¥ÈöèÁùÄContentProviderÊâÄÂú®ÁöÑËøõÁ®ãÁöÑÂêØÂä®. ÈÄöËøáÂõõ‰∏™ÂØπÊï∞ÊçÆÁöÑÊìç‰ΩúÊñπÊ≥ï‰∏≠ÁöÑ‰ªª‰Ωï‰∏Ä‰∏™, ÈÉΩÂèØ‰ª•Ëß¶ÂèëContentProviderÁöÑÂêØÂä®ËøáÁ®ã. ÂõõÁßçÊìç‰ΩúËøáÁ®ãÂ∑Æ‰∏çÂ§ö, ÈÇ£‰πàËøôÈáå‰ª•queryÊñπÊ≥ï‰∏∫‰æã È¶ñÂÖà‰ºöËé∑ÂèñIContentProviderÂØπË±°, ‰∏çÁÆ°ÊòØÈÄöËøáacquireUnstableProvider()ÊñπÊ≥ïËøòÊòØÁõ¥Êé•ÈÄöËøáacquireProvider()ÊñπÊ≥ï, ‰ªñ‰ª¨ÁöÑÊú¨Ë¥®ÈÉΩÊòØ‰∏ÄÊ†∑ÁöÑ, ÊúÄÁªàÈÉΩÊòØÈÄöËøáacquireProviderÊñπÊ≥ïÊù•Ëé∑ÂèñContentProvider. ApplicationContentResolver#acquireProvider()ÊñπÊ≥ïÂπ∂Ê≤°ÊúâÂ§ÑÁêÜ‰ªª‰ΩïÈÄªËæë, ÂÆÉÁõ¥Êé•Ë∞ÉÁî®‰∫ÜActivityThread#acquireProvider(), Ëøô‰∏™ÊñπÊ≥ïÂ¶Ç‰∏ã: 123456789101112131415161718192021222324public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; IActivityManager.ContentProviderHolder holder = null; try &#123; holder = ActivityManagerNative.getDefault().getContentProvider( getApplicationThread(), auth, userId, stable); &#125; catch (RemoteException ex) &#123; &#125; if (holder == null) &#123; Slog.e(TAG, "Failed to find provider info for " + auth); return null; &#125; // Install provider will increment the reference count for us, and break // any ties in the race. holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider;&#125; ËøôÊÆµ‰ª£Á†Å‰∏ªË¶Å‰ªéActivityThread‰∏≠Êü•ÊâæÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®‰∫ÜContentProvider‰∫Ü, Â¶ÇÊûúÂ≠òÂú®ÈÇ£‰πàÂ∞±Áõ¥Êé•ËøîÂõû. ActivityThread‰∏≠ÈÄöËøámProviderMapÊù•Â≠òÂÇ®Â∑≤ÁªèÂêØÂä®ÁöÑContentProviderÂØπË±°, Ëøô‰∏™ÈõÜÂêàÁöÑÂ≠òÂÇ®Á±ªÂûãArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap. Â¶ÇÊûúÁõÆÂâçContentProviderÊ≤°ÊúâÂêØÂä®, ÈÇ£‰πàÂ∞±ÂèëÈÄÅ‰∏Ä‰∏™ËøõÁ®ãÈó¥ËØ∑Ê±ÇÁªôAMSËÆ©ÂÖ∂ÂêØÂä®È°πÁõÆÁõÆÊ†áContentProvider, ÊúÄÂêéÂÜçÈÄöËøáinstallProvider()ÊñπÊ≥ïÊù•‰øÆÊîπÂºïÁî®ËÆ°Êï∞. ÈÇ£‰πàAMSÊòØÂ¶Ç‰ΩïÂêØÂä®ContentProviderÁöÑÂë¢? ÂÖ≥‰∫éContentProviderË¢´ÂêØÂä®ÁöÑÊó∂ÂÄô‰ºö‰º¥ÈöèÁùÄËøõÁ®ãÁöÑÂêØÂä®, Âú®AMS‰∏≠, È¶ñÂÖà‰ºöÂêØÂä®ContentProviderÊâÄÂú®ÁöÑËøõÁ®ã, ÁÑ∂ÂêéÂÜçÂêØÂä®ContentProvider. ÂêØÂä®ËøõÁ®ãÊòØÁî±AMS#startProcessLocked()ÊñπÊ≥ïÊù•ÂÆåÊàê, ÂÖ∂ÂÜÖÈÉ®‰∏ªË¶ÅÊòØÈÄöËøáProcess#start()ÊñπÊ≥ïÊù•ÂÆåÊàê‰∏Ä‰∏™Êñ∞ËøõÁ®ãÁöÑÂêØÂä®, Êñ∞ËøõÁ®ãÂêØÂä®ÂêéÂÖ∂ÂÖ•Âè£ÊñπÊ≥ï‰∏∫ActivityThread#main()ÊñπÊ≥ï. Â¶Ç‰∏ã: 123456789101112131415161718192021222324252627282930313233343536373839404142 public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; ActivityThread#main()ÊòØ‰∏Ä‰∏™ÈùôÊÄÅÊñπÊ≥ï, Âú®ÂÆÉÁöÑÂÜÖÈÉ®È¶ñÂÖà‰ºöÂàõÂª∫ActivityThreadÂÆû‰æãÂπ∂Ë∞ÉÁî®attach()ÊñπÊ≥ïÊù•ËøõË°å‰∏ÄÁ≥ªÂàóÂàùÂßãÂåñ, Êé•ÁùÄÂ∞±ÂºÄÂßãËøõË°åÊ∂àÊÅØÂæ™ÁéØ. ActivityThread#attach()ÊñπÊ≥ï‰ºöÂ∞ÜApplicationThreadÂØπË±°ÈÄöËøáAMS#attachApplicationÊñπÊ≥ïË∑®ËøõÁ®ã‰º†ÈÄíÁªôAMS, ÊúÄÁªàAMS‰ºöÂÆåÊàêContentProviderÁöÑÂàõÂª∫ËøáÁ®ã. ActivityThread#attach()ÈÉ®ÂàÜ‰ª£Á†Å: 12345try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; AMS#attachApplication()ÊñπÊ≥ïË∞ÉÁî®‰∫ÜattachApplication(), ÁÑ∂ÂêéÂèàË∞ÉÁî®‰∫ÜApplicationThread#bindApplication(), Ëøô‰∏™ËøáÁ®ã‰πüÂ±û‰∫éËøõÁ®ãÈÄö‰ø°. ËÄå‰∏äÈù¢ÁöÑbindApplication()ÊñπÊ≥ï‰ºöÂèëÈÄÅ‰∏Ä‰∏™BIND_APPLICATIONÁ±ªÂûãÁöÑÊ∂àÊÅØÁªômH, ËøôÊòØ‰∏Ä‰∏™Handler, ÂÆÉÊî∂Âà∞Ê∂àÊÅØÂêé‰ºöË∞ÉÁî®ActivityThread#handleBindApplication()ÊñπÊ≥ï. bindApplication()ÂèëÈÄÅÊ∫êÁ†ÅÂ¶Ç‰∏ã: 12345678910111213141516AppBindData data = new AppBindData();data.processName = processName;data.appInfo = appInfo;data.providers = providers;data.instrumentationName = instrumentationName;data.instrumentationArgs = instrumentationArgs;data.instrumentationWatcher = instrumentationWatcher;data.instrumentationUiAutomationConnection = instrumentationUiConnection;data.debugMode = debugMode;data.enableOpenGlTrace = enableOpenGlTrace;data.restrictedBackupMode = isRestrictedBackupMode;data.persistent = persistent;data.config = config;data.compatInfo = compatInfo;data.initProfilerInfo = profilerInfo;sendMessage(H.BIND_APPLICATION, data); ActivityThread#handlerBindApplication()ÂàôÂÆåÊàê‰∫ÜApplication‰ª•ÂèäContentProvider ÁöÑÂàõÂª∫ÔºåÂèØ‰ª•ÂàÜ‰∏∫Â¶Ç‰∏ãÂõõ‰∏™Ê≠•È™§: ÂàõÂª∫ContentProviderÂíåInstrumentation ÂàõÂª∫ApplicationÂØπË±° ÂêØÂä®ÂΩìÂâçËøõÁ®ãÁöÑContentProviderÂπ∂Ë∞ÉÁî®onCreate()ÊñπÊ≥ï. ‰∏ªË¶ÅÂÜÖÈÉ®ÂÆûÁé∞ÊòØinstallContentProvider()ÂÆåÊàê‰∫ÜContentProviderÁöÑÂêØÂä®Â∑•‰Ωú, È¶ñÂÖà‰ºöÈÅçÂéÜÂΩìÂâçËøõÁ®ãÁöÑProviderInfoÁöÑÂàóË°®Âπ∂‰∏Ä‰∏ÄË∞ÉÁî®installProvider()ÊñπÊ≥ïÊù•ÂêØÂä®‰ªñ‰ª¨, Êé•ÁùÄÂ∞ÜÂ∑≤ÁªèÂêØÂä®ÁöÑContentProviderÂèëÂ∏ÉÂà∞AMS‰∏≠, AMS‰ºöÊää‰ªñ‰ª¨Â≠òÂÇ®Âú®ProviderMap‰∏≠, ËøôÊ†∑‰∏ÄÊù•Â§ñÈÉ®Ë∞ÉÁî®ËÄÖÂ∞±ÂèØ‰ª•Áõ¥Êé•‰ªéAMS‰∏≠Ëé∑ÂèñÂà∞ContentProvider. installProvider()ÂÜÖÈÉ®ÈÄöËøáÁ±ªÂä†ËΩΩÂô®ÂàõÂª∫ÁöÑContentProviderÂÆû‰æãÂπ∂Âú®ÊñπÊ≥ï‰∏≠Ë∞ÉÁî®‰∫ÜattachInfo(), Âú®ËøôÂÜÖÈÉ®Ë∞ÉÁî®‰∫ÜContentProvider#onCreate() Ë∞ÉÁî®Application#onCreate() ÁªèËøá‰∫Ü‰∏äËø∞ÁöÑÂõõ‰∏™Ê≠•È™§, ContentProviderÂ∑≤ÁªèÂêØÂä®ÊàêÂäü, Âπ∂‰∏îÂÖ∂ÊâÄÂú®ÁöÑËøõÁ®ãÁöÑApplication‰πüÂ∑≤ÁªèÊàêÂäü, ËøôÊÑèÂë≥ÁùÄContentProviderÊâÄÂú®ÁöÑËøõÁ®ãÂ∑≤ÁªèÂÆåÊàê‰∫ÜÊï¥‰∏™ÁöÑÂêØÂä®ËøáÁ®ã, ÁÑ∂ÂêéÂÖ∂‰ªñÂ∫îÁî®Â∞±ÂèØ‰ª•ÈÄöËøáAMSÊù•ËÆøÈóÆËøô‰∏™ContentProvider‰∫Ü. ÂΩìÊãøÂà∞‰∫ÜContentProvider‰ª•Âêé, Â∞±ÂèØ‰ª•ÈÄöËøáÂÆÉÊâÄÊèê‰æõÁöÑÊé•Âè£ÊñπÊ≥ïÊù•ËÆøÈóÆÂÆÉ. ËøôÈáåË¶ÅÊ≥®ÊÑè: ËøôÈáåÁöÑContentProviderÂπ∂‰∏çÊòØÂéüÂßãÁöÑContentProvider. ËÄåÊòØContentProviderÁöÑBinderÁ±ªÂûãÂØπË±°IContentProvider, ËÄåIContentProviderÁöÑÂÖ∑‰ΩìÂÆûÁé∞ÊòØContentProviderNativeÂíåContentProvider.Transport. ÂêéËÄÖÁªßÊâø‰∫ÜÂâçËÄÖ. Â¶ÇÊûúËøòÁî®queryÊñπÊ≥ïÊù•Ëß£ÈáäÊµÅÁ®ã: ÈÇ£‰πàÊúÄÂºÄÂßãÂÖ∂‰ªñÂ∫îÁî®ÈÄöËøáAMSËé∑ÂèñÂà∞ContentProviderÁöÑBinderÂØπË±°Â∞±ÊòØIContentProvider. ËÄåIContentProviderÁöÑÂÆûÈôÖÂÆûÁé∞ËÄÖÊòØContentProvider.Transport. Âõ†Ê≠§ÂÆûÈôÖ‰∏äÂ§ñÈÉ®Â∫îÁî®Ë∞ÉÁî®ÁöÑÊó∂ÂÄôÊú¨Ë¥®‰∏ä‰ºö‰ª•ËøõÁ®ãÈó¥ÈÄö‰ø°ÁöÑÊñπÂºèË∞ÉÁî®ContentProvider.TransportÁöÑquery()ÊñπÊ≥ï,ÁÑ∂Âêé‰ªñÁöÑÂÜÖÈÉ®ÂèàË∞ÉÁî®‰∫ÜContentProviderÁöÑqueryÊñπÊ≥ïÔºåqueryÊñπÊ≥ïÁöÑÊâßË°åÁªìÊûúÂÜçÈÄöËøáBinderËøîÂõûÁªôË∞ÉÁî®ËÄÖ„ÄÇ]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>ÂõõÂ§ßÁªÑ‰ª∂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava Ê∫êÁ†ÅÂàÜÊûê]]></title>
    <url>%2F2018%2F03%2F08%2FRxJava%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Âü∫‰∫é RxJava 2.1.2 ÁªôÂÆö‰∏ãÈù¢ÁöÑ‰∏ÄÊÆµ‰ª£Á†ÅÔºå‰ªéÊ∫êÁ†ÅÁöÑËßíÂ∫¶ÂàÜÊûê RxJava ÁöÑÂÆûÁé∞ÂéüÁêÜÔºö 12345678910111213141516171819202122232425262728293031323334353637ObservableOnSubscribe&lt;Integer&gt; oos = new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(max); &#125; e.onComplete(); &#125;&#125;;Observer&lt;Integer&gt; o = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;;Observable.create(oos) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.computation()) .subscribe(o); ÂàÜÊûêÊ∫êÁ†Å‰πãÂâçÔºåÊàë‰ª¨ÂÖàÂÆö‰πâ‰∏Ä‰∏ãÂêçËØçÔºåRxJava ÊòØÂü∫‰∫éËßÇÂØüËÄÖÊ®°ÂºèÁöÑÔºåËøôÈáåÂ∞ÜË¢´ËßÇÂØüËÄÖÂè´ÂÅö‰∏ªÈ¢òÔºàSourceÔºâÔºåËßÇÂØüËÄÖÂè´ÂÅöËßÇÂØüËÄÖÔºàObserverÔºâ„ÄÇ ‰∏äÈù¢ÁöÑ‰ª£Á†ÅÈ¶ñÂÖàÂàõÂª∫‰∫Ü‰∏Ä‰∏™‰∏ªÈ¢òÂØπË±°ÔºåÁÑ∂ÂêéÂèàÂàõÂª∫‰∫Ü‰∏Ä‰∏™ËßÇÂØüËÄÖÂØπË±°ÔºåÊúÄÂêéÂ∞Ü‰∏§ËÄÖÂÖ≥ËÅîËµ∑Êù•ÔºåÂπ∂‰∏îÊúÄÈáçË¶ÅÁöÑ‰∏ÄÁÇπÔºåÊåáÂÆö‰∫Ü‰∏ªÈ¢òÂØπË±°ÂíåËßÇÂØüËÄÖÂØπË±°ÊâßË°åÁöÑÁ∫øÁ®ã„ÄÇ Observable.create(oos)È¶ñÂÖàÂàÜÊûêËøôË°å‰ª£Á†ÅÂÅö‰∫Ü‰ªÄ‰πà‰∫ãÊÉÖÔºö 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ObjectHelper Âè™ÊòØÁî®Êù•ÂÅöÈùûÁ©∫Âà§Êñ≠ÔºåËøôÈáåÂ∞±‰∏çÁî®ÁÆ°ÂÆÉ‰∫Ü„ÄÇÁúãÁúã RxJavaPlugins ÂÅö‰∫Ü‰ªÄ‰πàÔºö 123456789101112131415/** * Calls the associated hook function. * @param &lt;T&gt; the value type * @param source the hook's input value * @return the value returned by the hook */@SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;)@NonNullpublic static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; Ê≥®Èáä‰∏äÈÉΩËØ¥‰∫ÜÔºåËøôÊòØ‰∏Ä‰∏™Èí©Â≠êÂáΩÊï∞Ôºå‰πüÂ∞±ÊòØËØ¥Â¶ÇÊûú onObservableAssembly ÁöÑÂÄº‰∏ç‰∏∫Á©∫ÔºåÈÇ£‰πàÂ∞±Ë∞ÉÁî®Ëøô‰∏™Èí©Â≠êÂáΩÊï∞ÔºåonObservableAssembly ÊòØ‰∏Ä‰∏™ÈùôÊÄÅÂèòÈáèÔºåÈúÄË¶ÅÊàë‰ª¨‰∏ªÂä®ÁöÑÂéªËÆæÁΩÆÊâç‰ºöËµãÂÄºÔºåËøôÈáåÂΩìÂÅöÁ©∫Êù•ËÄÉËôëÔºåÂ¶ÇÊûú onObservableAssembly ‰∏∫Á©∫ÁöÑËØùÔºå‰πüÂ∞±ÊòØËØ¥Ëøô‰∏™ÊñπÊ≥ïÂï•ÈÉΩÊ≤°ÂÅöÔºåÁõ¥Êé•ËøîÂõû source ÂèÇÊï∞Ôºå‰πüÂ∞±ÊòØ‰∏äÈù¢ÁöÑ ObservableCreate ÂØπË±°„ÄÇ ÊÄªÁªì‰∏Ä‰∏ãÔºåObservable.create(oos) Âè™ÊòØÂàõÂª∫‰∫Ü‰∏Ä‰∏™ ObservableCreate ÂØπË±°„ÄÇËøô‰∏™ÊñπÊ≥ïÂ∞±ÊöÇÊó∂ÂÖàÂàÜÊûêÂà∞ËøôÈáåÔºåËá≥‰∫éËøô‰∏™ÂØπË±°ÂÜÖÈÉ®Êúâ‰ªÄ‰πà‰∏úË•øÔºåÊàë‰ª¨ÂêéÈù¢‰ºöËØ¥Âà∞„ÄÇ observeOn(AndroidSchedulers.mainThread())Êó¢ÁÑ∂‰πãÂâçÁöÑ create ÊñπÊ≥ïÂàõÂª∫‰∫Ü‰∏Ä‰∏™ ObservableCreate ÂØπË±°Âπ∂ËøîÂõûÔºå‰πüÂ∞±ÊòØËØ¥ observeOn(Schedulers.computation()) Ëøô‰∏™ÊñπÊ≥ïÊòØË∞ÉÁî®ÁöÑ ObservableCreate Ëøô‰∏™ÂØπË±°‰∏äÁöÑÊñπÊ≥ï„ÄÇ 1public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; ObservableCreate ÊòØÁªßÊâøËá≥ Observable ÁöÑ„ÄÇ 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; Observable ÁöÑ observeOn ÊòØ final ÁöÑÔºåÊâÄ‰ª•Ëµ∞ÁöÑÁà∂Á±ªÁöÑÊñπÊ≥ï„ÄÇÁªßÁª≠Ë∑üË∏™ observeOn Ë∞ÉÁî®ÁöÑÂêåÂêçÊñπÊ≥ïÔºö 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; ObjectHelper Ë∑≥Ëøá„ÄÇËøôÈáåÂèàÊòØ‰∏Ä‰∏™ onAssembly ÊñπÊ≥ïÁöÑË∞ÉÁî®ÔºåÊàëÂæàÂ•ΩÂ•áËøô‰∏™ÂçïËØçÊòØ‰ªÄ‰πàÊÑèÊÄù„ÄÇÁÇπËøõÂéªÁúã‰∏Ä‰∏ãÔºö 1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; ÂêåÊ†∑ÊòØ‰∏Ä‰∏™Èí©Â≠êÊñπÊ≥ïÔºåÁé∞Âú®‰πüÊòØÊúâÁªèÈ™åÁöÑ‰∫∫Âë¢ÔºåÂÜçÁúãÂà∞Ëøô‰∏™ÊñπÊ≥ïÔºåÂ∞±Áõ¥Êé•Ë∑≥ËøáÔºåÂè™ÂÖ≥ÂøÉÂÆÉ‰º†ÈÄíÁöÑÂèÇÊï∞ÂíåËøîÂõûÂÄºÂ∞±Ë°å‰∫Ü„ÄÇÂÆÉÁöÑËøîÂõûÂÄºÈªòËÆ§Â∞±ÊòØ‰º†ÈÄíËøõÊù•ÁöÑÂèÇÊï∞„ÄÇ ÊâÄ‰ª•ÔºåobserveOn ÊñπÊ≥ïÂ∞±ÊòØÂàõÂª∫Âπ∂ËøîÂõû‰∫Ü‰∏Ä‰∏™ ObservableObserveOn ÂØπË±°ÔºàÂ§ßÁ•ûÊïô‰Ω†Ëµ∑Á±ªÂêçÁ≥ªÂàó‰∫åÔºâÔºåËøôÈáåÈ¢ÑË≠¶‰∏Ä‰∏ãÔºå‰πãÂêéÂÉèËøôÊ†∑Á±ª‰ººÁöÑÁ±ªÂêçÂ∑Æ‰∏çÂ§öËøòÊúâ3‰∏™„ÄÇ subscribeOn(Schedulers.computation())Áî±‰∫é observeOn ÂàõÂª∫Âπ∂ËøîÂõû‰∫Ü‰∏Ä‰∏™ ObservableObserveOn ÂØπË±°ÔºåÊâÄ‰ª•ËøôÈáåË∞ÉÁî®ÁöÑÊòØ ObservableObserveOn ÂØπË±°‰∏äÁöÑÊñπÊ≥ï„ÄÇ 1public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; ‰πüÊòØÁªßÊâøËá≥ Observable „ÄÇ 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; ‰∏çÂá∫ÊÑèÊñôÔºå‰πüÊòØ final ÁöÑÔºåÂàõÂª∫‰∫Ü‰∏Ä‰∏™ ObservableSubscribeOn ÂØπË±°ÔºàÂ§ßÁ•ûÊïô‰Ω†Ëµ∑Á±ªÂêçÁ≥ªÂàó‰∏âÔºâÂπ∂ËøîÂõû„ÄÇ subscribe(o)ÂâçÈù¢ subscribeOn ÂàõÂª∫‰∫Ü‰∏Ä‰∏™ ObservableSubscribeOn ÂØπË±°Âπ∂ËøîÂõûÔºåÊâÄ‰ª•ËøôÈáåË∞ÉÁî®ÁöÑÊòØ ObservableSubscribeOn Ëøô‰∏™ÂØπË±°‰∏äÈù¢ÁöÑÊñπÊ≥ï„ÄÇ 1public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; ÁªßÊâøËá≥ Observable Á±ª„ÄÇ 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; Ëøô‰∏™ÊñπÊ≥ï‰πüÊòØ final ÁöÑÔºåÊâÄ‰ª•ÊòØË∞ÉÁî®ÁöÑËøô‰∏™ÊñπÊ≥ï„ÄÇ public final void subscribe(Observer&lt;? super T&gt; observer) { ‚Ä¶ } Ëøô‰∏™ÊñπÊ≥ïÊòØÊàë‰ª¨ÈúÄË¶ÅÂàÜÊûêÁöÑÈáçÁÇπÔºåÁúãÁúãÂÜÖÈÉ®ÂÖ∑‰ΩìÁöÑ‰ª£Á†ÅÂêßÂÖàÔºö 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; ËøôÈáåÂøΩÁï• ObjectHelper ÂíåÂºÇÂ∏∏Â§ÑÁêÜÁöÑ‰ª£Á†ÅÂè™Êúâ‰∏§Ë°å‰ª£Á†ÅÊòØÂÖ≥ÈîÆ„ÄÇ ÂÖàÁúã observer = RxJavaPlugins.onSubscribe(this, observer); 1234567public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) &#123; BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe; if (f != null) &#123; return apply(f, source, observer); &#125; return observer;&#125; Ê≤°ÊÉ≥Âà∞ÂïäÊ≤°ÊÉ≥Âà∞Ôºå‰Ω†ËøôÊµìÁúâÂ§ßÁúºÁöÑÂÆ∂‰ºô‰πüÊòØ‰∏Ä‰∏™Èí©Â≠êÊñπÊ≥ï„ÄÇÊâÄ‰ª•ËøôË°å‰ª£Á†ÅÁõ∏ÂΩì‰∫é obsever = observer; Êé•ÁùÄÁúãÔºåsubscribeActual(observer); 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); ËøôÊòØ‰∏Ä‰∏™ÊäΩË±°ÊñπÊ≥ïÔºåÊ≤°Âï•Â•ΩÂàÜÊûêÁöÑ„ÄÇ Êé•‰∏ãÊù•Êàë‰ª¨Ë¶ÅËøõÂÖ•Ê≠£È¢ò‰∫ÜÔºåÊ†πÊçÆÊàë‰ª¨ÁºñÂÜôÁöÑ‰ª£Á†ÅÔºåÊòØ ObservableSubscribeOn Ëøô‰∏™ÂØπË±°Ë∞ÉÁî®‰∫Ü subscribe ÊñπÊ≥ïÔºåÊâÄ‰ª•Êàë‰ª¨ÁúãÁúãËøô‰∏™Á±ªÁöÑ subscribeActual ÊñπÊ≥ï„ÄÇ 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; ËøôÈáåÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØ s Ëøô‰∏™ÂèÇÊï∞ÔºåÂêéÈù¢‰ºöÊúâÂæàÂ§öÂú∞ÊñπÁúãÂà∞Ëøô‰∏™ÂèÇÊï∞Ôºå‰∏ÄÂÆöË¶ÅÊêûÊ∏ÖÊ•öËøô‰∏™ÂèÇÊï∞ÊòØË∞Å‰º†ÈÄíËøáÊù•ÁöÑ„ÄÇÊØîÂ¶ÇËØ¥Ôºö 12A.subscribe(B)ÈÇ£‰πàÔºåÂèÇÊï∞ s Â∞±ÊòØ B„ÄÇ Âú®Êàë‰ª¨ÁöÑ‰ª£Á†Å‰∏≠ÊòØ ObservableSubscribeOn.subscribe(o); ÁêÜËß£‰∫ÜËøô‰∏ÄÁÇπÔºåÊàë‰ª¨ËØ¶ÁªÜÂàÜÊûê‰ª£Á†ÅÈáåÈù¢ÁöÑÂÜÖÂÆπÔºöÈ¶ñÂÖàÂàõÂª∫‰∫Ü‰∏Ä‰∏™ SubscribeOnObserver ÔºàÂ§ßÁ•ûÊïô‰Ω†Ëµ∑Á±ªÂêçÁ≥ªÂàóÂõõÔºâ„ÄÇÁÑ∂ÂêéË∞ÉÁî®‰∫ÜÊàë‰ª¨ÂàõÂª∫ÁöÑÂØπË±° o ÁöÑ onSubscribe ÊñπÊ≥ïÔºö 1234@Overridepublic void onSubscribe(Disposable d) &#123;&#125; Êàë‰ª¨ÁöÑ onSubscribe ÊñπÊ≥ïÈáåÈù¢Âï•ÈÉΩÊ≤°ÂÅö„ÄÇ‰∏çËøá‰∏ÄËà¨Êù•ËØ¥Ôºå‰Ω†Â∫îËØ•Ë∞ÉÁî®‰∏Ä‰∏ã onStart ÊñπÊ≥ï„ÄÇ Êé•‰∏ãÊù•ÊòØË∞ÉÁî® parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); setDisposable ÁöÑÊñπÊ≥ï‰∏çÂΩ±ÂìçÊµÅÁ®ãÂàÜÊûêÔºåËøôÈáåÂ∞±ÂÖàË∑≥Ëøá‰∫ÜÔºåÊúâÂÖ¥Ë∂£ÁöÑÂèØ‰ª•ÁÇπËøõÂéªÁúã‰∏Ä‰∏ã„ÄÇÁÑ∂ÂêéÂ∞±ÊòØ scheduler ÂèòÈáèÔºåËøô‰∏™ÂèòÈáèÂ∞±ÊòØÊàë‰ª¨‰ΩøÁî® subscribeOn ‰º†ÈÄíÁöÑÂèÇÊï∞Ôºö 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; Ëøô‰∏™ scheduler Â∞±ÊòØ Schedulers.computation()„ÄÇÁÑ∂ÂêéË∞ÉÁî®‰∫ÜÂÆÉÁöÑ scheduleDirect ÊñπÊ≥ïÔºö 123public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125; 1234567891011public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); w.schedule(task, delay, unit); return task;&#125; Ëøô‰∏§‰∏™ÊñπÊ≥ïÊòØÁà∂Á±ªÁöÑÔºåSchedulers.computation() ËøîÂõûÁöÑÊòØ‰∏Ä‰∏™ ComputationScheduler ÂØπË±°ÔºåËøôÈáåÊâæÂÖ∑‰ΩìÁöÑÂÆûÁé∞Á±ªÁî±‰∫éË∞ÉÁî®ÈìæÊØîËæÉÈïøÔºåÂ∞±‰∏çÁªôÂá∫‰∫ÜÔºåËá™Â∑±ÁÇπÁùÄÁÇπÁùÄÂ∞±ËÉΩÊâæÂà∞‰∫Ü„ÄÇÁúãÁúã ComputationScheduler ÊúâÊ≤°ÊúâÂ§çÂÜôËøô‰∏§‰∏™ÊñπÊ≥ïÔºö 123456@NonNull@Overridepublic Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) &#123; PoolWorker w = pool.get().getEventLoop(); return w.scheduleDirect(run, delay, unit);&#125; ÂÆÉË¶ÜÁõñ‰∫ÜÁà∂Á±ªÁöÑÁ¨¨2‰∏™ scheduleDirect ÊñπÊ≥ï„ÄÇËøôÈáåÂ∞±‰∏çÊ∑±ÂÖ•ÂàÜÊûêÈáåÈù¢ÁöÑÊ±†‰∫Ü„ÄÇÁúã w.scheduleDirect(run, delay, unit);Ôºö 12345678910111213141516public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; ÁÜüÊÇâÁöÑÁ∫øÁ®ãÊ±†‰ΩøÁî®‰ª£Á†Å„ÄÇÂ∏åÊúõÁúãÂà∞ËøôÈáå‰Ω†ËøòÊ≤°ÊúâÂøòËÆ∞Êàë‰ª¨Ë¶ÅÂàÜÊûêÁöÑÊòØ‰ªÄ‰πà„ÄÇÁÆÄÂçïÁöÑÂΩíÁ∫≥‰∏Ä‰∏ãÔºåÂÖ∂ÂÆûÂ∞±ÊòØÂêëÊàë‰ª¨ÂàõÂª∫ÁöÑ scheduler ÈáåÈù¢Êèê‰∫§‰∫Ü‰∏Ä‰∏™ runnable„ÄÇÊúÄÁªàËøô‰∏™ Runnable ËÇØÂÆö‰ºöÊâßË°åÔºåÈÇ£‰πàÁúãÁúãËøô‰∏™ Runnable ÈáåÈù¢Êúâ‰ªÄ‰πà‰ª£Á†ÅÔºö 1parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); 123456789101112final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; run ÊñπÊ≥ïÈáåÈù¢Â∞±Âè™Êúâ‰∏ÄÂè•‰ª£Á†ÅÔºå‰ΩÜÊòØÊàë‰ª¨ÈúÄË¶ÅÊêûÊ∏ÖÊ•öËøôÈáåÁöÑ source Âíå parent ÂàÜÂà´ÊòØÂì™‰∏™ÂØπË±°„ÄÇ parent ÂèØ‰ª•Áõ¥Êé•ÁúãÂà∞ÊòØ SubscribeOnObserver ÂØπË±°„ÄÇ source ÊòØ‰ΩøÁî®ÁöÑÂ§ñÈÉ®Á±ªÁöÑÂèòÈáè„ÄÇ 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; ËøôÈáåË∞ÉÁî®‰∫Ü super ÊñπÊ≥ïÔºåÊâÄ‰ª•ÊûÑÈÄ†ÂáΩÊï∞Èáå‰º†ÈÄíÁöÑÂèòÈáèÂ∞±ÊòØ source„ÄÇ 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; ËøôÈáåÊòØÊàë‰ª¨‰πãÂâçÂàÜÊûêËøáÁöÑÂàõÂª∫ ObservableSubscribeOn ÁöÑ‰ª£Á†ÅÔºåËøôÈáåÁöÑ this ÊåáÁöÑÊòØ observeOn ÂàõÂª∫ÁöÑ ObservableObserveOn ÂØπË±°„ÄÇÂ∏åÊúõÁúãÂà∞ËøôÈáå‰Ω†Ê≤°ÊúâÊêûÊôïÔºåÂ¶ÇÊûú‰Ω†ÊòØ‰ΩøÁî®ÊâãÊú∫ÁúãÁöÑÔºåÂπ∂‰∏îÁúãÊáÇ‰∫ÜÔºåÊàëÊòØÁúüÁöÑ‰Ω©Êúç„ÄÇ ‰πüÂ∞±ÊòØËØ¥Ôºårun ÈáåÈù¢ÁöÑ‰ª£Á†ÅÂ∞±ÊòØË∞ÉÁî®‰∫Ü ObservableObserveOn ÂØπË±°ÁöÑ subscribe ÊñπÊ≥ï„ÄÇ‰πãÂâçÊàë‰ª¨ÂàÜÊûêËøá‰∫ÜÔºåsubscribe ÊñπÊ≥ïÂÆûÈôÖ‰∏äÊ≤°ÊúâÂÅö‰ªÄ‰πàÔºåÂè™ÊòØË∞ÉÁî®‰∫Ü subscribeActual ÊñπÊ≥ïÔºåÊâÄ‰ª•Êàë‰ª¨ËøõÂÖ•Ëøô‰∏™Á±ªÂÜÖÈÉ®ÁúãÁúãÔºö 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; Êàë‰ª¨Âú® observeOn ‰º†ÈÄíÁöÑ scheduler ‰∏çÊòØ TrampolineScheduler Á±ªÂûãÁöÑÔºåÊâÄ‰ª•Âè™ÈúÄË¶ÅÁúã else ÁöÑ‰ª£Á†Å„ÄÇËøôÈáåÊòØÂÖàÂàõÂª∫‰∫Ü‰∏Ä‰∏™Â∑•‰ΩúÁ∫øÁ®ãÔºàÁî±‰∫éÊàë‰ª¨‰ΩøÁî®ÁöÑÊòØ AndroidSchedulerÔºåÊâÄ‰ª•ËøôÈáåÊòØÊåáÁöÑ‰∏ªÁ∫øÁ®ãÔºâÔºåÁÑ∂ÂêéË∞ÉÁî®‰∫Ü source ÁöÑ subscribe ÊñπÊ≥ï„ÄÇÈúÄË¶ÅÊ≥®ÊÑèÁöÑÊòØËøôÈáåÊúÄÂêéÂàõÂª∫‰∫Ü‰∏Ä‰∏™ ObserveOnObserver ÂØπË±°ÔºàÂ§ßÁ•ûÊïô‰Ω†Ëµ∑Á±ªÂêçÁ≥ªÂàó‰∫îÔºâ„ÄÇ ÂÖàÁúãÁúã createWorkÔºåÂú® HandlerScheduler ‰∏≠Ôºö 1234@Overridepublic Worker createWorker() &#123; return new HandlerWorker(handler);&#125; ËøîÂõû‰∫Ü‰∏Ä‰∏™ HandlerWorker ÂØπË±°„ÄÇ ÂÜçÁúã source.subscribe()ÔºåÈ¶ñÂÖàËøôÈáåÁöÑ source ÊåáÁöÑÊòØ create ÊñπÊ≥ïÂàõÂª∫ÁöÑ ObservableCreate ÂØπË±°ÔºåË∞ÉÁî® subscribe ‰º†ÈÄíÁöÑÊòØ ObserveOnObserver„ÄÇÁúãÁúãËøô‰∏™ÂØπË±°ÁöÑ subscribeActual ÊñπÊ≥ïÔºö 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; ËøôÈáåÁöÑÂèÇÊï∞ observer ÊòØ ObserveOnObserverÔºåsource ÊòØÊàë‰ª¨‰ª£Á†Å‰∏≠ÂàõÂª∫ÁöÑ oos ÂØπË±°„ÄÇ È¶ñÂÖàÂàõÂª∫‰∫Ü‰∏Ä‰∏™ CreateEmitter ÂØπË±°„ÄÇ Êé•ÁùÄÁúã ObserveOnObserver ÁöÑ onSubscribe ÊñπÊ≥ïÂÅö‰∫ÜÂï•Ôºö 12345678910111213141516171819202122232425262728293031@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.validate(this.s, s)) &#123; this.s = s; if (s instanceof QueueDisposable) &#123; @SuppressWarnings("unchecked") QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) &#123; sourceMode = m; queue = qd; done = true; actual.onSubscribe(this); schedule(); return; &#125; if (m == QueueDisposable.ASYNC) &#123; sourceMode = m; queue = qd; actual.onSubscribe(this); return; &#125; &#125; queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); actual.onSubscribe(this); &#125;&#125; ËøôÈáå‰ª£Á†ÅÊØîËæÉÈïøÔºåÂè™ÂàÜÊûêÈáçË¶ÅÁöÑ‰ª£Á†ÅÔºåÂ∞±ÊòØ actual.onSubscribe ËøôÂè•„ÄÇactual ÊòØÊûÑÈÄ†ÂáΩÊï∞‰∏≠ËµãÂÄºÁöÑÔºåÊâÄ‰ª•Êàë‰ª¨ÂõûÂà∞ÂàõÂª∫ ObserveOnObserver ÁöÑÂú∞ÊñπÔºåactual ÊåáÁöÑÊòØ SubscribeOnObserver ÂØπË±°„ÄÇÊâÄ‰ª•ÂÆÉË∞ÉÁî®‰∫Ü SubscribeOnObserver ÁöÑ onSubscribe ÊñπÊ≥ï„ÄÇÊé•‰∏ãÊù•ÂàÜÊûê‰∏Ä‰∏ãÂÆÉÁöÑ onSubscribe ÊñπÊ≥ïÂÅö‰∫Ü‰ªÄ‰πàÔºåËøôÈáå‰∏çÁúã‰πü‰∏ç‰ºöÂΩ±ÂìçÊµÅÁ®ã„ÄÇ 123456789SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; this.s = new AtomicReference&lt;Disposable&gt;();&#125;@Overridepublic void onSubscribe(Disposable s) &#123; DisposableHelper.setOnce(this.s, s);&#125; Ëøô‰∏™ÊñπÊ≥ïË∞ÉÁî®‰∫Ü setOnce ÊñπÊ≥ïÔºö 1234567891011public static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; ObjectHelper.requireNonNull(d, "d is null"); if (!field.compareAndSet(null, d)) &#123; d.dispose(); if (field.get() != DISPOSED) &#123; reportDisposableSet(); &#125; return false; &#125; return true;&#125; ËøôÈáåÊ∂âÂèäÂà∞‰∫Ü‰πêËßÇÈîÅÁ≠âÁé©ÊÑèÔºåÁÆÄÂçïÊù•ËØ¥Â∞±ÊòØÂÖàÂà§Êñ≠ field ÁöÑÂÄºÊòØÂê¶‰∏∫Á©∫ÔºåÂ¶ÇÊûú‰∏∫Á©∫ÂàôËÆæÁΩÆ‰∏∫ dÔºå‰∏ç‰∏∫Á©∫ÂàôÂ∞Ü d dispose„ÄÇÁÑ∂ÂêéÂà§Êñ≠ field ÁöÑÂÄºÔºåÁî±‰∫é field ÁöÑÂÄºÂè™ËÉΩËÆæÂÆö‰∏ÄÊ¨°Èùû DISPOSED ÂÄºÔºåÊâÄ‰ª•Â¶ÇÊûú‰∏ç‰∏∫ DISPOSEDÔºåËØ¥ÊòéÂ∑≤ÁªèË¢´ËÆæÁΩÆËøá‰∫ÜÔºåÂÜçÊä•Âá∫ÂºÇÂ∏∏ÔºåÂ¶ÇÊûú‰∏∫ DISPOSED ÊòØÂèØ‰ª•ÂÜçÊ¨°ËÆæÁΩÆÁöÑ„ÄÇÊåâÁÖßÊ≠£Â∏∏ÁöÑÊµÅÁ®ãÔºåËøôÈáåÂè™ÊòØÂ∞Ü field ÁöÑÂÄºËÆæÁΩÆ‰∏∫ dÔºåÁÑ∂ÂêéËøîÂõûtrue„ÄÇËøô‰∏™ÊñπÊ≥ïÂèØ‰ª•ÂÖà‰∏çÁî®ÁÆ°„ÄÇ ÂõûÂà∞‰∏ªÁ∫øÊµÅÁ®ã‰∏äÔºåsource.subscribe(parent); ËøôÊòØÊúÄÈáçË¶ÅÁöÑ‰∏ÄÂè•‰ª£Á†Å„ÄÇsource ÊòØÂú®ÊûÑÈÄ†ÂáΩÊï∞ËµãÂÄºÁöÑÔºåÁúãÁúãÊûÑÈÄ†ÊñπÊ≥ïÔºö 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ‰πüÂ∞±ÊòØËØ¥ËøôÈáåÁöÑ source ÊòØÊàë‰ª¨‰ª£Á†Å‰∏≠ÂàõÂª∫ÁöÑ oos ÂØπË±°„ÄÇparent ÊòØÊñ∞ÂàõÂª∫ÁöÑ CreateEmitter ÂØπË±°„ÄÇÁúãÁúãÊàë‰ª¨ oos ÁöÑ subscribe ÊñπÊ≥ïÔºö 123456789@Overridepublic void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e("aprz", Thread.currentThread().getName()); final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(i); &#125; e.onComplete();&#125; ËøôÈáåÂ∞±ÊòØ‰∫ã‰ª∂ÂºÄÂßãÁöÑËµ∑ÁÇπ„ÄÇÊâÄÊúâÁöÑ‰∫ã‰ª∂ÈÉΩÁî± ObservableEmitter ÂºÄÂßãÂèëÈÄÅÔºåÁúãÁúãÂÆÉÁöÑ‰ª£Á†ÅÔºåÂÆÉÊòØ‰∏Ä‰∏™Êé•Âè£ÔºåÂú®Êàë‰ª¨ÁöÑ‰æãÂ≠ê‰∏≠ÔºåÂÆÉÁöÑÂÆûÁé∞Á±ªÊòØ CreateEmitterÔºåÊâÄÊúâÊàë‰ª¨ÂàÜÊûêËøô‰∏™Á±ªÁöÑ onNext ÊñπÊ≥ïÔºö 12345678910@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; isDisposed ÊñπÊ≥ïËøîÂõû false Êâç‰ºöÂéªË∞ÉÁî® observer ÁöÑ onNext ÊñπÊ≥ïÔºåËøô‰∏™ observer ÊòØË∞ÅÂë¢? ÁúãÂà∞ËøôÈáåÊàë‰ª¨Â∞±Ë¶Å‰ªéÂêéÂæÄÂâçÊé®‰∏ÄÈÅç‰πãÂâçÁöÑ‰ª£Á†Å‰∫ÜÔºå‰∏çÁÆ°‰Ω†Áªù‰∏çÁªùÊúõÔºåÂèçÊ≠£ÊàëÊòØÂæàÁªùÊúõ„ÄÇËøôÁöÑ observer ÊòØ ObserveOnObserver ÂØπË±°„ÄÇ Êé•‰∏ãÊù•Êàë‰ª¨Â∞±ËøõÂÖ• ObserveOnObserver ÈáåÈù¢ÔºåÁúãÁúãÂÆÉÊé•Âèó‰∫ã‰ª∂‰πãÂêéÂÅö‰∫Ü‰ªÄ‰πàÔºå‰∏äÈù¢ÁöÑÂèÇÊï∞ e Â∞±ÊòØÔºö 1234567891011@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125; Ë∞ÉÁî®‰∫Ü schedule ÊñπÊ≥ïÔºö 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; Âêë work ‰∏≠Êèê‰∫§‰∫Ü‰∏Ä‰∏™ RunnableÔºåËøôÈáå‰º†ÈÄíÁöÑÊòØ this„ÄÇËØ¥ÊòéÂÆÉËá™Â∑±ËÇØÂÆöÂÆûÁé∞‰∫ÜËøô‰∏™Êé•Âè£ÔºåÊàë‰ª¨ÁúãÁúãÂÆÉÁöÑ run ÊñπÊ≥ïÂÅö‰∫ÜÂï•Ôºö 12345678@Overridepublic void run() &#123; if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125; ËøôÈáå‰∏ÄËà¨ÊòØËµ∞ drainNormal ÂêßÔºåÊàëÁåúÁöÑÔºåÊàë‰ª¨ÂàÜÊûêËøô‰∏™ÊñπÊ≥ïÂêß„ÄÇ 1234567891011121314151617181920212223242526272829303132333435363738394041424344void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; ‰ª£Á†ÅÂæàÈïøÔºåÂÖ∑‰ΩìÂÅö‰∫ÜÂï•Êàë‰ª¨ÊöÇÊó∂‰∏çÁî®ÂÖ≥ÂøÉÔºåÂè™ÈúÄË¶ÅÊ≥®ÊÑèÂà∞ a.onNexe(v) ËøôË°å‰ª£Á†ÅÔºåËøô‰∏™ a ÊòØ actual ÂèòÈáèÔºåactual ÂèàÊòØ SubscribeOnObserver ÂØπË±°ÔºåÊàë‰ª¨ÁúãÁúãÂÆÉÁöÑ onNext ÊñπÊ≥ïÔºö 1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; ÂæàÁÆÄÂçïÔºåËøôÈáåÁöÑ actual Â∞±ÊòØÊàë‰ª¨ÂàõÂª∫ÁöÑ o ‰∫ÜÔºåÊâÄ‰ª•ÊúÄÁªàË∞ÉÁî®Âà∞‰∫ÜÊàë‰ª¨ÁöÑ‰ª£Á†ÅÈáåÈù¢„ÄÇ Â•Ω‰∫ÜÔºåÂà∞ËøôÈáå‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÊµÅÁ®ãÂ∞±Êï¥ÁêÜÂá∫Êù•‰∫ÜÔºå‰ΩÜÊòØËøòÊúâ‰∏Ä‰∏™ÈóÆÈ¢òÊ≤°ÊúâËß£ÂÜ≥ÔºåÂ∞±ÊòØÁ∫øÁ®ãÂàáÊç¢ÊòØÂèëÁîüÂú®Âì™Èáå„ÄÇÂõ†‰∏∫‰∏∫‰∫Ü‰∏çÂΩ±ÂìçÊï¥‰ΩìÊµÅÁ®ãÁöÑÂàÜÊûêÔºåÊâÄ‰ª•‰∏äÈù¢Âπ∂Ê≤°ÊúâÂéªÂàÜÊûêÁ∫øÁ®ãÂàáÊç¢ÁöÑ‰∏úË•øÔºå‰∏ãÈù¢ÂºÄÂßãÂàÜÊûê„ÄÇ Áõ¥Êé•‰ªé subscribeOn ÂºÄÂßãÔºåÁúã ObservableSubscribeOn ÁöÑ‰ª£Á†Å 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; ‰ªéËøôÈáåÂºÄÂßãÂ∞±ËøõË°å‰∫ÜÁ∫øÁ®ãÁöÑÂàáÊç¢ÔºåÊ†πÊçÆ‰∏äÈù¢ÁöÑÂàÜÊûêÊàë‰ª¨Áü•ÈÅìËøôÈáåÊòØÂ∞Ü SubscribeTask ‰Ωú‰∏∫‰∏Ä‰∏™ Runnable ÂØπË±°ÁªôÊèê‰∫§Ëøõ‰∫ÜÊàë‰ª¨ÊåáÂÆöÁöÑ scheduler ÔºàsubscribeOn ‰º†ÈÄíÁöÑÔºâ‰∏≠„ÄÇÊâÄ‰ª•ÂêéÈù¢ÁöÑÊµÅÁ®ãÈÉΩÊòØÂú® scheduler ÊâÄÂú®ÁöÑÁ∫øÁ®ãÂú®ËøêË°å„ÄÇ ÂÜçÁúã observeOnÔºåÁúã ObservableObserveOn ÁöÑ‰ª£Á†Å„ÄÇ 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; ËøôÈáåÁöÑÁ∫øÁ®ãÂàáÊç¢ÊòØÂèëÁîüÂú® ObserveOnObserver Ëøô‰∏™ÂØπË±°ÁöÑÈáåÈù¢„ÄÇ 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; schedule ÁöÑÊµÅÁ®ãÔºåÊàë‰ª¨‰∏äÈù¢ÂàÜÊûêËøáÔºåworker.schedule(this) ËøôË°å‰ª£Á†ÅÂ∞±ÂèëÁîü‰∫ÜÁ∫øÁ®ãÂàáÊç¢ÔºåÊòØÂ∞Ü this ‰Ωú‰∏∫ Runnable ÂØπË±°Êèê‰∫§Âà∞‰∫ÜÊàë‰ª¨ÊåáÂÆöÁöÑÔºàobserverOn ‰º†ÈÄíÁöÑÔºâscheduler ‰∏≠„ÄÇÂÖ∑‰ΩìÂàÜÊûêÔºåÁî±‰∫é‰πãÂâçÁöÑÊµÅÁ®ãÊòØÂú®Âà´ÁöÑÁ∫øÁ®ã‰∏≠ÔºåÊâÄ‰ª•ÊÉ≥Ë¶ÅËøõË°åÁ∫øÁ®ãÂàáÊç¢ÔºåÊúÄÂÖàÊÉ≥Âà∞ÁöÑËÇØÂÆöÊòØ Handler„ÄÇÁî±‰∫éÊàë‰ª¨‰º†ÈÄíÁöÑÊòØ AndroidSchedulers.mainThread()ÔºåÊâÄ‰ª•Êàë‰ª¨Â∞±ÂàÜÊûêËøô‰∏™Âêß„ÄÇ AndroidSchedulers.mainThread() ÁöÑÂÆûÁé∞ÊòØ HandlerScheduler„ÄÇÁúãÁúãÂÆÉÁöÑ schedule ÊñπÊ≥ïÔºö 1234567891011121314151617181920212223242526@Overridepublic Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; if (run == null) throw new NullPointerException("run == null"); if (unit == null) throw new NullPointerException("unit == null"); if (disposed) &#123; return Disposables.disposed(); &#125; run = RxJavaPlugins.onSchedule(run); ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker's runnables. handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) &#123; handler.removeCallbacks(scheduled); return Disposables.disposed(); &#125; return scheduled;&#125; post ‰∫Ü‰∏Ä‰∏™ msgÔºåËøôÊ†∑Â∞±ÂÆåÊàê‰∫ÜÁ∫øÁ®ãÁöÑÂàáÊç¢„ÄÇ ‰∏ãÈù¢‰∏ä‰∏ÄÂº†ÂõæÔºåÊúâÂä©‰∫éÁêÜËß£ÂíåËÆ∞ÂøÜÔºö Âõæ‰∏≠ÁÆ≠Â§¥ÁöÑÊñπÂêë‰∏∫‰∫ã‰ª∂‰º†Êí≠ÁöÑÊñπÂêëÔºåÂ¶ÇÊûúÂÆö‰πâÊñπÊ≥ïË∞ÉÁî®ÁöÑÊñπÂêë‰∏∫È°∫Â∫èÔºåÈÇ£‰πàÂΩìË∞ÉÁî®observable.subscribe(observer)ÁöÑÊó∂ÂÄôÔºå‚ö†Ô∏èËÆ¢ÈòÖsubscribeÈ°∫Â∫èÊòØ‰ªé‰∏ãÊ∏∏ÂõûÊ∫ØÂà∞‰∏äÊ∏∏ÔºåÁÑ∂Âêé‰∏äÊ∏∏‰∫ßÁîü‰∫ã‰ª∂Âπ∂ÂèëÈÄÅÔºå‰∫ã‰ª∂ÂÜç‰º†ËæìÂà∞‰∏ãÊ∏∏„ÄÇ ÊØèÊ¨°ÊâßË°å observerOn Âíå subscribeOn ÁöÑÊó∂ÂÄôÔºåÂÜÖÈÉ®ÈÉΩ‰ºöÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑ Observable Âíå ObserverÂØπË±°„ÄÇ ‰∏ãÊ∏∏ÁöÑobservable ‰ºöÂºïÁî®‰∏äÊ∏∏ÁöÑ observableÔºåÂç≥ source ÂèòÈáè„ÄÇ ‰∏äÊ∏∏ÁöÑobserver ‰ºöÂºïÁî®‰∏ãÊ∏∏ÁöÑ observerÔºåÂç≥ actual ÂèòÈáè„ÄÇ Â§öÊ¨°ÊåáÂÆö‰∏äÊ∏∏ÁöÑÁ∫øÁ®ãÂè™ÊúâÁ¨¨‰∏ÄÊ¨°ÊåáÂÆöÁöÑÊúâÊïà, ‰πüÂ∞±ÊòØËØ¥Â§öÊ¨°Ë∞ÉÁî®subscribeOn() Âè™ÊúâÁ¨¨‰∏ÄÊ¨°ÁöÑÊúâÊïà, ÂÖ∂‰ΩôÁöÑ‰ºöË¢´ÂøΩÁï•„ÄÇÂõ†‰∏∫Ë¢´ËßÇÂØüËÄÖÂèëÈÄÅ‰∫ã‰ª∂Âú®ÊâÄÊúâ‰∏äÊ∏∏Á∫øÁ®ãÂàáÊç¢ÂÆåÊàê‰πãÂêéÊâçÊâßË°å„ÄÇ Â§öÊ¨°ÊåáÂÆö‰∏ãÊ∏∏ÁöÑÁ∫øÁ®ãÊòØÂèØ‰ª•ÁöÑ, ‰πüÂ∞±ÊòØËØ¥ÊØèË∞ÉÁî®‰∏ÄÊ¨°observeOn() , ‰∏ãÊ∏∏ÁöÑÁ∫øÁ®ãÂ∞±‰ºöÂàáÊç¢‰∏ÄÊ¨°„ÄÇÂõ†‰∏∫Êé•Âèó‰∫ã‰ª∂Âú®ÊØè‰∏™ObserveOnObserverÂØπË±°ÁöÑonNext‰∏≠ÈÉΩ‰ºöÂàáÊç¢‰∏ÄÊ¨°„ÄÇ ÊúÄÂêéÊàë‰ª¨ subscribe ÁöÑÊó∂ÂÄôÔºåÊòØË∞ÉÁî®ÁöÑÊúÄÂêéÂàõÂª∫ÁöÑ observable ÁöÑÊñπÊ≥ï„ÄÇËÄåÊØè‰∏™ observable ÂÜÖÈÉ®ÂèàË∞ÉÁî®‰∫Ü source ÁöÑ subscribe ÊñπÊ≥ïÔºåËøôÊ†∑Â∞±ÂΩ¢Êàê‰∫Ü‰∏ÄÂ±Ç‰∏ÄÂ±ÇÂæÄ‰∏ä‰º†ÈÄíÁöÑË∞ÉÁî®Èìæ„ÄÇÂΩìË∞ÉÁî®Âà∞ÊúÄÂâçÈù¢ÁöÑ‰∏Ä‰∏™ observable ÁöÑÊó∂ÂÄôÔºåÂ∞±ÊòØÊàë‰ª¨Ëá™Â∑±ÂàõÂª∫ÁöÑ source ObservableÔºåÂú®ËøôÈáåÊàë‰ª¨ÈúÄË¶ÅÊâãÂä®Ëß¶ÂèëËØ•‰∏éËØ• observable ÂØπÂ∫îÁöÑ observer ÂØπË±°ÁöÑ onNext ÊñπÊ≥ï„ÄÇËÄå observer ÁöÑ onNext ÊñπÊ≥ïÁöÑÂÜÖÈÉ®ÂèàË∞ÉÁî®‰∫Ü actual ÁöÑ onNext ÊñπÊ≥ïÔºåËøôÊ†∑Â∞±ÂΩ¢Êàê‰∫Ü‰∏ÄÂ±Ç‰∏ÄÂ±ÇÂæÄÂêé‰º†ÈÄíÁöÑË∞ÉÁî®Èìæ„ÄÇ ËôΩÁÑ∂Âú®Êàë‰ª¨ÁöÑ‰æãÂ≠ê‰∏≠ÔºåCreateEmitter Âπ∂‰∏çÊòØ‰∏Ä‰∏™ observer Ôºå‰ΩÜÊòØÂÆÉ‰πüÊúâ onNext Á≠âÊñπÊ≥ïÔºåÂèØ‰ª•ÊääÂÆÉÁúãÂÅö‰∏Ä‰∏™ observer„ÄÇ Â¶ÇÊ≠§ÔºåRxJava ÁöÑ‰∏Ä‰∏™ÊµÅÁ®ãÂ∞±ÁêÜÊ∏ÖÊ•ö‰∫Ü„ÄÇËøôË¥ßÁöÑÊµÅÁ®ãÂíå OkHttp ÊÄé‰πàÊúâÁÇπÂÉèÔºåÂè™ÊòØÁ®çÂæÆÊúâÁÇπ‰∏ç‰∏ÄÊ†∑„ÄÇ Ë°•ÂÖÖ‰∏Ä‰∏ãÂÖ≥‰∫éËÉåÂéãÁöÑÁü•ËØÜÔºöÂú®ÂºÇÊ≠•ËÆ¢ÈòÖÁöÑÊó∂ÂÄôÔºå‰ΩøÁî® ObservableÔºåÈªòËÆ§ÁöÑÁºìÂÜ≤Â§ßÂ∞èÊòØ 128ÔºåË∂ÖËøá Ëøô‰∏™Êï∞Èáè‰πãÂêé‰ºö resizeÔºå‰πüÂ∞±ÊòØËØ¥‰ºöÁºìÂÜ≤ÊâÄÊúâÁöÑ‰∫ã‰ª∂ÔºåËøôÊ†∑Â∞±‰ºöÂØºËá¥ÂÜÖÂ≠òÂç†Áî®‰∏ÄÁõ¥Â¢ûÂä†„ÄÇ]]></content>
      <categories>
        <category>ÊãÜËΩÆÂ≠ê</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁêÜËß£WindowÂíåWindowManager]]></title>
    <url>%2F2018%2F03%2F06%2F%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager%2F</url>
    <content type="text"><![CDATA[WindowË°®Á§∫‰∏Ä‰∏™Á™óÂè£ÁöÑÊ¶ÇÂøµ, Â¶ÇÊúâÈúÄË¶ÅÂú®Ê°åÈù¢‰∏äÊòæÁ§∫‰∏Ä‰∏™Á±ª‰ººÊÇ¨ÊµÆÁ™óÁöÑ‰∏úË•ø, ÈÇ£‰πàËøôÁßçÊïàÊûúÂ∞±ÈúÄË¶ÅWindowÊù•ÂÆûÁé∞. WindowÊòØ‰∏Ä‰∏™ÊäΩË±°Á±ª, ÂÖ∑‰ΩìÂÆûÁé∞ÊòØPhoneWindow. Â¶ÇÊûúÊÉ≥Ë¶ÅÂàõÂª∫‰∏Ä‰∏™WindowÂè™ÈúÄË¶ÅÈÄöËøáWindowManagerÂç≥ÂèØÂÆåÊàê. WindowManagerÊòØÂ§ñÁïåËÆøÈóÆWindowÁöÑÂÖ•Âè£, WindowÂÖ∑‰ΩìÂÆûÁé∞‰Ωç‰∫éWindowManagerService‰∏≠, WMÂíåWMSÁöÑ‰∫§‰∫íÊòØ‰∏Ä‰∏™IPCËøáÁ®ã. Android‰∏≠ÊâÄÊúâÁöÑËßÜÂõæÈÉΩÊòØÈÄöËøáWindowÊù•ÂëàÁé∞ÁöÑ, ‰∏çÁÆ°ÊòØActivity, Dialog, Toast‰ªñ‰ª¨ÁöÑËßÜÂõæÂÆûÈôÖ‰∏äÈÉΩÊòØÈôÑÂä†Âú®Window‰∏äÁöÑ. WindowÂíåWindowManagerÂÖàÊºîÁ§∫‰ΩøÁî®WindowMangerÊ∑ªÂä†‰∏Ä‰∏™Window. 1234567891011121314151617public void addWindow()&#123; Button button = new Button(this); button.setText("Âä®ÊÄÅÊ∑ªÂä†"); WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT); layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED; layoutParams.gravity = Gravity.LEFT | Gravity.TOP; layoutParams.x = 100; layoutParams.y = 300; getWindowManager().addView(button, layoutParams); &#125; ‚Äã FlagÂèÇÊï∞Ë°®Á§∫WindowÁöÑÂ±ûÊÄß,Ëøô‰∫õÂ±ûÊÄßÂèØ‰ª•ÊéßÂà∂WindowÁöÑÊòæÁ§∫ÁâπÊÄß. ‰∏ãÈù¢ÊòØÂ∏∏Áî®ÁöÑÂ±ûÊÄß: FLAG_NOT_FOCUSABLE: Ë°®Á§∫Window‰∏çÈúÄË¶ÅËé∑ÂèñÁÑ¶ÁÇπ, ËÄå‰∏çÈúÄË¶ÅÊé•Êî∂ÂêÑÁßçËæìÂÖ•‰∫ã‰ª∂, Ê≠§Ê†áËÆ∞‰ºöÂêåÊó∂ÂêØÂä®FLAG_NOT_TOUCH_MODAL, ÊúÄÁªà‰∫ã‰ª∂‰ºöÁõ¥Êé•‰º†ÈÄíÁªô‰∏ãÂ±ÇÁöÑÂÖ∑ÊúâÁÑ¶ÁÇπÁöÑWindow. FLAG_NOT_TOUCH_MODAL: ËøôÁßçÊ®°Âºè‰∏ã, Á≥ªÁªü‰ºöÂ∞ÜÂΩìÂâçWindowÂå∫Âüü‰ª•Â§ñÁöÑÁÇπÂáª‰∫ã‰ª∂‰º†ÈÄíÁªôÂ∫ïÂ±ÇÁöÑWindow, ÂΩìÂâçWindowÂå∫Âüü‰ª•ÂÜÖÁöÑÂçïÂáª‰∫ã‰ª∂ÂàôËá™Â∑±Â§ÑÁêÜ. Ëøô‰∏™Ê†áËÆ∞ÂæàÈáçË¶Å, ‰∏ÄËà¨Êù•ËØ¥ÈÉΩÈúÄË¶ÅÂºÄÂêØÊ≠§Ê†áËÆ∞, Âê¶ÂàôÂÖ∂‰ªñWindowÂ∞ÜÊó†Ê≥ïÊé•Êî∂Âà∞ÂçïÂáª‰∫ã‰ª∂. FLAG_SHOW_WHEN_LOCKED: ÂºÄÂêØÊ≠§Ê®°ÂºèÂèØ‰ª•ËÆ©WindowÊòæÁ§∫Âú®ÈîÅÂ±èÁöÑÁïåÈù¢‰∏ä. TypeÂèÇÊï∞Ë°®Á§∫WindowÁöÑÁ±ªÂûã WindowÂÖ±Êúâ‰∏âÁßçÁ±ªÂûã, ÂàÜÂà´ÊòØÂ∫îÁî®Window, Â≠êWindow, Á≥ªÁªüWindow. Â∫îÁî®Á±ªWindowÂØπÂ∫îÁùÄ‰∏Ä‰∏™Activity. Â≠êWindow‰∏çËÉΩÂçïÁã¨Â≠òÂú®, ‰ªñÈúÄË¶ÅÈôÑÂ±ûÂú®ÁâπÂÆöÁöÑÁà∂Window‰∏≠,ÊØîÂ¶ÇÂ∏∏ËßÅÁöÑDialogÂ∞±ÊòØ‰∏Ä‰∏™Â≠êWindow. Á≥ªÁªüWindowÊòØÈúÄË¶ÅÂ£∞ÊòéÊùÉÈôêÊâçËÉΩÂàõÂª∫ÁöÑWindow, ÊØîÂ¶ÇToastÂíåÁ≥ªÁªüÁä∂ÊÄÅÊ†èÈÉΩÊòØÁ≥ªÁªüÁöÑWindow. WindowÊòØÂàÜÂ±ÇÁöÑ, ÊØè‰∏™WindowÈÉΩÊúâÂØπÂ∫îÁöÑz-ordered, Â±ÇÁ∫ßÂ§ßÁöÑ‰ºöË¶ÜÁõñÂú®Â±ÇÁ∫ßÂ∞èÁöÑWindowÁöÑ‰∏äÈù¢, ËøôÂíåHTML‰∏≠ÁöÑz-indexÁöÑÊ¶ÇÂøµ‰∏ÄÊ†∑. Â∫îÁî®WindowÁöÑÂ±ÇÁ∫ßËåÉÂõ¥ÊòØ1~99, Â≠êWindowÁöÑÂ±ÇÁ∫ßËåÉÂõ¥ÊòØ1000~1999, Á≥ªÁªüWindowÁöÑÂ±ÇÁ∫ßËåÉÂõ¥ÊòØ2000~2999. Â¶ÇÊûúÊÉ≥Ë¶ÅÂú®ÊúÄÈ°∂Â±ÇÊòæÁ§∫, ÂèØ‰ª•ÈÄâÊã©‰ΩøÁî®TYPE_SYSTEM_OVERLAY, TYPE_SYSTEM_ERROR. Â¶ÇÊûúÈááÁî®‰∫ÜTYPE_SYSTEM_ERRORÂêåÊó∂Ë¶ÅÂ£∞ÊòéÊùÉÈôê: 1&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; Â¶ÇÊûú‰∏çÂ£∞ÊòéÈÇ£‰πàÂú®ÂàõÂª∫ÁöÑÊó∂ÂÄôÂ∞±‰ºöÊä•Èîô. WindowManagerÂ∏∏Áî®ÁöÑÂäüËÉΩ Âú®ViewManagerÊé•Âè£‰∏≠ÂÆö‰πâ‰∫Ü‰∏â‰∏™ÊñπÊ≥ï. Â∞±ÊòØÊàë‰ª¨Â∏∏Áî®ÁöÑÊñπÊ≥ïÊ∑ªÂä†View,Âà†Èô§View,‰øÆÊîπView. WMÁªßÊâø‰∫ÜËøô‰∏™Êé•Âè£. 12345public interface ViewManager &#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; WindowÁöÑÂÜÖÈÉ®Êú∫Âà∂WindowÊòØ‰∏Ä‰∏™ÊäΩË±°ÁöÑÊ¶ÇÂøµ, ÊØè‰∏ÄWindowÈÉΩÂØπÂ∫îÁùÄ‰∏Ä‰∏™ViewÂíå‰∏Ä‰∏™ViewRootImpl, WindowÂíåViewÈÄöËøáViewRootImplÊù•Âª∫Á´ãËÅîÁ≥ª, Âõ†Ê≠§WindowÂπ∂‰∏çÊòØÂÆûÈôÖÂ≠òÂú®ÁöÑ, ‰ªñÊòØ‰ª•ViewÁöÑÂΩ¢ÂºèÂ≠òÂú®. ÈÄöËøáWindowManagerÁöÑÂÆö‰πâÂíåÊèê‰æõÁöÑ‰∏â‰∏™Êé•Âè£ÊñπÊ≥ïÁúãÂá∫ÈÉΩÊòØÈíàÂØπViewÁöÑ. ËØ¥ÊòéViewÊâçÊòØWindowÂ≠òÂú®ÁöÑÂÆû‰Ωì. ËÄåÂú®ÂÆûÈôÖÁöÑ‰ΩøÁî®‰∏≠Êó†Ê≥ïÁõ¥Êé•ËÆøÈóÆWindow, ÂØπWindowÁöÑËÆøÈóÆÈÉΩÊòØÂøÖÈ°ªÈÄöËøáWM. WindowÁöÑÊ∑ªÂä†ËøáÁ®ãWindowÁöÑÊ∑ªÂä†ËøáÁ®ãÈúÄË¶ÅÈÄöËøáWindowManagerÁöÑaddView()Êù•ÂÆûÁé∞, ËÄåWindowManagerÊòØ‰∏Ä‰∏™Êé•Âè£, ÂÆÉÁöÑÁúüÊ≠£ÂÆûÁé∞ÊòØWindowManagerImplÁ±ª, Âú®WindowManagerImpl‰∏≠WindowÁöÑ‰∏âÂ§ßÊìç‰ΩúÂ¶Ç‰∏ã. 1234567891011121314151617@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow);&#125;@Overridepublic void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params);&#125; @Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; WindowManagerImplÂπ∂Ê≤°ÊúâÁõ¥Êé•ÂÆûÁé∞WindowÁöÑ‰∏âÂ§ßÊìç‰Ωú, ËÄåÊòØÂÖ®ÈÉ®‰∫§Áªô‰∫ÜWindowManagerGlobalÊù•Â§ÑÁêÜ. WindowManagerGlobal‰ª•Â∑•ÂéÇÁöÑÂΩ¢ÂºèÂêëÂ§ñÊèê‰æõËá™Â∑±ÁöÑÂÆû‰æã. ËÄåWindowManagerImplËøôÁßçÂ∑•‰ΩúÊ®°ÂºèÂ∞±ÂÖ∏ÂûãÁöÑÊ°•Êé•Ê®°Âºè, Â∞ÜÊâÄÊúâÁöÑÊìç‰ΩúÂÖ®ÈÉ®ÂßîÊâòÁªôWindowManagerGlobalÊù•ÂÆûÁé∞. WindowManagerGlobalÁöÑaddView()‰∏ªË¶ÅÂàÜ‰∏∫ Ê£ÄÊü•ÊâÄÊúâÂèÇÊï∞ÊòØÂê¶ÂêàÊ≥ï, Â¶ÇÊûúÊòØÂ≠êWindowÈÇ£‰πàËøòÈúÄË¶ÅË∞ÉÊï¥‰∏Ä‰∫õÂ∏ÉÂ±ÄÂèÇÊï∞. ÂàõÂª∫ViewRootImplÂπ∂Â∞ÜViewÊ∑ªÂä†Âà∞ÂàóË°®‰∏≠. ÈÄöËøáViewRootImplÊù•Êõ¥Êñ∞ÁïåÈù¢Âπ∂ÂÆåÊàêWindowÁöÑÊ∑ªÂä†ËøáÁ®ã. Ëøô‰∏™ËøáÁ®ãÊòØÈÄöËøáViewRootImpl#setView()Êù•ÂÆåÊàêÁöÑ. ViewÁöÑÁªòÂà∂ËøáÁ®ãÊòØÁî±ViewRootImplÊù•ÂÆåÊàêÁöÑ, Âú®ÂÜÖÈÉ®‰ºöË∞ÉÁî®requestLayout()Êù•ÂÆåÊàêÂºÇÊ≠•Âà∑Êñ∞ËØ∑Ê±Ç. ËÄåscheduleTraversals()ÂÆûÈôÖ‰∏äÊòØViewÁªòÂà∂ÁöÑÂÖ•Âè£. Êé•ÁùÄ‰ºöÈÄöËøáWindowSession(‰∏Ä‰∏™BinderÂØπË±°ÔºåÂÆûÁé∞Á±ªÊòØSession)ÂÆåÊàêWindowÁöÑÊ∑ªÂä†ËøáÁ®ã(WindowÁöÑÊ∑ªÂä†ËøáÁ®ãÊòØ‰∏ÄÊ¨°IPCË∞ÉÁî®). ÊúÄÁªà‰ºöÈÄöËøáWindowManagerServiceÊù•ÂÆûÁé∞WindowÁöÑÊ∑ªÂä†. WindowManagerServiceÂÜÖÈÉ®‰ºö‰∏∫ÊØè‰∏Ä‰∏™Â∫îÁî®‰øùÁïô‰∏Ä‰∏™ÂçïÁã¨ÁöÑSession. WindowÁöÑÂà†Èô§ËøáÁ®ãWindow ÁöÑÂà†Èô§ËøáÁ®ãÂíåÊ∑ªÂä†ËøáÁ®ã‰∏ÄÊ†∑, ÈÉΩÊòØÂÖàÈÄöËøáWindowManagerImplÂêé, Âú®Ëøõ‰∏ÄÊ≠•ÈÄöËøáWindowManagerGlobalÁöÑremoveView()Êù•ÂÆûÁé∞ÁöÑ. 123456789101112public void removeView(View view, boolean immediate) &#123; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException("Calling with view " + view + " but the ViewAncestor is attached to " + curView); &#125;&#125; ÊñπÊ≥ïÂÜÖÈ¶ñÂÖàÈÄöËøáfindViewLockedÊù•Êü•ÊâæÂæÖÂà†Èô§ÁöÑViewÁöÑÁ¥¢Âºï, Ëøô‰∏™ËøáÁ®ãÂ∞±ÊòØÂª∫Á´ãÊï∞ÁªÑÈÅçÂéÜ, ÁÑ∂ÂêéË∞ÉÁî®removeViewLockedÊù•ÂÅöËøõ‰∏ÄÊ≠•ÁöÑÂà†Èô§. 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125;&#125; ËøôÈáåÈÄöËøáViewRootImplÁöÑdie()ÂÆåÊàêÊù•ÂÆåÊàêÂà†Èô§Êìç‰Ωú. die()ÊñπÊ≥ïÂè™ÊòØÂèëÈÄÅ‰∫ÜËØ∑Ê±ÇÂà†Èô§ÁöÑÊ∂àÊÅØÂêéÂ∞±Á´ãÂàªËøîÂõû‰∫Ü, Ëøô‰∏™Êó∂ÂÄôViewÂπ∂Ê≤°ÊúâÂÆåÊàêÂà†Èô§Êìç‰Ωú, ÊâÄ‰ª•ÊúÄÂêé‰ºöÂ∞ÜÂÖ∂Ê∑ªÂä†Âà∞mDyingViews‰∏≠, mDyingViewsË°®Á§∫ÂæÖÂà†Èô§ÁöÑViewÁöÑÂàóË°®. 1234567891011121314151617boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(TAG, "Attempting to destroy the window while drawing!\n" + " window=" + this + ", title=" + mWindowAttributes.getTitle()); &#125; mHandler.sendEmptyMessage(MSG_DIE); return true;&#125; dieÊñπÊ≥ï‰∏≠Âè™ÊòØÂÅö‰∫ÜÁÆÄÂçïÁöÑÂà§Êñ≠, Â¶ÇÊûúÊòØÂºÇÊ≠•Âà†Èô§ÈÇ£‰πàÂ∞±ÂèëÈÄÅ‰∏Ä‰∏™MSG_DIEÁöÑÊ∂àÊÅØ, ViewRootImpl‰∏≠ÁöÑHandler‰ºöÂ§ÑÁêÜÊ≠§Ê∂àÊÅØÂπ∂Ë∞ÉÁî®doDie(); Â¶ÇÊûúÊòØÂêåÊ≠•Âà†Èô§, ÈÇ£‰πàÂ∞±‰∏çÂèëÈÄÅÊ∂àÊÅØÁõ¥Êé•Ë∞ÉÁî®doDie()ÊñπÊ≥ï. Âú®doDie()ÊñπÊ≥ï‰∏≠‰ºöË∞ÉÁî®dispatchDetachedFromWindow()ÊñπÊ≥ï, ÁúüÊ≠£Âà†Èô§ViewÁöÑÈÄªËæëÂú®Ëøô‰∏™ÊñπÊ≥ïÂÜÖÈÉ®ÂÆûÁé∞. ÂÖ∂‰∏≠‰∏ªË¶ÅÂÅö‰∫ÜÂõõ‰ª∂‰∫ã: ÂûÉÂúæÂõûÊî∂ÁöÑÁõ∏ÂÖ≥Â∑•‰Ωú, ÊØîÂ¶ÇÊ∏ÖÈô§Êï∞ÊçÆÂíåÊ∂àÊÅØ,ÁßªÈô§ÂõûË∞É. ÈÄöËøáSessionÁöÑremoveÊñπÊ≥ïÂà†Èô§Window: mWindowSession.remove(mWindow), ËøôÂêåÊ†∑ÊòØ‰∏Ä‰∏™IPCËøáÁ®ã, ÊúÄÁªà‰ºöË∞ÉÁî®WMSÁöÑremoveWindow()ÊñπÊ≥ï. Ë∞ÉÁî®ViewÁöÑdispatchDetachedFromWindow()ÊñπÊ≥ï, ÂÜÖÈÉ®‰ºöË∞ÉÁî®ViewÁöÑonDetachedFromWindow()‰ª•ÂèäonDetachedFromWindowInternal(). ËÄåÂØπ‰∫éonDetachedFromWindow()Â∞±ÊòØÂú®View‰ªéWindow‰∏≠ÁßªÈô§Êó∂, Ëøô‰∏™ÊñπÊ≥ïÂ∞±‰ºöË¢´Ë∞ÉÁî®, ÂèØ‰ª•Âú®Ëøô‰∏™ÊñπÊ≥ïÂÜÖÈÉ®ÂÅö‰∏Ä‰∫õËµÑÊ∫êÂõûÊî∂ÁöÑÂ∑•‰Ωú. ÊØîÂ¶ÇÂÅúÊ≠¢Âä®Áîª,ÂÅúÊ≠¢Á∫øÁ®ã„ÄÇ Ë∞ÉÁî®WindowManagerGlobal#doRemoveViewÊñπÊ≥ïÂà∑Êñ∞Êï∞ÊçÆ, ÂåÖÊã¨mRoots, mParams, mDyingViews, ÈúÄË¶ÅÂ∞ÜÂΩìÂâçWindowÊâÄÂÖ≥ËÅîÁöÑËøô‰∏âÁ±ªÂØπË±°‰ªéÂàóË°®‰∏≠Âà†Èô§„ÄÇ WindowÁöÑÊõ¥Êñ∞ËøáÁ®ãWindowManagerGlobal#updateViewLayout()ÊñπÊ≥ïÂÅöÁöÑÊØîËæÉÁÆÄÂçï, ÂÆÉÈúÄË¶ÅÊõ¥Êñ∞ViewÁöÑLayoutParamsÂπ∂ÊõøÊç¢ÊéâËÄÅÁöÑLayoutParams, Êé•ÁùÄÊõ¥Êñ∞ViewRootImpl‰∏≠ÁöÑLayoutParams. Ëøô‰∏ÄÊ≠•‰∏ªË¶ÅÊòØÈÄöËøásetLayoutParams()ÊñπÊ≥ïÂÆûÁé∞. 12345678910111213141516171819public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if(view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if(!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized(mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); root.setLayoutParams(wparams, false); &#125;&#125; Âú®ViewRootImpl‰∏≠‰ºöÈÄöËøáscheduleTraversals()Êù•ÂØπViewÈáçÊñ∞Â∏ÉÂ±Ä, ÂåÖÊã¨ÊµãÈáè,Â∏ÉÂ±Ä,ÈáçÁªò. Èô§‰∫ÜViewÊú¨Ë∫´ÁöÑÈáçÁªò‰ª•Â§ñ, ViewRootImplËøò‰ºöÈÄöËøáWindowSessionÊù•Êõ¥Êñ∞WindowÁöÑËßÜÂõæ, Ëøô‰∏™ËøáÁ®ãÊúÄÂêéÁî±WMSÁöÑrelayoutWindow()ÂÆûÁé∞ÔºåÂêåÊ†∑ÊòØ‰∏Ä‰∏™IPCËøáÁ®ã. WindowÁöÑÂàõÂª∫ËøáÁ®ãViewÊòØAndroid‰∏≠ËßÜÂõæÁöÑÂëàÁé∞ÊñπÂºè, ‰ΩÜÊòØView‰∏çËÉΩÂçïÁã¨Â≠òÂú®, ÂÆÉÂøÖÈ°ª‰æùÈôÑÂú®WindowËøô‰∏™ÊäΩË±°ÁöÑÊ¶ÇÂøµ‰∏äÈù¢, ÊúâËßÜÂõæÁöÑÂú∞ÊñπÂ∞±ÊúâWindow,Âõ†Ê≠§Activity„ÄÅDialog„ÄÅToastÁ≠âËßÜÂõæÈÉΩÂØπÂ∫îÁùÄ‰∏Ä‰∏™Window„ÄÇ ActivityÁöÑWindowÂàõÂª∫ËøáÁ®ãActivityÁöÑÂ§ß‰ΩìÂêØÂä®ÊµÅÁ®ã: ÊúÄÁªà‰ºöÁî±ActivityThread‰∏≠ÁöÑPerformLaunchActivity()Êù•ÂÆåÊàêÊï¥‰∏™ÂêØÂä®ËøáÁ®ã, Ëøô‰∏™ÊñπÊ≥ïÂÜÖÈÉ®‰ºöÈÄöËøáÁ±ªÂä†ËΩΩÂô®ÂàõÂª∫ActivityÁöÑÂÆû‰æãÂØπË±°, Âπ∂Ë∞ÉÁî®ÂÖ∂attach()ÊñπÊ≥ï‰∏∫ÂÖ∂ÂÖ≥ËÅîËøêË°åËøáÁ®ã‰∏≠ÊâÄ‰æùËµñÁöÑ‰∏ÄÁ≥ªÂàó‰∏ä‰∏ãÊñáÁéØÂ¢ÉÂèòÈáè. ‰ª£Á†ÅÂ¶Ç‰∏ã: 1234567891011121314151617181920private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity activity = null; //Ëé∑ÂæóÁ±ªÂä†ËΩΩÂô® java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); ... Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); return activity;&#125; Âú®attach()ÊñπÊ≥ïÈáå, Á≥ªÁªü‰ºöÂàõÂª∫ActivityÊâÄÂ±ûÁöÑWindowÂØπË±°Âπ∂‰∏∫ÂÖ∂ËÆæÁΩÆÂõûË∞ÉÊé•Âè£, WindowÂØπË±°ÁöÑÂàõÂª∫ÊòØÈÄöËøáPolicyManager#makeNewWindow()ÊñπÊ≥ïÂÆûÁé∞. Áî±‰∫éActivityÂÆûÁé∞‰∫ÜWindowÁöÑCallBackÊé•Âè£, Âõ†Ê≠§ÂΩìWindowÊé•Êî∂Âà∞Â§ñÁïåÁöÑÁä∂ÊÄÅÊîπÂèòÁöÑÊó∂ÂÄôÂ∞±‰ºöÂõûË∞ÉActivityÊñπÊ≥ï. ÊØîÂ¶ÇËØ¥Êàë‰ª¨ÁÜüÊÇâÁöÑonAttachedToWindow(), onDetachedFromWindow(), dispatchTouchEvent()Á≠âÁ≠â.‰ª£Á†ÅÂ¶Ç‰∏ã 1234567891011mWindow = new PhoneWindow(this);mWindow.setCallback(this);mWindow.setOnWindowDismissedCallback(this);mWindow.getLayoutInflater().setPrivateFactory(this);if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode);&#125;if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions);&#125;mUiThread = Thread.currentThread(); ÈÇ£‰πàActivityËßÜÂõæÊòØÊÄé‰πàÈôÑÂ±ûÂú®Window‰∏äÁöÑÂë¢? Êü•ÁúãÁªèÂ∏∏‰ΩøÁî®ÁöÑsetContentView()ÊñπÊ≥ïÂπ≤‰∫Ü‰ªÄ‰πà 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; ActivityÂ∞ÜÂÖ∑‰ΩìÂÆûÁé∞‰∫§Áªô‰∫ÜWindowÂ§ÑÁêÜ, ËÄåWindowÁöÑÂÖ∑‰ΩìÂÆûÁé∞Â∞±ÊòØPhoneWindow, ÊâÄ‰ª•Âè™ÈúÄË¶ÅÁúãPhoneWindowÁöÑÁõ∏ÂÖ≥ÈÄªËæëÂàÜ‰∏∫‰ª•‰∏ãÂá†Ê≠•: Â¶ÇÊûúÊ≤°ÊúâDecorView, ÈÇ£‰πàÂ∞±ÂàõÂª∫ÂÆÉ. Áî±installDecor()--&gt;generateDecor()Ëß¶Âèë Â∞ÜViewÊ∑ªÂä†Âà∞DecorViewÁöÑmContentParent‰∏≠ 12//Â∞ÜActivityÁöÑÂ∏ÉÂ±ÄÊñá‰ª∂Âä†ËΩΩÂà∞DecorViewÁöÑmContentParent‰∏≠mLayoutInflater.inflate(layoutResID, mContentParent); ÂõûË∞ÉActivityÁöÑonContentChanged()ÈÄöÁü•activityËßÜÂõæÂ∑≤ÁªèÂèëÁîüÊîπÂèò Ëøô‰∏™Êó∂ÂÄôDecorViewÂ∑≤ÁªèË¢´ÂàõÂª∫Âπ∂ÂàùÂßãÂåñÂÆåÊØï, ActivityÁöÑÂ∏ÉÂ±ÄÊñá‰ª∂‰πüÂ∑≤ÁªèÊ∑ªÂä†ÊàêÂäüÂà∞DecorViewÁöÑmContentParent‰∏≠. ‰ΩÜÊòØËøô‰∏™Êó∂ÂÄôDecorViewËøòÊ≤°ÊúâË¢´WindowManagerÊ≠£ÂºèÊ∑ªÂä†Âà∞Window‰∏≠. ËôΩÁÑ∂Êó©Âú®ActivityÁöÑattachÊñπÊ≥ï‰∏≠windowÂ∞±Â∑≤ÁªèË¢´ÂàõÂª∫‰∫Ü, ‰ΩÜÊòØËøô‰∏™Êó∂ÂÄôÁî±‰∫éDecorViewÂπ∂Ê≤°ÊúâË¢´WindowManagerËØÜÂà´, ÊâÄ‰ª•Ëøô‰∏™Êó∂ÂÄôÁöÑWindowÊó†Ê≥ïÊèê‰æõÂÖ∑‰ΩìÂäüËÉΩ, Âõ†‰∏∫‰ªñËøòÊó†Ê≥ïÊé•Êî∂Â§ñÁïåÁöÑËæìÂÖ•‰ø°ÊÅØ. Âú®ActivityThread#handleResumeActivity()ÊñπÊ≥ï‰∏≠, È¶ñÂÖà‰ºöË∞ÉÁî®Activity#onResume(), Êé•ÁùÄ‰ºöË∞ÉÁî®Activity#makeVisible(), Ê≠£ÊòØÂú®makeVisibleÊñπÊ≥ï‰∏≠, DecorViewÁúüÊ≠£ÁöÑÂÆåÊàê‰∫ÜÊ∑ªÂä†ÂíåÊòæÁ§∫Ëøô‰∏§‰∏™ËøáÁ®ã. Â¶Ç‰∏ã: 12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; DialogÁöÑWindowÂàõÂª∫ËøáÁ®ãDialogÁöÑWindowÁöÑÂàõÂª∫ËøáÁ®ãÂíåActivityÁ±ª‰ºº, ÊúâÂ¶Ç‰∏ãÂá†Ê≠• 1. ÂàõÂª∫Window Dialog‰∏≠ÁöÑWindowÂêåÊ†∑ÊòØÈÄöËøáPolicyManagerÂàõÂª∫ÁöÑmakeNewWindowÂàõÂª∫ÁöÑÔºåÂÆûÈôÖ‰∏äÂ∞±ÊòØPhoneWindow, Ëøô‰∏™ËøáÁ®ãÂíåActivityÁöÑWindowÂàõÂª∫ËøáÁ®ã‰∏ÄËá¥. 2. ÂàùÂßãÂåñDecorViewÂπ∂Â∞ÜDialogÁöÑËßÜÂõæÊ∑ªÂä†Âà∞DecorView‰∏≠ 123public void setContentView(int layoutResID) &#123; mWindow.setContentView(layoutResID);&#125; Ëøô‰∏™ËøáÁ®ã‰πüÁ±ª‰ºº, ÈÉΩÊòØÈÄöËøáWindowÂéªÊ∑ªÂä†ÊåáÂÆöÁöÑÂ∏ÉÂ±ÄÊñá‰ª∂. 3. Â∞ÜDecorViewÊ∑ªÂä†Âà∞Window‰∏≠Âπ∂ÊòæÁ§∫ Âú®DialogÁöÑshowÊñπÊ≥ï‰∏≠, ‰ºöÈÄöËøáWindowManagerÂ∞ÜDecorViewÊ∑ªÂä†Window‰∏≠. 123mWindowManager.addView(mDecor, l);mShowing = true; sendShowMessage(); ÊôÆÈÄöÁöÑDialogÊúâ‰∏Ä‰∏™ÁâπÊÆä‰πãÂ§Ñ, ÈÇ£Â∞±ÊòØÂøÖÈ°ªÈááÁî®ActivityÁöÑContent, Â¶ÇÊûúÈááÁî®ApplicationÁöÑContent, ÈÇ£‰πàÂ∞±‰ºöÊä•Èîô. Êä•ÁöÑÈîôÊòØÊ≤°ÊúâÂ∫îÁî®tokenÊâÄÂØºËá¥ÁöÑ, ËÄåÂ∫îÁî®token‰∏ÄËà¨Âè™ÊúâActivityÊâçÊã•Êúâ. ËøòÊúâ‰∏ÄÁßçÊñπÊ≥ï. Á≥ªÁªüWindowÊØîËæÉÁâπÊÆä, ‰ªñÂèØ‰ª•‰∏çÈúÄË¶Åtoken, Âõ†Ê≠§Âè™ÈúÄË¶ÅÊåáÂÆöÂØπËØùÊ°ÜÁöÑWindow‰∏∫Á≥ªÁªüÁ±ªÂûãÂ∞±ÂèØ‰ª•Ê≠£Â∏∏ÂºπÂá∫ÂØπËØùÊ°Ü. 12345//JAVA ÁªôDialogÁöÑWindowÊîπÂèò‰∏∫Á≥ªÁªüÁ∫ßÁöÑWindowdialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);//XML Â£∞ÊòéÊùÉÈôê&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; ToastÁöÑWindowÂàõÂª∫ËøáÁ®ãToastÂíåDialog‰∏çÂêå, ÂÆÉÁöÑÂ∑•‰ΩúËøáÁ®ãÂ∞±Á®çÊòæÂ§çÊùÇ. È¶ñÂÖàToast‰πüÊòØÂü∫‰∫éWindowÊù•ÂÆûÁé∞ÁöÑ. ‰ΩÜÊòØÁî±‰∫éToastÂÖ∑ÊúâÂÆöÊó∂ÂèñÊ∂àÁöÑÂäüËÉΩ, ÊâÄ‰ª•Á≥ªÁªüÈááÁî®‰∫ÜHandler. Âú®ToastÁöÑÂÜÖÈÉ®Êúâ‰∏§Á±ªIPCËøáÁ®ã, Á¨¨‰∏ÄÁ±ªÊòØToastËÆøÈóÆNotificationManagerServiceÂêéÈù¢ÁÆÄÁß∞NMS. Á¨¨‰∫åÁ±ªÊòØNotificationManagerServiceÂõûË∞ÉToastÈáåÁöÑTNÊé•Âè£„ÄÇ ToastÂ±û‰∫éÁ≥ªÁªüWindow, ÂÆÉÂÜÖÈÉ®ÁöÑËßÜÂõæÊúâ‰∏§ÁßçÊñπÂºèÊåáÂÆö, ‰∏ÄÁßçÊòØÁ≥ªÁªüÈªòËÆ§ÁöÑÊ†∑Âºè, Âè¶‰∏ÄÁßçÊòØÈÄöËøásetViewÊñπÊ≥ïÊù•ÊåáÂÆö‰∏Ä‰∏™Ëá™ÂÆö‰πâView. ‰∏çÁÆ°Â¶Ç‰Ωï, ‰ªñ‰ª¨ÈÉΩÂØπÂ∫îToastÁöÑ‰∏Ä‰∏™ViewÁ±ªÂûãÁöÑÂÜÖÈÉ®ÊàêÂëòmNextView. ToastÂÜÖÈÉ®Êèê‰æõ‰∫ÜcancelÂíåshow‰∏§‰∏™ÊñπÊ≥ï. ÂàÜÂà´Áî®‰∫éÊòæÁ§∫ÂíåÈöêËóèToast. ‰ªñ‰ª¨ÂÜÖÈÉ®ÊòØ‰∏Ä‰∏™IPCËøáÁ®ãÔºå‰ª£Á†ÅÂ¶Ç‰∏ãÔºö 1234567891011121314151617181920212223242526public void show() &#123; if (mNextView == null) &#123; throw new RuntimeException("setView must have been called"); &#125; INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125;public void cancel() &#123; mTN.hide(); try &#123; getService().cancelToast(mContext.getPackageName(), mTN); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; ÊòæÁ§∫ÂíåÈöêËóèToastÈÉΩÊòØÈúÄË¶ÅÈÄöËøáNMSÊù•ÂÆûÁé∞ÁöÑ. Áî±‰∫éNMSËøêË°åÂú®Á≥ªÁªüÁöÑËøõÁ®ã‰∏≠, ÊâÄ‰ª•Âè™ËÉΩÈÄöËøáËøúÁ®ãË∞ÉÁî®ÁöÑÊñπÂºèÊù•ÊòæÁ§∫ÂíåÈöêËóèToast. ËÄåTNËøô‰∏™Á±ªÊòØ‰∏Ä‰∏™BinderÁ±ª. Âú®ToastÂíåNMSËøõË°åIPCÁöÑËøáÁ®ã‰∏≠, ÂΩìNMSÂ§ÑÁêÜToastÁöÑÊòæÁ§∫ÊàñÈöêËóèËØ∑Ê±ÇÊó∂‰ºöË∑®ËøõÁ®ãÂõûË∞ÉTNÁöÑÊñπÊ≥ï. Ëøô‰∏™Êó∂ÂÄôÁî±‰∫éTNËøêË°åÂú®BinderÁ∫øÁ®ãÊ±†‰∏≠, ÊâÄ‰ª•ÈúÄË¶ÅÈÄöËøáHandlerÂ∞ÜÂÖ∂ÂàáÊç¢Âà∞ÂΩìÂâç‰∏ªÁ∫øÁ®ã. ÊâÄ‰ª•Áî±ÂÖ∂ÂèØÁü•, ToastÊó†Ê≥ïÂú®Ê≤°ÊúâLooperÁöÑÁ∫øÁ®ã‰∏≠ÂºπÂá∫ÔºåÂõ†‰∏∫HandlerÈúÄË¶Å‰ΩøÁî®LooperÊâçËÉΩÂÆåÊàêÂàáÊç¢Á∫øÁ®ãÁöÑÂäüËÉΩ„ÄÇ 12345678910111213141516 if (!isSystemToast) &#123; int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) &#123; final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) &#123; count++; // MAX_PACKAGE_NOTIFICATIONS == 50 if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123; Slog.e(TAG, "Package has already posted " + count + " toasts. Not showing more. Package=" + pkg); return; &#125; &#125; &#125;&#125; ÂØπ‰∫éÈùûÁ≥ªÁªüÂ∫îÁî®Êù•ËØ¥, ÊúÄÂ§öËÉΩÂêåÊó∂Â≠òÂú®ÂØπToastÂ∞ÅË£ÖÁöÑToastRecord‰∏äÈôê‰∏∫50‰∏™. ËøôÊ†∑ÂÅöÊòØ‰∏∫‰∫ÜÈò≤Ê≠¢DOS(Denial of Service). Â¶ÇÊûú‰∏çËøôÊ†∑, ÂΩìÈÄöËøáÂ§ßÈáèÂæ™ÁéØÂéªËøûÁª≠ÁöÑÂºπÂá∫Toast, ËøôÂ∞Ü‰ºöÂØºËá¥ÂÖ∂‰ªñÂ∫îÁî®Ê≤°ÊúâÊú∫‰ºöÂºπÂá∫Toast, ÈÇ£‰πàÂØπ‰∫éÂÖ∂‰ªñÂ∫îÁî®ÁöÑToastËØ∑Ê±Ç, Á≥ªÁªüÁöÑË°å‰∏∫Â∞±ÊòØÊãíÁªùÊúçÂä°, ËøôÂ∞±ÊòØÊãíÁªùÊúçÂä°ÊîªÂáªÁöÑÂê´‰πâ. Âú®ToastRecordË¢´Ê∑ªÂä†Âà∞mToastQueue()‰∏≠Âêé, NMSÂ∞±‰ºöÈÄöËøáshowNextToastLocked()ÊñπÊ≥ïÊù•ÊòæÁ§∫ÂΩìÂâçÁöÑToast„ÄÇToastÁöÑÊòæÁ§∫ÊòØÁî±ToastRecordÁöÑcallbackÊù•ÂÆåÊàêÁöÑ. Ëøô‰∏™callbackÂÆûÈôÖ‰∏äÂ∞±ÊòØToast‰∏≠ÁöÑTNÂØπË±°ÁöÑËøúÁ®ãBinder. ÈÄöËøácallbackÊù•ËÆøÈóÆTN‰∏≠ÁöÑÊñπÊ≥ïÊòØÈúÄË¶ÅË∑®ËøõÁ®ãÁöÑ. ÊúÄÁªàË¢´Ë∞ÉÁî®ÁöÑTN‰∏≠ÁöÑÊñπÊ≥ï‰ºöËøêË°åÂú®ÂèëËµ∑ToastËØ∑Ê±ÇÁöÑÂ∫îÁî®ÁöÑBinderÁ∫øÁ®ãÊ±†. 123456789101112131415161718void showNextToastLocked ()&#123; ToastRecord record = mToastQueue.get(0); while(record != null)&#123; if(DBG) Slog.d(TAG,"show pkg=" + record.pkg + "callback=" + record.callback); try&#123; record.callback.show(); scheduleTimeoutLocked(record); return; &#125;&#125;private void scheduleTimeoutLocked(ToastRecord r)&#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay);&#125; Ëøô‰∏™ callback Â∞±ÊòØ Toast ‰∏≠ÁöÑ TN ÂØπË±°ÁöÑËøúÁ®ã BinderÔºåÊúÄÁªàË¢´Ë∞ÉÁî®ÁöÑ TN ‰∏≠ÁöÑÊñπÊ≥ï‰ºöËøêË°åÂú®ÂèëËµ∑ Toast ËØ∑Ê±ÇÁöÑÂ∫îÁî®ÁöÑ Binder Á∫øÁ®ãÊ±†‰∏≠„ÄÇ ‰ªéÂ¶Ç‰∏ä‰ª£Á†ÅÊâÄÁ§∫Âú®ToastÊòæÁ§∫‰ª•Âêé, NMSÈÄöËøáËøô‰∏™ÊñπÊ≥ïÊù•ÂèëÈÄÅ‰∏Ä‰∏™Âª∂Êó∂Ê∂àÊÅØ, ÂÖ∑‰ΩìÂèñÂÜ≥ToastÁöÑÊó∂Èïø. LONG_DELAY, SHORT_DELAYÂàÜÂà´ÂØπÂ∫îÁùÄ3.5ÁßíÂíå2Áßí. ÂΩìÂª∂Êó∂Êó∂Èó¥ËææÂà∞ÁöÑÊó∂ÂÄô. NMS‰ºöÈÄöËøácancelToastLocked()ÊñπÊ≥ïÊù•ÈöêËóèToastÂπ∂Â∞ÜÂÖ∂‰ªémToastQueue‰∏≠ÁßªÈô§, Ëøô‰∏™Êó∂ÂÄôÂ¶ÇÊûúmToastQueue‰∏≠ËøòÊúâÂÖ∂‰ΩôToastÈÇ£‰πàNMSÂ∞±ÁªßÁª≠ÊòæÁ§∫ÂÖ∂‰ªñ. ToastÁöÑÈöêËóè‰πü‰ºöÈÄöËøáToastRecordÁöÑcallbackÂÆåÊàêÁöÑ.ÂêåÊ†∑ÊòØ‰∏ÄÊ¨°IPCËøáÁ®ã. ÊñπÂºèÂíåToastÊòæÁ§∫Á±ª‰ºº. 12345678910111213void cancelToastLocked(int index) &#123;ToastRecord record = mToastQueue.get(index);try &#123; record.callback.hide();&#125; catch (RemoteException e) &#123; Slog.w(TAG, "Object died trying to hide notification " + record.callback + " in package " + record.pkg); // don't worry about this, we're about to remove it from // the list anyway&#125;mToastQueue.remove(index);...&#125; ‰ª•‰∏äÂü∫Êú¨ËØ¥ÊòéToastÁöÑÊòæÁ§∫ÂíåÂΩ±ÂìçËøáÁ®ãÂÆûÈôÖ‰∏äÊòØÈÄöËøáToast‰∏≠ÁöÑTNËøô‰∏™Á±ªÊù•ÂÆûÁé∞ÁöÑ. ‰ªñÊúâ‰∏§‰∏™ÊñπÊ≥ïshow(), hide(). ÂàÜÂà´ÂØπÂ∫îÁùÄToastÁöÑÊòæÁ§∫ÂíåÈöêËóè. Áî±‰∫éËøô‰∏§‰∏™ÊñπÊ≥ïÊòØË¢´NMS‰ª•Ë∑®ËøõÁ®ãÁöÑÊñπÂºèË∞ÉÁî®ÁöÑ, Âõ†Ê≠§‰ªñ‰ª¨ËøêË°åÂú®BinderÁ∫øÁ®ãÊ±†‰∏≠. ‰∏∫‰∫ÜÂ∞ÜÊâßË°åÁéØÂ¢ÉÂàáÊç¢Âà∞ToastËØ∑Ê±ÇÊâÄÂú®Á∫øÁ®ã‰∏≠, Âú®‰ªñ‰ª¨ÂÜÖÈÉ®‰ΩøÁî®‰∫Ühandler,Â¶Ç‰∏ã 1234567891011121314@Overridepublic void show() &#123; if (localLOGV) Log.v(TAG, "SHOW: " + this); mHandler.post(mShow);&#125;/*** schedule handleHide into the right thread*/@Overridepublic void hide() &#123; if (localLOGV) Log.v(TAG, "HIDE: " + this); mHandler.post(mHide);&#125; ‰∏äÈù¢‰ª£Á†Å‰∏≠, mShow, mHideÊòØ‰∏§‰∏™Runnable, ‰ªñ‰ª¨ÂÜÖÈÉ®ÂàÜÂà´Ë∞ÉÁî®‰∫ÜhandleShowÂíåhandleHideÊñπÊ≥ï. ÊâÄ‰ª•Ëøô‰∏§‰∏™ÊñπÊ≥ïÊâçÊòØÁúüÊ≠£ÂÆåÊàêÈöêËóèÂíåÊòæÁ§∫ToastÁöÑÂú∞Êñπ. TNÁöÑhandleShow‰∏≠‰ºöÂ∞ÜToastÁöÑËßÜÂõæÊ∑ªÂä†Âà∞Window‰∏≠. TNÁöÑhandleHide‰∏≠‰ºöÂ∞ÜToastÁöÑËßÜÂõæ‰ªéWindow‰∏≠ÁßªÈô§. ÂÖ∑‰ΩìÂÆûÁé∞‰ª£Á†ÅÂ¶Ç‰∏ã: 123456789101112//handleShow() mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); mWM.addView(mView, mParams); //handleHide()if (mView != null) &#123; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; mView = null;&#125; ÂÖ≥‰∫éToastÊµÅÁ®ãÂ∑≤ÁªèÂÆå‰∫ã. Èô§‰∫ÜËØ¥Âà∞ÁöÑActivity, Dialog, Toast. ËøòÊúâPopupWindowËèúÂçïÊ†è, Áä∂ÊÄÅÊ†èÈÉΩÊòØÈÄöËøáWindowÊù•ÂÆûÁé∞ÁöÑ.]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>Window</tag>
        <tag>WindowManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidÂä®ÁîªÊ∑±ÂÖ•ÂàÜÊûê]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ViewÂä®ÁîªViewÂä®Áîª‰ΩúÁî®ÁöÑÂØπË±°ÊòØView, ÂÆÉÊîØÊåÅÂõõÁßçÂä®ÁîªÊïàÊûúÂπ≥Áßª, Áº©Êîæ, ÊóãËΩ¨, ÈÄèÊòé. Èô§‰∫ÜËøôÂõõÁßçÂÖ∏ÂûãÁöÑÂèòÂåñÊïàÊûú. Â∏ßÂä®Áîª‰πüÂ±û‰∫éViewÂä®Áîª. ViewÂä®ÁîªÁöÑÁßçÁ±ªViewÂä®ÁîªÁöÑÂõõÁßçÂèòÊç¢ÊïàÊûúÂØπÂ∫îÁùÄAnimationÁöÑÂõõ‰∏™Â≠êÁ±ª:TranslateAnimation, ScaleAnimation, RotateAnimationÂíåAlphaAnimation. ÂØπ‰∫éViewÂä®ÁîªÂª∫ËÆÆÈááÁî®XMLÊù•ÂÆö‰πâÂä®Áîª ÂêçÁß∞ Ê†áÁ≠æ Â≠êÁ±ª ÊïàÊûú Âπ≥ÁßªÂä®Áîª &lt;translate&gt; TranslateAnimation ÁßªÂä®View Áº©ÊîæÂä®Áîª &lt;scale&gt; ScaleAnimation ÊîæÂ§ßÊàñËÄÖÁº©Â∞èView ÊóãËΩ¨Âä®Áîª &lt;rotate&gt; RotateAnimation ÊóãËΩ¨View ÈÄèÊòéÂ∫¶Âä®Áîª &lt;alpha&gt; AlphaAnimation ÊîπÂèòViewÁöÑÈÄèÊòéÂ∫¶ ÂàõÂª∫ÁöÑÂä®ÁîªÁöÑxmlÊñá‰ª∂. ÊòØÊîæÂú®res/animËøô‰∏™Êñá‰ª∂Â§π‰∏ãÁöÑ. ViewÂä®ÁîªÊèèËø∞Êñá‰ª∂ÁöÑÂõ∫ÊúâËØ≠Ê≥ïÂ¶Ç‰∏ã 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:shareInterpolator="true" android:interpolator="@android:anim/decelerate_interpolator" android:fillAfter="true"&gt; &lt;alpha android:fromAlpha="float" android:toAlpha="float"/&gt; &lt;scale android:fromXScale="float" android:toXScale="float" android:fromYScale="float" android:toYScale="float" android:pivotX="float" android:pivotY="float"/&gt; &lt;translate android:fromXDelta="float" android:toXDelta="float" android:fromYDelta="float" android:toYDelta="float"/&gt; &lt;rotate android:fromDegrees="float" android:toDegrees="float" android:pivotY="float" android:pivotX="float"/&gt;&lt;/set&gt; ÂÖ≥‰∫éÂä®ÁîªÊàë‰ª¨ÂèØ‰ª•Âè™ËÆæÁΩÆ‰∏ÄÁßç‰πüÂèØ‰ª•ËÆæÁΩÆÂ§öÁßçÁöÑÁªÑÂêà. setÊ†áÁ≠æÂØπÂ∫îÁùÄAnimationSetÁ±ª, Ê†áÁ≠æ‰∏≠ÁöÑÂ±ûÊÄßÁöÑÊÑè‰πâ: shareInterpolator Ë°®Á§∫ÈõÜÂêà‰∏≠ÁöÑÂä®ÁîªÊòØÂê¶ÂíåÈõÜÂêàÂÖ±‰∫´‰∏Ä‰∏™ÊèíÂÄºÂô®. Â¶ÇÊûúÈõÜÂêà‰∏çÊåáÂÆöÊèíÂÄºÂô®, ÈÇ£‰πàÂ≠êÂä®ÁîªÂ∞±ÈúÄË¶ÅÂçïÁã¨Âà∂ÂÆöÊâÄÈúÄÁöÑÊèíÂÄºÂô®ÊàñËÄÖ‰ΩøÁî®ÈªòËÆ§ÂÄº fillAfter ÊòØÂê¶‰øùÁïôÂä®ÁîªÁªìÊùü‰πãÂêéÁöÑÁä∂ÊÄÅ translateÊ†áÁ≠æË°®Á§∫Âπ≥ÁßªÂä®Áîª, ÂØπÂ∫îÁùÄTranslateAnimationÁ±ª Â±ûÊÄßÂÄºÁöÑÊÑè‰πâÂ∞±ÊòØfromÂºÄÂ§¥ÁöÑ‰∏∫ÂºÄÂßãËµ∑ÁÇπ, toÂºÄÂ§¥ÁöÑÁªìÊùüÁÇπ scaleÊ†áÁ≠æË°®Á§∫Áº©ÊîæÂä®Áîª, ÂØπÂ∫îÁùÄScaleAnimationÁ±ª Â±ûÊÄßÂÄºÁöÑÊÑèÊÄùfromÂºÄÂ§¥ÁöÑË°®Á§∫ÂºÄÂßãÊó∂ÂéüÂõæÁº©ÊîæÁöÑÁôæÂàÜÊØî. Áî®ÊµÆÁÇπÊï∞Ë°®Á§∫1Ë°®Á§∫100%(Êó†ÂèòÂåñ),0.5Ë°®Á§∫50%(ÂéüÊù•ÁöÑ‰∏ÄËà¨), 2Ë°®Á§∫200%(ÂéüÊù•ÁöÑ‰∏§ÂÄç). toÂºÄÂ§¥ÁöÑË°®Á§∫ÁªìÊùüÊó∂ÁöÑÁôæÂàÜÊØî. pivotË°®Á§∫Áº©ÊîæÁöÑËΩ¥ÁÇπ. rotateÊ†áÁ≠æË°®Á§∫ÊóãËΩ¨Âä®Áîª, ÂØπÂ∫îÁùÄRotateAnimationÁ±ª fromDegreesÊóãËΩ¨ÁöÑÂºÄÂßãËßíÂ∫¶, toDegreesÊóãËΩ¨ÁöÑÁªìÊùüËßíÂ∫¶. pivotÊóãËΩ¨ÁöÑËΩ¥ÁÇπ alphaÊ†áÁ≠æË°®Á§∫ÈÄèÊòéÂ∫¶Âä®Áîª, ÂØπÂ∫îAlphaAnimationÁ±ª fromAlphaË°®Á§∫ÈÄèÊòéÂ∫¶ÁöÑËµ∑ÂßãÂÄº, toAlphaË°®Á§∫ÈÄèÊòéÂ∫¶ÁöÑÁªìÊùüÂÄº. ‰∏äÈù¢Ëøô‰∫õÊ†áÁ≠æËøòÊúâ‰∏Ä‰∫õÈÄöÁî®ÁöÑÂ±ûÊÄßÂÄº. ‰æãÂ¶ÇdurationÊâßË°åÊó∂Èó¥. xmlÂ¶ÇÊûúÂ£∞Êòé‰∫Ü‰πãÂêéÈÇ£‰πàÊàë‰ª¨Â∞±ËØ•Âú®‰ª£Á†Å‰∏≠Â∫îÁî®‰∫Ü. Â¶Ç‰∏ã: 123View btn_main = findViewById(R.id.parent);Animation animation = AnimationUtils.loadAnimation(this, R.anim.temp);btn_main.startAnimation(animation); ÂêåÊ†∑‰πüÂèØ‰ª•‰∏çÈúÄË¶ÅxmlÁõ¥Êé•Âú®‰ª£Á†Å‰∏≠ÁîüÊàêÂä®ÁîªÂØπË±°. 123AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0);alphaAnimation.setDuration(1000);btn_main.startAnimation(alphaAnimation); Âú®ÂºÄÂßãÂä®Áîª‰πãÂâçÂèØ‰ª•ÁªôÂä®ÁîªÊ∑ªÂä†‰∏Ä‰∏™ÁõëÂê¨setAnimationListener()ËøôÊ†∑Âú®Âä®ÁîªÂºÄÂßãÁªìÊùüÂíåÊØè‰∏ÄÊ¨°Âæ™ÁéØ‰∏ã‰∏ÄÊ¨°ÁöÑÊó∂ÂÄôÈÉΩÂèØ‰ª•Âú®ÂõûË∞ÉÊñπÊ≥ï‰∏≠ÁõëÂê¨Âà∞. 12345public static interface AnimationListener &#123; void onAnimationStart(Animation animation); void onAnimationEnd(Animation animation); void onAnimationRepeat(Animation animation);&#125; Ëá™ÂÆö‰πâViewÂä®ÁîªÂ¶ÇÊûúÈúÄË¶ÅËá™ÂÆö‰πâViewÂä®Áîª, È¶ñÂÖàÂ∫îËØ•ÁªßÊâøAnimationËøô‰∏™ÊäΩË±°Á±ªÊù•Ê¥æÁîüÂá∫‰∏ÄÁßçÊñ∞Âä®Áîª. ÁÑ∂ÂêéÈáçÂÜôinitialize()ÂíåapplyTransformation()ÊñπÊ≥ï. Âú®initialize‰∏≠ÂÅö‰∏Ä‰∫õÂàùÂßãÂåñÂä®‰Ωú, Âú®applyTransformation()‰∏≠ËøõË°åÁõ∏Â∫îÁü©ÈòµÂèòÊç¢, ÂæàÂ§öÊó∂ÂÄôÈúÄË¶ÅÈááÁî®CameraÊù•ÁÆÄÂåñÁü©ÈòµÂèòÊç¢ÁöÑËøáÁ®ã. ËÄåViewÂä®ÁîªÂèòÂåñ‰∏ªË¶ÅÂ∞±ÊòØÁü©ÈòµÁöÑÂèòÊç¢ËøáÁ®ã. ËøôÈáå‰∏æ‰∏Ä‰∏™Android‰∏≠ApiDemoÁöÑ‰∏Ä‰∏™Ëá™ÂÆö‰πâViewÂä®Áîª. Â§ßÊ¶ÇÊïàÊûúÂ∞±ÊòØËøôÊ†∑ÂèØ‰ª•ÂèÇÁÖßÂÆòÁΩëÁöÑapi‰πüÂèØÂú®ÂåÖ‰∏≠ÁöÑMyRotateAnimation Â∏ßÂä®ÁîªÂ∏ßÂä®ÁîªÊòØÈ°∫Â∫èÊí≠Êîæ‰∏ÄÁªÑÈ¢ÑÂÖàÂÆö‰πâÂ•ΩÁöÑÂõæÁâá, Á±ª‰ºº‰∫éÁîµÂΩ±. Á≥ªÁªüÊèê‰æõ‰∫ÜAnimationDrawableÊù•‰ΩøÁî®Â∏ßÂä®Áîª. ÂêåÊ†∑Âú®xml‰∏≠Â£∞Êòé, Âú®res/drawable/ÂåÖ‰∏ãÂàõÂª∫Êñá‰ª∂, Âπ∂ÊõøÊç¢ÊØè‰∏™drawableÂõæÁâáÂç≥ÂèØ 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/xx1" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx2" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx3" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx4" android:duration="500"/&gt;&lt;/animation-list&gt; Â∞Ü‰∏äËø∞ÁöÑDrawable‰Ωú‰∏∫ViewÁöÑËÉåÊôØÂπ∂ÈÄöËøáDrawableÊù•Êí≠ÊîæÂä®Áîª. 12AnimationDrawable background = (AnimationDrawable) iv_main.getBackground();background.start(); Â∏ßÂä®ÁîªÊØîËæÉÂÆπÊòìÂºïËµ∑OOMÔºåÂ∫îËØ•Â∞ΩÈáèÈÅøÂÖç‰ΩøÁî®„ÄÇ ViewÂä®ÁîªÁöÑÁâπÊÆä‰ΩøÁî®Âú∫ÊôØÂâçÈù¢‰ªãÁªçÁöÑViewÂä®ÁîªÈÉΩÊòØ‰ΩúÁî®Âú®Êüê‰∏Ä‰∏™ViewÂØπË±°‰∏äÁöÑ. ËøòÂèØ‰ª•ÈíàÂØπViewGroupÊéßÂà∂ÂÖ∂Â≠êÂÖÉÁ¥†. ÊàñËÄÖÈíàÂØπActivityÂàáÊç¢ÁöÑÂä®Áîª. LayoutAnimationLayoutAnimation‰ΩúÁî®‰∫éViewGroup‰∏äÁöÑ. ‰∏∫ViewGroupÊåáÂÆö‰∏Ä‰∏™Âä®Áîª, ËøôÊ†∑ÂΩìÂÆÉÁöÑÂ≠êÂÖÉÁ¥†Âá∫Âú∫Êó∂ÈÉΩ‰ºöÂÖ∑ÊúâËøôÁßçÂä®ÁîªÊïàÊûú. Â∏∏Áî®ÁöÑ‰ΩøÁî®Âú∫ÊôØÊòØÂú®ListViewÂíåGridView. ‰ΩøÁî®ÂæàÁÆÄÂçïÊ≠•È™§Â¶Ç‰∏ã. Âú®res/anim/anim_itemÊñá‰ª∂Â§π‰∏ãÂàõÂª∫xmlÊñá‰ª∂. 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="0.5" android:animationOrder="random" android:animation="@anim/layout"&gt; &lt;/layoutAnimation&gt; delay: Â≠êÂÖÉÁ¥†ÂºÄÂßãÂä®ÁîªÁöÑÂª∂ËøüÊó∂Èó¥, ‰º†ÂÖ•ÂÄºÊòØÊµÆÁÇπÂÄº. 1‰∏∫100%. ‰æãÂ¶ÇÂ¶ÇÊûúÊòØ0.5 ÂÖ•Âú∫Âä®ÁîªÂë®Êúü‰∏∫300ms(‰∏ãÈù¢ÂÖ≥ËÅîÂä®ÁîªÁöÑdurationÊó∂Èó¥), ÈÇ£‰πàÊØè‰∏™Â≠êÂÖÉÁ¥†ÈÉΩÈúÄË¶ÅÂª∂Ëøü150msÊâçËÉΩÊí≠ÊîæÂÖ•Âú∫Âä®Áîª. ËÄå‰∏îËøô‰∏™Êó∂Èó¥‰ºöÊ†πÊçÆitemÁöÑÈÄíÂ¢ûËÄåÂ¢ûÂä†. ÊØîÊñπËØ¥Á¨¨‰∏Ä‰∏™‰∏∫Âª∂Ëøü150ms, Á¨¨‰∫å‰∏™Â∞±ÊòØ300ms‰æùÊ¨°Á±ªÊé®. animationOrder: Â≠êÂÖÉÁ¥†Âä®ÁîªÁöÑÈ°∫Â∫è, Êúâ‰∏âÁßçÈÄâÊã©normal,reverse,random. reverseË°®Á§∫ÊéíÂú®ÂêéÈù¢ÁöÑÂÖÉÁ¥†ÂÖàÊâßË°åÂÖ•Âú∫Âä®Áîª. randomÈöèÊú∫Â≠êÂÖÉÁ¥†ÊâßË°åÂä®Áîª. animation: ‰∏∫Â≠êÂÖÉÁ¥†ÊåáÂÆöÂÖ∑‰ΩìÁöÑÂÖ•Âú∫Âä®Áîª. ÈáåÈù¢ÊîæÁöÑÂ∞±ÊòØÈíàÂØπViewÁöÑanimationÂä®ÁîªÁöÑxml layoutAnimationÂ£∞ÊòéÂÆåÊàê‰πãÂêé, Âú®Ë¶Å‰ΩúÁî®ÁöÑViewGroupÊ†áÁ≠æ‰∏≠Â¢ûÂä†android:layoutAnimation:&quot;@anim/xxx&quot;ËøõË°åÂÖ≥ËÅîÂç≥ÂèØ. ÂêåÊ†∑‰πüÂèØ‰ª•ÈÄöËøáJava‰ª£Á†ÅÂä®ÊÄÅÂàõÂª∫LayoutAnimationÁ±ªÊù•ÂÆûÁé∞. 12345678910//Ëé∑ÂæóÂ≠êÂÖÉÁ¥†ÈúÄË¶ÅÊâßË°åÁöÑViewÂä®ÁîªAnimation animation = AnimationUtils.loadAnimation(this, R.anim.anim_item); //ÂàõÂª∫‰∏Ä‰∏™LayoutAnimationÂä®ÁîªÂØπË±°LayoutAnimationController controller = new LayoutAnimationController(animation);controller.setDelay(0.5f);controller.setOrder(LayoutAnimationController.ORDER_RANDOM); //ÂØπViewGropËøõË°åÁªëÂÆölistView.setLayoutAnimation(controller); ActivityÁöÑÂàáÊç¢ÊïàÊûúActivityÈªòËÆ§ÊòØÊúâ‰∏ÄÁßçÂàáÊç¢ÊïàÊûúÁöÑ. Â¶ÇÊûúÈúÄË¶ÅËá™ÂÆö‰πâÂàáÊç¢ÊïàÊûú, ‰∏ªË¶ÅÁî®Âà∞overridePendingTransition()Ëøô‰∏™ÊñπÊ≥ï, Ëøô‰∏™ÊñπÊ≥ïÂøÖÈ°ªÂú®startActivity()ÊàñËÄÖfinish()‰πãÂêéË∞ÉÁî®Êâç‰ºöÁîüÊïà ÈúÄË¶ÅÁöÑÂΩ¢ÂèÇÊúâ‰∏§‰∏™, Á¨¨‰∏Ä‰∏™ÊòØË¢´ÊâìÂºÄÊó∂ÂÄôÊâÄÈúÄÁöÑÂä®ÁîªËµÑÊ∫êid, Á¨¨‰∫å‰∏™ÊòØË¢´ÊöÇÂÅúÊó∂,ÊâÄÈúÄÁöÑÂä®ÁîªËµÑÊ∫êid. Â±ûÊÄßÂä®ÁîªÂ±ûÊÄßÂä®ÁîªÊòØAPIÊñ∞Âä†ÂÖ•ÁöÑÁâπÊÄß, ÂíåViewÂä®Áîª‰∏çÂêå, ÂÆÉÂØπ‰ΩúÁî®ÂØπË±°ËøõË°å‰∫ÜÊâ©Â±ï, Â±ûÊÄßÂä®ÁîªÂèØ‰ª•ÂØπ‰ªª‰ΩïÂØπË±°ÂÅöÂä®Áîª. Â±ûÊÄßÂä®Áîª‰∏çÂÜçÂÉèViewÂä®ÁîªÈÇ£Ê†∑Âè™ËÉΩÊîØÊåÅÂõõÁßçÁÆÄÂçïÁöÑ‰∫§Êç¢ . Â±ûÊÄßÂä®Áîª‰∏≠ÊúâvalueAnimator. ObjectAnimator, AnimatorSetÁ≠âÊ¶ÇÂøµ ‰ΩøÁî®Â±ûÊÄßÂä®ÁîªÂ±ûÊÄßÂä®ÁîªÂèØ‰ª•ÂØπ‰ªª‰ΩïÂØπË±°ÁöÑÂ±ûÊÄßËøõË°åÂä®ÁîªËÄå‰∏ç‰ªÖ‰ªÖÊòØView, Âä®ÁîªÈªòËÆ§Êó∂Èó¥Èó¥Èöî‰∏∫300ms, ÈªòËÆ§Â∏ßÁéá10ms/Â∏ß. ÂèØ‰ª•ËææÂà∞ÁöÑÊïàÊûú‰∏∫: Âú®‰∏ÄÊÆµÊó∂Èó¥Èó¥ÈöîÂÜÖÂÆåÊàêÂØπË±°‰ªé‰∏Ä‰∏™Â±ûÊÄßÂÄºÂà∞Âè¶‰∏Ä‰∏™Â±ûÊÄßÂÄºÁöÑÊîπÂèò. Â±ûÊÄßÂä®ÁîªÊòØ‰ªéAPI11Â¢ûÂä†ÁöÑ. Â¶Ç: ÊîπÂèò‰∏Ä‰∏™ÂØπË±°ÁöÑËÉåÊôØËâ≤Â±ûÊÄß, ÂÖ∏ÂûãÁöÑÊîπÂèòViewÁöÑËÉåÊôØËâ≤, ‰∏ãÈù¢ÁöÑÂä®ÁîªÂèØ‰ª•ËÆ©ËÉåÊôØÈ¢úËâ≤ÁöÑÊ∏êÂèò, Âä®Áîª‰ºöÊó†ÈôêÂæ™ÁéØËÄå‰∏î‰ºöÊúâÂèçËΩ¨ÊïàÊûú. 123456ObjectAnimator colorAnim = ObjectAnimator.ofInt(activity_main, "backgroundColor", 0xffffa000, 0xffffa0ff); colorAnim.setDuration(5000); colorAnim.setEvaluator(new ArgbEvaluator()); colorAnim.setRepeatCount(ValueAnimator.INFINITE); colorAnim.setRepeatMode(ValueAnimator.REVERSE); colorAnim.start(); Âä®ÁîªÈõÜÂêà,5ÁßíÂÜÖÂØπViewÊóãËΩ¨Âπ≥ÁßªÁº©ÊîæÈÄèÊòé 12345678910111213AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether( ObjectAnimator.ofFloat(iv_main, "rotationX", 0,360), ObjectAnimator.ofFloat(iv_main, "rotationY", 0,360), ObjectAnimator.ofFloat(iv_main, "rotation", 0,360), ObjectAnimator.ofFloat(iv_main, "translationX", 0,200), ObjectAnimator.ofFloat(iv_main, "translationY", 0,200), ObjectAnimator.ofFloat(iv_main, "scaleX", 1,1.5f), ObjectAnimator.ofFloat(iv_main, "scaleY", 1,1.5f), ObjectAnimator.ofFloat(iv_main, "alpha", 1, 0.25f, 1) ); animatorSet.setDuration(5*1000).start(); ‰πüÂèØ‰ª•‰ΩøÁî®xmlÁöÑÂΩ¢ÂºèÂΩ¢ÂºèÊù•Â£∞Êòé 1234567891011121314151617181920212223242526&lt;set android:ordering=["together" | "sequentially"]&gt; &lt;objectAnimator android:propertyName="string" android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"]/&gt; &lt;animator android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"]/&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; ‰ª£Á†Å‰∏≠‰ΩøÁî®Ôºö 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator);set.setTarget(mButton);set.start(); ÁêÜËß£ÊèíÂÄºÂô®Âíå‰º∞ÂÄºÂô®TimeInterpolatorÊó∂Èó¥ÊèíÂÄºÂô®, ‰ΩúÁî®ÊòØÊ†πÊçÆÊó∂Èó¥ÊµÅÈÄùÁöÑÁôæÂàÜÊØîÊù•ËÆ°ÁÆóÂΩìÂâçÂ±ûÊÄßÂÄºÊîπÂèòÁöÑÁôæÂàÜÊØî. Á≥ªÁªüÈ¢ÑÁΩÆÁöÑÊúâ LinearInterpolator(Á∫øÊÄßÊèíÂÄºÂô®:ÂåÄÈÄüÂä®Áîª) AccelerateDecelerateInterpolator(Âä†ÈÄüÂáèÈÄüÊèíÂÄºÂô®:Âä®Áîª‰∏§Â§¥ÊÖ¢‰∏≠Èó¥Âø´) DecelerateInterpolator(ÂáèÈÄüÊèíÂÄºÂô®:Âä®ÁîªË∂äÊù•Ë∂äÊÖ¢) TypeEvaluator Á±ªÂûã‰º∞ÂÄºÁÆóÊ≥ï, ‰πüÂè´‰º∞ÂÄºÂô®. ‰ΩúÁî®ÊòØÊ†πÊçÆÂΩìÂâçÂ±ûÊÄßÊîπÂèòÁöÑÁôæÂàÜÊØîÊù•ËÆ°ÁÆóÊîπÂèòÂêéÁöÑÂ±ûÊÄßÂÄº. Á≥ªÁªüÈ¢ÑÁΩÆÁöÑ‰º∞ÂÄºÂô®Êúâ IntEvaluator Êï¥ÂΩ¢‰º∞ÂÄºÂô® FloatEvaluator ÊµÆÁÇπÂûã‰º∞ÂÄºÂô® ArgbEvaluator ColorÂ±ûÊÄß‰º∞ÂÄºÂô® Â±ûÊÄßÂä®Áîª‰∏≠ÁöÑÊèíÂÄºÂô®Âíå‰º∞ÂÄºÂô®ÈÉΩÂæàÈáçË¶Å, ‰ªñ‰ª¨ÊòØÂÆûÁé∞ÈùûÂåÄÈÄüÂä®ÁîªÁöÑÈáçË¶ÅÊâãÊÆµ Â±ûÊÄßÂä®ÁîªË¶ÅÊ±ÇÂØπË±°ÁöÑËØ•Â±ûÊÄßÊúâset``getÊñπÊ≥ï. ÊèíÂÄºÂô®Âíå‰º∞ÂÄºÂô®ÁÆóÊ≥ïÈô§‰∫ÜÁ≥ªÁªüÊèê‰æõÁöÑÂ§ñ. ‰πüÂèØ‰ª•Ëá™ÂÆö‰πâ. ÂÆûÁé∞ÊñπÂºè‰πüÂæàÁÆÄÂçï, Âõ†‰∏∫ÊèíÂÄºÂô®Âíå‰º∞ÂÄºÁÆóÊ≥ïÈÉΩÊòØ‰∏Ä‰∏™Êé•Âè£, ‰∏îÂÜÖÈÉ®ÈÉΩÂè™Êúâ‰∏Ä‰∏™ÊñπÊ≥ï, Êàë‰ª¨Âè™Ë¶ÅÊ¥æÁîü‰∏Ä‰∏™Á±ªÂÆûÁé∞Êé•Âè£Êé•ÂèØ‰ª•. ÂÖ∑‰ΩìÂ∞±ÊòØ: Ëá™ÂÆö‰πâÊèíÂÄºÂô®ÈúÄË¶ÅÂÆûÁé∞InterpolatorÊàñËÄÖTimeInterpolator. Ëá™ÂÆö‰πâ‰º∞ÂÄºÁÆóÊ≥ïÈúÄË¶ÅÂÆûÁé∞TypeEvaluator Â±ûÊÄßÂä®ÁîªÁöÑÁõëÂê¨Âô®Â±ûÊÄßÂä®ÁîªÊèê‰æõ‰∫ÜÁõëÂê¨Âô®Áî®‰∫éÁõëÂê¨Âä®ÁîªÁöÑÊí≠ÊîæËøáÁ®ã ‰∏ªË¶ÅÊúâ‰∏§‰∏™Êé•Âè£AnimatorUpdateListenerÂíåAnimatorListenerÊé•Âè£. AnimatorListener ÈÄöËøáÊé•Âè£ÁöÑÂÆö‰πâÂèØ‰ª•ÁúãÂá∫, ÁõëÂê¨‰∫ÜÂä®ÁîªÁöÑÂºÄÂßã,ÁªìÊùü,ÂèñÊ∂à,‰ª•ÂèäÈáçÂ§çÊí≠Êîæ. Á≥ªÁªü‰∏∫‰∫ÜÊñπ‰æøÂºÄÂèëÊèê‰æõ‰∫ÜAnimatorListenerAdapterÁ±ª. ‰ªñÊòØAnimatorListenerÁöÑÈÄÇÈÖçÂô®. ËøôÊ†∑Â∞±‰∏çÈúÄË¶ÅÈùûÂæóÂÆûÁé∞Âõõ‰∏™ÊäΩË±°ÊñπÊ≥ïËÄåÊòØÊåâÁÖßÊàë‰ª¨ÁöÑÈúÄË¶ÅÈÄâÊã©Â§çÂÜô. AnimatorUpdateListener ÊØîËæÉÁâπÊÆä, ‰ªñ‰ºöÁõëÂê¨Êï¥‰∏™Âä®ÁîªËøáÁ®ã, Âä®ÁîªÊòØÁî±ËÆ∏Â§öÂ∏ßÁªÑÊàêÁöÑ. ÊØèÊí≠Êîæ‰∏ÄÂ∏ßonAnimationUpdateÂ∞±‰ºöË¢´Ë∞ÉÁî®‰∏ÄÊ¨° ÂØπ‰ªªÊÑèÂ±ûÊÄßÂÅöÂä®ÁîªÈóÆÈ¢ò: Â¶ÇÊûúÈúÄË¶ÅÊää‰∏Ä‰∏™buttonÊéß‰ª∂ÁöÑÂÆΩÂ¢ûÂä†200px. Â∫îËØ•ÊÄé‰πàÂÅö? ViewÂä®ÁîªÂè™ÊòØÊîØÊåÅÂõõÁßçÂü∫Êú¨ÁöÑÂ±ûÊÄßÊìç‰Ωú, ËÄåScaleÂè™ÊòØÁº©Êîæ. Âπ∂‰∏îËøò‰ºöÂØπÂÜÖÂÆπËøõË°åÊãâ‰º∏Âπ∂‰∏î‰º¥ÈöèÁùÄyËΩ¥ÁöÑÂ¢ûÂä†. ÊâÄ‰ª•Â±ûÊÄßÂä®ÁîªÂú®ËøôÈáåÂ∞±ÂèØ‰ª•Ê¥æ‰∏äÁî®Âú∫. ‰ΩÜÊòØÂ¶ÇÊûúÁõ¥Êé•ÂØπwidthÂ±ûÊÄßËøõË°å‰øÆÊîπÈÇ£‰πà‰∏ç‰ºöÊúâÊïàÊûú. ÂàÜÊûê‰∏Ä‰∏ã: Â±ûÊÄßÂä®ÁîªÁöÑÂéüÁêÜ: Â±ûÊÄßÂä®ÁîªË¶ÅÊ±ÇÂä®Áîª‰ΩúÁî®ÁöÑÂØπË±°Êèê‰æõËØ•Â±ûÊÄßÁöÑgetÂíåsetÊñπÊ≥ï, Â±ûÊÄßÂä®ÁîªÊ†πÊçÆÂ§ñÁïå‰º†ÈÄíÁöÑËØ•Â±ûÊÄßÂÄºÁöÑÂàùÂßãÂÄºÂíåÊúÄÁªàÂÄº, ‰ª•Âä®ÁîªÁöÑÊïàÊûúÂ§öÊ¨°Ë∞ÉÁî®setÊØèÊ¨°setÁöÑÂÄº‰πüÊòØ‰∏çÂêå. ÊúÄÁªàËææÂà∞ÁªàÁÇπÂÄº. ÊâÄ‰ª•Ë¶ÅËÆ©Âä®ÁîªÁîüÊïàÂ∫îËØ•Êª°Ë∂≥‰∏§‰∏™Êù°‰ª∂: ÂøÖÈ°ªÊèê‰æõsetXXX()ÊñπÊ≥ï, Â¶ÇÊûúÂä®ÁîªÊ≤°Êúâ‰º†ÈÄíÂàùÂßãÂÄºËøòË¶ÅÊèê‰æõgetXXX()ÊñπÊ≥ï. ËøôÊ†∑Á≥ªÁªüÂú®ÈúÄË¶ÅÂàùÂßãÂ±ûÊÄßÁöÑÊó∂ÂÄôÂú®ÂèñÂÄºÊó∂‰∏ç‰ºöÂõ†‰∏∫Ê≤°ÊúâgetXXX()ËÄåÂèëÁîüCrash. set‰øÆÊîπÁöÑÂÄºÂøÖÈ°ªËÉΩÊîπÈÄöËøáÊüêÁßçÂΩ¢ÂºèÂèçÊò†Âá∫Êù•, ÊØîÂ¶Ç‰ºöÂ∏¶Êù•UIÁöÑÊîπÂèò. (Â¶ÇÊûú‰∏çÊª°Ë∂≥ËøôÊù°,Âä®ÁîªÊó†ÊïàÊûú‰ΩÜ‰∏ç‰ºöCrash) ÈÇ£ButtonÊú¨Ë∫´ÂÖ∑Â§ásetWidth()‰∏∫‰ªÄ‰πà‰ºöÊó†ÊïàÊûú. ËøôÊòØÂõ†‰∏∫ËôΩÁÑ∂ButtonÊèê‰æõ‰∫ÜÊñπÊ≥ï, ‰ΩÜÊòØËøô‰∏™setWidth()ÊñπÊ≥ïÂπ∂‰∏çÊòØÊîπÂèòËßÜÂõæÂ§ßÂ∞èÁöÑ, ‰ªñÊòØTextViewÊñ∞Ê∑ªÂä†ÁöÑÊñπÊ≥ï, ViewÂç¥Ê≤°ÊúâËøôÊ†∑ÁöÑÊñπÊ≥ï. ËÄåsetWidth()ÊñπÊ≥ïÁöÑÂÜÖÈÉ®,‰ΩúÁî®‰∏çÊòØËÆæÁΩÆViewÁöÑÂ§ßÂ∞è, ËÄåÊòØËÆæÁΩÆTextViewÁöÑÊúÄÂ§ßÂÆΩÂ∫¶ÂíåÊúÄÂ∞èÂÆΩÂ∫¶, Ëøô‰∏™ÂíåTextViewÁöÑÂÆΩÊòØ‰∏§‰∏™‰∏úË•ø. ËøôÊ†∑ËØ¥Êéß‰ª∂ÁöÑÂÆΩÂ∫¶ÂØπÂ∫îxml‰∏≠ÁöÑlayout_width, ËÄåsetWidth()ÂØπÂ∫îÁöÑÂ∞±ÊòØxml‰∏≠ÁöÑwidthÂ±ûÊÄß. ÊâÄ‰ª•ÁªºÂêà‰∏äËø∞ÂéüÂõ†, Êª°Ë∂≥Êù°‰ª∂‰∏ÄËÄå‰∏çÊª°Ë∂≥Êù°‰ª∂‰∫å. ÂÆòÁΩëÊñáÊ°£‰∏≠ÁªôÂá∫‰∫Ü‰∏âÁßçËß£ÂÜ≥ÊñπÊ°à: Áªô‰Ω†ÁöÑÂØπË±°Âä†‰∏ägetÂíåsetÊñπÊ≥ï, Â¶ÇÊûú‰Ω†ÊúâÊùÉÈôêÁöÑËØù. Áî®‰∏Ä‰∏™Á±ªÊù•ÂåÖË£Ö(Wrapper)ÂéüÂßãÂØπË±°, Èó¥Êé•‰∏∫ÂÖ∂Êèê‰æõgetÂíåsetÊñπÊ≥ï. ÈááÁî®valueAnimator, ÁõëÂê¨Âä®ÁîªËøáÁ®ã,Ëá™Â∑±ÂÆûÁé∞Â±ûÊÄßÁöÑÊîπÂèò. ÊØîËæÉÔºö ËôΩÁÑ∂ÁÆÄÂçï‰ΩÜÊòØÊ≤°ÊúâÊùÉÈôêÂéªSDKÂÜÖÈÉ®ÂÆûÁé∞Âéª ÂèØ‰ª•ÂàõÂª∫‰∏Ä‰∏™ÂÜÖÈÉ®ÂåÖË£ÖÁ±ªÂàõÂª∫set(),get()ÊñπÊ≥ïÂØπViewÁúüÊ≠£ÁöÑÂÆΩÂ∫¶ÁöÑLayoutParams.widthÂ±ûÊÄßËøõË°å‰øÆÊîπ. ÈááÁî®ValueAnimator, ÁõëÂê¨Âä®ÁîªËøáÁ®ã, Ëá™Â∑±ÂÆûÁé∞Â±ûÊÄßÊîπÂèò. ValueAnimatorÊú¨Ë∫´‰∏ç‰ΩúÁî®‰∫é‰ªª‰ΩïÂØπË±°. ‰ΩÜÊòØ‰ªñÂèØ‰ª•ÂØπ‰∏Ä‰∏™ÂÄºÂÅöÂä®Áîª. ÁÑ∂ÂêéÁõëÂê¨ÂÖ∂Âä®ÁîªËøáÁ®ãÔºåÂú®Âä®ÁîªËøáÁ®ã‰∏≠ÈÖçÂêà‰º∞ÂÄºÂô®Evaluator‰øÆÊîπÊàë‰ª¨ÁöÑÂØπË±°Â±ûÊÄß. Â±ûÊÄßÂä®ÁîªÁöÑÂ∑•‰ΩúÂéüÁêÜÂâçÈù¢ËØ¥Ëøá, ËØ¥Â±ûÊÄßÁîªË¶ÅÊ±Ç‰ΩúÁî®ÁöÑÂØπË±°Êèê‰æõËØ•Â±ûÊÄßÊñπÊ≥ïsetÊñπÊ≥ï, Â±ûÊÄßÂä®ÁîªÊ†πÊçÆ‰º†ÈÄíÁöÑËØ•Â±ûÊÄßÁöÑÂàùÂßãÂÄºÂíåÊúÄÁªàÂÄº, ‰ª•Âä®ÁîªÁöÑÊïàÊûúÂ§öÊ¨°ÂéªË∞ÉÁî®setÊñπÊ≥ï. ÊØèÊ¨°setÊñπÊ≥ïÊó∂ÂÄô‰º†ÈÄíÁöÑÂÄºÈÉΩÊòØ‰∏ç‰∏ÄÊ†∑ÁöÑ. ‰πüÂ∞±ÊòØÈöèÁùÄÊó∂Èó¥ÁöÑÊé®ÁßªÊâÄ‰º†ÈÄíÁöÑÂÄº‰ºöË∂äÊù•Ë∂äÊé•ËøëÁªàÁÇπÂÄº. Ê∫êÁ†ÅÂàÜÊûê: ÈíàÂØπObjectAnimatorÁöÑstart()‰∏∫ÂÖ•Âè£ 1234567891011121314151617181920212223242526272829303132333435363738394041424344 @Overridepublic void start() &#123; // See if any of the current active/pending animators need to be canceled AnimationHandler handler = sAnimationHandler.get(); if (handler != null) &#123; int numAnims = handler.mAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; numAnims = handler.mPendingAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; numAnims = handler.mDelayedAnims.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; &#125; if (DBG) &#123; Log.d(LOG_TAG, "Anim target, duration: " + getTarget() + ", " + getDuration()); for (int i = 0; i &lt; mValues.length; ++i) &#123; PropertyValuesHolder pvh = mValues[i]; Log.d(LOG_TAG, " Values[" + i + "]: " + pvh.getPropertyName() + ", " + pvh.mKeyframes.getValue(0) + ", " + pvh.mKeyframes.getValue(1)); &#125; &#125; super.start();&#125; ËøôÊÆµ‰ª£Á†Å‰∏ªË¶ÅÂ∞±ÊòØÂèñÊ∂àÂíåÂΩìÂâçÂä®ÁîªÁõ∏ÂêåÁöÑÂä®Áîª. ÊúÄÂºÄÂßãÂà§Êñ≠‰∫ÜÂΩìÂâçÂä®Áîª,Á≠âÂæÖÂä®Áîª,Âª∂ËøüÂä®ÁîªÊòØÂê¶Êúâ‰∏ÄËá¥ÁöÑ. Â¶ÇÊûúÊúâÈÇ£‰πàÂ∞±ÁªôÂèñÊ∂à. ÊúÄÂêéË∞ÉÁî®‰∫ÜÁà∂Á±ªÊñπÊ≥ï. Âõ†‰∏∫ObjectAnimatorÁªßÊâø‰∫ÜValueAnimator,ÊâÄ‰ª•ÁªßÁª≠Áúã‰∏Ä‰∏ãÁà∂Á±ªÁöÑstart() 1234567891011121314151617181920212223242526private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException("Animators may only be run on Looper threads"); &#125; mReversing = playBackwards; mPlayingBackwards = playBackwards; int prevPlayingState = mPlayingState; mPlayingState = STOPPED; mStarted = true; mStartedDelay = false; mPaused = false; updateScaledDuration(); // in case the scale factor has changed since creation time AnimationHandler animationHandler = getOrCreateAnimationHandler(); animationHandler.mPendingAnimations.add(this); if (mStartDelay == 0) &#123; // This sets the initial value of the animation, prior to actually starting it running if (prevPlayingState != SEEKED) &#123; setCurrentPlayTime(0); &#125; mPlayingState = STOPPED; mRunning = true; notifyStartListeners(); &#125; animationHandler.start();&#125; Â±ûÊÄßÂä®ÁîªÈúÄË¶ÅËøêË°åÂú®ÊúâLooperÁöÑÁ∫øÁ®ã‰∏≠, ÊúÄÁªà‰ºöË∞ÉÁî®AnimationHandler.start()ÊñπÊ≥ï.AnimationHandlerÂπ∂‰∏çÊòØHandler, ‰ªñÊòØ‰∏Ä‰∏™Runnable. ÂêéÈù¢‰ºöË∞ÉÂà∞JNIÂ±Ç, ÁÑ∂ÂêéJNIÂ±ÇËøò‰ºöË∞ÉÂõû, ÁÑ∂ÂêérunÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®, Ëøô‰∏™RunableÊ∂âÂèäÂíåÂ∫ïÂ±ÇÁöÑ‰∫§‰∫í. Áï•Ëøá. ÁúãÈáçÁÇπ. ValueAnimatorÁöÑdoAnimationFrame()ÊñπÊ≥ï, ÂÜÖÈÉ®ÊúÄÂêéË∞ÉÁî®‰∫ÜanimationFrame()ÊñπÊ≥ï,ËÄåanimationFrame()ÂÜÖÈÉ®Ë∞ÉÁî®‰∫ÜanimateValue()ÊñπÊ≥ï 1234567891011121314void animateValue(float fraction) &#123; fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].calculateValue(fraction); &#125; if (mUpdateListeners != null) &#123; int numListeners = mUpdateListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mUpdateListeners.get(i).onAnimationUpdate(this); &#125; &#125;&#125; ÁúãÂà∞‰∫ÜcalculateValue()ÊñπÊ≥ï, Ëøô‰∏™Â∞±ÊòØËÆ°ÁÆóÊØèÂ∏ßÂä®ÁîªÊâÄÂØπÂ∫îÁöÑÂ±ûÊÄßÁöÑÂÄº, ÁÑ∂ÂêéÁúã‰∏Ä‰∏ãset,getÊñπÊ≥ï. ÊØîÂ¶Ç‰πãÂâçËØ¥ÁöÑÂ¶ÇÊûúÊ≤°ÊúâÂàùÂßãÂÄº, ÂàôË∞ÉÁî®getÊñπÊ≥ïÁ≠â.. Êü•ÁúãPropertyValuesHolderÁ±ªÁöÑsetupValue() 12345678910111213141516private void setupValue(Object target, Keyframe kf) &#123; if (mProperty != null) &#123; Object value = convertBack(mProperty.get(target)); kf.setValue(value); &#125; if (mGetter == null) &#123; Class targetClass = target.getClass(); setupGetter(targetClass); if (mGetter == null) &#123; // Already logged the error - just return to avoid NPE return; &#125; &#125; Object value = convertBack(mGetter.invoke(target)); kf.setValue(value); ÂΩìÂä®ÁîªÁöÑ‰∏ã‰∏ÄÂ∏ßÂà∞Êù•ÁöÑÊó∂, setAnimatedValue()ÊñπÊ≥ï‰ºöÂ∞ÜÊñ∞ÁöÑÂ±ûÊÄßÂÄºÁªôÂØπË±°, Ë∞ÉÁî®ÂÖ∂set()ÊñπÊ≥ï.ÂêåÊ†∑set‰πüÊòØÂèçÂ∞ÑË∞ÉÁî® 123456789void setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); &#125; if (mSetter != null) &#123; mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); &#125;&#125; ‰ΩøÁî®Âä®ÁîªÁöÑÊ≥®ÊÑè‰∫ãÈ°π OOMÈóÆÈ¢ò: Âú®Â∏ßÂä®ÁîªÊó∂ÂÄôÂÆπÊòìÂèëÁîü ÂÜÖÂ≠òÊ≥ÑÊºè: Â¶ÇÊûúÊúâÊó†ÈôêÂæ™ÁéØÁöÑÂ±ûÊÄßÂä®Áîª, Âú®ÁïåÈù¢ÈÄÄÂá∫ÁöÑÊó∂ÂÄô‰∏ÄÂÆöË¶ÅÂÅúÊ≠¢Âä®Áîª ,Âê¶Âàôactivity‰ºöÊó†Ê≥ïÈáäÊîæ. ËÄåViewÂä®ÁîªÂπ∂‰∏çÂ≠òÂú®Ê≠§ÈóÆÈ¢ò. ÂÖºÂÆπÊÄßÈóÆÈ¢ò: ‰∏ªË¶ÅÊòØ3.0‰ª•‰∏ãÁ≥ªÁªü ViewÂä®ÁîªÈóÆÈ¢ò: Âõ†‰∏∫ÊòØÂØπÂéüÂßãViewÂÅöÁöÑÂΩ±ÂÉèÊïàÊûú. Âπ∂Êú™ÁúüÊ≠£ÊîπÂèòViewÁöÑÁä∂ÊÄÅ. ÊâÄ‰ª•Âú®Âä®ÁîªÂÆåÊàê‰πãÂêéÔºåÂõûÂØºËá¥ËÆæÁΩÆsetVisibility(View.GONE)Êó†Êïà. Ëøô‰∏™Êó∂ÂÄôË∞ÉÁî®view.clearAnimation()Ê∏ÖÈô§ViewÊïàÊûúÂç≥ÂèØ„ÄÇ ‰∏çË¶Å‰ΩøÁî®px Âä®Áîª‰∫§‰∫í. Á≥ªÁªü3.0‰πãÂâçÊó†ËÆ∫ÊòØÂ±ûÊÄßÂä®ÁîªËøòÊòØViewÂä®ÁîªÊñ∞ÁöÑ‰ΩçÁΩÆÈÉΩÊó†Ê≥ïËß¶ÂèëÂçïÂáª‰∫ã‰ª∂.ÈúÄË¶ÅÊ≥®ÊÑèÔºõ ‰ªé3.0ÂºÄÂßãÔºåÂ±ûÊÄßÂä®ÁîªÁöÑÁÇπÂáª‰∫ã‰ª∂ÁöÑËß¶Âèë‰ΩçÁΩÆ‰∏∫ÁßªÂä®Âêé‰ΩçÁΩÆÔºå‰ΩÜÊòØViewÂä®Áîª‰ªçÂú®Âéü‰ΩçÁΩÆ„ÄÇ Á°¨‰ª∂Âä†ÈÄü,ÊèêÈ´òÂä®ÁîªÊµÅÁïÖÂ∫¶]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>Â±ûÊÄßÂä®Áîª</tag>
        <tag>ViewÂä®Áîª</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android‰∏≠ÁöÑDrawable]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E7%9A%84Drawable%2F</url>
    <content type="text"><![CDATA[DrawableÁÆÄ‰ªãDrawableË°®Á§∫‰∏ÄÁßçÂõæÂÉèÁöÑÊ¶ÇÂøµ. ‰ºòÁÇπ:‰ΩøÁî®ÊØîËá™ÂÆö‰πâViewÁöÑÊàêÊú¨‰Ωé, ÈùûÂõæÁâáÁ±ªÂûãÁöÑDrawableÂç†Áî®Á©∫Èó¥ËæÉÂ∞è. DrawableÊú¨Ë∫´ÊòØ‰∏Ä‰∏™ÊäΩË±°Á±ª. ÊòØÊâÄÊúâDrawableÂØπË±°ÁöÑÂü∫Á±ª, ÊØè‰∏™ÂÖ∑‰ΩìÁöÑDrawableÈÉΩÊòØÂÖ∂Â≠êÁ±ª. DrawableÂÜÖÈÉ®ÂÆΩÈ´òÈÄöËøágetIntrinsicWidthÂíågetIntrinsicHeightËøô‰∏§‰∏™ÊñπÊ≥ïËé∑Âæó. ÈúÄË¶ÅÊ≥®ÊÑèËøô‰∏™ÂÜÖÈÉ®ÂÆΩÈ´òÁöÑÊ¶ÇÂøµÈíàÂØπ‰∏çÂêåÁöÑÁ±ªÂûãÁöÑDrawable, ÂØπ‰∫éÂõæÁâáÂΩ¢ÊàêÁöÑDrawableÂÜÖÈÉ®ÂÆΩÈ´òÂ∞±ÊòØÂõæÁâáÁöÑÂÆΩÈ´ò. ËÄåÈ¢úËâ≤ÊâÄÂΩ¢ÊàêÁöÑDrawableÊ≤°ÊúâÂÜÖÈÉ®ÂÆΩÈ´òÁöÑÊ¶ÇÂøµ. DrawableÁöÑÂÜÖÈÉ®ÂÆΩÈ´ò‰∏çÁ≠â‰∫éÂÆÉÁöÑÂ§ßÂ∞è. ÂΩì‰Ωú‰∏∫ViewÁöÑËÉåÊôØÁöÑËßÜÂõæ, Drawable‰ºöË¢´Êãâ‰º∏Ëá≥ViewÁöÑÂêåÁ≠âÂ§ßÂ∞è. DrawableÁöÑÂàÜÁ±ªBitmapDrawableË°®Á§∫‰∏ÄÂº†ÂõæÁâá, Âú®ÂºÄÂèë‰∏≠Áõ¥Êé•ÂºïÁî®ÂéüÂßãÂõæÁâá‰πüÂèØ, ‰∏ãÈù¢ÁªôÂá∫Âú®XML‰∏≠ÊèèËø∞Á®çÂæÆÂÆåÊï¥ÁöÑÂ£∞Êòé 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@mipmap/ic_sample" android:antialias="true" android:dither="true" android:filter="true" android:gravity="top" android:mipMap="true" android:tileMode="repeat" &gt;&lt;/bitmap&gt; src: ÂõæÁâáÁöÑËµÑÊ∫êÊñá‰ª∂id(AS‰∏ãÂèØËÉΩ‰∏ç‰ºöËá™Âä®ÊèêÁ§∫mipmap,Áõ¥Êé•ÂÜôÂÖ•Âç≥ÂèØ) antialias: ÂõæÁâáÊäóÈîØÈΩø.Â±ûÊÄßÂÄºboolean ÂºÄÂêØÂèØ‰ª•ËÆ©ÂõæÁâáÂèòÂæóÂπ≥Êªë. dither: ÊäñÂä®ÊïàÊûú. Â±ûÊÄßÂÄºBoolean. ÂΩìÂõæÁâáÁöÑÂÉèÁ¥†ÈÖçÁΩÆÂíåÊâãÊú∫Â±èÂπïÁöÑÂÉèÁ¥†ÈÖçÁΩÆ‰∏ç‰∏ÄËá¥Êó∂,ÂºÄÂêØÊ≠§ÈÄâÈ°πÂèØ‰ª•ËÆ©È´òË¥®ÈáèÁöÑÂõæÁâáÂú®‰ΩéË¥®ÈáèÁöÑÂ±èÂπï‰∏äÁªßÁª≠‰øùÊåÅËæÉÂ•ΩÊïàÊûú. ‰æãÂ¶ÇÂõæÁâáÊ®°Âºè‰∏∫ARGB8888,ËÄåËÆæÂ§áÂ±èÂπïÊâÄÊîØÊåÅ‰∏∫RGB555. ÂºÄÂêØÂèØ‰ª•ËÆ©ÂõæÁâá‰∏ç‰ºöËøá‰∫éÂ§±Áúü. filter: ËøáÊª§ÊïàÊûú. ÂΩìÂõæÁâáÂ∞∫ÂØ∏Ë¢´Êãâ‰º∏ÊàñËÄÖÂéãÁº©,ÂèØ‰ª•‰øùÊåÅËæÉÂ•ΩÁöÑÊïàÊûú. gravity: ÂèØ‰ª•ÂØπÂõæÁâáËøõË°åÂÆö‰Ωç. ÂèØ‰ª•‰ΩøÁî®|ÁªÑÂêàÂ±ûÊÄß‰ΩøÁî®. ÂèØ‰æõ‰ΩøÁî®ÁöÑÂ±ûÊÄß ÂèØÈÄâÈ°π Âê´‰πâ top ÊîæÂú®È°∂ÈÉ®, ‰∏çÊîπÂèòÂõæÁâáÂ§ßÂ∞è bottom ÊîæÂú®Â∫ïÈÉ®, ‰∏çÊîπÂèòÂõæÁâáÂ§ßÂ∞è left ÊîæÂú®Â∑¶Á´Ø, ‰∏çÊîπÂèòÂõæÁâáÂ§ßÂ∞è right ÊîæÂú®Âè≥Á´Ø, ‰∏çÊîπÂèòÂõæÁâáÂ§ßÂ∞è center_vertical ‰ΩøÂõæÁâáÁ´ñÁõ¥Â±Ö‰∏≠, ‰∏çÊîπÂèòÂõæÁâáÂ§ßÂ∞è fill_vertical ÂõæÁâáÁ´ñÁõ¥ÊñπÂêëÂ°´ÂÖÖÂÆπÂô® center_horizontal ‰ΩøÂõæÁâáÊ∞¥Âπ≥Â±Ö‰∏≠, ‰∏çÊîπÂèòÂõæÁâáÂ§ßÂ∞è fill_horizontal ÂõæÁâáÊ∞¥Âπ≥ÊñπÂêëÂ°´ÂÖÖÂÆπÂô® center ÂõæÁâáÂêåÊó∂Ê∞¥Âπ≥ÂíåÂûÇÁõ¥Â±Ö‰∏≠, ‰∏çÊîπÂèòÂõæÁâáÂ§ßÂ∞è fill ÂõæÁâáÊ∞¥Âπ≥ÂíåÁ´ñÁõ¥ÊñπÂêëÂùáÂ°´ÂÖÖÂÆπÂô®, ËøôÊòØÈªòËÆ§ÂÄº clip_vertical Ë°®Á§∫Á´ñÁõ¥ÊñπÂêëÁöÑË£ÅÂâ™, ËæÉÂ∞ë‰ΩøÁî® clip_horizontal Ë°®Á§∫Ê∞¥Âπ≥ÊñπÂêëÁöÑË£ÅÂâ™, ËæÉÂ∞ë‰ΩøÁî® mipmap: Á∫πÁêÜÊò†Â∞Ñ ÈªòËÆ§‰∏∫false tileMode: Âπ≥Èì∫Ê®°Âºè. ÊúâÂõõÁßçÂÄº: disableÂÖ≥Èó≠Âπ≥Èì∫Ê®°Âºè(ÈªòËÆ§ÂÄº), repeatÊôÆÈÄöÂπ≥Èì∫ÂºÄÂêØ, mirrorÂπ≥Èì∫ÁöÑÂêåÊó∂,Âπ≥Èì∫ÂõæÁâáÂÅöÈïúÈù¢ÊïàÊûú. clampÂú®ÂéüÂßãÂõæÁâáÊúÄÂè≥ËæπÂÉèÁ¥†ÂêëÂè≥Âª∂‰º∏, ÊúÄ‰∏ãËæπÂÉèÁ¥†Âêë‰∏ãÂª∂‰º∏.Â¶ÇÂõæ: NinePatchDrawable Ë°®Á§∫‰∏ÄÂº†.9Ê†ºÂºèÁöÑÂõæÁâá, .9ÂõæÁâáÂèØ‰ª•Ëá™Âä®ÁöÑÊ†πÊçÆÊâÄÈúÄË¶ÅÁöÑÂÆΩÈ´òËøõË°åÁõ∏Â∫îÁöÑÁº©ÊîæÂπ∂‰øùËØÅ‰∏çÂ§±Áúü. ÂíåBitmapDrawable‰ΩøÁî®‰∏ÄÊ†∑Áõ¥Êé•ÂºïÂÖ•ÂõæÁâáÂç≥ÂèØ. xmlÊñπÂºèÂ¶Ç‰∏ã: 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;nine-patch xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;xxxx&quot; android:dither=&quot;true&quot;/&gt; ShapeDrawableËøôÊòØ‰∏ÄÁßçÈÄöËøáÈ¢úËâ≤Êù•ÊûÑÊàêÁöÑÂõæÁâá, ÂÆÉÂèØ‰ª•‰∏∫Á∫ØËâ≤ÁöÑÂõæÂΩ¢, ‰πüÂèØ‰ª•ÂÖ∑ÊúâÊ∏êÂèòÁöÑÂõæÂΩ¢. ‰ª•‰∏ãÊòØ‰∏Ä‰∏™ÁÆÄÂçï‰ΩøÁî®ÊñπÊ≥ï 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;!--ÂúÜËßí--&gt; &lt;corners android:radius=&quot;50dp&quot;/&gt; &lt;padding android:top=&quot;5dp&quot;/&gt; &lt;!--Â°´ÂÖÖ--&gt; &lt;solid android:color=&quot;@color/colorPrimary&quot;/&gt; &lt;!--gradient Âíåsolid ‰∫íÊñ•Â±ûÊÄßË∞ÅÊîæÂú®ÂêéÈù¢Ë∞ÅÊâçÊúâÊïà--&gt; &lt;!--Ê∏êÂèò--&gt; &lt;gradient android:angle=&quot;90&quot; android:startColor=&quot;#f00&quot; android:centerColor=&quot;#0f0&quot; android:endColor=&quot;#00f&quot;/&gt; &lt;!--ËæπÊ°Ü--&gt; &lt;stroke android:width=&quot;30dp&quot; android:color=&quot;#ff0000&quot; /&gt;&lt;/shape&gt; Êù•ËØ¥ËØ¥ÂÖ∑‰ΩìÁöÑÂ±ûÊÄßÈÉΩÊúâ‰ªÄ‰πà shape: Ë°®Á§∫ÂõæÁâáÁöÑÂΩ¢Áä∂, ÊúâÂõõ‰∏™ÈÄâÈ°π: rectangle()Áü©ÂΩ¢, oval(Ê§≠ÂúÜ), line(Ê®™Á∫ø), ring(ÂúÜÁéØ). ÈªòËÆ§ÂÄº‰∏∫Áü©ÂΩ¢. Âè¶Â§ñlineÂíåringËøô‰∏§‰∏™ÈÄâÈ°πÂøÖÈ°ªË¶ÅÈÄöËøá&lt;stroke&gt;Ê†áÁ≠æÊù•ÊåáÂÆöÁ∫øÁöÑÂÆΩÂ∫¶ÂíåÈ¢úËâ≤Á≠â‰ø°ÊÅØ, Âê¶ÂàôÊó†Ê≥ïËææÂà∞È¢ÑÊúüÊïàÊûú.ÂΩìringËøô‰∏™ÂΩ¢Áä∂ËøòÈúÄË¶ÅÊ∑ªÂä†Âá†‰∏™Â±ûÊÄßinnerRadiusÂúÜÁéØÂÜÖÂçäÂæÑ, thicknessÂúÜÁéØÁöÑÂéöÂ∫¶,Â§ñÂçäÂæÑÂáèÂéªÂÜÖÂçäÂæÑÁöÑË∑ùÁ¶ª. ËøòÊúâ‰∏§‰∏™ÂçäÂàÜÊØîÁöÑÂ±ûÊÄß.ÊïàÊûú‰∏ÄÊ†∑. useLevel:Âü∫Êú¨ÈÉΩÊòØÁî®false, Âê¶ÂàôÂèØËÉΩÊó†Ê≥ïÂà∞ËææÈ¢ÑÊúüÁöÑÊòæÁ§∫ÊïàÊûú,Èô§ÈùûË¢´ÂΩìÂÅöLevelListDrawable.Â¶Ç‰∏ãÂõæÂèØ‰ª•ÁúãÁúãÂá†‰∏™ÊñπÂºèÁöÑÊ†∑Â≠ê &lt;corner&gt; Ë°®Á§∫shapeÁöÑÂõõ‰∏™ËßíÂ∫¶. ÂÆÉÂè™ÈÄÇÁî®‰∫éÁü©ÂΩ¢shape. ÊîØÊåÅÂ±ûÊÄßÊÄªÂÖ±Êúâ‰∫î‰∏™,‰∏Ä‰∏™RadiusÂíåÂõõ‰∏™È°∂ËßíÂ¶ÇtopLeftRadiusÁ≠âÁ≠â. RadiusÁöÑ‰ºòÂÖàÁ∫ßÊúÄ‰Ωé, ‰ºöË¢´ÂÖ∂‰ªñÂ±ûÊÄßË¶ÜÁõñ. &lt;gradient&gt; ÂÆÉ‰∏é&lt;solid&gt;Ê†áÁ≠æÊòØ‰∫íÁõ∏‰∫íÊñ•ÁöÑ. ÂÖ∂‰∏≠solidË°®Á§∫Á∫ØËâ≤Â°´ÂÖÖ, ËÄågradientÂàôË°®Á§∫Ê∏êÂèòÊïàÊûú. ÊúâÂ¶Ç‰∏ãÂ±ûÊÄß: android:angle ‚ÄìÊ∏êÂèòÁöÑËßíÂ∫¶, ÈªòËÆ§‰∏∫0, ÂÖ∂ÂÄºÂøÖÈ°ª‰∏∫45ÁöÑÂÄçÊï∞. 0Ë°®Á§∫‰ªéÂ∑¶Âà∞Âè≥, 90Ë°®Á§∫‰ªé‰∏ãÂà∞‰∏ä. android:centerX ‚ÄìÊ∏êÂèòÁöÑ‰∏≠ÂøÉÁÇπÊ®™ÂùêÊ†á(ËåÉÂõ¥0~1) android:centerY ‚ÄìÊ∏êÂèòÁöÑ‰∏≠ÂøÉÁÇπÁ∫µÂùêÊ†á(ËåÉÂõ¥0~1) android:startColor ‚ÄìÊ∏êÂèòÁöÑËµ∑ÂßãËâ≤ android:centerColor ‚ÄìÊ∏êÂèòÁöÑ‰∏≠Èó¥Ëâ≤ android:endColor ‚ÄìÊ∏êÂèòÁöÑÁªìÊùüËâ≤ android:gradientRadius ‚ÄìÊ∏êÂèòÂçäÂæÑ, ‰ªÖÂΩìandroid:type=‚Äùradial‚ÄùÊó∂ÊúâÊïà,Âπ∂‰∏îÂΩìtype=‚Äùradial‚ÄùÁöÑÊó∂ÂÄôÂøÖÈ°ªÂ£∞ÊòéÊ≠§Â±ûÊÄß,Âê¶ÂàôÂ¥©Ê∫É android:useLevel ‚Äì‰∏ÄËà¨‰∏∫false.ÂΩìDrawable‰Ωú‰∏∫StateListDrawable‰ΩøÁî®Êó∂‰∏∫true android:type ‚ÄìÊ∏êÂèòÁöÑÁ±ªÂûã, Êúâlinear(Á∫øÊÄßÊ∏êÂèò), radial(ÂæÑÂêëÊ∏êÂèò), sweep(Êâ´ÊèèÁ∫øÊ∏êÂèò)‰∏âÁßç, ÈªòËÆ§‰∏∫Á∫øÊÄßÊ∏êÂèò ÁúãÁúãtype‰∏çÂêåÁöÑÊ†ºÂºè‰ªÄ‰πàÊ†∑Â≠ê &lt;solid&gt;Ë°®Á§∫Á∫ØËâ≤Â°´ÂÖÖ, ÈÄöËøáandroid:colorÊù•ÊåáÂÆöÈ¢úËâ≤ &lt;stroke&gt; shapeÁöÑÊèèËæπ,ÊúâÂõõ‰∏™Â±ûÊÄß. widthÊèèËæπÁöÑÂÆΩÂ∫¶, colorÊèèËæπÁöÑÈ¢úËâ≤, dashWidthÁªÑÊàêËôöÁ∫øÁöÑÁ∫øÊÆµÁöÑÂÆΩÂ∫¶, dashGapÁªÑÊàêËôöÁ∫øÁöÑÁ∫øÊÆµ‰πãÈó¥ÁöÑÈó¥Èöî. &lt;padding&gt; Ëøô‰∏™Ë°®Á§∫Á©∫ÁôΩ, ‰ΩÜÊòØ‰ªñË°®Á§∫ÁöÑ‰∏çÊòØshapeÁöÑÁ©∫ÁôΩ, ËÄåÊòØÂåÖÂê´ÂÆÉÁöÑViewÁöÑÁ©∫ÁôΩ, Êúâ‰∏ä‰∏ãÂ∑¶Âè≥Âõõ‰∏™Â±ûÊÄß &lt;size&gt; DrawableÊúâ‰∏§‰∏™ÊñπÊ≥ïËé∑ÂæóÂõ∫ÊúâÈ´òÂ∫¶. getIntrinsicWidth(), getIntrinsicHeight(). Â∞±ÊòØÂ¶ÇÊûúÊòØÂõæÁâáDrawableÈÇ£Â∞±ÊòØÂõæÁâáÁöÑÂ±ûÊÄßÂ§ßÂ∞è. Â¶ÇÊûú‰∏çÊòØÈÇ£Â∞±ÊòØËøîÂõû-1. Â¶ÇÊûúsizeÊ†áÁ≠æËÆæÁΩÆ‰∫ÜÂ§ßÂ∞è. Âú®ÊñπÊ≥ïËøîÂõûÁöÑÊó∂ÂÄôÂ∞±‰∏çÂÜçÊòØ-1. ‰ΩÜÊòØ‰Ωú‰∏∫ViewÁöÑËÉåÊôØ, shapeËøò‰ºöË¢´Êãâ‰º∏ÊàñËÄÖÁº©‰∏∫ViewÁöÑÂ§ßÂ∞è. LayerDrawableÂØπÂ∫îÁöÑÊ†áÁ≠æÊòØ&lt;layer-list&gt;, ‰ªñË°®Á§∫‰∏Ä‰∏™Â±ÇÊ¨°ÂåñÂæóDrawableÈõÜÂêà.ÈÄöËøáÂ∞Ü‰∏çÂêåÁöÑDrawableÊîæÁΩÆÂú®‰∏çÂêåÁöÑÂ±ÇÈù¢‰∏ä‰ªéËÄåËææÂà∞‰∏ÄÁßçÂè†Âä†ÁöÑÊïàÊûú. ‰∏Ä‰∏™ËøôÁßçÊ†áÁ≠æÂèØ‰ª•ÂåÖÂê´Â§ö‰∏™item, ÊØè‰∏™itemË°®Á§∫‰∏Ä‰∏™Drawable. ItemÁöÑÁªìÊûÑÊØîËæÉÁÆÄÂçïÔºåÂ∏∏ËßÅÁöÑÊúâandroid:top„ÄÅandroid:bottom„ÄÅandroid:left„ÄÅandroid:rightÔºåË°®Á§∫DrawableÁõ∏ÂØπ‰∫éViewÁöÑ‰∏ä‰∏ãÂ∑¶Âè≥ÂÅèÁßªÈáè„ÄÇÂèØ‰ª•Áõ¥Êé•ÈÄöËøádrawableÂ±ûÊÄßÂºïÁî®‰∏Ä‰∏™Drawable‰πüÂèØ‰ª•Âú®item‰∏≠Ëá™ÂÆö‰πâ‰∏Ä‰∏™Drawable. 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#0ac39e" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="60dp"&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="1dp" android:left="1dp" android:right="1dp"&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; StateListDrawableStateListÂØπÂ∫î&lt;selector&gt;Ê†áÁ≠æ, ‰πüÊòØDrawableÈõÜÂêà. Ëøô‰∏™Êàë‰ª¨ÁªèÂ∏∏‰ΩøÁî®Âú®ÂºÄÂèë‰∏≠ÁöÑÊåâÈíÆÁä∂ÊÄÅÈÄâÊã©Âô®. 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize="true" android:dither="true" android:variablePadding="false" &gt; &lt;!-- Âè™ÊòØÂàó‰∏æ‰∏Ä‰∏ã &lt;item android:state_pressed="true" android:drawable="xxx"/&gt; &lt;item android:state_focused="true" android:drawable="xxx"/&gt; &lt;item android:state_hovered="true" android:drawable="xxx"/&gt; &lt;item android:state_pressed="true" android:drawable="xxx"/&gt; &lt;item android:state_selected="true" android:drawable="xxx"/&gt; &lt;item android:state_checkable="true" android:drawable="xxx"/&gt; &lt;item android:state_checked="true" android:drawable="xxx"/&gt; &lt;item android:state_enabled="true" android:drawable="xxx"/&gt; &lt;item android:state_activated="true" android:drawable="xxx"/&gt; &lt;item android:state_window_focused="true" android:drawable="xxx"/&gt; --&gt;&lt;/selector&gt; selectÊ†áÁ≠æÂØπÂ∫îÊúâ‰∏â‰∏™Â±ûÊÄß constantSize: Áî®‰∫éStateListDrawableÁöÑÂõ∫ÊúâÂ§ßÂ∞èÊòØÂê¶‰∏çÈöèÁùÄÂÖ∂Áä∂ÊÄÅÊîπÂèòËÄåÊîπÂèòÁöÑ, Âõ†‰∏∫Áä∂ÊÄÅÁöÑÊîπÂèò‰ºöÂàáÊç¢‰∏çÂêåÁöÑitemÁöÑdrawable, ËÄå‰∏çÂêåÁöÑdrawableÂÖ∑Êúâ‰∏çÂêåÁöÑÂõ∫ÊúâÂ§ßÂ∞è. Â¶ÇÊûú‰∏∫trueÈÇ£Â∞±ÊòØÊï¥‰∏™StateListDrawableÂõ∫ÊúâÂ§ßÂ∞èÊòØÂÜÖÈÉ®ÊâÄÊúâDrawableÁöÑÊúÄÂ§ßÂõ∫ÊúâÂ§ßÂ∞èÁöÑÂÄº. false‰ºöÈöè‰πãÂèòÂåñ, ÈªòËÆ§‰∏∫false dither: ÊòØÂê¶ÂºÄÂêØÊäñÂä®ÊïàÊûú, ÈªòËÆ§‰∏∫true variablePadding: Ë°®Á§∫paddingÊòØÂê¶ÈöèÁùÄÁä∂ÊÄÅÁöÑÊîπÂèòËÄåÊîπÂèò, paddingÂèñÂæóÂÄºÊòØÊâÄÊúâDrawableÁöÑÊúÄÂ§ßÂÄº. ÈªòËÆ§‰∏∫false. ‰∏ç‰ºöÈöè‰πãÊîπÂèò. &lt;item&gt;Ê†áÁ≠æ‰πüÊØîËæÉÁÆÄÂçï, ÊåáÂÆö‰∏Ä‰∏™drawable,Âπ∂Âä†‰∏Ä‰∏™Áä∂ÊÄÅÂà§Êñ≠ÂÄº. ‰∏ãÈù¢ÁªôÂá∫Â∏∏ËßÅÁöÑÁä∂ÊÄÅÂà§Êñ≠ Áä∂ÊÄÅ Âê´‰πâ android:state_pressed Ë°®Á§∫Êåâ‰∏ãÁä∂ÊÄÅ, ÊØîÂ¶ÇButtonË¢´Êåâ‰∏ãÂêéÊ≤°ÊúâÊùæÂºÄÊó∂ÁöÑÁä∂ÊÄÅ android:state_focused Ë°®Á§∫ViewÂ∑≤ÁªèËé∑Âèñ‰∫ÜÁÑ¶ÁÇπ android:state_selected Ë°®Á§∫Áî®Êà∑ÈÄâÊã©‰∫ÜView android:state_checked Ë°®Á§∫Áî®Êà∑ÈÄâ‰∏≠‰∫ÜView, ‰∏ÄËà¨ÈÄÇÁî®‰∫éCheckBoxËøôÁ±ªÂú®ÈÄâ‰∏≠ÂíåÈùûÈÄâ‰∏≠‰πãÈó¥ÂàáÊç¢ÁöÑ android:state_enabled Ë°®Á§∫ViewÂΩìÂâçÊòØÂê¶ÂèØÁî® ÈªòËÆ§Áä∂ÊÄÅÁöÑ‰∏ÄÂÆöË¶ÅÊîæÂú®ÊúÄÂêé‰∏ÄÊù°, Âõ†‰∏∫Á≥ªÁªüÊòØÊåâÁÖß‰ªé‰∏äÂà∞‰∏ãÁöÑÈ°∫Â∫èÊü•Êâæ. Âè™Ë¶ÅÊâæÂà∞‰ªª‰Ωï‰∏Ä‰∏™ÂåπÈÖçÁä∂ÊÄÅÁöÑÈÇ£‰πà‰πÖÁªìÊùü‰∫Ü. LevelListDrawableLevelListDrawableÂØπÂ∫î‰∫é&lt;level-list&gt;Ê†áÁ≠æ, ‰πüË°®Á§∫‰∏Ä‰∏™DrawableÈõÜÂêà, ÈõÜÂêà‰∏≠ÊØè‰∏Ä‰∏™DrawableÈÉΩÊúâ‰∏Ä‰∏™Á≠âÁ∫ßÁöÑÊ¶ÇÂøµ, Ê†πÊçÆ‰∏çÂêåÁöÑÁ≠âÁ∫ßLevelListDrawable‰ºöÂàáÊç¢‰∏çÂêåÁöÑÂØπÂ∫îÁöÑDrawable. 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_sample" android:maxLevel="2" android:minLevel="2"/&gt; &lt;item android:drawable="@mipmap/ic_launcher" android:maxLevel="1" android:minLevel="1" /&gt;&lt;/level-list&gt; ËøôÈáåÂ∞±Áõ∏ÂΩì‰∫éÁªôÊØè‰∏Ä‰∏™DrawableËÆæÂÆö‰∏Ä‰∏™Ê†áËØÜ. level-list‰ºöÊ†πÊçÆËøô‰∏™Ê†áËØÜÂéªËá™Â∑±ÁöÑitem‰∏≠Êü•Êâæ. ÈªòËÆ§Á≠âÁ∫ß‰∏∫0, LevelÁöÑÂèñÂÄºÂú®0~10000. Âú®ÁªôÊØè‰∏™ItemÂ£∞ÊòéÁ≠âÁ∫ßÁöÑÊó∂ÂÄôÂ∞ΩÈáèÊúÄÂ§ßÂíåÊúÄÂ∞èÁ≠âÁ∫ß‰øùÊåÅ‰∏ÄËá¥. ËÆ©ÊØè‰∏™itemÈÉΩÂèØ‰ª•Êúâ‰∏Ä‰∏™ÂîØ‰∏ÄÊ†áËØÜÁ≠âÁ∫ß, ËÄåÈÅøÂÖçÊúâ‰∏Ä‰∫õÂÖ¨ÂÖ±Êã•ÊúâÁ≠âÁ∫ßÁöÑItemÂØºËá¥Âá∫Áé∞ÂíåÊàë‰ª¨È¢ÑÊúüÁöÑ‰∏çÁ¨¶. Â¶ÇÊûú‰Ωú‰∏∫‰∫ÜËÉåÊôØ, ÈÇ£‰πàËé∑ÂæóDrawableÂØπË±°ÈÄöËøágetLevel(), setLevel()Êù•ÂæóÂà∞ÂíåËÆæÁΩÆ‰∏çÂêåÁöÑÁ≠âÁ∫ßÂÅöÂà∞ÂàáÊç¢ÂõæÁâáÁöÑÊïàÊûú. Â¶ÇÊûúÊòØImageViewÈÇ£‰πàÈÄöËøásetImageLevel()ÂâçÊôØËÆæÁΩÆÂÖ∂Á≠âÁ∫ßÂ∞±ÂèØ‰ª•,‰∏ÄÂÆöÂà´Âøò‰∫ÜÊääDrawableËÆæÁΩÆÂâçÊôØÂÜçÈÄöËøáËøôÁßçÊñπÂºèÂÆûÁé∞. TransitionDrawableÂØπÂ∫îÁùÄ&lt;transition&gt;Ê†áÁ≠æ, ÂÆÉÁî®‰∫éÂÆûÁé∞‰∏§‰∏™Drawable‰πãÈó¥ÁöÑÊ∑°ÂÖ•Ê∑°Âá∫ÊïàÊûú. 1234567&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_sample"/&gt; &lt;item android:drawable="@mipmap/ic_launcher"/&gt;&lt;/transition&gt; 12 TransitionDrawable drawable = (TransitionDrawable) iv_main.getBackground();drawable.startTransition(5000); Ëøô‰∏™Ê≤°‰ªÄ‰πàÂ•ΩËØ¥ÁöÑ‰∫Ü, ÂæàÁÆÄÂçï. Ê≥®ÊÑè‰∏Ä‰∏ãÂ¶ÇÊûúÊòØÁªôImageViewËÆæÁΩÆÂâçÊôØÁöÑËØùÈÇ£‰πà‰∏çË¶ÅÁî®getBackground()Êù•Ëé∑Âèñ‰∫Ü,ÈÄöËøágetDrawable()Êù•Ëé∑Âèñ. InsetDrawableInsetDrawableÂØπÂ∫î&lt;inset&gt;Ê†áÁ≠æ, ÂÆÉÂèØ‰ª•Â∞ÜÂÖ∂‰ªñDrawableÂÜÖÂµåÂà∞Ëá™Â∑±ÂΩì‰∏≠, Âπ∂ÂèØ‰ª•Âú®ÂõõÂë®ÁïôÂá∫‰∏ÄÂÆöÁöÑË∑ùÁ¶ª. ÂΩì‰∏Ä‰∏™ViewÂ∏åÊúõËá™Â∑±ÁöÑËÉåÊôØÊØîËá™Â∑±ÁöÑÂÆûÈôÖÂå∫ÂüüÂ∞èÁöÑÊó∂ÂÄô, ÂèØ‰ª•‰ΩøÁî®Ëøô‰∏™Êù•ÂÆûÁé∞.(Áõ∏ÂΩì‰∫éÁªô‰ΩøÁî®ÁöÑViewÂ¢ûÂä†‰∫ÜmarginÊïàÊûú) LayerDrawable‰πüÂèØ‰ª•ÂÆûÁé∞Ê≠§ÊïàÊûú 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:insetBottom="20dp" android:insetTop="50dp" android:insetRight="20dp" android:insetLeft="20dp"&gt; &lt;shape &gt; &lt;solid android:color="#ffff00"/&gt; &lt;/shape&gt;&lt;/inset&gt; ScaleDrawableScaleDrawableÂØπÂ∫î&lt;scale&gt;Ê†áÁ≠æ, ‰ªñÂèØ‰ª•Ê†πÊçÆËá™Â∑±ÁöÑÁ≠âÁ∫ßlevelÂ∞ÜÂà∂ÂÆöÁöÑDrawableÁº©ÊîæÂà∞‰∏ÄÂÆöÊØî‰æã. 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@mipmap/ic_sample" android:scaleHeight="10%" android:scaleWidth="10%" android:scaleGravity="center"&gt;&lt;/scale&gt; Âπ∂Âú®‰ª£Á†Å‰∏≠ËÆæÁΩÆÁ≠âÁ∫ß, ÈªòËÆ§‰∏∫0ÊòØ‰∏çÊòæÁ§∫ScaleDrawable 12ScaleDrawable drawable = (ScaleDrawable) findViewById(R.id.activity_main).getBackground();drawable.setLevel(1); ÂÖ∂‰∏≠scaleHeightÂíåscaleWidthÈúÄË¶ÅÁöÑÊòØÁôæÂàÜÊØîÂÄº. ÊúâÁÇπÂà´Êâ≠, Â¶ÇÊûú‰Ω†ËÆæÁΩÆ‰∫Ü10%, ÈÇ£‰πàÂÆûÈôÖÁöÑÊÑè‰πâÂ∞±ÊòØÁº©Êîæ‰∫ÜÂéüÂ§ßÂ∞èÁöÑ10%, Áõ∏ÂΩì‰∫éÂéªÊéâ‰∫ÜËÆæÁΩÆÁöÑÂÄº. ÊúÄÁªàÂëàÁé∞Âá∫Êù•ÁöÑÊòØ1-ËÆæÂÆöÁöÑÁôæÂàÜÊØî. Â∞±ÊòØÂ±ïÁé∞‰∫Ü90%. ËÄåËÆæÁΩÆÁöÑÁ≠âÁ∫ß‰ºöÂΩ±ÂìçÊúÄÁªàÁöÑÂõæÁâáÂ§ßÂ∞è, Á≠âÁ∫ßË∂äÂ§ßÂõæÁâáË∂äÂ§ß. ÊúÄÂ•ΩÁ≠âÁ∫ßÊéßÂà∂Âà∞0~10000 ÊúÄÂêé. ClipDrawableClipDrawableÂØπÂ∫î‰∫é&lt;clip&gt;Ê†áÁ≠æ, ‰ªñÂèØ‰ª•Ê†πÊçÆËá™Â∑±ÂΩìÂâçÁöÑÁ≠âÁ∫ßÊù•Ë£ÅÂâ™Drawable, Ë£ÅÂâ™ÁöÑÊñπÂêëÈÄöËøáandroid:clipOrientationÂíåandroid:gravityËøô‰∏§‰∏™Â±ûÊÄßÊù•ÂÖ±ÂêåÊéßÂà∂. 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;clip xmlns:android="http://schemas.android.com/apk/res/android" android:clipOrientation="horizontal" android:drawable="@mipmap/ic_sample" android:gravity="center"&gt;&lt;/clip&gt; È¶ñÂÖàandroid:clipOrientation Â¶ÇÊûúÂèÇÊï∞Ê∑ªÂä†Ê∞¥Âπ≥ horizontal. ÂÆûÈôÖ‰∏äÊòØÁ´ñÁõ¥ÂàáÂâ≤, ‰øùÁïôÂûÇÁõ¥ÊñπÂêëÁöÑÂÆåÊï¥. Â¶ÇÊûúÊòØVerticalÂèç‰πã. ÁúãÂõæÂêß. ËÄågravityÊúâÁöÑÂ±ûÊÄßÂíåBitmapDrawable‰∏≠ÁöÑgravity‰∏ÄÊ†∑. ËøôÈáåÁé∞Âú®ÊòØandroid:clipOrientation=&quot;horizontal&quot;ÂÆÉÊòØ‰ª•Ê∞¥Âπ≥ÊñπÂêëÂÅöÁöÑÂûÇÁõ¥ÂàáÂâ≤. ÈÇ£‰πàÈÄöËøáÁªôgravityËÆæÁΩÆÂ∑¶ ‰∏≠ Âè≥Â∞±ÊòØleft, center, rightÂèØ‰ª•ËææÂà∞‰∏çÂêåÁöÑÊïàÊûú. Â¶ÇÂõæ ÈáçË¶ÅÁöÑ‰∏ÄÁÇπËøòÊúâÂä®ÊÄÅ‰ª£Á†ÅËÆæÁΩÆÁ≠âÁ∫ß, Ë¶ÅÊòØ‰∏çËÆæÁΩÆÁ≠âÁ∫ßÂ∞±ÊòØÈªòËÆ§ÁöÑ0, 0Â∞±ÊòØÂàáÂâ≤Êéâ100%ÁöÑÈÉ®ÂàÜ,ÊâÄ‰ª•Ââ©‰∏ãÁöÑÈÉ®‰Ωç‰∏∫0‰πüÂ∞±ÊòØÁ©∫ÁöÑ 12ClipDrawable drawable = (ClipDrawable) findViewById(R.id.activity_main).getBackground();drawable.setLevel(5000); Ëøô‰∏™Á≠âÁ∫ßÁöÑÊï∞ËøòÊòØ1~10000. Á≠âÁ∫ß‰∏∫0ÈÇ£‰πàÊÑèÂë≥ÁùÄË£ÅÂâ™DrawableÁöÑ100%ÈÉ®ÂàÜ. ‰ªÄ‰πà‰∏úË•øÊ≤°Êúâ.Á©∫ÁöÑ Á≠âÁ∫ß‰∏∫5000ÈÇ£‰πàÊÑèÂë≥ÁùÄË£ÅÂâ™DrawableÁöÑ50%ÈÉ®ÂàÜ, Êàë‰∏äÈù¢ÁöÑÊºîÁ§∫ÁöÑÂõæÁâáÈÉΩÊòØ‰ª•Á≠âÁ∫ß‰∏∫5000‰∏∫Ê†áÂáÜÊµãËØïÁöÑ Á≠âÁ∫ß‰∏∫10000ÈÇ£‰πàÂ∞±ÊÑèÂë≥ÁöÑË£ÅÂâ™ÈÉ®ÂàÜ‰∏∫DrawableÁöÑ100%ÈÉ®ÂàÜ, ‰πüÂ∞±ÊòØÂÆåÂÖ®ÊòæÁ§∫‰∫Ü. ÂèØ‰ª•ÁúãÂá∫Êù•‰∫Ü, ÁªºÂêà‰∏äÈù¢ÁöÑÁúãÂá∫, ‰∏äÈù¢ÁöÑgravityÁöÑÊñπÂêëÂèØ‰ª•ËÆ§‰∏∫ÊòØ‰ªéÈÇ£ËæπÂºÄÂßãËøõË°åË£ÅÂâ™‰øùÁïô. Ëá™ÂÆö‰πâDrawable‰∏ÄËà¨DrawableÈÉΩÊòØ‰Ωú‰∏∫ViewÁöÑËÉåÊôØÂõæ, ÊàñËÄÖImageViewÁöÑÊòæÁ§∫ÂõæÁâá. ÂÖ∂Â∑•‰ΩúÂéüÁêÜÊ†∏ÂøÉÂ∞±ÊòØdraw()ÊñπÊ≥ï. ËÄåÁ≥ªÁªü‰ºöË∞ÉÁî®DrawableÁöÑdraw()Êù•ÁªòÂà∂ViewÁöÑËÉåÊôØ, ÊâÄ‰ª•Êàë‰ª¨ÈÄöËøáÈáçÂÜôdraw()Êù•ÂÆûÁé∞Ëá™ÂÆö‰πâDrawable. ‰∏ÄËà¨draw(), setAlpha(), setColorFilter(), ÂíågetOpacity()ÈÉΩÊòØË¶ÅÂÆûÁé∞ÁöÑ , draw()ÈáåÈù¢ÁöÑÂÖ∑‰ΩìÂÆûÁé∞ÂíåÊàë‰ª¨ViewÁöÑonDraw()ÂæàÁõ∏‰ºº. ÂèØ‰ª•ÂèÇËÄÉShapeDrawableÂíåBitmapDrawableÁöÑÊ∫êÁ†ÅÂéª‰ªøÈÄ†ÂÆûÁé∞. Âú®Ëá™ÂÆö‰πâÁöÑÊó∂ÂÄôÊ≥®ÊÑè: Â¶ÇÊûúË¶ÅÂÆö‰πâÁöÑDrawableÊúâÂõ∫ÊúâÁöÑÂ§ßÂ∞èÂÄº, ÈÇ£‰πàÊúÄÂ•ΩÈáçÂÜôgetIntrinsicWidth()ÂíågetIntrinsicHeight()Ëøô‰∏§‰∏™ÊñπÊ≥ï. Âõ†‰∏∫ÂÆÉ‰ºöÂΩ±ÂìçÂà∞ViewÁöÑwrap_contentÂ∏ÉÂ±Ä. ÊúÄÂêéÂÜÖÈÉ®Â§ßÂ∞è‰∏ç‰∏ÄÂÆöÁ≠â‰∫éDrawableÁöÑÂÆûÈôÖÂ§ßÂ∞è, DrawableÂÆûÈôÖÂ§ßÂ∞èÂèØ‰ª•ÈÄöËøágetBound()Êù•Ëé∑Âèñ.]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>Drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ÁêÜËß£RemoteViews]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%90%86%E8%A7%A3RemoteViews%2F</url>
    <content type="text"><![CDATA[RemoteViewÁöÑÂ∫îÁî®ÁÆÄ‰ªã:Âú®ÂºÄÂèë‰∏≠, ÈÄöÁü•Ê†èÈÉΩÁü•ÈÅìÊòØÈÄöËøáNotificationManagerÁöÑnotifyÊñπÊ≥ïÂÆûÁé∞. Ê°åÈù¢Â∞èÈÉ®‰ª∂ÂàôÊòØÈÄöËøáAppWidgetProviderÂÆûÁé∞. ÂêéËÄÖÊú¨Ë¥®‰∏äÊòØ‰∏Ä‰∏™ÂπøÊí≠.Êõ¥Êñ∞‰ªñ‰ª¨Êó†Ê≥ïÂÉè‰ª•ÂâçÈÇ£Ê†∑.ËøôÊòØÂõ†‰∏∫‰∏çÊòØ‰∏Ä‰∏™ËøõÁ®ã,Â∞èÈÉ®‰ª∂ÊòØSystemServerËøõÁ®ã. ‰∏∫‰∫ÜË∑®ËøõÁ®ãÊõ¥Êñ∞ÁïåÈù¢,RemoteViewsÊèê‰æõ‰∫Ü‰∏ÄÁ≥ªÂàóÁöÑsetÊñπÊ≥ï‚Ä¶ RemoteViewsÈÄöÁü•Ê†èÁöÑÂ∫îÁî®ÂÖà‰ΩøÁî®Á≥ªÁªüÈªòËÆ§ÁöÑÊ†∑Âºè. ‚Äì! ÂÖà‰∏çËÆ∞ÂΩïnotification‰∫Ü. ÂèëÁé∞‰π¶‰∏äÁöÑÊñπÊ≥ïÂú®ÁºñËØëÁéØÂ¢É23ÁâàÊú¨‰ª•‰∏äÊó†Êïà. 23‰ª•‰∏ãÊòØÊ≤°ÊúâÈóÆÈ¢òÁöÑ.notification.setLatestEventInfo()Ê≠§ÊñπÊ≥ïÂ∑≤ÁªèË¢´Âà†Èô§‰∫Ü. Ë¥¥Âá∫Ëá™ÂÆö‰πâÂ∏ÉÂ±ÄÈÄöÁü•Ê†è‰ª£Á†ÅÂà©Áî®remoteViews 123456789101112131415161718192021222324252627/** * ÊâìÂºÄËá™ÂÆö‰πâÂ∏ÉÂ±ÄÁöÑÈÄöÁü•Ê†è */private void displayRemoteViews() &#123; Notification notification = new Notification(); notification.icon = R.mipmap.ic_launcher; notification.tickerText = "ÊàëÊòØÂ∞èÈÉ®‰ª∂"; notification.when = System.currentTimeMillis(); notification.flags = Notification.FLAG_AUTO_CANCEL; Intent intent = new Intent(getApplicationContext(), MainActivity.class); PendingIntent pedingIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); RemoteViews remoteViews = new RemoteViews(getPackageName(), R.layout.layout_notification); remoteViews.setTextViewText(R.id.tv_msg, "ÊàëÊòØÊñáÂ≠ó‰ø°ÊÅØ"); remoteViews.setImageViewResource(R.id.iv_icon, R.mipmap.favicon); notification.contentView = remoteViews; notification.contentIntent = pedingIntent; PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, OpenActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); remoteViews.setOnClickPendingIntent(R.id.tv_open, openActivity2PendingIntent); NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); manager.notify(2, notification);&#125; ‰º†ÂÖ•‰∫Ü‰∏Ä‰∏™Ëá™ÂÆö‰πâÂ∏ÉÂ±ÄÈáåÈù¢Êúâ‰∏Ä‰∏™imageView‰∏§‰∏™textView. Â¶Ç‰∏ãÂõæ: RemoteViewÂú®Ê°åÈù¢Â∞èÈÉ®‰ª∂‰∏äÁöÑÂ∫îÁî®AppWidgetProviderÊòØÁ≥ªÁªüÊèê‰æõÁöÑÁî®‰∫éÂÆûÁé∞Ê°åÈù¢Â∞èÈÉ®‰ª∂ÁöÑÁ±ª, ÁªßÊâøBroadcaseReceiver.ÂèØ‰ª•ÂΩìÊàêÂπøÊí≠ÁêÜËß£. Ê°åÈù¢Â∞èÈÉ®‰ª∂ÁöÑÂºÄÂèëÊ≠•È™§ 1.ÂÆö‰πâÂ∞èÈÉ®‰ª∂ÁïåÈù¢ Âú®ÂàõÂª∫‰∏Ä‰∏™Â∏ÉÂ±ÄxmlÂΩìÂÅöËøô‰∏™Â∞èÈÉ®‰ª∂Ë¶ÅÂ±ïÁ§∫ÁöÑÊ†∑Â≠ê 2.ÂÆö‰πâÂ∞èÈÉ®‰ª∂ÈÖçÁΩÆ‰ø°ÊÅØ Âú®res/xmlÊñá‰ª∂Â§π‰∏ãÊñ∞Âª∫‰∏Ä‰∏™xxx_info.xmlÁöÑÊñá‰ª∂ 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android" android:initialLayout="@layout/layout_widget" android:minHeight="100dp" android:minWidth="100dp" android:updatePeriodMillis="60000" &gt;&lt;/appwidget-provider&gt; initiaLayout: Â∞èÂ∑•ÂÖ∑ÊâÄË¶Å‰ΩøÁî®ÁöÑÂàùÂßãÂåñÂ∏ÉÂ±Ä minHeight``minWidth: ÊåáÂÆöÂ∞èÂ∑•ÂÖ∑ÁöÑÂ∞∫ÂØ∏ updatePeriodMillis: Ëá™Âä®Âà∑Êñ∞ÁöÑÊó∂Èó¥, Âçï‰ΩçÊØ´Áßí 3.ÂÆö‰πâÂ∞èÈÉ®‰ª∂ÁöÑÂÆûÁé∞Á±ª 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Created by suzeyu on 16/8/11. * ÂÆö‰πâÂ∞èÈÉ®‰ª∂ÁöÑÂÆûÁé∞Á±ª */public class MyAppWidgetProvider extends AppWidgetProvider &#123; public static final String TAG = MyAppWidgetProvider.class.getName(); public static final String CLICK_ACTION = "com.szysky.note.androiddevseek_05.action.CLICK"; @Override public void onReceive(final Context context, Intent intent) &#123; super.onReceive(context, intent); Log.i(TAG, "onReceive: Êé•Êî∂Âà∞ÂπøÊí≠--&gt;"+intent.getAction()); //ÊòØËß¶ÂèëÁöÑËá™Â∑±ÁÇπÂáªÊó∂ÂèëÈÄÅÁöÑactionÈÇ£‰πàÂ∞±ËÆ©Â∞èÈÉ®‰ª∂ÊóãËΩ¨ if (intent.getAction().equals(CLICK_ACTION))&#123; Toast.makeText(context, "ÂáÜÂ§áÊóãËΩ¨", Toast.LENGTH_SHORT).show(); AsyncTask.execute(new Runnable() &#123; @Override public void run() &#123; Bitmap srcBmp = BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon); AppWidgetManager widgetManager = AppWidgetManager.getInstance(context); for (int i = 0; i &lt; 37; i++) &#123; float degree = (i * 10) % 360; RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, rotateBmp(context, srcBmp, degree)); if (i==36)&#123; Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent peddingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, peddingIntent); &#125; widgetManager.updateAppWidget(new ComponentName(context, MyAppWidgetProvider.class), remoteViews); SystemClock.sleep(50); &#125; &#125; &#125;); &#125; &#125; /** * ÊóãËΩ¨‰∏Ä‰∏™bitmap */ private Bitmap rotateBmp(Context context, Bitmap srcBmp, float degree) &#123; Matrix matrix = new Matrix(); matrix.reset(); matrix.setRotate(degree); return Bitmap.createBitmap(srcBmp, 0, 0, srcBmp.getWidth(), srcBmp.getHeight(), matrix, true); &#125; /** * ÂΩìËá™ÂÆö‰πâÁöÑÂ∞èÊ°åÈù¢Ë¢´Ê∑ªÂä† Ëøô‰∏™ÊñπÊ≥ïÂè™ÊúâÂú®Êú¨ÂÆû‰æã‰∏≠Âè™ÊúâË¢´Ê∑ªÂä†ÁöÑÊó∂ÂÄôÊâçË∞ÉÁî® */ @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; super.onUpdate(context, appWidgetManager, appWidgetIds); final int counter = appWidgetIds.length; Log.i(TAG, "Â∞èÊ°åÈù¢Êõ¥Êñ∞‰∫Ü counter="+counter); for (int i = 0; i &lt; counter; i++) &#123; int appWidgetID = appWidgetIds[i]; onWidgetUpdate(context, appWidgetManager, appWidgetID); &#125; &#125; /** * Ê°åÈù¢Â∞èÈÉ®‰ª∂Êõ¥Êñ∞ Ëøô‰∏™ÊñπÊ≥ïÂè™ÊúâÂú®Êú¨ÂÆû‰æã‰∏≠Âè™ÊúâË¢´Ê∑ªÂä†ÁöÑÊó∂ÂÄôÊâçË∞ÉÁî® */ private void onWidgetUpdate(Context context, AppWidgetManager appWidgetManager, int appWidgetID) &#123; Log.i(TAG, "onWidgetUpdate: id=="+appWidgetID); RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon)); Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, pendingIntent); appWidgetManager.updateAppWidget(appWidgetID, remoteViews); &#125;&#125; Áõ¥Êé•ËØ¥Áî®ÈÄîÊää, Â∞èÈÉ®‰ª∂Ë¢´Ê∑ªÂä†Âà∞Ê°åÈù¢ÁöÑÊó∂ÂÄô, ‰ºöÂÖàËµ∞onUpdate()ÂõûË∞É,Ëøô‰∏™Êó∂ÂÄôÊâßË°åÊñπÊ≥ïÈÄöËøáRemoteViews()ÊûÑÂª∫‰∏Ä‰∏™Â∏ÉÂ±Ä,Âπ∂Êõ¥Êñ∞Ê°åÈù¢‰∏äÊñ∞ÁöÑÂ∏ÉÂ±ÄÂíåËÆæÁΩÆ‰∫ÜÁÇπÂáª‰∫ã‰ª∂,ÁÑ∂ÂêéËµ∞onReceive() . Â¶ÇÊûúÂΩìÊàë‰ª¨ÁÇπÂáªÁöÑÂ∞èÈÉ®‰ª∂ÁöÑÊó∂ÂÄô, ‰ºöËß¶ÂèëÂπøÊí≠‰∏≠ÁöÑonReceive()ÁÑ∂ÂêéËøõË°åÂõæÁâáÁöÑÊóãËΩ¨.ËøôÂ∞±ÊòØ‰∏äËø∞‰ª£Á†ÅÁöÑÂ§ß‰ΩìÊµÅÁ®ã. 4.ÊúÄÂêéË¶ÅÂú®Ê∏ÖÂçïÊñá‰ª∂‰∏≠Â£∞ÊòéÂ∞èÈÉ®‰ª∂ 12345678910&lt;receiver android:name=".MyAppWidgetProvider"&gt; &lt;meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_provider_info"/&gt; &lt;intent-filter&gt; &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE"/&gt; &lt;action android:name="com.szysky.note.androiddevseek_05.action.CLICK"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; Á¨¨‰∏Ä‰∏™actionÂàôÊòØ‰Ωú‰∏∫Â∞èÈÉ®‰ª∂ÁöÑË°®Á§∫ËÄåÂøÖÈ°ªÂ≠òÂú®ÁöÑ. Á¨¨‰∫å‰∏™actionÂ∞±ÊòØË¶ÅËØÜÂà´ËÆæÂÆöÁöÑÂçïÂáªË°å‰∏∫. ÁÑ∂ÂêéÂ∞±ÂèØ‰ª•Âú®‰∏ªÂ±èÂπï‰∏äÈïøÊåâÊ∑ªÂä†Â∞èÈÉ®‰ª∂Êü•ÁúãÊïàÊûú‰∫Ü Â´åÈ∫ªÁÉ¶Â∞±Áõ¥Êé•Êâ£‰ª£Á†Å,ËøôÊòØÈìæÊé• AppWidgetProviderËøô‰∏™Á±ªËøòÊúâÂÖ∂‰ªñÁîüÂëΩÂë®ÊúüÁöÑÂõûË∞É, ÂÖ∂ÂÆûÂ∞±ÊòØÂΩìÂπøÊí≠Âà∞Êù•‰πãÂêé, AppWidgetProvider‰ºöËá™Âä®Ê†πÊçÆÂπøÊí≠ÁöÑActionÈÄöËøáonReceive()Êù•Ëá™Âä®ËøõË°åÂàÜÂèëÂπøÊí≠. onEnable(): ÂΩìËØ•Á™óÂè£Â∞èÈÉ®‰ª∂Á¨¨‰∏ÄÊ¨°Ê∑ªÂä†Âà∞Ê°åÈù¢Êó∂Ë∞ÉÁî®ËØ•ÊñπÊ≥ï, ÂèØÊ∑ªÂä†Â§öÊ¨°‰ΩÜÂè™Âú®Á¨¨‰∏ÄÊ¨°Ë∞ÉÁî®. onUpdate(): Â∞èÈÉ®‰ª∂Ë¢´Ê∑ªÂä†Êó∂ÊàñËÄÖÊØèÊ¨°Â∞èÈÉ®‰ª∂Êõ¥Êñ∞Êó∂ÈÉΩ‰ºöË∞ÉÁî®‰∏ÄÊ¨°ËØ•ÊñπÊ≥ï, Â∞èÈÉ®‰ª∂ÁöÑÊõ¥Êñ∞Êó∂Êú∫Áî±updatePeriodMillisÊù•ÊåáÂÆö, ÊØè‰∏™Âë®ÊúüÂ∞èÈÉ®‰ª∂ÈÉΩ‰ºöËá™Âä®Êõ¥Êñ∞‰∏ÄÊ¨°. onDeleted(): ÊØèÂà†Èô§‰∏ÄÊ¨°Â∞èÈÉ®‰ª∂Â∞±‰ºöË∞ÉÁî®‰∏ÄÊ¨°. onReceive(): ËøôÊòØÂπøÊí≠ÁöÑÂÜÖÁΩÆÊñπÊ≥ï, Áî®‰∫éÂàÜÂèëÂÖ∑‰ΩìÁöÑ‰∫ã‰ª∂ÁªôÂÖ∂‰ªñÊñπÊ≥ï. ‰∏ãÈù¢Â∞±ÊòØÂàÜÊûê‰∫Ü PendingIntentÊ¶ÇËø∞PendingIntentÂíåIntentÁöÑÂå∫Âà´: PendingIntent: Á≠âÂæÖÊÑèÂõæ, Êúâ‰∏Ä‰∏™IntentÂ∞ÜÂú®Êüê‰∏™ÂæÖÂÆöÁöÑÊó∂ÂàªÂèëÁîü. Intent: ÊòØÁ´ãÂàªÂèëÁîü. ‰ΩøÁî®Âú∫ÊôØ ÊúÄÂÖ∏ÂûãÁöÑÂ∞±ÊòØÁªôRemoteViewsÊ∑ªÂä†ÂçïÂáª‰∫ã‰ª∂, Âõ†‰∏∫RemoteViewsËøêË°åÂú®ËøúÁ®ãËøõÁ®ã‰∏≠, Âõ†Ê≠§RemoteViews‰∏çÂêå‰∫éÊôÆÈÄöÁöÑView, ÊâÄ‰ª•Êó†Ê≥ïÁõ¥Êé•ÂêëViewÈÇ£Ê†∑ÈÄöËøásetOnClickListener()ÊñπÊ≥ïÈÇ£Ê†∑ËÆæÁΩÆÂçïÂáª‰∫ã‰ª∂. Ë¶ÅÊÉ≥ÁªôRemoteViewsËÆæÁΩÆÂçïÂáª‰∫ã‰ª∂, Â∞±ÂøÖÈ°ª‰ΩøÁî®PendingIntent, PendingIntentÈÄöËøásend()Âíåcancel()Êù•ÂèëÈÄÅÂíåÂèñÊ∂àÁâπÂÆöÁöÑÂæÖÂÆöIntent. PendingIntentÊîØÊåÅ‰∏âÁßçÂæÖÂÆöÊÑèÂõæ: ÂêØÂä®Activity, ÂêØÂä®Service, ÂíåÂèëÈÄÅÂπøÊí≠ ÂØπÂ∫îÁùÄPendingIntent‰∏â‰∏™ÈùôÊÄÅÊñπÊ≥ï getActivity(),getService(), getBroadCast(). ÂΩìËøô‰∏âÁßçÊñπÊ≥ïËøîÂõûÁöÑPendingIntentÂæÖÂÆöÊÑèÂõæÂèëÁîüÊó∂ÂÄô, ÂØπÂ∫îÁöÑÊïàÊûúÂ∞±ÊòØÊàë‰ª¨Êó•Â∏∏ÂºÄÂêØËøô‰∏âÂ§ßÁªÑ‰ª∂ÁöÑÊÉÖÂΩ¢. ‰∏äËø∞‰∏â‰∏™ÊñπÊ≥ïÈÉΩÈúÄË¶ÅÂõõ‰∏™ÂèÇÊï∞. ÈúÄË¶ÅËØ¥‰∏Ä‰∏ãÁ¨¨‰∫å‰∏™ÂèÇÊï∞requestCodeÂíåÁ¨¨Âõõ‰∏™ÂèÇÊï∞flags. ÂÖ∂‰∏≠requestCodeË°®Á§∫PendingIntentÂèëÈÄÅÊñπÁöÑËØ∑Ê±ÇÁ†Å, Â§öÊï∞ÊÉÖÂÜµ‰∏ãËÆæ‰∏∫0Âç≥ÂèØ, Âè¶Â§ñrequestCode‰ºöÂΩ±ÂìçÂà∞flagsÁöÑÊïàÊûú. flags: Â∏∏Áî®ÁöÑÁ±ªÂûãÊúâ: FLAG_ONE_SHOT, FLAG_UPDATE_CURRENT, FLAG_NO_CREATE, FLAG_CANCEL_CURRENT. Âú®Ê≠§‰πãÂâçÈ¶ñÂÖàË¶ÅÊòéÁ°Æ‰∏Ä‰∏™Ê¶ÇÂøµ, PendingIntentÁöÑÂåπÈÖçËßÑÂàô, Âú®‰ªÄ‰πàÊÉÖÂÜµ‰∏ã‰∏§‰∏™PendingIntentÊòØÁõ∏ÂêåÁöÑ. PendingIntentÂåπÈÖçËßÑÂàô: Â¶ÇÊûú‰∏§‰∏™PendingIntentÁöÑÂÜÖÈÉ®IntentÁõ∏ÂêåÂπ∂‰∏îrequestCode‰πüÁõ∏ÂêåÈÇ£‰πàËøô‰∏§‰∏™PendingIntentÂ∞±ÊòØÊÉ≥ÂêåÁöÑ. requestCodeÊòØintÂÄº‰∏çÈúÄË¶ÅËß£Èáä. ËÄåIntentÂåπÈÖçËßÑÂàôÊòØ: Â¶ÇÊûú‰∏§‰∏™IntentÁöÑComponentNameÂíåintent-filterÈÉΩÁõ∏Âêå, ÈÇ£‰πàËøô‰∏§‰∏™IntentÂ∞±ÊòØÁõ∏ÂêåÁöÑ. ExtrasÊòØ‰∏çÂèÇ‰∏éIntentÁöÑÂåπÈÖçËßÑÂàô. FLAG_ONE_SHOT: ÂΩìÂâçÊèèËø∞ÁöÑPendingIntentÂè™ËÉΩË¢´‰ΩøÁî®‰∏ÄÊ¨°, ÁÑ∂ÂêéÂÆÉÂ∞±‰ºöË¢´Ëá™Âä®cancle, Â¶ÇÊûúÂêéÁª≠ËøòÊúâÁõ∏ÂêåÁöÑPendingIntent, ÈÇ£‰πàÂÆÉ‰ª¨ÁöÑsendÊñπÊ≥ïÂ∞±‰ºöË∞ÉÁî®Â§±Ë¥•. ÂØπ‰∫éÈÄöÁü•Ê†èÊ∂àÊÅØÊù•ËØ¥, Â¶ÇÊûúÈááÁî®Ê≠§Ê†áËÆ∞, ÈÇ£‰πàÂêåÁ±ªÁöÑÈÄöÁü•Âè™ËÉΩ‰ΩøÁî®‰∏ÄÊ¨°, ÂêéÁª≠ÁöÑÈÄöÁü•ÂçïÂáªÂêéÂ∞ÜÊó†Ê≥ïÊâìÂºÄ. FLAG_NO_CREATE: ÂΩìÂâçÊèèËø∞ÁöÑPendingIntent‰∏ç‰ºö‰∏ªÂä®ÂàõÂª∫, Â¶ÇÊûúÂΩìÂâçPendingIntent‰πãÂâç‰∏çÂ≠òÂú®, ÈÇ£‰πàgetActivity, getService, getBroadcastÊñπÊ≥ï‰ºöÁõ¥Êé•ËøîÂõûnull, Âç≥Ëé∑ÂèñPendingIntentÂ§±Ë¥•. Ëøô‰∏™Ê†áËÆ∞ÂæàÂ∞ëËßÅ, ÂÆÉÊó†Ê≥ïÂçïÁã¨‰ΩøÁî®,Âõ†Ê≠§Êó•Â∏∏‰∏≠Ê≤°ÊúâÂ§™Â§öÊÑè‰πâ. FLAG_CANCEL_CURRENT: ÂΩìÂâçÊèèËø∞ÁöÑPendingIntentÂ¶ÇÊûúÂ∑≤ÁªèÂ≠òÂú®, ÈÇ£‰πà‰ªñ‰ª¨ÈÉΩ‰ºöË¢´cancel, ÁÑ∂ÂêéÁ≥ªÁªü‰ºöÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑPendingIntent. ÂØπ‰∫éÈÄöÁü•Ê†èÊ∂àÊÅØÊù•ËØ¥, ÈÇ£‰∫õË¢´cancelÁöÑÊ∂àÊÅØÂçïÂáªÂêéÂ∞ÜÊó†Ê≥ïÊâìÂºÄ. FLAG_UPDATE_CURRENT: ÂΩìÂâçÊèèËø∞ÁöÑPendingIntentÂ¶ÇÊûúÂ∑≤ÁªèÂ≠òÂú®, ÈÇ£‰πà‰ªñ‰ª¨ÈÉΩ‰ºöËá™Âä®Ë¢´Êõ¥Êñ∞, Âç≥ÂÆÉ‰ª¨ÁöÑIntent‰∏≠ÁöÑExtra‰ºöË¢´Êç¢ÊàêÊñ∞ÁöÑ. ËßÑÂàôËØ¥‰∫ÜÊé•‰∏ãÊù•ÁªìÂêàÂÆûÈôÖ‰ΩøÁî®ËØ¥Êòé: Â¶ÇÊûúmanager.notify(1, notification),Â¶ÇÊûúÂèÇÊï∞1ÁöÑidÊòØÂ∏∏Èáè,ÈÇ£‰πàÂ§öÊ¨°Ë∞ÉÁî®notify()Âè™ËÉΩÂºπÂá∫‰∏Ä‰∏™ÈÄöÁü•, ÂêéÁª≠ÁöÑÈÄöÁü•‰ºöÊääÂâçÈù¢ÁöÑÈÄöÁü•ÂÖ®ÈÉ®Êõø‰ª£, Â¶ÇÊûúÊØèÊ¨°idÈÉΩÊòØ‰∏ç‰∏ÄÊ†∑ÁöÑ, ÈÇ£‰πàÂ§öÊ¨°Ë∞ÉÁî®notify()Â∞±‰ºöÂºπÂá∫Â§ö‰∏™ÈÄöÁü•. ÊâÄ‰ª•Â¶ÇÊûúnotify()ÊòØÂ∏∏Èáè, ÈÇ£‰πà‰∏çÁÆ°PendingIntentÊòØÂê¶ÂåπÈÖç, ÂêéÈù¢ÁöÑÈÄöÁü•ÈÉΩ‰ºöÁõ¥Êé•ÊõøÊç¢ÂâçÈù¢ÁöÑÈÄöÁü•. Â¶ÇÊûúnotify()ÊØèÊ¨°‰∏çÂêå, ÈÇ£‰πàÂΩìpendingIntent‰∏çÂåπÈÖçÊó∂(ËøôÈáåÊåáÁöÑÂåπÈÖçÂ∞±ÊòØ‰∏äÈù¢‰ªãÁªçÁöÑIntentÂíårequestCodeÊòØÂê¶ÂêåÊó∂Áõ∏Âêå), ‰∏çÁÆ°ÈááÁî®‰ΩïÁßçÊ†áËÆ∞, Ëøô‰∫õÈÄöÁü•‰πãÈó¥ÈÉΩ‰∏ç‰ºö‰∫íÁõ∏Âπ≤Êâ∞. ‰ΩÜÊòØÂ¶ÇÊûúPendingIntentÂåπÈÖçÊó∂Â∞±Ë¶ÅÁî®Âà∞ÂéªÊåâÁÖß‰πãÂâçËØ¥ÁöÑÊ†áËÆ∞Âå∫Âà´Êù•ÂàíÂàÜ FLAG_ONE_SHOT‚Äì&gt; ÈÇ£‰πàÂêéÁª≠ÈÄöÁü•‰∏≠ÁöÑPendingIntent‰ºöÂíåÁ¨¨‰∏ÄÊù°ÈÄöÁü•‰øùÊåÅ‰∏ÄËá¥, ÂåÖÊã¨Extras, ÂçïÂáª‰ªª‰Ωï‰∏ÄÊù°ÈÄöÁü•Âêé, Ââ©‰∏ãÁöÑÈÄöÁü•ÂùáÊó†Ê≥ïÂÜçÊâìÂºÄ, ÂΩìÊâÄÊúâÁöÑÈÄöÁü•ÈÉΩË¢´Ê∏ÖÈô§Âêé, ‰ºöÂÜçÊ¨°ÈáçÂ§çËøô‰∏™ËøáÁ®ã. FLAG_CANCEL_CURRENT‚Äì&gt; ÈÇ£‰πàÂè™ÊúâÊúÄÊñ∞ÁöÑÈÄöÁü•ÂèØ‰ª•ÊâìÂºÄ, ‰πãÂâçÂºπÂá∫ÁöÑÊâÄÊúâÈÄöÁü•ÂùáÊó†Ê≥ïÊâìÂºÄ FLAG_UPDATE_CURRENT‚Äì&gt; ÈÇ£‰πà‰πãÂâçÂºπÂá∫ÁöÑÈÄöÁü•‰∏≠ÁöÑPendingIntent‰ºöË¢´Êõ¥Êñ∞, ÊúÄÁªà‰ªñ‰ª¨ÂíåÊúÄÊñ∞ÁöÑ‰∏ÄÊù°ÈÄöÁü•‰øùÊåÅÂÆåÂÖ®ÁöÑ‰∏ÄËá¥, ÂåÖÊã¨ÂÖ∂‰∏≠ÁöÑExtras,Âπ∂‰∏îËøô‰∫õÈÄöÁü•ÈÉΩÊòØÂèØ‰ª•ÊâìÂºÄÁöÑ. ‚Äã RemoteViewsÁöÑÂÜÖÈÉ®Êú∫Âà∂RemoteViewsÁöÑ‰ΩúÁî®ÊòØÂú®ÂÖ∂‰ªñËøõÁ®ã‰∏≠ÊòæÁ§∫Âπ∂Êõ¥Êñ∞ViewÁïåÈù¢. ÊúÄÂ∏∏Áî®ÁöÑÊûÑÈÄ†ÂáΩÊï∞Â∞±ÊòØpublic RemoteViews(String packageName, int layoutId), Ê≥®ÊÑèRemoteViewsÁõÆÂâçÂπ∂‰∏çËÉΩÊîØÊåÅÊâÄÊúâÁöÑViewÁ±ªÂûã, ÁõÆÂâçÊîØÊåÅÂ¶Ç‰∏ã(‰∏çÂåÖÊã¨ÂÖ∂Â≠êÁ±ª): Layout FrameLayout, LinearLayout, RelativeLayout, GridLayout View TextView, ImageView, ImageButton, Button, AnalogClock, Chronometer, ProgressBar, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub RemoteViewsÊ≤°ÊúâÊèê‰æõfindviewById()ÊñπÊ≥ï, Âè™Êúâ‰∏ÄÁ≥ªÂàóÁöÑset()ÊñπÊ≥ï. ÊñπÊ≥ïÂêç ‰ΩúÁî® setTextViewText() ËÆæÁΩÆTextViewÁöÑÊñáÊú¨ setTextViewSize() ËÆæÁΩÆTextViewÁöÑÂ≠ó‰ΩìÂ§ßÂ∞è setTextColor() ËÆæÁΩÆTextViewÁöÑÂ≠ó‰ΩìÈ¢úËâ≤ setImageViewResource() ËÆæÁΩÆimageViewÁöÑÂõæÁâáËµÑÊ∫ê setImageViewBitmap() ËÆæÁΩÆimageViewÁöÑÂõæÁâá setInt() ÂèçÂ∞ÑË∞ÉÁî®ViewÂØπË±°ÁöÑÂèÇÊï∞Á±ªÂûã‰∏∫intÁöÑÊñπÊ≥ï setLong() ÂèçÂ∞ÑË∞ÉÁî®ViewÂØπË±°ÁöÑÂèÇÊï∞Á±ªÂûã‰∏∫longÁöÑÊñπÊ≥ï setBoolean() ÂèçÂ∞ÑË∞ÉÁî®ViewÂØπË±°ÁöÑÂèÇÊï∞Á±ªÂûã‰∏∫booleanÁöÑÊñπÊ≥ï setOnClickPendingIntent() ‰∏∫ViewÊ∑ªÂä†ÂçïÂáª‰∫ã‰ª∂, ‰∫ã‰ª∂Á±ªÂûãÂè™ËÉΩPendingIntent RemoteViewsÁöÑÂ∑•‰ΩúÊµÅÁ®ã ÈÄöÁü•Ê†èÂíåÊ°åÈù¢Â∞èÈÉ®‰ª∂ÂàÜÂà´Áî±NotificationManagerÂíåAppWidgetManagerÁÆ°ÁêÜ, ËÄåËøô‰∏§‰∏™ÁÆ°ÁêÜËÄÖÈÉΩÊòØÈÄöËøáBinderÂàÜÂà´ÂíåSystemServerËøõÁ®ã‰∏≠ÁöÑNotificationManagerService‰ª•ÂèäAppWidgetServiceËøõË°åÈÄö‰ø°. Áî±Ê≠§ÂèØËßÅ,ÈÄöÁü•Ê†èÂíåÊ°åÈù¢Â∞èÈÉ®‰ª∂‰∏≠ÁöÑÂ∏ÉÂ±ÄÊñá‰ª∂ÂÆûÈôÖ‰∏äÊòØÂú®NotificationManagerService‰ª•ÂèäAppWidgetService‰∏≠Ë¢´Âä†ËΩΩÁöÑ, ËÄå‰ªñ‰ª¨ËøêË°åÂú®Á≥ªÁªüÁöÑSystemServer‰∏≠, ËøôÂ∞±ÂíåÊàë‰ª¨ÁöÑËøõÁ®ãÊûÑÊàê‰∫ÜËøõÁ®ãÈó¥ÈÄö‰ø°. ÊúÄÂºÄÂßãRemoteViews‰ºöÈÄöËøáBinder‰º†ÈÄíÂà∞SystemServerËøõÁ®ã, RemoteViewsÂÆûÁé∞‰∫ÜParcelableÊé•Âè£. Á≥ªÁªüÊ†πÊçÆRemoteViews‰∏≠ÁöÑÂåÖÂêçÁ≠â‰ø°ÊÅØÂéªÂæóÂà∞ËØ•Â∫îÁî®ÁöÑËµÑÊ∫ê, ÁÑ∂ÂêéÈÄöËøáLayoutInflateÂéªÂä†ËΩΩRemoteViews‰∏≠ÁöÑÂ∏ÉÂ±ÄÊñá‰ª∂. Âú®SystemServerËøõÁ®ã‰∏≠Âä†ËΩΩÂêéÁöÑÂ∏ÉÂ±ÄÊñá‰ª∂ÊòØ‰∏Ä‰∏™ÊôÆÈÄöÁöÑView, Âè™‰∏çËøáÁõ∏ÂØπ‰∫éÊàë‰ª¨ÁöÑËøõÁ®ã‰ªñÊòØ‰∏Ä‰∏™RemoteViewsËÄåÂ∑≤. Êé•ÁùÄÁ≥ªÁªü‰ºöÂØπViewÊâßË°å‰∏ÄÁ≥ªÂàóÁïåÈù¢Êõ¥Êñ∞‰ªªÂä°, Ëøô‰∫õ‰ªªÂä°Â∞±ÊòØ‰πãÂâçÁöÑËÆæÁΩÆÁöÑset(). setÊñπÊ≥ïÂØπViewÊâÄÂÅöÁöÑÊõ¥Êñ∞‰∏çÊòØÁ´ãÂç≥ÊâßË°å, Âú®RemoteViewsÂÜÖÈÉ®‰ºöËÆ∞ÂΩïÊâÄÊúâÁöÑÊõ¥Êñ∞Êìç‰Ωú, ÂÖ∑‰ΩìÁöÑÊâßË°åÊó∂Êú∫Ë¶ÅÁ≠âÂà∞RemoteViewsË¢´Âä†ËΩΩ‰ª•ÂêéÊâçËÉΩÊâßË°å, ËøôÊ†∑RemoteViewsÂ∞±ÂèØ‰ª•Âú®SystemServerËøõÁ®ã‰∏≠ÊòæÁ§∫, ËøôÂ∞±ÊòØÊàë‰ª¨ÁúãÂà∞ÁöÑÈÄöÁü•Ê†èÊàñËÄÖÊ°åÈù¢Â∞èÈÉ®‰ª∂. ÂΩìÈúÄË¶ÅÊõ¥Êñ∞RemoteViewsÊó∂, Êàë‰ª¨ÈúÄË¶ÅË∞ÉÁî®setÊñπÊ≥ïÂπ∂ÈÄöËøáNotificationManagerÂíåAppWidgetManagerÊù•Êèê‰∫§Êõ¥Êñ∞‰ªªÂä°, ÂÖ∑‰ΩìÁöÑÊõ¥Êñ∞Êìç‰Ωú‰πüÊòØÂú®SystemServerËøõÁ®ã‰∏≠ÂÆåÊàêÁöÑ. ‰∏∫‰ªÄ‰πà‰∏çÊîØÊåÅÊâÄÊúâÁöÑViewÂíåÂÖ∂Êìç‰Ωú? Âõ†‰∏∫‰ª£‰ª∑Â§™Â§ß, ViewÁöÑÊñπÊ≥ïÂ§™Â§ö, Âè¶Â§ñÂ∞±ÊòØÂ§ßÈáèÁöÑIPCÊìç‰Ωú‰ºöÂΩ±ÂìçÊïàÁéá. ‰∏∫‰∫ÜËß£ÂÜ≥Ëøô‰∏™ÈóÆÈ¢ò, Á≥ªÁªüÂπ∂Ê≤°ÊúâÈÄöËøáBinderÁõ¥Êé•ÊîØÊåÅViewÁöÑË∑®ËøõÁ®ãËÆøÈóÆ, ËÄåÊòØÊèê‰æõ‰∫Ü‰∏Ä‰∏™ActionÁöÑÊ¶ÇÂøµ, Action‰ª£Ë°®‰∏Ä‰∏™ViewÊìç‰Ωú, ActionÂêåÊ†∑ÂÆûÁé∞‰∫ÜParcelableÊé•Âè£. Á≥ªÁªüÈ¶ñÂÖàÂ∞ÜViewÊìç‰ΩúÂ∞ÅË£ÖÂà∞ActionÂØπË±°Âπ∂Â∞ÜËøô‰∫õÂØπË±°Ë∑®ËøõÁ®ã‰º†ËæìÂà∞ËøúÁ®ãËøõÁ®ã, Êé•ÁùÄÂú®ËøúÁ®ãËøõÁ®ã‰∏≠ÊâßË°åActionÂØπË±°‰∏≠ÁöÑÂÖ∑‰ΩìÊìç‰Ωú. Âú®Êàë‰ª¨ÁöÑÂ∫îÁî®‰∏≠ÊØèË∞ÉÁî®‰∏ÄÊ¨°set(), RemoteViews‰∏≠Â∞±‰ºöÊ∑ªÂä†‰∏Ä‰∏™ÂØπÂ∫îÁöÑActionÂØπË±°, ÂΩìÊàë‰ª¨ÈÄöËøáNotificationManagerÂíåAppWidgetManagerÊù•Êèê‰∫§Êàë‰ª¨ÁöÑÊõ¥Êñ∞Êó∂, Ëøô‰∫õActionÂØπË±°Â∞±‰ºö‰º†ËæìÂà∞ËøúÁ®ãËøõÁ®ãÂπ∂Âú®ËøúÁ®ãËøõÁ®ã‰∏≠‰∏ÄÊ¨°ÊâßË°å. Â¶ÇÂõæ: ËøúÁ®ãËøõÁ®ãÈÄöËøáRemoteViewsÁöÑapplyÊñπÊ≥ïÊù•ËøõË°åViewÁöÑÊõ¥Êñ∞Êìç‰Ωú, RemoteViewsÁöÑapplyÊñπÊ≥ïÂÜÖÈÉ®Âàô‰ºöÂéªÈÅçÂéÜÊâÄÊúâÁöÑActionÂØπË±°Âπ∂Ë∞ÉÁî®‰ªñ‰ª¨ÁöÑapplyÊñπÊ≥ï, ÂÖ∑‰ΩìÁöÑViewÊõ¥Êñ∞Êìç‰ΩúÊòØÁî±ActionÂØπË±°ÁöÑapplyÊñπÊ≥ïÊù•ÂÆåÊàêÁöÑ. ‰∏äËø∞ÂÅöÊ≥ïÁöÑÂ•ΩÂ§ÑÊòØÊòæËÄåÊòìËßÅÁöÑ, È¶ñÂÖà‰∏çÈúÄË¶ÅÂÆö‰πâÂ§ßÈáèÁöÑBinderÊé•Âè£, ÂÖ∂Ê¨°ÈÄöËøáËøúÁ®ãËøõÁ®ã‰∏≠ÊâπÈáèÊâßË°åRemoteViewsÁöÑ‰øÆÊîπÊìç‰Ωú‰ªéËÄåÈÅøÂÖç‰∫ÜÂ§ßÈáèÁöÑIPCÊìç‰Ωú, ËøôÂ∞±ÊèêÈ´ò‰∫ÜÁ®ãÂ∫èÁöÑÊÄßËÉΩ. Êé•‰∏ãÊù•‰ªéÊ∫êÁ†ÅËßíÂ∫¶ÂàÜÊûê. È¶ñÂÖàÊúÄÈïøÁî®Âà∞ÁöÑsetTextViewText(),Ê∫êÁ†ÅÂ¶Ç‰∏ã 123public void setTextViewText(int viewId, CharSequence text) &#123; setCharSequence(viewId, "setText", text);&#125; Êé•Êî∂ÁöÑÂèÇÊï∞ÊØîËæÉÁÆÄÂçï,ÁªßÁª≠Ë∑üËøõsetCharSequence()ÊñπÊ≥ï. 123public void setCharSequence(int viewId, String methodName, CharSequence value) &#123; addAction(new ReflectionAction(viewId, methodName, ReflectionAction.CHAR_SEQUENCE, value));&#125; ‰ªéËøôÈáåÂÆûÁé∞ÁúãÂà∞, ÂÜÖÈÉ®Âπ∂Ê≤°ÊúâÂØπViewËøõÁ®ãÁõ¥Êé•ÁöÑÊìç‰Ωú, ËÄåÊòØÊ∑ªÂä†‰∏Ä‰∏™ReflectionAction()‰∏Ä‰∏™ÁúãÂêçÂ≠óÁ±ª‰ººÂèçÂ∞ÑÁ±ªÂûãÁöÑÂØπË±°. Êé•‰∏ãÁúãaddAction() 12345678910private void addAction(Action a) &#123; //ÁúÅÁï•ÈÉ®ÂàÜ‰ª£Á†Å... if (mActions == null) &#123; mActions = new ArrayList&lt;Action&gt;(); &#125; mActions.add(a); // update the memory usage stats a.updateMemoryUsageEstimate(mMemoryUsageCounter);&#125; ËøôÈáåÁúãÂà∞, Âú®RemoteViewsÂÜÖÈÉ®Êúâ‰∏Ä‰∏™mActionsÊàêÂëò, ÂÆÉÊòØ‰∏Ä‰∏™ArrayList, Â§ñÁïåÊØèË∞ÉÁî®‰∏ÄÊ¨°set(), RemoteViewsÂ∞±‰ºö‰∏∫ÂÖ∂ÂàõÂª∫‰∏Ä‰∏™ActionÂØπË±°Âπ∂Âä†ÂÖ•Âà∞Ëøô‰∏™ÈõÜÂêà‰∏≠, ËøôÈáå‰ªÖ‰ªÖÂ∞ÜActionÂØπË±°‰øùÂ≠ò‰∫ÜËµ∑Êù•, Âπ∂Êú™ÂØπViewËøõË°åÂÆûÈôÖÁöÑÊìç‰Ωú, Ëøô‰∏ÄÁÇπÂú®‰∏äÈù¢ÁöÑÁêÜËÆ∫ÂàÜÊûê‰∏≠Â∑≤ÁªèÊèêÂà∞Ëøá. Êé•‰∏ãÊù•ÂÜçÁúãReflectionActionÁöÑÂÆûÁé∞‰πãÂâç, ÂÖàÁúã‰∏Ä‰∏ãRemoteViewsÁöÑapply()ÊñπÊ≥ï‰ª•ÂèäActionÁ±ªÁöÑÂÆûÁé∞. 12345678910111213141516171819202122232425262728293031323334public View apply(Context context, ViewGroup parent, OnClickHandler handler) &#123; RemoteViews rvToApply = getRemoteViewsToApply(context); View result; final Context contextForResources = getContextForResources(context); Context inflationContext = new ContextWrapper(context) &#123; @Override public Resources getResources() &#123; return contextForResources.getResources(); &#125; @Override public Resources.Theme getTheme() &#123; return contextForResources.getTheme(); &#125; @Override public String getPackageName() &#123; return contextForResources.getPackageName(); &#125; &#125;; LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); // Clone inflater so we load resources from correct context and // we don't add a filter to the static version returned by getSystemService. inflater = inflater.cloneInContext(inflationContext); inflater.setFilter(this); result = inflater.inflate(rvToApply.getLayoutId(), parent, false); rvToApply.performApply(result, parent, handler); return result; &#125; ËøôÊÆµ‰ª£Á†ÅÈ¶ñÂÖàÈÄöËøáLayoutInflateÂéªÂä†ËΩΩRemoteViews‰∏≠ÁöÑÂ∏ÉÂ±ÄÊñá‰ª∂, RemoteViews‰∏≠ÁöÑÂ∏ÉÂ±ÄÊñá‰ª∂ÂèØ‰ª•ÈÄöËøágetLayoutId()Ëøô‰∏™ÊñπÊ≥ïËé∑Âæó, Âä†ËΩΩÂÆåÂ∏ÉÂ±ÄÊñá‰ª∂Âêé‰ºöÈÄöËøáperformApply()ÂéªÊâßË°å‰∏Ä‰∫õÊõ¥Êñ∞Êìç‰Ωú,Â¶Ç‰∏ã: 12345678910private void performApply(View v, ViewGroup parent, OnClickHandler handler) &#123; if (mActions != null) &#123; handler = handler == null ? DEFAULT_ON_CLICK_HANDLER : handler; final int count = mActions.size(); for (int i = 0; i &lt; count; i++) &#123; Action a = mActions.get(i); a.apply(v, parent, handler); &#125; &#125; &#125; Ëøô‰∏™ÂÆûÁé∞Â∞±ÊòØÈÅçÂéÜmActionsÂπ∂ÊâßË°åÊØè‰∏™ActionÂØπË±°ÁöÑapply()ÊñπÊ≥ï, ËøôÈáåÁåúÊÉ≥ActionÂØπË±°ÁöÑapplyÊñπÊ≥ïÂ∞±ÊòØÁúüÊ≠£Êìç‰ΩúViewÁöÑÂú∞Êñπ. RemoteViewsÂú®ÈÄöÁü•Ê†èÂíåÊ°åÈù¢Â∞èÈÉ®‰ª∂‰∏≠ÁöÑÂ∑•‰ΩúËøáÁ®ãÂíå‰∏äÈù¢ÊèèËø∞ÁöÑËøáÁ®ãÊòØ‰∏ÄËá¥ÁöÑ. ÂΩìË∞ÉÁî®‰∫ÜRemoteViewsÁöÑsetÊñπÊ≥ïÊó∂, Âπ∂‰∏ç‰ºöÁ´ãÂàªÊõ¥Êñ∞‰ªñ‰ª¨ÁöÑÁïåÈù¢, ËÄåÂøÖÈ°ªË¶ÅÈÄöËøáNotificationManagerÁöÑnotifyÊñπÊ≥ï‰ª•ÂèäAppWidgetManagerÁöÑupdateAppWidgetÊâçËÉΩÊõ¥Êñ∞‰ªñ‰ª¨ÁöÑÁïåÈù¢. ÂÆûÈôÖ‰∏äÂú®AppWidgetManagerÁöÑupdateAppWidgetÂÜÖÈÉ®ÂÆûÁé∞‰∏≠, ‰ªñ‰ª¨Â∞±ÊòØÈÄöËøáRemoteViewsÁöÑapply‰ª•ÂèäreapplyÊñπÊ≥ïÊù•Âä†ËΩΩÊàñËÄÖÊõ¥Êñ∞Â∏ÉÂ±ÄÁöÑ. applyÂíåreApplyÁöÑÂå∫Âà´Âú®‰∫é:ÂâçËÄÖ‰ºöÂä†ËΩΩÂ∏ÉÂ±ÄÂπ∂Êõ¥Êñ∞ÁïåÈù¢, ËÄåÂêéËÄÖÂè™‰ºöÊõ¥Êñ∞ÁïåÈù¢. ÈÄöÁü•Ê†èÂíåÊ°åÈù¢Â∞èÈÉ®‰ª∂Âú®ÂàùÂßãÂåñÁïåÈù¢ÁöÑÊó∂ÂÄôÂõûË∞ÉÁî®apply()ÊñπÊ≥ï, ËÄåÂú®ÂêéÁª≠ÁöÑÊõ¥Êñ∞ÁïåÈù¢Êó∂Âàô‰ºöË∞ÉÁî®reapply()ÊñπÊ≥ï. ‰∫ÜËß£‰∫Üapply()‰ª•Âèäreapply()ÁöÑ‰ΩúÁî®Âêé, Êé•ÁùÄÁúãActionÁöÑÂ≠êÁ±ªÂÖ∑‰ΩìÂÆûÁé∞, ÂÖàÁúãReflectionActionÁöÑÂÖ∑‰ΩìÂÆûÁé∞. 12345678910111213141516171819202122232425262728293031323334private final class ReflectionAction extends Action &#123; //ÁúÅÁï•ÈÉ®ÂàÜ‰ª£Á†Å ... String methodName; int type; Object value; ReflectionAction(int viewId, String methodName, int type, Object value) &#123; this.viewId = viewId; this.methodName = methodName; this.type = type; this.value = value; &#125; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final View view = root.findViewById(viewId); if (view == null) return; Class&lt;?&gt; param = getParameterType(); if (param == null) &#123; throw new ActionException("bad type: " + this.type); &#125; try &#123; getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value)); &#125; catch (ActionException e) &#123; throw e; &#125; catch (Exception ex) &#123; throw new ActionException(ex); &#125; &#125; // ...&#125; ReflectionActionË°®Á§∫ÁöÑÊòØ‰∏Ä‰∏™ÂèçÂ∞ÑÂä®‰Ωú, ÈÄöËøáÂÆÉÂØπViewÁöÑÊìç‰Ωú‰ºö‰ª•ÂèçÂ∞ÑÁöÑÊñπÂºèÊù•Ë∞ÉÁî®, ÂÖ∂‰∏≠getMethodÂ∞±ÊòØÊ†πÊçÆÊñπÊ≥ïÂêçÊù•ÂæóÂà∞ÂèçÂ∞ÑÊâÄÈúÄË¶ÅÁöÑMethodÂØπË±°. Èô§‰∫ÜReflectionAction, ËøòÊúâÂÖ∂‰ªñÁöÑAction. ‰æãÂ¶Ç: TextViewSizeAction, ViewPaddingAction, SetOnClickPendingIntentÁ≠â. Áúã‰∏Ä‰∏ãTextViewSizeAction 1234567891011121314151617181920212223private class TextViewSizeAction extends Action &#123; public TextViewSizeAction(int viewId, int units, float size) &#123; this.viewId = viewId; this.units = units; this.size = size; &#125; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final TextView target = (TextView) root.findViewById(viewId); if (target == null) return; target.setTextSize(units, size); &#125; public String getActionName() &#123; return "TextViewSizeAction"; &#125; int units; float size; public final static int TAG = 13;&#125; Ëøô‰∏™Á±ªÊ≤°Êúâ‰ΩøÁî®ÂèçÂ∞Ñ, Âõ†‰∏∫setTextSizeÁöÑÊñπÊ≥ïÊúâ‰∏§‰∏™ÂèÇÊï∞,Âõ†Ê≠§Êó†Ê≥ïÂ§çÁî®ReflectionAction, Âõ†‰∏∫Ëøô‰∏™ÂèçÂ∞ÑË∞ÉÁî®Âè™ËÉΩÊúâ‰∏Ä‰∏™ÂèÇÊï∞. ÂÖ≥‰∫éÂçïÂáª‰∫ã‰ª∂, RemoteViewsÂè™ÊîØÊåÅÂèëËµ∑PendingIntent,‰∏çÊîØÊåÅonClickListener()ËøôÁßçÊ®°Âºè. setOnClickPendingIntent,setPendingIntentTemplate,setOnClickFillIntentËøô‰∏â‰∏™ÁöÑÂå∫Âà´. setOnClickPendingIntent: Âè™ÊîØÊåÅÊôÆÈÄöViewËÆæÁΩÆÁÇπÂáª‰∫ã‰ª∂, ‰∏çËÉΩÁªôÈõÜÂêà(ListView,StackView)‰∏≠ÁöÑViewËÆæÁΩÆÁÇπÂáª‰∫ã‰ª∂,Â¶Çitem. Âõ†‰∏∫ÂºÄÈîÄÊØîËæÉÂ§ß, Á≥ªÁªüÁ¶ÅÊ≠¢‰∫ÜËøôÁßçÊñπÂºè. Â¶ÇÊûúË¶ÅÁªôÈõÜÂêà‰∏≠ÁöÑitemÊ∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂,ÂàôÂøÖÈ°ª‰ΩøÁî®Âêé‰∏§ÁßçÁªÑÂêà‰ΩøÁî®ÊâçÂèØ‰ª•. RemoteViewsÁöÑÊÑè‰πâÂèØ‰ª•Ê®°Êãü‰∏Ä‰∏™ÈÄöÁü•Ê†èÊïàÊûúÂπ∂ÂÆûÁé∞Ë∑®ËøõÁ®ãÁöÑUIÊõ¥Êñ∞. ‰∏Ä‰∏™Â∫îÁî®ÈúÄË¶ÅËÉΩÂ§üÊõ¥Êñ∞Âè¶‰∏Ä‰∏™Â∫îÁî®‰∏≠ÁöÑÊüê‰∏™ÁïåÈù¢ÔºåËøô‰∏™Êó∂ÂÄôÊàë‰ª¨ÂΩìÁÑ∂ÂèØ‰ª•ÈÄâÊã©AIDLÂéªÂÆûÁé∞Ôºå‰ΩÜÊòØÂ¶ÇÊûúÂØπÁïåÈù¢ÁöÑÊõ¥Êñ∞ÊØîËæÉÈ¢ëÁπÅÔºåËøô‰∏™Êó∂ÂÄôÂ∞±‰ºöÊúâÊïàÁéáÈóÆÈ¢òÔºåÂêåÊó∂AIDLÊé•Âè£Â∞±ÊúâÂèØËÉΩ‰ºöÂèòÂæóÂæàÂ§çÊùÇ Ëøô‰∏™Êó∂ÂÄôÂ¶ÇÊûúÈááÁî®RemoteViewsÊù•ÂÆûÁé∞Â∞±Ê≤°ÊúâËøô‰∏™ÈóÆÈ¢ò‰∫ÜÔºåÂΩìÁÑ∂RemoteViews‰πü‰ºöÊúâÁÇπÁº∫ÁÇπÔºåÈÇ£Â∞±ÊòØ‰ªñ‰ªÖÊîØÊåÅ‰∏Ä‰∫õÂ∏∏ËßÅÁöÑView,ÂØπ‰∫éËá™ÂÆö‰πâVIew‰ªñÊòØ‰∏çÊîØÊåÅÁöÑ]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>RemoteViews</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewÁöÑÂ∑•‰ΩúÂéüÁêÜ]]></title>
    <url>%2F2018%2F03%2F01%2FView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRootÂíåDecorViewËøôÊòØÂú®View‰∏âÂ§ßÊµÅÁ®ã‰πãÂâç(measure, layout, draw),ÈúÄË¶Å‰∫ÜËß£ÁöÑÊ¶ÇÂøµ. ViewRootÂØπÂ∫î‰∫éViewRootImplÁ±ª, ÂÆÉÊòØËøûÊé•WindowManagerÂíåDecorViewÁöÑÁ∫ΩÂ∏¶. ViewÁöÑ‰∏âÂ§ßÊµÅÁ®ãÈÉΩÊòØÈÄöËøáViewRootÊù•ÂÆåÊàêÁöÑ. ÂΩì‰∏Ä‰∏™ActivityÂØπË±°Âú®ActivityThreadË¢´ÂàõÂª∫Âêé. ‰ºöÂ∞ÜDecorViewÊ∑ªÂä†Âà∞Window‰∏≠, ÂêåÊó∂‰ºöÂàõÂª∫ViewRootImpÂØπË±°, Âπ∂Â∞ÜViewRootImplÂØπË±°ÂíåDecorViewÂª∫Á´ãÂÖ≥ËÅîÔºö 12root = new ViewRootImpl(view.getContext(), display);root.setView(view, wparams, panelParentView); ViewÁªòÂà∂ÊµÅÁ®ãÊòØ‰ªéViewRootÁöÑPerformTraversals()ÂºÄÂßãÁöÑ. ÁªèËøá‰∏âÂ§ßÊµÅÁ®ãÊâçËÉΩÂ∞Ü‰∏Ä‰∏™ViewÁªòÂà∂Âá∫Êù•. PerformTraversals()‰ºö‰æùÊ¨°Ë∞ÉÁî®performMeasure, performLayout, performDraw. ËÄåÂâç‰∏§ÁßçÂÜÖÈÉ®ÁöÑË∞ÉÁî®Âü∫Êú¨‰∏ÄËá¥,ÈÉΩÊòØÂÖàË∞ÉÁî®measure()/layout(),ÁÑ∂ÂêéÂÜçË∞ÉÁî®onMeasure()/onLayout()Âú®Ëøô‰∏™ÊñπÊ≥ï‰∏≠‰ºöÂØπÊâÄÊúâÂ≠êÂÖÉÁ¥†ËøõË°åÊµãÈáèÂíåÁªòÂà∂.‰æùÊ¨°ÂêëÂÜÖÈÉ®‰º†ÈÄí. performDraw()ÊúâÁÇπ‰∏çÂêåÊòØÂú®drawË∞ÉÁî®ÁöÑdispatchDraw(). PerformTraversalsÁªòÂà∂ÊµÅÁ®ãÂ¶Ç‰∏ãÂõæÔºö measureËøáÁ®ã: ÂÜ≥ÂÆö‰∫ÜViewÂÆΩÈ´ò, measureÂêéÂèØ‰ª•ÈÄöËøágetMeasureWidthÂíågetMeasureHeightÊù•Ëé∑ÂèñViewÁöÑÂÆΩÈ´ò. ‰∏ÄËà¨ÊÉÖÂÜµ‰∏ãÊòØÊúÄÁªàÂÆΩÈ´ò. layoutËøáÁ®ã: ÂÜ≥ÂÆö‰∫ÜViewÁöÑÈ°∂ÁÇπÂùêÊ†áÂíåÂÆûÈôÖViewÁöÑÂÆΩÈ´ò. ÂÆåÊàêÂêéÈÄöËøágetTop, getBottom, getLeft, getRightËé∑ÂæóÂõõ‰∏™È°∂ÁÇπ, ÈÄöËøágetWidth,ÂíågetHeightËé∑ÂæóÂÆΩÈ´ò drawËøáÁ®ã: Âè™Êúâdraw()ÊñπÊ≥ïÂÆåÊàê‰πãÂêéViewÁöÑÂÜÖÂÆπÊâç‰ºöÊòæÁ§∫Âá∫Êù•. 12setContentView(R.layout.activity_inside_intercept);((ViewGroup) getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); ‰∏äÈù¢Á¨¨‰∏ÄË°åÂèØ‰ª•ËØ¥Êó†Êó∂Êó†Âàª‰∏çÂ≠òÂú®. ËÄå‰∏ãÈù¢ËøôË°åÂú®‰∏ä‰∏ÄÁ´†ËØ¥ËøáÂ∞±ÊòØËé∑ÂæóÊàë‰ª¨ËÆæÁΩÆÁöÑÂ∏ÉÂ±Ä.ÈÇ£DecorViewÂ∏ÉÂ±ÄÁ©∂Á´üÊòØÊÄé‰πàÊ†∑ÁöÑ, ‰∏ãÂõæ. DecorViewÂ∞±ÊòØ‰∏Ä‰∏™FrameLayout. ËÄå‰∏ÄËà¨ÊÉÖÂÜµ‰∏ãÂÆÉÁöÑÂ∏ÉÂ±ÄÂ∞±Â¶Ç‰∏äÈù¢ÂõæÈÇ£Ê†∑(ÂÖ∑‰ΩìÂíå‰∏ªÈ¢òÊúâÂÖ≥Á≥ª). ËÄåÊàë‰ª¨ÁªèÂ∏∏setContentView(xxx). Â∞±ÊòØÊääÊàë‰ª¨ÁºñÂÜôÁöÑxmlÁöÑÂ∏ÉÂ±ÄÊ∑ªÂä†Âà∞‰∫ÜDecorViewÁöÑandroid.R.id.contentÁöÑÊéß‰ª∂Â∏ÉÂ±Ä‰∏≠. ÊâÄ‰ª•‰πüÂ∞±ËÉΩËØ¥ÈÄö‰∏∫‰ªÄ‰πàgetChildAt(0)‰ºöËé∑ÂæóÊàë‰ª¨ÁöÑÁöÑÂ∏ÉÂ±Ä.Âπ∂‰∏î‰∏∫‰ªÄ‰πàÊàë‰ª¨Áî®ÁöÑÂÖ≥ËÅîÂ∏ÉÂ±ÄÁöÑÊñπÊ≥ïÊòØsetContent‚Ä¶ MeasureSpec ÂæàÂ§ßÁ®ãÂ∫¶‰∏äÂÜ≥ÂÆö‰∏Ä‰∏™ViewÁöÑÂ∞∫ÂØ∏ËßÑÊ†º, ‰πãÊâÄ‰ª•‰∏çÊòØÁªùÂØπ, ÊòØÂõ†‰∏∫Ëøô‰∏™ËøáÁ®ãËøòÂèóÁà∂ÂÆπÂô®ÁöÑÂΩ±Âìç. ÁêÜËß£MeasureSpecMeasureSpecÊú¨Ë∫´ÊòØ‰∏Ä‰∏™32‰ΩçÁöÑintÂÄº, ‰ΩÜÊòØÂç¥Ë°®Á§∫‰∫Ü‰∏§Áßç‰ø°ÊÅØ. È´ò2‰Ωç: ‰ª£Ë°®‰∫ÜSpecMode, ÊµãÈáèÊ®°Âºè ‰Ωé30‰Ωç: ‰ª£Ë°®‰∫ÜSpecSize, Âú®‰∏äËø∞ÊµãÈáèÊ®°Âºè‰∏≠ÁöÑÂ§ßÂ∞è 1234567891011121314151617181920212223242526272829303132public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; .....&#125; ÊòØ‰∏çÊòØÊå∫ÊúâÊÑèÊÄù. ‰∏âÁßçÁ±ªÂûãÂàÜÂà´È´ò‰∫å‰Ωç01, 00, 10Êù•‰ª£Ë°®. Áõ¥Êé•Âà©Áî®‰ΩçËøêÁÆó. Êù•ÂÆûÁé∞ÂèØ‰ª•ËÆ©È¢ëÁπÅËÆ°ÁÆóÁöÑ‰∏úË•ø‰ΩøÁî®ÊúÄÊé•ËøëËÆ°ÁÆóÊú∫ÁöÑËøêÁÆóÊñπÂºè. ‰∏çÈúÄË¶ÅÈ¢ùÂ§ñÁöÑËΩ¨Êç¢. ‰πüÈÅøÂÖç‰∫ÜËøáÂ§öÁöÑÂØπË±°ÂÜÖÂ≠òÂàÜÈÖç. ËØ¥‰∏Ä‰∏ãSpecModeÁöÑ‰∏âÁßçÊ®°Âºè UNSPECIFIED: Áà∂ÂÆπÂô®‰∏çÂØπViewÊúâ‰ªª‰ΩïÁöÑÈôêÂà∂,Ë¶ÅÂ§öÂ§ßÂ∞±ÁªôÂ§öÂ§ß, ËøôÁßçÊÉÖÂÜµ‰∏ÄËà¨Áî®‰∫éÁ≥ªÁªüÂÜÖÈÉ®,Ë°®Á§∫‰∏Ä‰∏≠ÊµãÈáèÁä∂ÊÄÅ EXACTLY: Áà∂ÂÆπÂô®Â∑≤ÁªèÊ£ÄÊµãÂá∫ViewÊâÄÈúÄË¶ÅÁöÑÁ≤æÁ°ÆÂ§ßÂ∞è, Ëøô‰∏™Êó∂ÂÄôViewÁöÑÊúÄÁªàÂ§ßÂ∞èÂ∞±ÊòØSpecSizeÊâÄÊåáÂÆöÁöÑÂÄº. ÂØπÂ∫îÁùÄLayoutParams‰∏≠ÁöÑmatch_parentÂíåÂÖ∑‰ΩìÁöÑÊï∞ÂÄº. AT_MOST: Áà∂ÂÆπÂô®Âà∂ÂÆö‰∫Ü‰∏Ä‰∏™ÂèØÁî®ÁöÑÂ§ßÂ∞èÂèäSpecSize, ViewÁöÑÂ§ßÂ∞è‰∏çËÉΩË∂ÖËøáËøô‰∏™ÂÄº, ÂÆÉÂØπÂ∫î‰∏éLayoutParams‰∏≠ÁöÑwrap_content MeasureSpecÂíåLayoutParamsÂÖ≥Á≥ªÈÄöÂ∏∏ËÆæÁΩÆÁöÑLayoutParams,Á≥ªÁªü‰ºöÂú®Áà∂ÂÆπÂô®ÁöÑÁöÑÁ∫¶Êùü‰∏ãËΩ¨Êç¢ÊàêÂØπÂ∫îÁöÑMeasureSpec,ÁÑ∂ÂêéÊ†πÊçÆËøô‰∏™MeasureSpecÊù•Á°ÆÂÆöViewÊµãÈáèÂêéÁöÑÂÆΩÈ´ò. ÊâÄ‰ª•ViewËá™Ë∫´ÁöÑMeasureSpecÊòØÈúÄË¶ÅLayoutParamsÂíåÁà∂ÂÆπÂô®‰∏ÄËµ∑ÁªÑÂêàÁîüÊàêÁöÑ. ‰∏äÈù¢ËÆ≤Ëø∞ÁöÑÊòØÊôÆÈÄöView, ‰ΩÜÊòØÈ°∂Á∫ßView(DecorView)ÊúâÊâÄ‰∏çÂêå. DecorViewÊòØÁâ©ÁêÜÁ™óÂè£Â∞∫ÂØ∏ÂíåËá™Ë∫´ÁöÑLayoutParamsÂÜ≥ÂÆöÁöÑ. ÂÖ∑‰ΩìÂú®ViewRootImplÁ±ªmeasureHierarchy()ËøõË°åÁîüÊàêÁöÑ. MeasureSpec‰∏ÄÊó¶Á°ÆÂÆö, onMeasure‰∏≠Â∞±ÂèØ‰ª•ÊµãÈáèViewÁöÑÂÆΩÈ´ò. ÂØπ‰∫éÊàë‰ª¨Êó•Â∏∏Êìç‰ΩúÁöÑView ViewÁöÑmeasureËøáÁ®ãÊòØÁî±ViewGroup‰º†ÈÄíËÄåÊù•ÁöÑ. ÁúãViewGroup#measureChildWithMargins()ÊñπÊ≥ï 123456789101112131415protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; ‰∏äÈù¢‰ºöÂØπÂ≠êÂÖÉÁ¥†ËøõË°åmeasureÔºåËÄåÂú®Ê≠§‰πãÂâçÔºå‰ºöÈÄöËøágetChildMeasureSpec()Êù•ÂæóÂà∞Â≠êÂÖÉÁ¥†ÁöÑMeasureSpec. ÈÄöËøáË∞ÉÁî®ÊñπÊ≥ï‰º†ÂÖ•ÁöÑÂèÇÊï∞ÁúãÂà∞ÔºåÁîüÊàêViewÁöÑMeasureSpecÂÖ∑‰ΩìÁî±‰ª•‰∏ãÂõ†Á¥†ÂÖ±ÂêåÂÜ≥ÂÆöÔºö Áà∂ÂÆπÂô®ÁöÑMeasureSpecÂíåpaddingÔºåViewËá™Ë∫´ÁöÑmarginÂíåLayoutParamsÔºåÂØπ‰∫éÂ≠êViewÁöÑLayoutParamsÂ¶ÇÊûúÊòØÔºö dp/px: ‰∏çÁÆ°Áà∂ÂÆπÂô®ÁöÑMeasureSpecÊòØ‰ªÄ‰πà. ViewÈÉΩÊòØEXACTLY(Á≤æÁ°ÆÊ®°Âºè), ËÄåÂ§ßÂ∞èÈÅµÂæ™Ëá™Ë∫´LayoutParamsÁöÑÂ§ßÂ∞è. match_parent: Â¶ÇÊûúÁà∂ÂÆπÂô®ÊòØEXACTLY(Á≤æÁ°ÆÊ®°Âºè),ÈÇ£‰πàÂ≠êView‰πüÊòØEXACTLY(Á≤æÁ°ÆÊ®°Âºè)Âπ∂‰∏îÂ§ßÂ∞èÊòØÁà∂ÂÆπÂô®ÁöÑÂâ©‰ΩôÁ©∫Èó¥. Â¶ÇÊûúÁà∂ÂÆπÂô®ÊòØAT_MOST(ÊúÄÂ§ßÊ®°Âºè),ÈÇ£‰πàÂ≠êView‰πüÊòØAT_MOST(ÊúÄÂ§ßÊ®°Âºè)Âπ∂‰∏îÂ§ßÂ∞è‰∏ç‰ºöË∂ÖËøáÁà∂ÂÆπÂô®ÁöÑÂâ©‰ΩôÁ©∫Èó¥. wrap_content: ‰∏çÁÆ°Áà∂ÂÆπÂô®ÊòØ‰ªÄ‰πà. ViewÈÉΩÊòØAT_MOST(ÊúÄÂ§ßÊ®°Âºè), Âπ∂‰∏îÂ§ßÂ∞è‰∏çËÉΩË∂ÖËøáÁà∂ÂÆπÂô®Ââ©‰ΩôÁ©∫Èó¥. ‰∏äËø∞Ê≤°ÊúâËØ¥ÊòéUNSPECIFIEDÂú®match_parentÂíåwrap_content‰∏≠. Âõ†‰∏∫Ëøô‰∏™Ê®°Âºè‰∏ªË¶ÅÁî®‰∫éÁ≥ªÁªüÂ§öÊ¨°MeasureÁöÑÊÉÖÂΩ¢,‰∏ÄËà¨Êù•ËØ¥‰∏çÈúÄË¶ÅÂÖ≥Ê≥®. ÊôÆÈÄöViewÁöÑMeasureSpecÁöÑÂàõÂª∫ÊµÅÁ®ã,ËßÑÂàôÂ¶Ç‰∏ãË°®ÊâÄÁ§∫Ôºö ViewÁöÑÂ∑•‰ΩúÊµÅÁ®ã ‰∏ªË¶ÅÊåámeasure, layout, draw‰∏âÂ§ßÊµÅÁ®ã. Âç≥ÊµãÈáè,Â∏ÉÂ±Ä,ÁªòÂà∂. measureËøáÁ®ãËøôÈáåÈù¢Â≠òÂú®‰∏§ÁßçÂú∫ÊôØ: View: ÈÄöËøá‰∫ÜmeasureÊñπÊ≥ïÂ∞±ÂÆåÊàê‰∫ÜÊµãÈáèËøáÁ®ã ViewGroup: Èô§‰∫ÜÊµãÈáèËá™Â∑±,Ëøò‰ºöÈÅçÂéÜÂéªË∞ÉÁî®ÊâÄÊúâÂ≠êÂÖÉÁ¥†ÁöÑmeasureÊñπÊ≥ï. ÂêÑ‰∏™Â≠êÂÖÉÁ¥†Âú®ÈÄíÂΩíÂéªÊâßË°åËøô‰∏™ÊµÅÁ®ã ViewÁöÑmeasureËøáÁ®ã ViewÁöÑmeasureËøáÁ®ãÁî±ÂÖ∂measure()ÊñπÊ≥ïÊù•ÂÆåÊàê, measure()ÊñπÊ≥ïÊòØ‰∏Ä‰∏™finalÁ±ªÂûã, ËÄåÂú®ÂÜÖÈÉ®Ë∞ÉÁî®‰∫ÜonMeasure()Ëøô‰∏™ÂèØ‰∏çÊòØfinal, ÊâÄ‰ª•‰πüÂèØ‰ª•Ëá™ÂÆö‰πâÁöÑÊó∂ÂÄôÂ§çÂÜô. Áúã‰∏Ä‰∏ãÂÜÖÈÉ®. 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; setMeasureDimension()‰ºöËÆæÁΩÆViewÂÆΩÈ´òÁöÑÊµãÈáèÂÄº. ËøôÈáåÈúÄË¶ÅÁúã‰∏Ä‰∏ãgetDefaultSize()Ëøô‰∏™ÊñπÊ≥ï. 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; ÁúãÂà∞Â¶ÇÊûúËøô‰∏™viewÊòØEXACTLY(Á≤æÂáÜÊ®°Âºè), ÈÇ£‰πàËøîÂõûÁöÑÂ§ßÂ∞èÂ∞±ÊòØSpecSize„ÄÇ UNSPECIFIED‰∏ÄËà¨Áî®‰∫éÁ≥ªÁªüÊµãÈáèÂÖà‰∏çËØ¥. ËÄåAT_MOST(ÊúÄÂ§ßÊ®°Âºè)ÁöÑÊó∂ÂÄô. ËôΩÁÑ∂ÊòØ‰∏çÂêåÊ®°Âºè‰ΩÜÊòØÈªòËÆ§ÊÉÖÂÜµ‰∏ãÂíåÁ≤æÁ°ÆÊ®°ÂºèÊòØ‰∏ÄÊ†∑ÁöÑÁªìÊûú. getSuggestedMinimumWidth()ÂíågetSuggestedMinimumHeight(). Áúã‰∏Ä‰∏ãÂÆûÁé∞. 1234567protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; È¶ñÂÖà‰ºöÁúãÊòØÂê¶ËÆæÁΩÆ‰∫ÜËÉåÊôØ. Êó†ËÉåÊôØ: ÈÇ£‰πàÂÆΩÂ∫¶‰∏∫mMinWidth,Ëøô‰∏™ÂÄºÂØπÂ∫îÂ∏ÉÂ±Ä‰∏≠ÁöÑandroid:minWidthÂ±ûÊÄß,ÈªòËÆ§‰∏∫0. ÊúâËÉåÊôØ: ÈÇ£‰πàÂèñmMinWidthÂíåmBackground.getMinimumWidth()ÊúÄÂ§ßÂÄº. Êàë‰ª¨Áúã‰∏Ä‰∏ã:getMinimumHeight() 1234public int getMinimumHeight() &#123; final int intrinsicHeight = getIntrinsicHeight(); return intrinsicHeight &gt; 0 ? intrinsicHeight : 0;&#125; ÂéüÊù•getMinimumHeight()ËøîÂõûÁöÑÂ∞±ÊòØDrawableÁöÑÂéüÂßãÈ´òÂ∫¶„ÄÇ Â¶ÇÊûúÊ≤°ÊúâÂ∞±ËøîÂõû0. ÂÖ≥‰∫éÂéüÂßãÈ´òÂ∫¶‰∏æ‰∏™‰æãÂ≠êShapeDrawableÊó†ÂéüÂßãÂÆΩÈ´òÔºå BitmapDrawbleÊúâÂéüÂßãÂÆΩÈ´òÂ∞±ÊòØÂõæÁâáÁöÑÂ∞∫ÂØ∏„ÄÇ ÂÜçÊÄªÁªì‰∏ãgetDefaultSize()ÁöÑÈªòËÆ§Ë°å‰∏∫ÔºåËôΩÁÑ∂Êàë‰ª¨Âú®xmlÂ∏ÉÂ±Ä‰∏≠‰ΩøÁî®‰∫Üwrap_contentÔºå‰ΩÜÂÆûÈôÖÊïàÊûú‰∏∫ÔºöViewËá™Ë∫´ÁöÑMeasureSpecÁ≠â‰∫éÁà∂ÂÆπÂô®Ëá™Ë∫´ÁöÑÂâ©‰ΩôÂ§ßÂ∞èÔºåÂπ∂Ê≤°ÊúâÂéªÈÄÇÈÖçViewÊú¨Ë∫´ÁöÑÂ§ßÂ∞è„ÄÇÂõ†Ê≠§Ôºö ÂØπ‰∫éÁõ¥Êé•ÁªßÊâøViewÁöÑËá™ÂÆö‰πâÊéß‰ª∂ÔºåÈúÄË¶ÅÈáçÂÜôonMeasure()ÊñπÊ≥ïÂπ∂ËÆæÁΩÆwrap_contentÊó∂ÁöÑËá™Ë∫´Â§ßÂ∞è„ÄÇ Ëá™ÂÆö‰πâViewÁöÑÊó∂ÂÄôÂ¶ÇÊûú‰∏çÂØπwrap_contentËøõË°åÈ¢ùÂ§ñÂ§ÑÁêÜÔºåÈÇ£‰πàÂ∞±‰ºöË∞ÉÁî®ÈªòËÆ§setMeasureDimension()ÊñπÊ≥ï. ËÄåÈªòËÆ§‰∏≠ÊñπÊ≥ïÁöÑÂÆûÂèÇ‰º†ÈÄíÁöÑÊòØgetDefaultSize()Ëøô‰∏™ÊñπÊ≥ï‰∏≠ÂØπAT_MOSTËøôÁßçÊ®°ÂºèÊ≤°ÊúâÂ§ÑÁêÜ. Áõ¥Êé•Ê≤øÁî®ÂíåÁ≤æÁ°ÆÊ®°ÂºèÁöÑÂ§ßÂ∞è(Áõ∏ÂΩì‰∫éËÆæÁΩÆ‰∫Üwrap_contentÂç¥ÂæóÂà∞‰∫Ümatch_parentÁöÑÊòæÁ§∫ÁªìÊûú) ÂèØ‰ª•ÈíàÂØπËøô‰∏™ÈóÆÈ¢ò, ÂÅöÂá∫ÂØπÂ∫îÁöÑÁºñÁ†ÅËøõË°åËß£ÂÜ≥: 123456789101112131415161718192021222324@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //ÈªòËÆ§‰ºöË∞ÉÁî®Áà∂Á±ªÁöÑsetMeasuredDimension() super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpaceMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpaceMode = MeasureSpec.getMode(heightMeasureSpec); //ËÆæÁΩÆ‰∏§‰∏™ÈªòËÆ§ÂÄºÂÆΩÈ´ò int defaultHeight = 100; int defaultWidth = 100; // ÈíàÂØπAT_MOSTÊ®°ÂºèËøõË°åÁâπÊÆäÂ§ÑÁêÜ if (widthSpaceMode == MeasureSpec.AT_MOST &amp;&amp; heightSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, defaultHeight); &#125; else if (widthSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, heightSpaceSize); &#125; else if (heightSpaceMode == MeasureSpec.AT_MOST) setMeasuredDimension(widthMeasureSpec, defaultHeight); &#125; &#125; ViewGroupÁöÑMeasure ÂØπ‰∫éViewGroup‰∏çÂÖâ‰ºöÊµãÈáèËá™Â∑±,Ëøò‰ºöÈÅçÂéÜË∞ÉÁî®ÊâÄÊúâÁöÑÂ≠êÂÖÉÁ¥†ÁöÑmeasure(). ÂíåView‰∏çÂêåÁöÑÊòØViewGroupÊòØ‰∏Ä‰∏™ÊäΩË±°Á±ª,ÂÆÉÊ≤°ÊúâÈáçÂÜôonMeasure,‰ΩÜÊèê‰æõ‰∫ÜmeasureChildren()ÁöÑÊñπÊ≥ï. Ëøô‰∏™measureChildren()ÊñπÊ≥ïÂÜÖÈÉ®ÊØîËæÉÁÆÄÂçïÂ∞±ÊòØÈÅçÂéÜËá™Â∑±ÁöÑÂ≠©Â≠êÁÑ∂ÂêéË∞ÉÁî®-&gt;measureChild() Ëøô‰∏™measureChild()Ëøô‰∏™ÊñπÊ≥ïÂâçÈù¢Ë¥¥ËøáÊ∫êÁ†Å„ÄÇÂ∞±ÊòØÂèñÂá∫Â≠êÂÖÉÁ¥†ÁöÑLayoutParamsÔºåÂπ∂Ë∞ÉÁî® getChildMeasureSpec()Ôºå ÈÄöËøá‰º†ÂÖ•Â≠êÂÖÉÁ¥†ÁöÑLayoutParamsÈáåÈù¢ÁöÑÂÆΩÈ´òÂ±ûÊÄßÂíåpaddingÔºåÁà∂ÂÖÉÁ¥†ÁöÑmarginÂíåÂΩìÂâçMeasureSpecÂ±ûÊÄßÊù•ËÆ°ÁÆóÂá∫Â≠êÂÖÉÁ¥†ÁöÑMeasureSpecÊúÄÂêéË∞ÉÁî®child.measure()‰º†ÂÖ•‰πãÂâçËÆ°ÁÆóÁöÑÊµãÈáèËßÑÊ†º„ÄÇ ViewGroup‰∏∫‰ªÄ‰πàÊ≤°ÊúâÂÆö‰πâÊµãÈáèÁöÑÂÖ∑‰ΩìËøáÁ®ã? Âõ†‰∏∫ÂÖ∑‰ΩìÁöÑÊµãÈáèËøáÁ®ãÈúÄË¶Å‰∫§ÁªôÂ≠êÁ±ªÂéªÂÆûÁé∞ÁöÑ. ÊØîÂ¶ÇLinearLayout,RelativeLayout. Áúã‰∏Ä‰∏ãLinearLayoutÁöÑonMeasure()ÊòØÂ¶Ç‰ΩïÂÆö‰πâÁöÑ. 12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; Ê†πÊçÆËÆæÁΩÆÁöÑÊéíÂàóÊñπÂºèËøôÈáåÂàÜ‰πã‰∫Ü‰∏§ÁßçÊµãÈáèÊñπÊ≥ï. Á®çÂæÆÁúã‰∏Ä‰∏ãÂ§ßÊ¶ÇËΩÆÂªìÔºåÈÄâÊã©measureVertical()‰∏çË¥¥Ê∫êÁ†Å‰∫ÜËøô‰∏™ÊñπÊ≥ï300Ë°åÂë¢! È¶ñÂÖàLinearLayoutÁöÑËøô‰∏™ÊñπÊ≥ï‰ºöÈÅçÂéÜÊØè‰∏™Â≠êÂÖÉÁ¥†Âπ∂ÊâßË°åmeasureChildBeforeLayout()ÊñπÊ≥ï„ÄÇËøô‰∏™ÊñπÊ≥ïÂÜÖÈÉ®‰ºöË∞ÉÁî®Â≠êÂÖÉÁ¥†ÁöÑmeasure()ÔºåËøôÊ†∑Â≠êÂÖÉÁ¥†‰ºö‰æùÊ¨°ÊµãÈáèÔºåÂπ∂‰∏î‰ºöÈÄöËøámTotalLenghtËøô‰∏™ÂèòÈáèÊù•Â≠òÂÇ®LinearLayoutÂú®Á´ñÁõ¥ÊñπÂêë‰∏äÁöÑÂàùÊ≠•È´òÂ∫¶ÔºåÊØèÊµãÈáè‰∏Ä‰∏™Â∞±‰ºöÂ¢ûÂä†„ÄÇÂΩìÂ≠êÂÖÉÁ¥†ÊµãÈáèÂÆå‰πãÂêéÔºåLinearLayout‰ºöÊµãÈáèËá™Â∑±ÁöÑÂ§ßÂ∞è„ÄÇ Âú®ÂØπËá™Â∑±ËøõË°åÊµãÈáèÁöÑÊó∂ÂÄôÔºå Â¶ÇÊûúÂ∏ÉÂ±Ä‰∏≠ÁöÑÈ´òÂ∫¶ÈááÁî®ÁöÑÊòØmatch_parentÊàñËÄÖÂÖ∑‰ΩìÊï∞ÂÄºÔºåÈÇ£‰πàÂÆÉÁöÑÊµãÈáèËøáÁ®ãÂíåView‰∏ÄÊ†∑ÔºåÂç≥È´òÂ∫¶‰∏∫specSize„ÄÇÂ¶ÇÊûúÂ∏ÉÂ±Ä‰∏≠ÈááÁî®wrap_contentÈÇ£‰πàÈ´òÂ∫¶Â∞±ÊòØÊâÄÊúâÁöÑÂ≠êÂÖÉÁ¥†ÊÄªÂíå‰ΩÜÊòØ‰∏çËÉΩË∂ÖËøáÁà∂ÂÖÉÁ¥†Ââ©‰ΩôÁ©∫Èó¥ÔºåÂÖ∑‰ΩìÂèØÂèÇËÄÉresolveSizeAndState()ÁöÑÂÆûÁé∞„ÄÇ Âà∞ËøôÈáåÂü∫Êú¨‰∏ämeasureÊµãÈáèËøáÁ®ãÂ∑≤ÁªèÂÅö‰∫ÜÊØîËæÉËØ¶ÁªÜÁöÑÂàÜÊûêÔºåËøô‰∏™ËøáÁ®ã‰πüÊòØ‰∏âÂ§ßËøáÁ®ã‰∏≠ÊúÄÂ§çÊùÇÁöÑ‰∏Ä‰∏™ÔºåÂú®measureÂÆåÊàê‰πãÂêéÂ∞±ÂèØ‰ª•ÈÄöËøágetMeasuredWidth/HeightÊñπÊ≥ïËé∑ÂèñViewÁöÑÊµãÈáèÂÆΩÈ´ò„ÄÇ ‰ΩÜÊòØËØ∑Ê≥®ÊÑè: Êüê‰∫õÊûÅÁ´ØÊÉÖÂÜµ‰∏ãÔºåmeasureÂèØËÉΩÊâßË°åÂ§öÊ¨°„ÄÇ ÊâÄ‰ª•Â∞ΩÈáèÂú®onLayout()ÊñπÊ≥ï‰∏≠ÂéªËé∑ÂæóÊúÄÁªàÂÆΩÈ´ò„ÄÇ Ê≠£Á°ÆËé∑ÂèñÂÆΩÈ´òÊñπÊ≥ïÈ¶ñÂÖàÊòéÁ°Æ‰∏ÄÁÇπ:ViewÁöÑmeasureÂíåActivityÁöÑÁîüÂëΩÂë®ÊúüÊñπÊ≥ï‰∏çÊòØÂêåÊ≠•ÊâßË°å.ÊâÄ‰ª•Êó†Ê≥ï‰øùËØÅÂú®Êüê‰∏™ÁîüÂëΩÂë®Êúü(onCreate,onStart)Ëé∑ÂèñÂà∞Ê≠£Á°ÆÁöÑÊµãÈáèÂÆΩÈ´ò Activity/View#onWindowFocusChanged() view.post(runnable) ViewTreeObserver#onGlobalLayout view.measure() onWindowFocusChanged() ViewÂ∑≤ÁªèÂàùÂßãÂåñÂÆåÊØïÔºåÂÆΩÈ´òÂ∑≤ÁªèÂáÜÂ§áÂ•Ω„ÄÇËøôÈáåÈúÄË¶ÅÊ≥®ÊÑèÂè™Ë¶ÅActivityÁöÑÁÑ¶ÁÇπÂèëÁîüÂèòÂåñÊ≠§ÊñπÊ≥ïÂ∞±‰ºöË¢´Ë∞ÉÁî®ÔºåÊâÄ‰ª•Â¶ÇÊûú‰Ω†ÁöÑÁïåÈù¢Âú®ËøõË°åonPauseÂíåonResumeÔºåÈÇ£‰πàonWindowFocusChanged()‰πü‰ºöÂæóÂà∞Ë∞ÉÁî®„ÄÇ View.post(runnable) ÈÄöËøápostÂèØ‰ª•Â∞Ü‰∏Ä‰∏™runnableÊäïÈÄíÂà∞Ê∂àÊÅØÈòüÂàóÁöÑÂ∞æÈÉ®ÔºåÁÑ∂ÂêéÁ≠âÂæÖLooperË∞ÉÁî®Âà∞Ê≠§runnableÁöÑÊó∂ÂÄôÔºåViewÂ∑≤ÁªèÂàùÂßãÂåñÂÆåÊØï„ÄÇ ‰ΩøÁî®ViewTreeObserver ÂΩìViewÁöÑÂèØËßÅÊÄßÂèëÁîü‰∫ÜÊîπÂèòÁöÑÊó∂ÂÄôÔºåonGlobalLayout()Â∞ÜÂèëÁîüÂõûË∞ÉÔºåÊ≥®ÊÑè‰º¥ÈöèÁùÄViewÊ†ëÁöÑÁä∂ÊÄÅÊîπÂèòÁ≠âÔºåËøô‰∏™ÂõûË∞ÉÊñπÊ≥ïÂèØËÉΩ‰ºöË¢´Ë∞ÉÁî®Â§öÊ¨°.„ÄÇ‰ΩøÁî®‰ª£Á†ÅÂ¶Ç‰∏ã 123456789ViewTreeObserver viewTreeObserver = view.getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); int height = view.getMeasuredHeight(); int width = view.getMeasuredWidth(); &#125; &#125;); view.measure(widthMeasureSpec, heightMeasureSpec) ‰πüÂèØ‰ª•ÊâãÂä®ËøõË°åÊµãÈáèÔºå‰ΩÜÊòØÈúÄË¶ÅÂàÜÊÉÖÂÜµÂ§ÑÁêÜMeasureSpec match_parent ÂΩìViewÊòØÊ≠§Â±ûÊÄßÁöÑÊó∂ÂÄôÊó†Ê≥ï‰ΩøÁî®measure()ÔºåÈ¶ñÂÖà‰ΩøÁî®ËøôÁßçÊñπÊ≥ïÈúÄË¶ÅÁöÑÂèÇÊï∞ÔºåÊòØÈÄöËøáÁà∂ÂÆπÂô®ÂíåÂ≠êÂÖÉÁ¥†ÁªÑÂêàÊù•ÁîüÊàêÁöÑÂ≠êÂÖÉÁ¥†ÁöÑMeasureSpecÂ±ûÊÄß„ÄÇÊâÄ‰ª•Âú®Â§ñÈÉ®Êàë‰ª¨‰∏çÁü•ÈÅìÁà∂ÂÖÉÁ¥†ÁöÑÂèÇÊï∞ÂÄºÂæóÊó∂ÂÄôÂè™ËÉΩÂ§ÑÁêÜ‰∏çÈúÄË¶ÅÁà∂ÂÖÉÁ¥†Êï∞ÊçÆÂ∞±ÂèØ‰ª•ÁîüÊàêÂ≠êÂÖÉÁ¥†ÁöÑMeasureSpecÁöÑÊ®°Âºè ÊâÄ‰ª•ÂæàÊ∏ÖÊ•ö, Ëøô‰∏™match_patchËøô‰∏™Ê®°ÂºèÔºåÂú®ÁªôÂÖ∂Â≠êÂÖÉÁ¥†ÊûÑÈÄ†MeasureSpecÁöÑÊó∂ÂÄôÈúÄË¶ÅÂæóÂÄºparentSizeÔºåÊâÄ‰ª•ÂæóÂà∞ÁöÑ‰πüÊòØÊó†Êïà„ÄÇ ÂÖ∑‰ΩìÊï∞ÂÄºpx/dx ÂÅáËÆæËøôÈáåÊòØ100px, È¶ñÂÖàÊûÑÊàêÂÆΩÈ´òÂØπÂ∫îÁöÑMeasureSpecÂ±ûÊÄß 123int widthSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int heightSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY); view.measure(widthSpec, heightSpec); wrap_content 123int widthSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST);int heightSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST); view.measure(widthSpec, heightSpec); ÈÄöËøá(1&lt;&lt;30) - 1 ÂèØ‰ª•ÊûÑÊàê‰∏Ä‰∏™MeasureSpec‰Ωé30‰ΩçÁöÑÊúÄÂ§ßÂÄº. Áî®ÁêÜËÆ∫‰∏äViewËÉΩÊîØÊåÅÁöÑÊúÄÂ§ßÂÄºÂéªÊûÑÈÄ†MeasureSpec„ÄÇ layoutËøáÁ®ãÂú®ViewGroup‰∏≠‰ºöÂÖàÈÄöËøálayout()ÊñπÊ≥ïÁ°ÆÂÆöÊú¨Ë∫´ÁöÑ‰ΩçÁΩÆ. ÁÑ∂ÂêéË∞ÉÁî®onLayout()ÊñπÊ≥ïÈÅçÂéÜÊâÄÊúâÁöÑÂ≠êÂÖÉÁ¥†,Âπ∂Ë∞ÉÁî®Â≠êÂÖÉÁ¥†ÁöÑlayout()ÊñπÊ≥ïÁ°ÆÂÆöÂ≠êÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆ‚Ä¶‰æùÊ¨°Âæ™ÁéØ. ÊèêÂá∫ViewÁöÑlayoutÊñπÊ≥ï, ËøôÈáåÊäΩÂèñÈÉ®ÂàÜ‰ª£Á†Å 12345678910111213public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); &#125; &#125; ËøôÊ†∑Êù•Áúã,Â§ßËá¥ÊµÅÁ®ãÈÄöËøásetFrame()ÊñπÊ≥ïÊù•ËÆæÂÆöViewÁöÑÂõõ‰∏™È°∂ÁÇπÁöÑ‰ΩçÁΩÆÔºåÂç≥mLeft„ÄÅmTop„ÄÅmBottom„ÄÅmRightËøôÂõõ‰∏™È°∂ÁÇπ‰∏ÄÊó¶Á°ÆÂÆö„ÄÇÂΩìÂâçViewÁöÑ‰ΩçÁΩÆ‰πüÂ∞±Á°ÆÂÆöÔºåÁÑ∂Âêé‰ºöË∞ÉÁî®onLayout()ÊñπÊ≥ïÔºåËøô‰∏™ÊñπÊ≥ïÊòØÁ°ÆÂÆöÂ≠êÂÖÉÁ¥†ÁöÑView‰ΩçÁΩÆ„ÄÇ ËøôÈáåÁöÑÂíåonMeasure()Á±ª‰ººÔºå onLayout()ÂÖ∑‰ΩìÂÆûÁé∞ÂíåÂÖ∑‰ΩìÁöÑÂ∏ÉÂ±ÄÊúâÂÖ≥, ÊâÄ‰ª•ViewÂíåViewGroupÂùáÊ≤°ÊúâÁúüÊ≠£ÂÆûÁé∞onLayout()ÊñπÊ≥ï„ÄÇ Áúã‰∏Ä‰∏ãLinearLayoutÁöÑonLayout()Ê∫êÁ†Å 12345678@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; ÂíåonMeasure()‰∏ÄÊ†∑ÂàÜÊîØ,Êé•‰∏ãÊù•Ë∑üËøõlayoutVertical()Ë¥¥Âá∫‰∏ªË¶Å‰ª£Á†Å 1234567891011121314151617181920212223242526272829303132void layoutVertical(int left, int top, int right, int bottom) &#123; //ÁúÅÁï•‰∏ÄÈÉ®ÂàÜ... for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; //ÁúÅÁï•‰∏ÄÈÉ®ÂàÜ... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; ‰∏äÈù¢‰ª£Á†ÅÂ§ß‰ΩìÈÄªËæë: È¶ñÂÖàÈÅçÂéÜÊâÄÊúâÂ≠©Â≠êÂπ∂Ë∞ÉÁî®setChildFrame()Êù•‰∏∫Â≠êÂÖÉÁ¥†ÊåáÂÆöÂØπÂ∫îÁöÑ‰ΩçÁΩÆ. ÂÖ∂‰∏≠childTop‰ºöÈÄêÊ∏êÂ¢ûÂ§ß, ËøôÂ∞±ÊÑèÂë≥ÁùÄÂêéÈù¢ÁöÑÂ≠êÂÖÉÁ¥†‰ºöË¢´ÊîæÁΩÆÂú®Èù†‰∏ãÁöÑ‰ΩçÁΩÆ. ËÄåsetChildFrame()ÂÜÖÈÉ®‰ªÖÊúâ‰∏ÄË°å‰ª£Á†Å, Â∞±ÊòØË∞ÉÁî®Â≠êÂÖÉÁ¥†ÁöÑlayout()Âπ∂‰º†ÂÖ•ÂÆÉËá™Ë∫´Â∫îËØ•Â≠òÊîæÁöÑ‰ΩçÁΩÆ. 123private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; ËÄåÂú®setChildFrame()‰∏≠‰º†ÂÖ•ÁöÑÂÆΩÈ´òÂ∞±ÊòØÂ≠êÂÖÉÁ¥†ÁöÑÊµãÈáèÂÆΩÈ´ò„ÄÇ ËÄåÂú®Â≠êÂÖÉÁ¥†ÁöÑlayout()‰∏≠ÈÄöËøásetFrame()Êù•ËÆæÁΩÆÂÖÉÁ¥†ÁöÑÂõõ‰∏™È°∂ÁÇπ„ÄÇ ViewÁöÑÊµãÈáèÂÆΩÈ´ògetMeasureWidth()/getMeasureHeight() Âíå layoutÂêéÁî®getWidth()/getHeight()Ëé∑ÂæóÁöÑÊúÄÁªàÂÆΩ/È´òÊúâ‰ªÄ‰πàÂå∫Âà´? Âú®‰∏ÄËà¨ÊÉÖÂÜµ‰∏ãÔºåÊµãÈáèmeasureÂíålayoutÊó∂ÂÄôÁöÑÂÄºÊòØÂÆåÂÖ®‰∏ÄÊ†∑ÁöÑÔºåÂõ†‰∏∫layout()‰∏≠Êé•ÂèóÁöÑÂèÇÊï∞Â∞±ÊòØÈÄöËøáÊµãÈáèÁöÑÁªìÊûúËé∑ÂèñÂà∞ÁöÑ„ÄÇ Âπ∂‰∏îÂÜÖÈÉ®Áõ¥Êé•ÈÄöËøásetFrame()ËµãÂÄºÂà∞Ëá™Â∑±ÁöÑÂõõ‰∏™ÊàêÂëòÂèòÈáè‰∏ä„ÄÇ‰ΩÜÊòØÂ¶ÇÊûúÂØπlayout()ËøõË°å‰∫ÜÂ§çÂÜô„ÄÇÂ¶Ç‰∏ã 1234 @Overrideprotected void layout(int l, int t, int r, int b) &#123; super.layout( l, t+200, r, b+200);&#125; Â¶ÇÊûúËøõË°å‰∫ÜËøôÊ†∑ÁöÑÂ§çÂÜô, ÈÇ£‰πàÊúÄÁªàÂÆΩÈ´òÊ∞∏Ëøú‰ºö‰∏éÊµãÈáèÁöÑÂá∫Êù•ÁöÑÂÄºÁõ∏Â∑Æ200,‰ΩÜÊòØËøôÊ†∑ÂÅö‰ºöÂØºËá¥ÊòæÁ§∫‰∏çÊ≠£Â∏∏ÔºåÂπ∂Ê≤°Êúâ‰ªÄ‰πàÊÑè‰πâ. drawËøáÁ®ãËøô‰∏™ËøáÁ®ãÂè™ÊòØÂ∞ÜViewÁªòÂà∂Âà∞Â±èÂπï‰∏äÈù¢. ÁªòÂà∂ËÉåÊôØbackground.draw(canvas) ÁªòÂà∂Ëá™Â∑±onDraw() ÁªòÂà∂childrendispatchDraw() ÁªòÂà∂Ë£ÖÈ•∞onDrawScrollBars() ViewÁªòÂà∂ËøáÁ®ã‰º†ÈÄíÊòØÈÄöËøádispatchDraw()ÂÆûÁé∞ÁöÑ. ‰º†ÈÄí‰∫ÜËá™Â∑±ÁöÑÁîªÂ∏É. Ëøô‰∏™ÊñπÊ≥ï‰ºöÈÅçÂéÜÂ≠êÂÖÉÁ¥†Âπ∂‰∏îË∞ÉÁî®Â≠êÂÖÉÁ¥†ÁöÑdraw() View‰∏Ä‰∏™ÁâπÊúâÁöÑÊñπÊ≥ïsetWillNotDraw()ÔºåËøô‰∏™ÊñπÊ≥ïÊòØËÆæÁΩÆ‰∫ÜtrueÈÇ£‰πàÁ≥ªÁªü‰ºöËøõË°åÁõ∏Â∫îÁöÑ‰ºòÂåñÔºå Âú®View‰∏≠ÈªòËÆ§ÊòØÂÖ≥Èó≠ÁöÑ.ÔºåËÄåViewGroupÈªòËÆ§ÊòØÂºÄÂêØÁöÑ„ÄÇÂ¶ÇÊûúÊàë‰ª¨ÁªßÊâø‰∫ÜËá™ÂÆö‰πâViewGroupÂ¶ÇÊûúËøòÈúÄË¶ÅÁªòÂà∂Ëá™Â∑±ÁöÑÂÜÖÂÆπÈÇ£‰πàÈúÄË¶ÅÊòæÁ§∫ÁöÑÂÖ≥Èó≠Ê≠§Ê†áËÆ∞„ÄÇ Ëá™ÂÆö‰πâViewËá™ÂÆö‰πâViewÁöÑÂàÜÁ±ª1.Áõ¥Êé•ÁªßÊâøViewÈáçÂÜôonDrawÊñπÊ≥ï ËøôÁßçÊñπÊ≥ï‰∏ªË¶ÅÁî®‰∫éÂÆûÁé∞‰∏Ä‰∫õ‰∏çËßÑÂàôÁöÑÊïàÊûú,Ôºå‰∏çÊñπ‰æøÁªÑÂêàÂ∏ÉÂ±ÄÂÆûÁé∞ÔºåÊàñËÄÖÂèàÊúâÂä®ÊÄÅÊòæÁ§∫ÁöÑ‰∏Ä‰∫õÂõæÂΩ¢„ÄÇ ÈúÄË¶ÅËá™Â∑±ÁªòÂà∂ÈÇ£‰πàÂ∞±ÈáçÂÜôonDraw()ÊñπÊ≥ï„ÄÇËøôÁßçÊñπÊ≥ïÈúÄË¶ÅËá™Â∑±ÊîØÊåÅwrap_contentÂíåpadding 2.Áõ¥Êé•ÁªßÊâøViewGroupÊ¥æÁîüÁâπÊÆäÁöÑLayout ËøôÁßçÊñπÂºèÁî®‰∫éÂÆûÁé∞Ëá™ÂÆö‰πâÂ∏ÉÂ±ÄÔºåËøôÁßçÂ∏ÉÂ±ÄÁöÑÂÆûÁé∞Á®çÂæÆÂ§çÊùÇÔºåÈúÄË¶ÅÂêàÈÄÇÁöÑÂ§ÑÁêÜViewGroupÁöÑÊµãÈáèÔºåÂ∏ÉÂ±ÄËøô‰∏§‰∏™ËøáÁ®ãÔºåÂπ∂ÂêåÊó∂Â§ÑÁêÜÂ≠êÂÖÉÁ¥†ÁöÑÊµãÈáèÂíåÂ∏ÉÂ±ÄËøáÁ®ã„ÄÇ 3.ÁªßÊâøÁâπÂÆöÁöÑView(TextView) ÊØîËæÉÂ∏∏ËßÅÔºå ‰∏ÄËà¨Áî®‰∫éÊâ©Â±ïÂ∑≤ÊúâÁöÑViewÁöÑÂäüËÉΩ„ÄÇËøôÁßç‰∏çÈúÄË¶ÅËá™Â∑±Â§ÑÁêÜwrap_contentÂíåpadding 4.ÁªßÊâøÁâπÂÆöViewGroup(LinearLayout) ÂΩìÊüêÁßçÊïàÊûúÁúãËµ∑Êù•ÂÉèÂá†ÁßçViewÁöÑÁªÑÂêàÂú®‰∏ÄËµ∑ÁöÑÊó∂ÂÄôÔºåÂèØ‰ª•ÈááÁî®ËøôÁßçÊñπÂºè„ÄÇËøôÁßçÊñπÂºè‰∏çÈúÄË¶ÅËá™Â∑±Â§ÑÁêÜViewGroupÁöÑÊµãÈáèÂíåÂ∏ÉÂ±Ä„ÄÇ Ëá™ÂÆö‰πâViewÁöÑÈ°ªÁü• ÈáçÂÜôViewÁöÑonMeasure()ÊîØÊåÅwrap_contentÂ±ûÊÄß ÈáçÂÜôonMeasure()ÈíàÂØπAT_MOSTÊ®°ÂºèÁâπÊÆäÂ§ÑÁêÜ„ÄÇÂ¶ÇÊûú‰∏çÂ§ÑÁêÜÔºåËÆæÁΩÆÁöÑwrap_contentÂ±ûÊÄßÁõ∏ÂΩì‰∫ématch_parentÁöÑÊïàÊûúÔºåÂèÇËÄÉÂâçÈù¢ÁöÑViewÁöÑmeasureËøáÁ®ã„ÄÇ ÈáçÂÜôViewÁöÑonDraw()ÊîØÊåÅpaddingÂ±ûÊÄß Â¶ÇÊûúÁõ¥Êé•ÁªßÊâøViewÔºåÂú®onDraw()‰∏≠‰∏çÂ§ÑÁêÜpaddingÔºåÈÇ£‰πàÂ±ûÊÄßÊòØÊó†Ê≥ïËµ∑‰ΩúÁî®ÁöÑ„ÄÇËøòÊúâÁªßÊâøViewGroupÁöÑÊéß‰ª∂ÈúÄË¶ÅÂú®onMeasureÂíåonLayout‰∏≠ËÄÉËôëpaddingÂíåÂ≠êÂÖÉÁ¥†ÁöÑmargin‰ºöÈÄ†ÊàêÁöÑÂΩ±Âìç„ÄÇ Â∞ΩÈáè‰∏çË¶ÅÂú®View‰∏≠new Handler‰ΩøÁî® ÂÜÖÈÉ®Â∑≤ÁªèÊèê‰æõ‰∫ÜpostÁ≥ªÂàóÊñπÊ≥ïÔºàÂÜÖÈÉ®ÂÆûÁé∞‰πüÊòØHandlerÔºâÔºåÈô§ÈùûÂæàÊòéÁ°ÆË¶ÅÊòØÁî®HandlerÂèëÈÄÅÊ∂àÊÅØ„ÄÇ View‰∏≠Â¶ÇÊûúÊúâÁ∫øÁ®ãÊàñËÄÖÂä®ÁîªÔºåÈúÄË¶ÅÂèäÊó∂ÁöÑÂÅúÊ≠¢ ÂΩìÂåÖÂê´Ê≠§ViewÁöÑActivityÈÄÄÂá∫ÊàñËÄÖÊ≠§ViewË¢´removeÁöÑÊó∂ÂÄôÔºåViewÁöÑonDetachedFromWindow()‰ºöË¢´Ë∞ÉÁî®ÔºåÂèØ‰ª•ÈÄÇÂΩìÂ§ÑÁêÜÈò≤Ê≠¢ÂÜÖÂ≠òÊ≥ÑÊºè„ÄÇ ViewÂ∏¶ÊúâÁöÑÊªëÂä®ÂµåÂ•óÊó∂ÔºåÈúÄË¶ÅÂ§ÑÁêÜÂ•ΩÊªëÂä®ÂÜ≤Á™Å Ëá™ÂÆö‰πâViewÂÆû‰æã1.Ëá™ÂÆö‰πâViewÊ¥æÁîüÁ±ª È¶ñÂÖàÊàë‰ª¨Áúã‰∏Ä‰∏ãËá™ÂÆö‰πâViewÂèØËÉΩÊ∂âÂèäÁöÑÂ±ûÊÄßÔºåÊØîÂ¶Ç‰∏Ä‰∏™CircleView: 12345678&lt;com.ryg.chapter_4.ui.CircleView android:id="@+id/circleView1" android:layout_width="wrap_content" android:layout_height="100dp" android:layout_margin="20dp" android:background="#000000" android:padding="20dp" app:circle_color="@color/light_green" /&gt; Á¨¨‰∏ÄÊ≠•: ÈÄÇÈÖçwrap_contentÂ±ûÊÄß ÂØπ‰∫éÁõ¥Êé•ÁªßÊâøViewÁöÑÁ©∫Èó¥Ôºå‰∏çÁÆ°ÊòØËÆæÁΩÆmatch_parent‰πüÂ•ΩÔºåwrap_content‰πüÂ•ΩÁà∂ÂÆπÂô®ÈÉΩ‰ºöÁªôÂàÜÈÖçËá™Â∑±Ââ©‰ΩôÁ©∫Èó¥ÁöÑÂ§ßÂ∞èÁªôÂ≠êÂÆπÂô®‰Ωú‰∏∫specSizeÁöÑÁ©∫Èó¥Â§ßÂ∞è„ÄÇÂ¶ÇÊûú‰∏çÂØπwrap_contentÂ§ÑÁêÜÈÇ£Â∞±ÊòØÁõ∏ÂΩì‰∫éÂíåmatch_parentÂ°´ÂÖÖÁà∂ÂÆπÂô®ÁöÑÊïàÊûú‰∏ÄÊ†∑„ÄÇ ÊâÄ‰ª•ÈúÄË¶ÅÂØπonMeasure()ÊñπÊ≥ï‰∏≠ÁöÑAT_MOSTÊ®°ÂºèÁöÑÊåáÂÆöÈªòËÆ§Â§ßÂ∞èÊØîÂ¶Ç200pxÔºö 12345678910111213141516protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //ÈªòËÆ§Ë∞ÉÁî®super.setMeasuredDimension() super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(200, 200); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(200, heightSpecSize); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSpecSize, 200); &#125; &#125; Á¨¨‰∫åÊ≠•: ÈÄÇÈÖçpaddingÂ±ûÊÄß marginÊòØ‰∫§ÁªôÁà∂ÂÆπÂô®ÂàÜÈÖçÁöÑÔºå‰ΩÜÊòØpaddingÊòØË¶ÅÂ≠êViewËá™Â∑±Ë¶ÅÂ§ÑÁêÜÁöÑ. ËøôÊó∂ÈúÄË¶ÅÈáçÂÜôonDraw()‰∏≠Êù•Â§ÑÁêÜ. 123456789101112protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); final int paddingLeft = getPaddingLeft(); final int paddingRight = getPaddingRight(); final int paddingTop = getPaddingTop(); final int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingTop - paddingBottom; int radius = Math.min(width, height) / 2; canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, mPaint); &#125; Á¨¨‰∏âÊ≠•:ÊúâÊó∂ÂÄôÊàë‰ª¨ÈúÄË¶ÅÊèê‰æõËá™ÂÆö‰πâÂ±ûÊÄßÔºå ‰æãÂ¶Çandroid:id=ËøôÁßçÔºåÊé•‰∏ãÊù•Ê∑ªÂä†Ëá™ÂÆö‰πâÂ±ûÊÄßÔºö Âú®valuesÁõÆÂΩï‰∏ãÂàõÂª∫Ëá™ÂÆö‰πâÂ±ûÊÄßÁöÑxml. ÂêçÂ≠óÈöè‰æøÂΩìÊúÄÂ•Ωattrs.xmlÊàñËÄÖattrs_xxx_xxx.xml. 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="CircleView"&gt; &lt;attr name="circle_color" format="color"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; ‰∏äÈù¢Áõ∏ÂΩì‰∫é,ÂÆö‰πâ‰∫Ü‰∏Ä‰∏™CircleViewÁöÑÂ±ûÊÄßÈõÜÂêà. Âú®Ëøô‰∏™ÈõÜÂêàÈáåÈù¢‰ºöÊúâËá™ÂÆö‰πâÂ±ûÊÄß. ËøôÈáåÁöÑformatÊ†ºÂºèÂèØ‰ª•ÊòØÊåáÂÆöÂ∞∫ÂØ∏ÁöÑdimension, ËµÑÊ∫êidÂºïÁî®ÁöÑreference, Âü∫Êú¨Á±ªÂûãstring, integer ,booleanÁ≠â. Â£∞ÊòéÂ•Ω‰∫ÜÂ±ûÊÄßÂú®Êàë‰ª¨Ëá™ÂÆö‰πâView‰∏≠Â∞±ÂèØ‰ª•ÂºïÁî®Â§ÑÁêÜ‰∫Ü. Â¶ÇÊûÑÈÄ†ÊñπÊ≥ï‰∏≠. 1234567891011public CircleView(Context context, AttributeSet attrs) &#123; super(context, attrs, defStyleAttr); //Ëé∑Âæó‰∏Ä‰∏™Ëá™ÂÆö‰πâÁöÑÂØπÂ∫îÂ±ûÊÄßÂÄºÈõÜÂêà TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView); //ÂèñÂá∫Â±ûÊÄßÈõÜÂêà‰∏≠ÁöÑÊüê‰∏™Â±ûÊÄßÂÄº mColor = typedArray.getColor(R.styleable.CircleView_circle_color, Color.GREEN); //ÈáäÊîæËµÑÊ∫ê typedArray.recycle(); init(); &#125; Âú®Â∏ÉÂ±Ä‰∏≠‰ΩøÁî®Âç≥ÂèØ. ÂÖàÂ£∞Êòéschemas. xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; ,‰ΩøÁî®appÊù•Êõø‰ª£‰πãÂâçÁöÑÁ±ª‰ººandroidÂâçÁºÄÁöÑÂºïÂØº. ÁªßÊâøViewÁöÑÊ¥æÁîüÁ±ªÂ∞±Âà∞Ê≠§‰∏∫Ê≠¢‰∫ÜÔºöÊïàÊûúÂ¶Ç‰∏ãÔºö]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>Ëá™ÂÆö‰πâView</tag>
        <tag>ViewÁöÑÂ∑•‰ΩúÂéüÁêÜ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewÁöÑ‰∫ã‰ª∂‰ΩìÁ≥ª]]></title>
    <url>%2F2018%2F02%2F28%2FView%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[View ÁöÑÂü∫Á°ÄÁü•ËØÜ ViewÁöÑ‰ΩçÁΩÆÂèÇÊï∞ ViewÁõ∏ÂØπ‰∫éÁà∂ÂÆπÂô®ÁöÑÂùêÊ†átopÔºåleftÔºårightÔºåbottom„ÄÇ 12width = right - leftheight = bottom - top ‰ªéAndroid 3.0ÂºÄÂßãÂ¢ûÂä†‰∫Üx„ÄÅy„ÄÅtranslationX„ÄÅtranlationYÔºõÂÖ∂‰∏≠Ôºö View‰πüÊèê‰æõ‰∫ÜÁõ∏Â∫îÁöÑget/setÊñπÊ≥ïÔºåÂÖ≥Á≥ªÊç¢ÁÆóÔºö 12x = left + translationXy = top + translationY Ê≥®ÊÑè‚ö†Ô∏èÔºöViewÂú®Âπ≥ÁßªÁöÑËøáÁ®ã‰∏≠ÔºåtopÂíåleftÁöÑÂÄºÂπ∂‰∏ç‰ºöÊîπÂèòÔºåÊ≠§Êó∂ÂèëÁîüÊîπÂèòÁöÑÊòØx„ÄÅy„ÄÅtranslationXÂíåtranslationY„ÄÇ MotionEvent Âíå TouchSlop ACTION_DOWN‚Äî‚ÄîÊâãÊåáÂàöÊé•Ëß¶Â±èÂπï ACTION_MOVE‚Äî‚ÄîÊâãÊåáÂú®Â±èÂπï‰∏äÁßªÂä® ACTION_UP‚Äî‚ÄîÊâãÊåá‰ªéÂ±èÂπï‰∏äÊùæÂºÄÁöÑ‰∏ÄÁû¨Èó¥ getX/getYËøîÂõûÁöÑÊòØÁõ∏ÂØπ‰∫éÂΩìÂâçViewÁöÑÂ∑¶‰∏äËßíÁöÑxÂíåyÁöÑÂùêÊ†áÔºåËÄågetRawX/getRawYËøîÂõûÁöÑÊòØÊòØÁõ∏ÂØπ‰∫éÊâãÊú∫Â±èÂπïÂ∑¶‰∏äËßíÁöÑÂùêÊ†á„ÄÇ TouchSlop ÊòØÁ≥ªÁªüËÉΩËØÜÂà´Âá∫ÁöÑË¢´ËÆ§‰∏∫ÊòØÊªëÂä®ÁöÑÊúÄÂ∞èË∑ùÁ¶ª(8dp)„ÄÇ ViewConfigrarion.get(getContext()).getScaledTouchSlop() VelocityTracker„ÄÅGestureDetectorÂíåScroller VelocityTrackerÁî®‰∫éËøΩË∏™ÊâãÊåáÂú®ÊªëÂä®ËøáÁ®ã‰∏≠ÁöÑÈÄüÂ∫¶„ÄÇ GestureDetector ÊâãÂäøÊ£ÄÊµãÔºåÁî®‰∫éÊ£ÄÊµãÂçïÂáª„ÄÅÊªëÂä®„ÄÅÈïøÊåâ„ÄÅÂèåÂáªÁ≠âË°å‰∏∫„ÄÇÈúÄË¶ÅÂÆûÁé∞Êé•Âè£onGestureListenerÂíåonDoubleTapListenerÊØîËæÉÂ∏∏Áî®ÁöÑÊúâÔºöonSingleTapUpÔºàÂçïÂáªÔºâ„ÄÅonFlingÔºàÂø´ÈÄüÊªëÂä®Ôºâ„ÄÅonScollÔºàÊãñÂä®Ôºâ„ÄÅonLongPressÔºàÈïøÊåâÔºâ„ÄÅonDoubleTapÔºàÂèåÂáªÔºâ„ÄÇ ScrollÂÆûÁé∞ÂºπÊÄßÊªëÂä®„ÄÇ ViewÁöÑÊªëÂä® ‰ΩøÁî®scrollTo/srollBy123public void scrollTo (int x, int y);//ÁªùÂØπÂùêÊ†áÊªëÂä®public void scrollBy(int x, int y);//Áõ∏ÂØπÂùêÊ†áÊªëÂä® Â¶ÇÊûú‰ªéÂ∑¶Âà∞Âè≥ÊªëÂä®ÔºåÈÇ£‰πàmSrollX‰∏∫Ë¥üÂÄºÔºåÂèç‰πã‰∏∫Ê≠£ÔºõÂ¶ÇÊûú‰ªé‰∏äÂæÄ‰∏ãÊªëÂä®ÔºåÈÇ£‰πàmScrollY‰∏∫Ë¥üÂÄºÔºåÂèç‰πã‰∏∫Ê≠£Ôºõ‰ΩøÁî®scrollToÂíåscrollByÊù•ÂÆûÁé∞ViewÁöÑÊªëÂä®ÔºåÂè™ËÉΩÂ∞ÜViewÁöÑÂÜÖÂÆπËøõË°åÁßªÂä®Ôºå‰∏çÂΩ±ÂìçÂÜÖÈÉ®ÂÖÉÁ¥†ÁöÑÁÇπÂáª‰∫ã‰ª∂Ôºå‰ΩÜÊòØÂπ∂‰∏çËÉΩÊîπÂèòViewÁöÑÂéüÂßãÂ∏ÉÂ±Ä‰ΩçÁΩÆ„ÄÇ ‰ΩøÁî®Âä®Áîª ViewÂä®ÁîªÔºåÁî®xmlÂÆûÁé∞ View Âä®ÁîªÊòØÂØπViewÁöÑÂΩ±ÂÉèÂÅöÊìç‰ΩúÔºåÂπ∂‰∏çËÉΩÁúüÊ≠£ÁöÑÊîπÂèòViewÁöÑ‰ΩçÁΩÆÂèÇÊï∞ÂíåÂÆΩÈ´òÔºõÂπ∂‰∏îÂ¶ÇÊûúÂ∏åÊúõÂä®ÁîªÂêéÁöÑÁä∂ÊÄÅ‰øùÁïôÂøÖÈ°ªËÆæÁΩÆfillAfterÂ±ûÊÄß‰∏∫true„ÄÇÈÄÇÁî®‰∫éÊ≤°Êúâ‰∫§‰∫íÊÄßÁöÑÔºàÁÇπÂáªÔºâÂú∫ÊôØ„ÄÇ Â±ûÊÄßÂä®Áîª 1ObjectAnimator.ofFloat(targetView, "translationX", 0, 100).setDuration(100).start(); Â±ûÊÄßÂä®ÁîªËÉΩÂ§üÊîπÂèòÂéüÂßã‰ΩçÁΩÆÔºåÊ≤°ÊúâÁº∫ÁÇπÔºå‰ºòÂÖàÊé®Ëçê‰ΩøÁî®„ÄÇ ÊîπÂèòÂ∏ÉÂ±ÄÂèÇÊï∞ÊîπÂèòViewÁöÑÂ∏ÉÂ±ÄÂèÇÊï∞LayoutParamsÔºåÈÄÇÁî®‰∫éÊúâ‰∫§‰∫íÁöÑViewÔºåÊìç‰ΩúÁ®çÂæÆÂ§çÊùÇ„ÄÇ ÂºπÊÄßÊªëÂä®‰ΩøÁî®Scroller Scroller Êú¨Ë∫´‰∏çËÉΩÂÆûÁé∞ View ÁöÑÊªëÂä®ÔºåÂÆÉÈúÄË¶ÅÈÖçÂêà View ÁöÑ computeScroll ÊñπÊ≥ïÊâçËÉΩÂÆåÊàêÂºπÊÄßÊªëÂä®ÁöÑÊïàÊûú„ÄÇÈÄöËøá‰∏çÊñ≠Âú∞ËÆ© View ÈáçÁªòÔºåËÄåÊØè‰∏ÄÊ¨°ÈáçÁªòË∑ùÁ¶ªÊªëÂä®ÂÖ∂ÂÆûËµ∑ÂßãÊó∂Èó¥‰ºöÊúâ‰∏Ä‰∏™Êó∂Èó¥Èó¥ÈöîÔºåÈÄöËøáËøô‰∏™Êó∂Èó¥Èó¥Èöî Scroller ÂæóÂá∫ View ÂΩìÂâçÁöÑÊªëÂä®‰ΩçÁΩÆÔºåÁü•ÈÅì‰∫ÜÊªëÂä®‰ΩçÁΩÆÂ∞±ÂèØ‰ª•ÈÄöËøá scrollTo ÊñπÊ≥ïÂÆåÊàê View ÁöÑÊªëÂä®„ÄÇ View ÁöÑÊØè‰∏ÄÊ¨°ÈáçÁªòÈÉΩ‰ºöÂØºËá¥ View ÁöÑÂ∞èÂπÖÂ∫¶ÊªëÂä®ÔºåËÄåÂ§öÊ¨°ÁöÑÂ∞èÂπÖÂ∫¶ÊªëÂä®ÁªÑÊàê‰∫ÜÂºπÊÄßÊªëÂä®ÔºåËøôÂ∞±ÊòØ Scroller ÊªëÂä®ÁöÑÂ∑•‰ΩúÊú∫Âà∂„ÄÇ 123456789101112131415161718192021Scroller mScroller = new Scroller(mContext);// ÁºìÊÖ¢ÊªöÂä®Âà∞ÊåáÂÆöÁöÑ‰ΩçÁΩÆ private void smoothScrollTo(int destX, int destY)&#123; int scrollX = getScrollX(); int deltaX = destX - scrollX; // ‰ª• 1000ms ÂÜÖÊªëÂêë destXÔºå ÊïàÊûúÊòØÊÖ¢ÊÖ¢ÊªëÂä® mScroller.startScroll(scrollX, destY, deltaX , 0, 1000); // View ÁöÑÈáçÁªò invalidate();&#125; // ÈáçÂÜô computeScroll ÊñπÊ≥ïÔºåÂπ∂Âú®ÂÜÖÈÉ®ÂÆåÊàêÂπ≥ÊªëÊªöÂä®ÁöÑÈÄªËæë @Overridepublic void computeScroll() &#123; //Âà§Êñ≠viewÊòØÂú®ÊåáÂÆöÊó∂Èó¥ÂÜÖÊòØÂê¶ÂÆåÊàêÊªëÂä®,Âπ∂ËÆ°ÁÆóÂá∫ÂΩìÂâçÊó∂Èó¥ÁöÑ mScrolleX Âíå mScrollY if (mScroller.computeScrollOffset())&#123; //ÈÄöËøámScrollerËé∑ÂèñÂΩìÂâç‰ΩçÁΩÆÔºåÂÆûÁé∞ÊªëÂä® scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // ÂÜçÊ¨°ËøõË°åÈáçÁªò postInvalidate(); &#125;&#125; ÈÄöËøáÂä®ÁîªÂ±ûÊÄßÂä®ÁîªÔºö12ObjectAnimator animator = ObjectAnimator.ofFloat(view, "translationX", 0.0f, 100.0f);animator.setDuration(100).start(); ÊàñËÄÖ 1234567891011121314151617181920private void scroller()&#123; //Âä®ÁîªËµ∑Âßã‰ΩçÁΩÆ final int startX = 0; //Âä®ÁîªË¶ÅÊªëÂä®ÁöÑË∑ùÁ¶ª final int deltax = 1000; final ValueAnimator animator = ValueAnimator.ofInt(0, 1).setDuration(2000); //Âä®ÁîªÊ∑ªÂä†ÁõëÂê¨Âô® animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //Ëé∑ÂèñÂä®ÁîªÂÆåÊàêÊØî‰æãÂÄº float fraction = animator.getAnimatedFraction(); //Ê†πÊçÆÊØî‰æãÂÄºÂØπÁõÆÊ†áviewËøõË°åÊªëÂä® targetView.scrollTo(startX +(int)(deltax * fraction), 0); //add other operation &#125; &#125;); //ÂºÄÂßãÊâßË°å animator.start();&#125; Á¨¨‰∫åÁßçÊñπÊ≥ïÊÄùÊÉ≥ÂíåScrollerÂæàÁ±ª‰ººÔºåÈÄöËøáÊó∂Èó¥ÊµÅÈÄùÊØî‰æãÊù•ËÆ°ÁÆóÊªëÂä®Ë∑ùÁ¶ª„ÄÇ ‰ΩøÁî®Âª∂ËøüÁ≠ñÁï• ‰ΩøÁî®HandlerÊàñËÄÖViewÁöÑpostDelayÊñπÊ≥ïÔºåÈó¥ÈöîÁöÑÂèëÈÄÅÊ∂àÊÅØÔºåËÆ°ÁÆóÊªëÂä®Ë∑ùÁ¶ªÔºåÂπ∂‰ΩøÁî®scrollToÂÆåÊàêÊªëÂä®„ÄÇ ViewÁöÑ‰∫ã‰ª∂ÂàÜÂèë ÁÇπÂáª‰∫ã‰ª∂ÁöÑ‰º†ÈÄíËßÑÂàô1public boolean dispatchTouchEvent(MotionEvent ev) Áî®Êù•ËøõË°å‰∫ã‰ª∂ÁöÑÂàÜÂèëÔºåÂ¶ÇÊûú‰∫ã‰ª∂ËÉΩÂ§ü‰º†ÈÄíÁªôÂΩìÂâçÁöÑViewÔºåÈÇ£‰πàÊ≠§ÊñπÊ≥ï‰∏ÄÂÆö‰ºöË¢´Ë∞ÉÁî®ÔºåËøîÂõûÁªìÊûúÂèóÂΩìÂâçViewÁöÑonTouchEventÂíå‰∏ãÁ∫ßÁöÑViewÁöÑdispatchTouchEventÊñπÊ≥ïÁöÑÂΩ±ÂìçÔºåË°®Á§∫ÊòØÂê¶Ê∂àËÄóÂΩìÂâç‰∫ã‰ª∂„ÄÇ 1public boolean onInterceptTouchEvent(MotionEvent event) Âú®dispatchTouchEventÂÜÖÈÉ®Ë∞ÉÁî®ÔºåÁî®Êù•Âà§Êñ≠ÊòØÂê¶Êã¶Êà™Êüê‰∏™‰∫ã‰ª∂ÔºåÂ¶ÇÊûúÂΩìÂâçViewÊã¶Êà™‰∫ÜÊüê‰∏™‰∫ã‰ª∂ÔºåÈÇ£‰πàÂú®Âêå‰∏Ä‰∏™‰∫ã‰ª∂Â∫èÂàó‰∏≠ÔºåÊ≠§ÊñπÊ≥ï‰∏ç‰ºöË¢´ÂÜçÊ¨°Ë∞ÉÁî®ÔºåËøîÂõûÁªìÊûúË°®Á§∫ÊòØÂê¶Êã¶Êà™ÂΩìÂâç‰∫ã‰ª∂„ÄÇ 1public boolean onTouchEvent(MotionEvent event) Âú®dispatchTouchEvent‰∏≠Ë∞ÉÁî®ÔºåÁî®Êù•Â§ÑÁêÜÁÇπÂáª‰∫ã‰ª∂ÔºåËøîÂõûÁªìÊûúË°®Á§∫ÊòØÂê¶Ê∂àËÄóÂΩìÂâç‰∫ã‰ª∂ÔºåÂ¶ÇÊûú‰∏çÊ∂àËÄóÔºåÂàôÂú®Âêå‰∏Ä‰∫ã‰ª∂Â∫èÂàó‰∏≠ÔºåÂΩìÂâçViewÊó†Ê≥ïÂÜçÊ¨°Êé•Êî∂Âà∞‰∫ã‰ª∂„ÄÇ ‰º™‰ª£Á†ÅË°®Á§∫Ôºö 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onIterceptTouchEvent(ev)) &#123; //Êã¶Êà™‰∫ã‰ª∂ consume = onTouchEvent(ev); //Ëá™Â∑±Â§ÑÁêÜ‰∫ã‰ª∂ &#125; else &#123; consume = child.dispatchTouchEvent(ev); //ÂàÜÂèëÁªôÂ≠êViewÂ§ÑÁêÜ‰∫ã‰ª∂ &#125; return consume;&#125; Ê≥®ÊÑè‚ö†Ô∏èÂ¶ÇÊûú‰∏Ä‰∏™ViewËÆæÁΩÆ‰∫ÜOnTouchListenerÔºåÈÇ£‰πàonTouchÊñπÊ≥ïÂ∞Ü‰ºòÂÖàË¢´Ë∞ÉÁî®ÔºõÂ¶ÇÊûúonTouchÊñπÊ≥ïËøîÂõûtureÔºåonTouchEventÊñπÊ≥ïÂ∞Ü‰∏ç‰ºöË¢´Ë∞ÉÁî®ÔºåËøîÂõûfalseÔºåonTouchEventÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®ÔºõÂú®onTouchEvent‰∏≠ÔºåÂ¶ÇÊûúËÆæÁΩÆ‰∫ÜOnClickListenerÔºåÈÇ£‰πàÂÆÉÁöÑonClickÊñπÊ≥ïÂ∞ÜË¢´Ë∞ÉÁî®„ÄÇ‰ºòÂÖàÁ∫ßÔºöonTouch‚Äî&gt;onTouchEvent‚Äî&gt;onClick ‰∫ã‰ª∂‰º†ÈÄíÈ°∫Â∫èÔºöActivity‚Äî&gt;Window‚Äî&gt;View, Â¶ÇÊûú‰∏Ä‰∏™ViewÁöÑonTouchEventËøîÂõûfalseÔºåÈÇ£‰πàÂÆÉÁöÑÁà∂ÂÆπÂô®ÁöÑonTouchEventÂ∞ÜË¢´Ë∞ÉÁî®Ôºå‰ª•Ê≠§Á±ªÊé®ÔºåÂ¶ÇÊûúÊâÄÊúâÂÖÉÁ¥†ÈÉΩ‰∏çÂ§ÑÁêÜËøô‰∏™‰∫ã‰ª∂ÔºåÈÇ£‰πàÊúÄÁªà‰º†ÈÄíÁªôActivityÁöÑonTouchEventÊù•Â§ÑÁêÜ„ÄÇ ‰∏Ä‰∏™‰∫ã‰ª∂Â∫èÂàóÔºå‰ªéACTION_DOWNÂºÄÂßãÔºå‰∏≠Èó¥ÊúâÊï∞Èáè‰∏çÂÆöÁöÑACTION_MOVE,ÊúÄÁªà‰ª•ACTION_UPÁªìÊùü„ÄÇ ‰∏Ä‰∏™‰∫ã‰ª∂Â∫èÂàóÂè™ËÉΩË¢´‰∏Ä‰∏™ViewÊã¶Êà™‰∏îÊ∂àËÄóÔºå‰∏ÄÊó¶Êüê‰∏™ViewÂÜ≥ÂÆöÊã¶Êà™ÔºåÈÇ£‰πàËøô‰∏™‰∫ã‰ª∂Â∫èÂàóÈÉΩÂè™ËÉΩÁî±ÂÆÉÊù•Â§ÑÁêÜÔºåÂπ∂‰∏îÂÆÉÁöÑonIterceptTouchEvent‰∏ç‰ºöÂÜçË¢´Ë∞ÉÁî®ÔºàonIterceptTouchEvent‰ªÖ‰ªÖË∞ÉÁî®‰∏ÄÊ¨°Ôºâ„ÄÇ Êüê‰∏™View‰∏ÄÊó¶ÂºÄÂßãÂ§ÑÁêÜ‰∫ã‰ª∂ÔºåÂ¶ÇÊûúÂÆÉ‰∏çÊ∂àËÄóACTION_DOWN‰∫ã‰ª∂ÔºàonTouchEventËøîÂõûfalseÔºâÔºåÈÇ£‰πàÂêå‰∏Ä‰∫ã‰ª∂Â∫èÂàó‰∏≠ÁöÑÂÖ∂‰ªñ‰∫ã‰ª∂ÈÉΩ‰∏ç‰ºöÂÜç‰∫§ÁªôÂÆÉÂ§ÑÁêÜÔºåÂπ∂‰∏î‰∫ã‰ª∂Â∞ÜÈáçÊñ∞‰∫§ÁªôÂÆÉÁöÑÁà∂ÂÖÉÁ¥†ÂéªÂ§ÑÁêÜ„ÄÇ ViewGroupÈªòËÆ§‰∏çÊã¶Êà™‰ªª‰Ωï‰∫ã‰ª∂ÔºåonInterceptEventÊñπÊ≥ïÈªòËÆ§ËøîÂõûfalse„ÄÇ ViewÊ≤°ÊúâonInterceptEventÊñπÊ≥ïÔºå‰∏ÄÊó¶Êúâ‰∫ã‰ª∂‰º†ÈÄíÁªôÂÆÉÔºåÈÇ£‰πàonTouchEventÊñπÊ≥ïÂ∞±‰ºöË¢´Ë∞ÉÁî®„ÄÇ ViewÁöÑonTouchEventÈªòËÆ§ÈÉΩ‰ºöÊ∂àËÄó‰∫ã‰ª∂ÔºàËøîÂõûtrueÔºâÔºåÈô§ÈùûÂÆÉÊòØ‰∏çÂèØÁÇπÂáªÁöÑÔºàclickableÂíålongClickableÂêåÊó∂‰∏∫falseÔºâ„ÄÇViewÁöÑlongClickableÈªòËÆ§ÈÉΩ‰∏∫false„ÄÇenableÂ±ûÊÄß‰∏çÂΩ±ÂìçonTouchEventÁöÑËøîÂõûÂÄº„ÄÇ onClickÂèëÁîüÁöÑÂâçÊèêÊòØViewÊòØÂèØÁÇπÂáªÁöÑÔºåÂπ∂‰∏îÊî∂Âà∞‰∫ÜdownÂíåup‰∫ã‰ª∂„ÄÇ ‰∫ã‰ª∂‰º†ÈÄíËøáÁ®ãÊòØÁî±Áà∂ÂÖÉÁ¥†ÂàÜÂèëÂà∞Â≠êÂÖÉÁ¥†ÔºåÈÄöËøárequestDisallowInterceptTouchEventÊñπÊ≥ïÂèØ‰ª•Âú®Â≠êÂÖÉÁ¥†‰∏≠Âπ≤È¢ÑÂ§´ÂÖÉÁ¥†ÁöÑ‰∫ã‰ª∂ÂàÜÂèëËøáÁ®ãÔºàACTION_DOWNÈô§Â§ñÔºâ„ÄÇ ‰∫ã‰ª∂ÂàÜÂèëÊ∫êÁ†ÅËß£Êûê‰∫ã‰ª∂ÂàÜÂèëÊÄª‰ΩìÂõæÔºö ActivityÂØπÁÇπÂáª‰∫ã‰ª∂ÁöÑÂàÜÂèëËøáÁ®ã 1Activiy‚Äî&gt;Window(PhoneWindow)‚Äî&gt;DecorView‚Äî&gt;ContentView‚Äî&gt;È°∂Á∫ßViewGroup‚Äî&gt;Views ViewGroupÂØπÁÇπÂáª‰∫ã‰ª∂ÁöÑÂàÜÂèëËøáÁ®ã ViewÂØπÁÇπÂáª‰∫ã‰ª∂ÁöÑÂ§ÑÁêÜ ‚Äã ÊÄªÁªìÔºö ÂèÇËÄÉ: Android‰∫ã‰ª∂ÂàÜÂèëÊú∫Âà∂ËØ¶Ëß£ Android‰∫ã‰ª∂ÂàÜÂèëÊú∫Âà∂ÂÆåÂÖ®Ëß£ÊûêÔºåÂ∏¶‰Ω†‰ªéÊ∫êÁ†ÅÁöÑËßíÂ∫¶ÂΩªÂ∫ïÁêÜËß£(‰∏ã) Android ViewÁöÑ‰∫ã‰ª∂ÂàÜÂèëÊú∫Âà∂ÂíåÊªëÂä®ÂÜ≤Á™ÅËß£ÂÜ≥ ÂõæËß£ Android ‰∫ã‰ª∂ÂàÜÂèëÊú∫Âà∂ View ÁöÑÊªëÂä®ÂÜ≤Á™ÅÂ∏∏ËßÅÁöÑÊªëÂä®ÂÜ≤Á™ÅÂú∫ÊôØÔºö Âú∫ÊôØ1‚Äî‚ÄîÂ§ñÈÉ®ÊªëÂä®ÊñπÂêëÂíåÂÜÖÈÉ®ÊªëÂä®ÊñπÂêë‰∏ç‰∏ÄËá¥ÔºàViewPager + ListViewÔºâ Âú∫ÊôØ2‚Äî‚ÄîÂ§ñÈÉ®ÊªëÂä®ÊñπÂêëÂíåÂÜÖÈÉ®ÊªëÂä®ÊñπÂêë‰∏ÄËá¥ÔºàSrcollView + ListViewÔºâ Âú∫ÊôØ3‚Äî‚Äî‰∏äÈù¢‰∏§ÁßçÊÉÖÂÜµÁöÑÂµåÂ•óÔºàSlideMenu + ScrollView + ListViewÔºâ ÊÄé‰πàÂ§ÑÁêÜÔºüÂà©Áî®‰∫ã‰ª∂ÂàÜÂèëÊú∫Âà∂ÔºåÈíàÂØπÊªëÂä®ÂÜ≤Á™Å‰ΩøÁî®Â§ñÈÉ®Êã¶Êà™Ê≥ïÂíåÂÜÖÈÉ®Êã¶Êà™Ê≥ï Â§ñÈÉ®Êã¶Êà™Ê≥ï ÊåáÁÇπÂáª‰∫ã‰ª∂ÈÄöËøáÁà∂ÂÆπÂô®ÁöÑÊã¶Êà™Â§ÑÁêÜÔºåÂ¶ÇÊûúÁà∂ViewÈúÄË¶ÅÊã¶Êà™Â∞±Êã¶Êà™ÔºåÂê¶Âàô‰∫§ÁªôÂ≠êViewÂ§ÑÁêÜÔºåËøôÁßçÊñπÊ≥ïÁ¨¶Âêà‰∫ã‰ª∂ÁöÑÂàÜÂèëÊú∫Âà∂„ÄÇÈúÄË¶ÅÈáçÂÜôÁà∂ÂÆπÂô®ÁöÑonInterceptTouchEventÊñπÊ≥ï„ÄÇ 12345678910111213141516171819202122232425262728public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; //ÂøÖÈ°ªËøîÂõûfalse break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (Êª°Ë∂≥Áà∂ÂÆπÂô®ÁöÑÊã¶Êà™Ë¶ÅÊ±Ç) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; //ÂøÖÈ°ªËøîÂõûfalse break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; Ê†πÊçÆ‰∏öÂä°ÈÄªËæëÈúÄË¶ÅÔºåÂú®ACTION_MOVEÊñπÊ≥ï‰∏≠ËøõË°åÂà§Êñ≠ÔºåÂ¶ÇÊûúÈúÄË¶ÅÁà∂ViewÂ§ÑÁêÜÂàôËøîÂõûtrueÔºåÂê¶ÂàôËøîÂõûfalseÔºå‰∫ã‰ª∂ÂàÜÂèëÁªôÂ≠êViewÂéªÂ§ÑÁêÜ„ÄÇ ACTION_DOWN ‰∏ÄÂÆöËøîÂõûfalseÔºå‰∏çË¶ÅÊã¶Êà™ÂÆÉÔºåÂê¶ÂàôÊ†πÊçÆView‰∫ã‰ª∂ÂàÜÂèëÊú∫Âà∂ÔºåÂêéÁª≠ACTION_MOVE ‰∏é ACTION_UP‰∫ã‰ª∂ÈÉΩÂ∞ÜÈªòËÆ§‰∫§ÁªôÁà∂ViewÂéªÂ§ÑÁêÜÔºÅ ÂéüÂàô‰∏äACTION_UP‰πüÈúÄË¶ÅËøîÂõûfalseÔºåÂ¶ÇÊûúËøîÂõûtrueÔºåÂπ∂‰∏îÊªëÂä®‰∫ã‰ª∂‰∫§ÁªôÂ≠êViewÂ§ÑÁêÜÔºåÈÇ£‰πàÂ≠êViewÂ∞ÜÊé•Êî∂‰∏çÂà∞ACTION_UP‰∫ã‰ª∂ÔºåÂ≠êViewÁöÑonClick‰∫ã‰ª∂‰πüÊó†Ê≥ïËß¶Âèë„ÄÇËÄåÁà∂View‰∏ç‰∏ÄÊ†∑ÔºåÂ¶ÇÊûúÁà∂ViewÂú®ACTION_MOVE‰∏≠ÂºÄÂßãÊã¶Êà™‰∫ã‰ª∂ÔºåÈÇ£‰πàÂêéÁª≠ACTION_UP‰πüÂ∞ÜÈªòËÆ§‰∫§ÁªôÁà∂ViewÂ§ÑÁêÜÔºÅ ÂÜÖÈÉ®Êã¶Êà™Ê≥ï Âç≥Áà∂View‰∏çÊã¶Êà™‰ªª‰Ωï‰∫ã‰ª∂ÔºåÊâÄÊúâ‰∫ã‰ª∂ÈÉΩ‰º†ÈÄíÁªôÂ≠êViewÔºåÂ≠êViewÊ†πÊçÆÈúÄË¶ÅÂÜ≥ÂÆöÊòØËá™Â∑±Ê∂àË¥π‰∫ã‰ª∂ËøòÊòØÁªôÁà∂ViewÂ§ÑÁêÜ„ÄÇËøôÈúÄË¶ÅÂ≠êView‰ΩøÁî®requestDisallowInterceptTouchEventÊñπÊ≥ïÊâçËÉΩÊ≠£Â∏∏Â∑•‰Ωú„ÄÇ‰∏ãÈù¢ÊòØÂ≠êViewÁöÑdispatchTouchEventÊñπÊ≥ïÁöÑ‰º™‰ª£Á†ÅÔºö 12345678910111213141516171819202122232425262728public boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; parent.requestDisallowInterceptTouchEvent(true);//Áà∂ÂÆπÂô®ËÆæÁΩÆ‰∏çÊã¶Êà™ break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; if (Áà∂ÂÆπÂô®ÈúÄË¶ÅÊ≠§Á±ªÁÇπÂáª‰∫ã‰ª∂) &#123; parent.requestDisallowInterceptTouchEvent(false);//Áà∂ÂÆπÂô®ËÆæÁΩÆÊã¶Êà™ &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; Áà∂ViewÈúÄË¶ÅÈáçÂÜôonInterceptTouchEventÊñπÊ≥ïÔºö 12345678public boolean onInterceptTouchEvent(MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125; ‰ΩøÁî®ÂÜÖÈÉ®Êã¶Êà™Ê≥ïÈúÄË¶ÅÊ≥®ÊÑèÔºö ÂÜÖÈÉ®Êã¶Êà™Ê≥ïË¶ÅÊ±ÇÁà∂View‰∏çËÉΩÊã¶Êà™ACTION_DOWN‰∫ã‰ª∂ÔºåÁî±‰∫éACTION_DOWN‰∏çÂèóFLAG_DISALLOW_INTERCEPTÊ†áÂøó‰ΩçÊéßÂà∂Ôºå‰∏ÄÊó¶Áà∂ÂÆπÂô®Êã¶Êà™ACTION_DOWNÈÇ£‰πàÊâÄÊúâÁöÑ‰∫ã‰ª∂ÈÉΩ‰∏ç‰ºö‰º†ÈÄíÁªôÂ≠êView„ÄÇ ÊªëÂä®Á≠ñÁï•ÁöÑÈÄªËæëÊîæÂú®Â≠êViewÁöÑdispatchTouchEventÊñπÊ≥ïÁöÑACTION_MOVE‰∏≠ÔºåÂ¶ÇÊûúÁà∂ÂÆπÂô®ÈúÄË¶ÅËé∑ÂèñÁÇπÂáª‰∫ã‰ª∂ÂàôË∞ÉÁî® parent.requestDisallowInterceptTouchEvent(false)ÊñπÊ≥ïÔºåËÆ©Áà∂ÂÆπÂô®ÂéªÊã¶Êà™‰∫ã‰ª∂„ÄÇ ÂèÇËÄÉÔºö ‰∏ÄÊñáËß£ÂÜ≥Android ViewÊªëÂä®ÂÜ≤Á™Å]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>ViewÁöÑ‰∫ã‰ª∂ÂàÜÂèë</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPCÊú∫Âà∂]]></title>
    <url>%2F2018%2F02%2F22%2FIPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android‰∏≠ÁöÑÂ§öËøõÁ®ãÊ®°ÂºèÂºÄÂêØÂ§öËøõÁ®ãÊ®°Âºè Âú®AndroidMenifest‰∏≠‰∏∫ÂõõÂ§ßÁªÑ‰ª∂ÊåáÂÆöandroid:processÂ±ûÊÄß ÈÄöËøáJNIÂú®nativeÂ±Çfork‰∏Ä‰∏™Êñ∞ÁöÑËøõÁ®ã Êü•ÁúãËøõÁ®ã‰ø°adb shell ps | grep packagename android:process Â±ûÊÄßÊñπÂºèÂå∫Âà´ ‚Äú:remote‚ÄùÂºÄÂ§¥ÔºåËøõÁ®ãÂêç‰∏∫packagename:remote ,Â±û‰∫éÂΩìÂâçÂ∫îÁî®ÁöÑÁßÅÊúâËøõÁ®ã„ÄÇ ‚Äúcom.packagename.remote‚ÄùÂÆåÊï¥ÂëΩÂêçÂàôÂ±û‰∫éÂÖ®Â±ÄËøõÁ®ãÔºåÈÄöËøáÂÖ∑ÊúâÁõ∏ÂêåÁöÑShareUIDÂíåÁ≠æÂêçÔºå‰∏§‰∏™‰∏çÂêåÂ∫îÁî®ÂèØ‰ª•Ë∑ëÂú®Âêå‰∏Ä‰∏™ËøõÁ®ã‰∏≠„ÄÇÂÖ∑ÊúâÁõ∏ÂêåUIDÁöÑÂ∫îÁî®ÂèØ‰ª•ÂÖ±‰∫´Êï∞ÊçÆÔºàdataÁõÆÂΩï„ÄÅÁªÑ‰ª∂‰ø°ÊÅØÁ≠âÔºâ Â§öËøõÁ®ãÊ®°ÂºèËøêË°åÊú∫Âà∂ ‰∏çÂêåÁöÑËøõÁ®ãÁöÑÁªÑ‰ª∂‰ºöÊã•ÊúâÁã¨Á´ãÁöÑËôöÊãüÊú∫„ÄÅApplication„ÄÅ‰ª•ÂèäÂÜÖÂ≠òÁ©∫Èó¥„ÄÇ Â§öËøõÁ®ãÊ≥®ÊÑèÁöÑÈóÆÈ¢òÔºö ÈùôÊÄÅÊàêÂëòÂíåÂçïÂàó‰∏çËÉΩË∑®ËøõÁ®ã‰ΩøÁî® Á∫øÁ®ãÂêåÊ≠•Â§±Êïà SharedPreferenceÁöÑÂèØÈù†ÊÄß‰∏ãÈôç Application‰ºöÂ§öÊ¨°ÂàõÂª∫ SharePrefÂ∫ïÂ±ÇÈÄöËøáËØªÂÜôxmlÊñá‰ª∂ÂÆûÁé∞ÔºåÂπ∂ÂèëÊâßË°åËØªÂÜôÊìç‰ΩúÂèØËÉΩ‰ºöÂØºËá¥‰∏ÄÂÆöÂá†ÁéáÁöÑÊï∞ÊçÆ‰∏¢Â§± ‚Äã IPCÂü∫Á°ÄÊ¶ÇÂøµ‰ªãÁªçSerializableÊé•Âè£ 123456public class User implements Serializable &#123; private static final long serialVersionUID = 87113688048893844L; public int userId; public String userName; public boolean isMale;&#125; Ëøô‰∏™serialVersionUIDÊòØÁî®Êù•ËæÖÂä©Â∫èÂàóÂåñÂíåÂèçÂ∫èÂàóÂåñÁöÑÔºåÂ∫èÂàóÂåñÊó∂‰ºöÂ∞ÜËØ•Â≠óÊÆµÂÜôÂÖ•Êñá‰ª∂‰∏≠ÔºåÁÑ∂ÂêéÂèçÂ∫èÂàóÂåñÊó∂Ê£ÄÊµãÊñá‰ª∂‰∏≠ÁöÑserialVersionUIDÊòØÂê¶‰∏éÂΩìÂâçÁ±ª‰∏ÄËá¥„ÄÇÂ¶ÇÊûú‰∏ç‰∏ÄËá¥ÔºåÂ∞ÜÂ∫èÂàóÂåñÂ§±Ë¥•„ÄÇ ÊúÄÂ•ΩËÉΩÂ§üÊâãÂä®ÊåáÂÆöserialVersionUIDÔºåËøôÊ†∑ÁâàÊú¨Êõ¥Êñ∞ÂêéÔºåÊàë‰ª¨ÂèØËÉΩÂà†Èô§ÊàñÊñ∞Â¢û‰∫Ü‰∏Ä‰∫õFieldÔºå‰ΩÜÊòØÂèçÂ∫èÂàóÂåñ‰ªçËÉΩÊàêÂäü„ÄÇ‰∏çÊåáÂÆöÁöÑËØùÁî±‰∫éÁ±ªÂÜÖÈÉ®ÊàêÂëòÂèòÂåñÔºåÊâÄ‰ª•ËÆ°ÁÆóhashÂÄºÂèòÂåñÔºåÂØºËá¥ÂèçÂ∫èÂàóÂ§±Ë¥•„ÄÇ ÈùôÊÄÅÊàêÂëò‰∏çÂèÇ‰∏éÂ∫èÂàóÂåñ transientÂÖ≥ÈîÆÂ≠óÊ†áËÆ∞ÁöÑÊàêÂëòÂèòÈáè‰∏çÂèÇ‰∏éÂ∫èÂàóÂåñ SerialableÊé•Âè£ÊòØÂ∫èÂàóÂåñÈúÄË¶ÅÂ§ßÈáèI/OÊìç‰ΩúÔºåÂºÄÈîÄÂ§ß ParcelableÊé•Âè£ Parcelable‰∏ªË¶ÅÁî®Âú®ÂÜÖÂ≠òÂ∫èÂàóÂåñ‰∏äÔºåÊïàÁéáÈ´òÔºåAndroidÂπ≥Âè∞Êé®ËçêÁî®„ÄÇ ‰ΩÜÊòØÂØπË±°Â∫èÂàóÂåñÂêéË¶ÅÁΩëÁªú‰º†ËæìÂíåÊåÅ‰πÖÂåñÂ≠òÂÇ®Êé®ËçêÁî®Serialable„ÄÇ BinderÈ©±Âä® ClientÂíåServerÂàÜÂà´Â±û‰∫é‰∏çÂêåÁöÑËøõÁ®ãÔºå‰ªñ‰ª¨‰πãÈó¥ÁöÑÂØπË±°‰∏çËÉΩÁõ¥Êé•ÂÖ±‰∫´ÔºåÈÇ£‰πàÊòØÊÄé‰πà‰º†ÈÄíÁöÑÂë¢Ôºü ÂÖ∂ÂÆûÂ∞±ÊòØÈÄöËøáBinderÈ©±Âä®„ÄÇClientÁ´ØÊãøÂà∞ÁöÑÂÖ∂ÂÆûÊòØServerÁ´ØBinderÂØπË±°ÁöÑProxyÂØπË±°ÔºåÈÄöËøáË∞ÉÁî®ËØ•ProxyÂØπË±°ÁöÑÊñπÊ≥ïÔºåÂÆûÈôÖÊïàÊûúÁõ∏ÂΩì‰∫éServerÁöÑBinder‰∏≠ÁöÑÊñπÊ≥ï„ÄÇ ‰ªéËøõÁ®ãÈó¥ÈÄö‰ø°ÁöÑËßíÂ∫¶ÁúãÔºåBinder ÊòØ‰∏ÄÁßçËøõÁ®ãÈó¥ÈÄö‰ø°ÁöÑÊú∫Âà∂Ôºõ ‰ªé Server ËøõÁ®ãÁöÑËßíÂ∫¶ÁúãÔºåBinder ÊåáÁöÑÊòØ Server ‰∏≠ÁöÑ Binder ÂÆû‰ΩìÂØπË±°Ôºõ ‰ªé Client ËøõÁ®ãÁöÑËßíÂ∫¶ÁúãÔºåBinder ÊåáÁöÑÊòØÂØπ Binder ‰ª£ÁêÜÂØπË±°ÔºåÊòØ Binder ÂÆû‰ΩìÂØπË±°ÁöÑ‰∏Ä‰∏™ËøúÁ®ã‰ª£ÁêÜ ‰ªé‰º†ËæìËøáÁ®ãÁöÑËßíÂ∫¶ÁúãÔºåBinder ÊòØ‰∏Ä‰∏™ÂèØ‰ª•Ë∑®ËøõÁ®ã‰º†ËæìÁöÑÂØπË±°ÔºõBinder È©±Âä®‰ºöÂØπËøô‰∏™Ë∑®Ë∂äËøõÁ®ãËæπÁïåÁöÑÂØπË±°ÂØπ‰∏ÄÁÇπÁÇπÁâπÊÆäÂ§ÑÁêÜÔºåËá™Âä®ÂÆåÊàê‰ª£ÁêÜÂØπË±°ÂíåÊú¨Âú∞ÂØπË±°‰πãÈó¥ÁöÑËΩ¨Êç¢„ÄÇ ‚Äã Binder BinderÊòØÂÆ¢Êà∑Á´ØÂíåÊúçÂä°Á´ØÈÄö‰ø°ÁöÑÂ™í‰ªãÔºåÂΩìbindServiceÁöÑÊó∂ÂÄôÔºåÊúçÂä°Á´Ø‰ºöËøîÂõû‰∏Ä‰∏™ÂåÖÂê´‰∫ÜÊúçÂä°Á´Ø‰∏öÂä°Ë∞ÉÁî®ÁöÑBinderÂØπË±°ÔºåÈÄöËøáËøô‰∏™BinderÂØπË±°ÔºåÂÆ¢Êà∑Á´ØÂ∞±ÂèØ‰ª•Ëé∑ÂèñÊúçÂä°Á´ØÊèê‰æõÁöÑÊúçÂä°ÂíåÊï∞ÊçÆ„ÄÇaidlÁ±ªÊ†∏ÂøÉÂÆûÁé∞ÂÜÖÈÉ®Á±ªStub‰ª•ÂèäStubÁöÑÂÜÖÈÉ®‰ª£ÁêÜÁ±ªProxy„ÄÇ DESCRIPTOR BinderÁöÑÂîØ‰∏ÄÊ†áÁ§∫Ôºå‰∏ÄËà¨Áî®ÂΩìÂâçBinderÁöÑÁ±ªÂêç asInterface(android.os.IBinder obj) Áî®‰∫éÂ∞ÜÊúçÂä°Á´ØÁöÑBinderÂØπË±°ËΩ¨Êç¢ÊàêÂÆ¢Êà∑Á´ØÊâÄÈúÄÁöÑAIDLÊé•Âè£Á±ªÂûãÂØπË±°ÔºåÂå∫ÂàÜËøõÁ®ãÔºåÂ¶ÇÊûúÂÆ¢Êà∑Á´ØÂíåÊúçÂä°Á´Ø‰Ωç‰∫éÂêå‰∏ÄËøõÁ®ãÔºåËøîÂõûÊúçÂä°Á´ØÁöÑStubÂØπË±°Êú¨Ë∫´ÔºåÂê¶ÂàôËøîÂõûStub.proxyÂØπË±°„ÄÇ asBinder ËøîÂõûÂΩìÂâçÁöÑBinderÂØπË±° onTransact ËøêË°åÂú®ÊúçÂä°Á´ØÁöÑBinderÁ∫øÁ®ãÊ±†‰∏≠ÔºåÂéüÂûã‰∏∫ 1public Boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flag) codeÁ°ÆÂÆöÁõÆÊ†áÊñπÊ≥ïÔºådataÁõÆÊ†áÂèÇÊï∞ÔºåreplyÂÜôÂÖ•ËøîÂõûÂÄº„ÄÇ Proxy#getBookList Ëøô‰∏™ÊñπÊ≥ïËøêË°åÂú®ÂÆ¢Êà∑Á´ØÔºåÂÆ¢Êà∑Á´ØËøúÁ®ãË∞ÉÁî®ËØ•ÊñπÊ≥ïÔºåÂàõÂª∫ËæìÂÖ•ÂûãParcelÂØπË±°dataÔºåËæìÂá∫ÂûãParcelÂØπË±°_replyÂíåËøîÂõûÂÄºÂØπË±°List„ÄÇÊé•ÁùÄË∞ÉÁî®transactÊñπÊ≥ïÂèëËµ∑RPCÔºàËøúÁ®ãËøáÁ®ãË∞ÉÁî®ÔºâËØ∑Ê±ÇÔºåÂêåÊó∂ÂΩìÂâçÁ∫øÁ®ãÊåÇËµ∑ÔºõÁÑ∂ÂêéÊúçÂä°Á´ØÁöÑonTransactÊñπÊ≥ï‰ºöË¢´Ë∞ÉÁî®ÔºåÁõ¥Âà∞RPCËøîÂõûÔºåÂΩìÂâçÁ∫øÁ®ãÁªßÁª≠ÊâßË°åÔºåÂπ∂‰ªé_reply‰∏≠ËøîÂõûÁªìÊûú„ÄÇ ÈÄöËøálinkToDeath Âíå unlinkToDeathÁªôBinderËÆæÁΩÆÊ≠ª‰∫°‰ª£ÁêÜDeathRecipientÔºåÂΩìÊúçÂä°Á´ØËøõÁ®ãÂºÇÂ∏∏ÁªàÊ≠¢Êó∂ÔºåÂèØ‰ª•Êî∂Âà∞ÈÄöÁü•„ÄÇ Android‰∏≠ÁöÑIPCÊñπÂºè ‰ΩøÁî®Bundle ‰ΩøÁî®Êñá‰ª∂ÂÖ±‰∫´ÔºàËÄÉËôëÂπ∂ÂèëËØªÂÜôÁöÑÈóÆÈ¢òÔºåÊ≥®ÊÑè‚ö†Ô∏èSharedPrefences‰∏çÊîØÊåÅË∑®ËøõÁ®ãËØªÂÜôÔºâ ‰ΩøÁî®Messenger ‰ø°‰Ωø ‰ΩøÁî®AIDL ‚Äã ‰ΩøÁî®Messager ‚Äã MessgenerÁöÑÂ∑•‰ΩúÂéüÁêÜ AIDL ÊúçÂä°Á´ØÔºöÂàõÂª∫‰∏Ä‰∏™serviceÊù•ÁõëÂê¨ÂÆ¢Êà∑Á´ØÁöÑËØ∑Ê±ÇÔºåÂàõÂª∫‰∏Ä‰∏™AIDLÊñá‰ª∂ÔºåÊö¥Èú≤Âá∫AIDLÊé•Âè£‰æõÂÆ¢Êà∑Á´ØË∞ÉÁî®ÔºåÊúÄÂêéÂú®service‰∏≠ÂÆûÁé∞Ëøô‰∏™AIDLÊé•Âè£„ÄÇ ÂÆ¢Êà∑Á´ØÔºöbindServiceÁªëÂÆöÊúçÂä°ÔºåË∞ÉÁî®AIDLÊé•Âè£ AIDLÊñá‰ª∂ÊîØÊåÅÁ±ªÂûãÔºöÂü∫Êú¨Êï∞ÊçÆÁ±ªÂûã„ÄÅString„ÄÅArrayList„ÄÅHashMap„ÄÅPacelableÂØπË±°„ÄÅÂÖ∂‰ªñAIDLÊé•Âè£„ÄÇ Ê≥®ÊÑè‚ö†Ô∏èËá™ÂÆö‰πâÁöÑPacelableÂØπË±°ÂøÖÈ°ªÊñ∞Âª∫‰∏Ä‰∏™ÂíåÂÆÉÂêåÂêçÁöÑAIDLÊñá‰ª∂ÔºåÂπ∂ÊòæÁ§∫importËøõÊù•„ÄÇ Èô§‰∫ÜÂü∫Êú¨Êï∞ÊçÆÁ±ªÂûãÔºåÂÖ∂‰ªñÂèÇÊï∞ÂøÖÈ°ªË°®‰∏äÊñπÂêëÔºöin„ÄÅout„ÄÅinout 1234##Book.aidlpackage com.ryg.chapter_2.aidl;parcelable Book; 123456789101112##IBookManager.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;import com.ryg.chapter_2.aidl.IOnNewBookArrivedListener;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookArrivedListener listener);//obsever mode void unregisterListener(IOnNewBookArrivedListener listener);&#125; 12345678##IOnNewBookArrivedListener.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;interface IOnNewBookArrivedListener &#123; void onNewBookArrived(in Book newBook);&#125; AIDL‰∏≠ËßÇÂØüËÄÖÊ®°ÂºèÁöÑ‰ΩøÁî®ÔºåÊèê‰æõ‰∏Ä‰∏™AIDLÊé•Âè£ÔºåÂÆ¢Êà∑Á´ØÈúÄË¶ÅÂÆûÁé∞ËØ•listenerÔºàÈÄöËøáÁªßÊâøËØ•Listener.StubÊé•Âè£ÔºâÔºå‰º†ÈÄíÁªôÊúçÂä°Á´ØÔºåÊúçÂä°Á´ØÂ§ÑÁêÜÂÆåÊàêÂêéÂÜçÂõûË∞ÉÂõûÂÆ¢Êà∑Á´Ø„ÄÇ Ê≥®ÂÜåÂíåËß£Ê≥®ÂÜåÔºå‰ΩøÁî®==RemoteCallbackList==Ôºå‰∏ìÈó®Êèê‰æõÁî®‰∫éÂà†Èô§Ë∑®ËøõÁ®ãÁöÑlistenerÊé•Âè£„ÄÇ Â¶ÇÊûúÊüê‰∏™ËøúÁ®ãÊñπÊ≥ïÊòØËÄóÊó∂ÁöÑÔºåÈÇ£‰πàË¶ÅÈÅøÂÖçÂú®ÂÆ¢Êà∑Á´ØUIÁ∫øÁ®ã‰∏≠ÂéªËÆøÈóÆËøúÁ®ãÊñπÊ≥ïÔºåÂê¶Âàô‰ºöÂØºËá¥ÂÆ¢Êà∑Á´ØANR„ÄÇÂÆ¢Êà∑Á´ØÁöÑonServiceConnectedÂíåonServiceDisconnectedÊñπÊ≥ïÈÉΩËøêË°åÂú®UIÁ∫øÁ®ã‰∏≠ÔºåÊâÄ‰ª•‰πü‰∏çËÉΩÂú®ËøôÈáåË∞ÉÁî®ÊúçÂä°Á´ØÁöÑËÄóÊó∂ÊñπÊ≥ï„ÄÇËß£ÂÜ≥ÁöÑÂäûÊ≥ïÊòØÂú®ÈùûUIÁ∫øÁ®ã‰∏≠Ë∞ÉÁî®ÂéüÂéÇÊñπÊ≥ï„ÄÇ ÂêåÁêÜÔºåÂ¶ÇÊûúÊúâÊúçÂä°Á´ØÈúÄË¶ÅË∞ÉÁî®ÂÆ¢Êà∑Á´ØÁöÑlistenerÊñπÊ≥ïÔºåË¢´Ë∞ÉÁî®ÁöÑÊñπÊ≥ïÂ∞ÜËøêË°åÂú®ÂÆ¢Êà∑Á´ØÁöÑBinderÁ∫øÁ®ãÊ±†‰∏≠ÔºåÂ¶ÇÊûúlistener‰∏≠ÁöÑÊñπÊ≥ïÊØîËæÉËÄóÊó∂Ôºå‰πüË¶ÅÊ≥®ÊÑèÊúçÂä°Á´ØÁöÑANRÈóÆÈ¢ò„ÄÇ BinderÊÑèÂ§ñÊ≠ª‰∫°ÈáçËøû ÁªôBinderËÆæÁΩÆDeathRecipientÁõëÂê¨ÔºàÂú®ÂÆ¢Êà∑Á´ØBinderÁ∫øÁ®ã‰∏≠Ë¢´ÂõûË∞ÉÔºâ Âú®onServiceDisconnected‰∏≠ÈáçËøûËøúÁ®ãÊúçÂä°ÔºàÂú®ÂÆ¢Êà∑Á´ØUIÁ∫øÁ®ãË¢´ÂõûË∞ÉÔºâ ÊùÉÈôêÈ™åËØÅ AndroidMenifest.xmlÂ£∞ÊòéÊùÉÈôê 123&lt;permission android:name="com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE" android:protectionLevel="normal" /&gt; Âú®ÊúçÂä°ÈòüÁöÑonBindÊàñËÄÖonTransactÊñπÊ≥ï‰∏≠ËøõË°åÊùÉÈôêÈ™åËØÅ„ÄÇ ‰ΩøÁî®ContentProviderÁªßÊâøContentProviderÔºåÈÄöËøáContentResolverÁöÑquery„ÄÅupdate„ÄÅinsert„ÄÅdeleteÊñπÊ≥ïÂÆûÁé∞Êï∞ÊçÆÂ∫ìSQLiteOpenHelperÁöÑCRUDÊìç‰Ωú„ÄÇ ‰ΩøÁî®Socket‰ΩøÁî®ServerSocket‚Äî&gt;TCPËøûÊé•; UDP‰πüÊòØË∑®ËøõÂüéÁöÑÈÄö‰ø°ÊñπÂºè„ÄÇ BinderËøûÊé•Ê±† Èù¢ÂØπÂ§ö‰∏™Ê®°ÂùóÈúÄË¶ÅÁî®Âà∞AIDLÔºåÊàë‰ª¨‰∏çËÉΩÈíàÂØπÊØè‰∏Ä‰∏™AIDLÊé•Âè£ÂçïÁã¨ÂàõÂª∫Â§ö‰∏™Service„ÄÇ ËøôÁßçÊ®°Âºè‰∏ãÔºöÊØè‰∏™‰∏öÂä°Ê®°ÂùóÂàõÂª∫Ëá™Â∑±ÁöÑAIDLÊé•Âè£Âπ∂ÂÆûÁé∞Ê≠§Êé•Âè£Ôºå‰∏çÂêå‰∏öÂä°Ê®°Âùó‰πãÈó¥Ê≤°ÊúâËÄ¶ÂêàÔºåÂπ∂ÂêëÊúçÂä°Á´ØÊèê‰æõËá™Â∑±ÁöÑÂîØ‰∏ÄÊ†áËØÜÂíåÂØπÂ∫îÁöÑBinderÂØπË±°ÔºõÂØπ‰∫éÊúçÂä°Á´ØÊù•ËØ¥ÔºåÂè™ÈúÄË¶ÅÊèê‰æõ‰∏Ä‰∏™ServiceÔºåÂπ∂ÂåÖÂê´‰∏Ä‰∏™queryBinderÊé•Âè£ÔºåËøô‰∏™Êé•Âè£ËÉΩÂ§üÊ†πÊçÆ‰∏öÂä°Ê®°ÂùóÁöÑÁâπÂæÅÊù•ËøîÂõûÁõ∏Â∫îÁöÑBinderÂØπË±°Ôºõ‰∏çÂêå‰∏öÂä°Ê®°ÂùóÊãøÂà∞Ëá™Â∑±ÁöÑBinderÂØπË±°ÂêéÂ∞±ÂèØ‰ª•ËøõË°åËøúÁ®ãÊñπÊ≥ïË∞ÉÁî®‰∫Ü„ÄÇ BinderËøûÊé•Ê±†ÁöÑ‰ΩúÁî®Â∞±ÊòØÂ∞ÜÊØè‰∏™‰∏öÂä°Ê®°ÂùóÁöÑBinderËØ∑Ê±ÇÁªü‰∏ÄËΩ¨ÂèëÂà∞ËøúÁ®ãÁöÑService‰∏≠ÂéªÊâßË°åÔºå‰ªéËÄåÈÅøÂÖçÈáçÂ§çÂàõÂª∫Service„ÄÇ BinderËøûÊé•Ê±†Â∑•‰ΩúÂéüÁêÜ 123456## Module A package com.ryg.chapter_2.binderpool;interface ISecurityCenter &#123; String encrypt(String content); String decrypt(String password);&#125; 12345## Module Bpackage com.ryg.chapter_2.binderpool;interface ICompute &#123; int add(int a, int b);&#125; 12345678910## BinderPool aidl interfacepackage com.ryg.chapter_2.binderpool;interface IBinderPool &#123; /** * @param binderCode, the unique token of specific Binder&lt;br/&gt; * @return specific Binder who's token is binderCode. */ IBinder queryBinder(int binderCode);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.ryg.chapter_2.binderpool;import java.util.concurrent.CountDownLatch;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;public class BinderPool &#123; private static final String TAG = "BinderPool"; public static final int BINDER_NONE = -1; public static final int BINDER_COMPUTE = 0; public static final int BINDER_SECURITY_CENTER = 1; private Context mContext; private IBinderPool mBinderPool; //BinderPool aidl interface private static volatile BinderPool sInstance; private CountDownLatch mConnectBinderPoolCountDownLatch; private BinderPool(Context context) &#123; mContext = context.getApplicationContext(); connectBinderPoolService(); &#125; // singleton, double check public static BinderPool getInsance(Context context) &#123; if (sInstance == null) &#123; synchronized (BinderPool.class) &#123; if (sInstance == null) &#123; sInstance = new BinderPool(context); &#125; &#125; &#125; return sInstance; &#125; /** ** ÁªëÂÆöBinderPoolÁöÑËøúÁ®ãÊúçÂä° **/ private synchronized void connectBinderPoolService() &#123; mConnectBinderPoolCountDownLatch = new CountDownLatch(1); Intent service = new Intent(mContext, BinderPoolService.class); mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE); try &#123; //Â∞ÜbindServiceËøôÂºÇÊ≠•Êìç‰ΩúËΩ¨‰∏∫ÂêåÊ≠•ÁöÑÔºåËÄóÊó∂Êìç‰Ωú mConnectBinderPoolCountDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * query binder by binderCode from binder pool * * @param binderCode * the unique token of binder * @return binder who's token is binderCode&lt;br&gt; * return null when not found or BinderPoolService died. */ public IBinder queryBinder(int binderCode) &#123; IBinder binder = null; try &#123; if (mBinderPool != null) &#123; binder = mBinderPool.queryBinder(binderCode); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; return binder; &#125; private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // ignored. &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinderPool = IBinderPool.Stub.asInterface(service); try &#123; mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient, 0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; mConnectBinderPoolCountDownLatch.countDown(); &#125; &#125;; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; Log.w(TAG, "binder died."); mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, 0); mBinderPool = null; connectBinderPoolService(); &#125; &#125;; /** * ÂΩìBinderËøûÊé•Ê±†ËøûÊé•‰∏äËøúÁ®ãÊúçÂä°Êó∂Ôºå‰ºöÊ†πÊçÆ‰∏çÂêåÊ®°ÂùóÁöÑÊ†áËØÜbindeCodeËøîÂõû‰∏çÂêåÁöÑBinderÂØπË±°Ôºå * ÈÄöËøáËøô‰∏™ÂØπË±°ÊâÄÊâßË°åÁöÑÊìç‰ΩúÂèëÁîüÂú®ËøúÁ®ãÊúçÂä°Âô® **/ public static class BinderPoolImpl extends IBinderPool.Stub &#123; public BinderPoolImpl() &#123; super(); &#125; @Override public IBinder queryBinder(int binderCode) throws RemoteException &#123; IBinder binder = null; switch (binderCode) &#123; case BINDER_SECURITY_CENTER: &#123; binder = new SecurityCenterImpl(); break; &#125; case BINDER_COMPUTE: &#123; binder = new ComputeImpl(); break; &#125; default: break; &#125; return binder; &#125; &#125;&#125; Êúâ‰∫ÜBinderPoolÊú∫Âà∂ÂêéÔºåÂ¶ÇÊûúÊúâ‰∏Ä‰∏™Êñ∞ÁöÑ‰∏öÂä°Ê®°ÂùóÈúÄË¶ÅÂä†AIDLÔºåÈÇ£‰πàÂú®ÂÆûÁé∞ÁöÑËá™Â∑±ÁöÑAIDLÊé•Âè£ÂêéÔºåÂè™ÈúÄË¶Å‰øÆÊîπBInderPoolImpl‰∏≠ÁöÑqueryBinderÊñπÊ≥ïÁªôËá™Â∑±Ê∑ªÂä†‰∏Ä‰∏™binderCodeÂπ∂ËøîÂõûÂØπÂ∫îÁöÑBinderÂØπË±°Âç≥ÂèØÔºå‰∏çÈúÄË¶ÅÂàõÂª∫Êñ∞ÁöÑService„ÄÇ ÈÄâÁî®ÂêàÈÄÇÁöÑIPCÊñπÂºè ÂêçÁß∞ ‰ºòÁÇπ Áº∫ÁÇπ ÈÄÇÁî®Âú∫ÊôØ Bundle ÁÆÄÂçïÊòìÁî® Âè™ËÉΩ‰º†ËæìBundleÊîØÊåÅÁöÑÊï∞ÊçÆ ÂõõÂ§ßÁªÑ‰ª∂Èó¥ÁöÑËøõÁ®ãÈÄö‰ø° Êñá‰ª∂ÂÖ±‰∫´ ÁÆÄÂçïÊòìÊáÇ ‰∏çÈÄÇÂêàÈ´òÂπ∂ÂèëÂú∫ÊôØÔºåÂπ∂‰∏îÊó†Ê≥ïÂÅöÂà∞ËøõÁ®ãÈó¥Âç≥Êó∂ÈÄö‰ø° Êó†Âπ∂ÂèëÔºå‰∫§Êç¢ÁÆÄÂçïÁöÑÊï∞ÊçÆ„ÄÅÂÆûÊó∂ÊÄß‰∏çÈ´òÁöÑÂú∫ÊôØ AIDL ÂäüËÉΩÂº∫Â§ßÔºåÊîØÊåÅ‰∏ÄÂØπÂ§öÂπ∂ÂèëÈÄö‰ø° ‰ΩøÁî®Â§çÊùÇÔºåÈúÄË¶ÅÂ§ÑÁêÜÂ•ΩÁ∫øÁ®ãÂêåÊ≠• ‰∏ÄÂØπÂ§öÈÄö‰ø°ÊúâRPCÈúÄÊ±Ç Messager ÂäüËÉΩ‰∏ÄËà¨ÔºåÊîØÊåÅ‰∏ÄÂØπÂ§ö‰∏≤Ë°åÈÄö‰ø° ‰∏çËÉΩÂ§ÑÁêÜÂπ∂ÂèëÊÉÖÂΩ¢Ôºå‰∏çÊîØÊåÅRPCÔºåÊï∞ÊçÆÈÄöËøáMessage‰º†ËæìÔºåÂè™ËÉΩÊîØÊåÅBundleÊï∞ÊçÆÁ±ªÂûã ‰∏≤Ë°å‰∏ÄÂØπÂ§öÂç≥Êó∂ÈÄö‰ø°ÔºåÊó†RPCÈúÄÊ±ÇÔºåÊàñËÄÖÊó†ÈúÄËøîÂõûÁªìÊûúRPCÈúÄÊ±Ç ContentProvider Âú®Êï∞ÊçÆÊ∫êËÆøÈóÆÂäüËÉΩÂº∫Â§ßÔºåÊîØÊåÅ‰∏ÄÂØπÂ§öÂπ∂ÂèëÊï∞ÊçÆÂÖ±‰∫´ ÂèØ‰ª•ÁêÜËß£‰∏∫ÂèóÁ∫¶ÊùüÁöÑAIDLÔºå‰∏ªË¶ÅÊèê‰æõÊï∞ÊçÆÊ∫êÁöÑCRUD ‰∏ÄÂØπÂ§öÁöÑËøõÁ®ãÈó¥Êï∞ÊçÆÂÖ±‰∫´ Socket ÂäüËÉΩÂº∫Â§ßÔºåÈÄöËøáÁΩëÁªú‰º†ËæìÂ≠óËäÇÊµÅÔºåÊîØÊåÅ‰∏ÄÂØπÂ§öÁöÑÂπ∂ÂèëÂÆûÊó∂ÈÄö‰ø° ÂÆûÁé∞ÁªÜËäÇÁ®çÂæÆÁπÅÁêêÔºå‰∏çÊîØÊåÅÁõ¥Êé•ÁöÑRPC ÁΩëÁªúÊï∞ÊçÆ‰∫§Êç¢]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>AIDL</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActivityÁöÑÁîüÂëΩÂë®ÊúüÂíåÂêØÂä®Ê®°Âºè]]></title>
    <url>%2F2017%2F07%2F13%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[ActivityÁöÑÁîüÂëΩÂë®ÊúüÂíåÂêØÂä®Ê®°ÂºèÁîüÂëΩÂë®ÊúüÂàÜÊûêÂÖ∏ÂûãÁîüÂëΩÂë®ÊúüÂàÜÊûê onStartÂíåonStopÊòØ‰ªéActivityÊòØÂê¶ÂèØËßÅÁöÑËøô‰∏™ËßíÂ∫¶ÂõûË∞ÉÁöÑÔºåËÄåonResumeÂíåonPauseÊòØ‰ªéActivityÊòØÂê¶‰Ωç‰∫éÂâçÂè∞Ëøô‰∏™ËßíÂ∫¶Êù•ÂõûË∞ÉÁöÑ„ÄÇ ActivityÁöÑÂêØÂä®ËøáÁ®ãÂæàÂ§çÊùÇÔºåÊ∂âÂèäInstrumentation„ÄÅActivityThreadÂíåActivityManagerServiceÔºàÁÆÄÁß∞AMSÔºâÔºõÁÆÄÂçïÁêÜËß£ÔºåÂêØÂä®ActivityÁöÑËØ∑Ê±Ç‰ºöÁî±InstrumentationÊù•Â§ÑÁêÜÔºåÁÑ∂ÂêéÂÆÉÈÄöËøáBinderÂêëAMSÂèëËØ∑Ê±ÇÔºåAMSÂÜÖÈÉ®Áª¥Êä§‰∏Ä‰∏™ActivityStackÂπ∂Ë¥üË¥£Ê†àÂÜÖÁöÑActivityÁöÑÁä∂ÊÄÅÂêåÊ≠•ÔºåAMSÈÄöËøáActivityThreadÂéªÂêåÊ≠•ActivityÁöÑÁä∂ÊÄÅ‰ªéËÄåÂÆåÊàêÁîüÂëΩÂë®ÊúüÊñπÊ≥ïÁöÑË∞ÉÁî®„ÄÇ ÂÅáËÆæÂΩìÂâçActivityÊòØAÔºåÊñ∞ÂêØÂä®‰∏Ä‰∏™Activity BÔºåÈÇ£‰πàAÁöÑonPauseÂÖàÊâßË°åÔºåÁÑ∂ÂêéBÁöÑonCreate„ÄÅonStart„ÄÅonResumeÔºåÂÜçÊòØAÁöÑonStop„ÄÇ ÊâÄ‰ª•AndroidÂÆòÊñπÊñáÊ°£‰∏≠ÊúâËØ¥ÊòéÔºå‰∏çËÉΩÂú®onPause‰∏≠‰ΩúÈáçÈáèÁ∫ßÁöÑËÄóÊó∂Êìç‰ΩúÔºåÂõ†‰∏∫onPauseÊâßË°åÂÆåÂêéÊñ∞ÁöÑActivityÊâçËÉΩResume„ÄÇÊ≥®Ôºö‰∏çË¶ÅÂú®onPauseÂíåonStop‰∏≠ÊâßË°åËÄóÊó∂Êìç‰ΩúÔºåÂ∞§ÂÖ∂ÊòØonPause„ÄÇ ÂºÇÂ∏∏ÊÉÖÂÜµ‰∏ãÁöÑÁîüÂëΩÂë®ÊúüÂàÜÊûê ËµÑÊ∫êÁõ∏ÂÖ≥ÁöÑÁ≥ªÁªüÈÖçÁΩÆÊîπÂèòÂØºËá¥ActivityË¢´ÊùÄÊ≠ªÂπ∂ÈáçÊñ∞ÂàõÂª∫ ÈÖçÁΩÆÊîπÂèòÔºàÊóãËΩ¨ÔºâonPause‚Äì&gt;onSaveInstanceState‚Äì&gt;onStop‚Äì&gt;onDestroy‚Äì&gt;ÈáçÂª∫‚Äì&gt;onCreate‚Äì&gt;onStart‚Äì&gt;onRestoreInstanceState Ê≥®ÊÑèÔºöonSaveInstanceStateÂú®onStop‰πãÂâçÔºåonRestoreInstanceStateÂú®onStart‰πãÂêé ËµÑÊ∫êÂÜÖÂ≠ò‰∏çË∂≥ÂØºËá¥‰Ωé‰ºòÂÖàÁ∫ßÁöÑActivityË¢´ÊùÄÊ≠ª Â±èÂπïÊóãËΩ¨Êó∂ÂÄôActivity‰∏çÊÉ≥ÈáçÊñ∞ÂàõÂª∫ÔºåÈÖçÁΩÆandroid:configChanges=&quot;orientation|screenSize|keyboardHidden&quot; ActivityÁöÑÂêØÂä®Ê®°ÂºèÔºàLaunchModeÔºâ standardÔºöÊ†áÂáÜÊ®°Âºè ‰∏éÂêØÂä®‰ªñÁöÑActivityËøêË°åÂú®Âêå‰∏Ä‰∏™ÁöÑ‰ªªÂä°Ê†à‰∏≠Ôºõ singleTopÔºöÊ†àÈ°∂Â§çÁî®Ê®°Âºè singleTaskÔºöÊ†àÂÜÖÂ§çÁî®Ê®°Âºè Â§öÊ¨°ÂêØÂä®Activity‰∏ç‰ºöÈáçÂ§çÂàõÂª∫ÂÆû‰æãÔºåÂõûË∞ÉÂÖ∂onNewIntentÔºåÂπ∂ÈôÑÂ∏¶ClearTopÊïàÊûú„ÄÇ ‰ªÄ‰πàÊòØ‰ªªÂä°Ê†àÔºüÔºü ‰∏éÂèÇÊï∞TaskAffinityÂÖ≥ËÅîÔºå‰πüÁß∞‰∏∫‰ªªÂä°Áõ∏ÂÖ≥ÊÄßÔºåËØ•Â±ûÊÄßË°®Á§∫‰ªªÂä°Ê†àÁöÑÂêçÂ≠óÔºåÈªòËÆ§Â∞±ÊòØpackageNameÔºå‰πüÂèØ‰ª•ÂçïÁã¨ÊåáÂÆöTaskAffinityÁöÑÂ±ûÊÄßÔºõ Ê†πÊçÆActivityÊòØÂê¶‰Ωç‰∫éÊöÇÂÅúÁä∂ÊÄÅÔºåÂèàÂèØ‰ª•ÂàÜ‰∏∫ÂâçÂè∞‰ªªÂä°Ê†àÂíåÂêéÂè∞‰ªªÂä°Ê†à„ÄÇ 1adb shell dumpsys activiy ActivityÁöÑFlag FLAG_ACTIVITY_NEW_TASK‚Äî&gt;‚ÄùsingleTask‚Äù FLAG_ACTIVITY_SINGLE_TOP‚Äî&gt;‚ÄùsingleTop‚Äù FLAG_ACITIVY_CLEAR_TOP‚Äî&gt;‰∏ÄËà¨ÈÖçÂêà‚ÄúsingleTask‚Äù‰ΩøÁî®ÔºåÂõûË∞ÉonNewIntent FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS ÁßªÈô§ÂéÜÂè≤ActivityÂàóË°® IntentFilterÁöÑÂåπÈÖçËßÑÂàô actionÁöÑÂåπÈÖçËßÑÂàô‚Äî&gt;Intent‰∏≠ÂøÖÈ°ªÊúâ‰∏Ä‰∏™actionËÉΩÂ§üÂíåIntentFilter‰∏≠ÁöÑÊüê‰∏™actionÁõ∏Âêå categotyÁöÑÂåπÈÖçËßÑÂàô‚Äî&gt;Intent‰∏≠ÂèØ‰ª•Ê≤°ÊúâcategoryÔºå‰ΩÜÊòØÂ¶ÇÊûúÊúâcategotyÔºåÂàôÊØè‰∏™categoryÈÉΩÈúÄË¶ÅÂíåIntentFilter‰∏≠ÁöÑÁõ∏Âêå„ÄÇ Âú®startActiviyÊó∂ÔºåÁ≥ªÁªüÈªòËÆ§‰ºö‰∏∫IntentÂä†‰∏äandroid.intent.categoty.DEFAULTËøô‰∏™categoryÔºåÊâÄ‰ª•IntentFilter‰∏≠ÂøÖÈ°ªÊúâ‰∏äËø∞categoryÊâçËÉΩÊé•ÂèóÈöêÂºèË∞ÉÁî®Ôºõ dataÁöÑÂåπÈÖçËßÑÂàô: mimeType + URI URIÈªòËÆ§‰∏∫contentÂíåfileÔºõÂ¶ÇÊûúË¶Å‰∏∫IntentÂÆåÊï¥ÊåáÂÆödataÔºåÂøÖÈ°ªË∞ÉÁî®setDataAndTypeÊñπÊ≥ï„ÄÇ Âà§Êñ≠ÊòØÂê¶ÊúâActivityÈÖçÁΩÆÈöêÂºèIntent‚Äî&gt;ÂèØ‰ª•Áî®PackageManagerÁöÑresolveActivityÊñπÊ≥ïÊàñËÄÖIntentÁöÑresolveActivityÊñπÊ≥ï]]></content>
      <categories>
        <category>AndroidÂºÄÂèëËâ∫ÊúØÊé¢Á¥¢</category>
      </categories>
      <tags>
        <tag>ActivityÁöÑÁîüÂëΩÂë®ÊúüÂíåÂêØÂä®Ê®°Âºè</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F07%2F13%2Frefactor%2F</url>
    <content type="text"><![CDATA[#ÈáçÊûÑ Extract Method (ÊèêÁÇºÂáΩÊï∞) Move Method (Êê¨ÁßªÂáΩÊï∞Ôºâ Self Encapsulate Field (Ëá™Â∞ÅË£ÖÂ≠óÊÆµ) Replace Type Code With State/Strategy (‰ª•Áä∂ÊÄÅÔºèÁ≠ñÁï•Ê®°ÂºèÂèñ‰ª£Áä∂ÊÄÅÁ†Å) Replace Condition with Polymorphism (‰ª•Â§öÊÄÅÂèñ‰ª£Êù°‰ª∂Ë°®ËææÂºè) ###ÈáçÊûÑÂéüÂàô ‰Ωï‰∏∫ÈáçÊûÑ ÂØπËΩØ‰ª∂ÂÜÖÈÉ®ÁªìÊûÑÁöÑ‰∏ÄÁßçË∞ÉÊï¥ÔºåÁõÆÁöÑÊòØÂú®‰∏çÊîπÂèòËΩØ‰ª∂ÂèØËßÇÂØüË°å‰∏∫ÁöÑÂâçÊèê‰∏ãÔºåÊèêÈ´òÂÖ∂ÂèØÁêÜËß£ÊÄßÔºåÈôç‰ΩéÂÖ∂‰øÆÊîπÊàêÊú¨„ÄÇ ‰∏∫‰ΩïÈáçÊûÑ ÊîπËøõËΩØ‰ª∂ËÆæËÆ°„ÄÅÊòØËΩØ‰ª∂Êõ¥ÂÆπÊòìÁêÜËß£„ÄÅÂ∏ÆÂä©ÊâæÂà∞bug„ÄÅÊèêÈ´òÁºñÁ®ãÈÄüÂ∫¶„ÄÇ ‰ΩïÊó∂ÈáçÊûÑ Ê∑ªÂä†ÂäüËÉΩÊó∂ÈáçÊûÑ„ÄÅ‰øÆË°•ÈîôËØØÊó∂ÈáçÊûÑ„ÄÅÂ§çÂÆ°‰ª£Á†ÅÊó∂ÈáçÊûÑ ÈáçÊûÑ‰∏éÈó¥Êé•Â±Ç Èó¥Êé•Â±Ç‰ª∑ÂÄºÔºö ÂÖÅËÆ∏ÈÄªËæëÂÖ±‰∫´„ÄÅÂàÜÂºÄËß£ÈáäÊÑèÂõæÂíåÂÆûÁé∞„ÄÅÈöîÁ¶ªÂèòÂåñ„ÄÅÂ∞ÅË£ÖÊù°‰ª∂ÈÄªËæëÔºàÂ§öÊÄÅÔºâ ÈáçÊûÑÁöÑÈöæÈ¢ò Êï∞ÊçÆÂ∫ìËøÅÁßª„ÄÅ‰øÆÊîπÂ∑≤ÂÖ¨Â∏ÉÁöÑÊé•Âè£„ÄÅÈöæ‰ª•ÈáçÊûÑÁöÑÂ§çÊùÇËÆæËÆ° ###‰ª£Á†ÅÁöÑÂùèÂë≥ÈÅì Duplicated codeÔºàÈáçÂ§ç‰ª£Á†ÅÔºâ Long MethodÔºàËøáÈïøÂáΩÊï∞Ôºâ Large ClassÔºàËøáÂ§ßÁöÑÁ±ªÔºâ Long Parameter List (ËøáÈïøÂèÇÊï∞ÂàóÔºâ Divergent Change ÔºàÂèëÊï£ÂºèÂèòÂåñÔºâ‰∏ÄÁßçÁ±ªÂèóÂ§öÁßçÂèòÂåñÁöÑÂΩ±ÂìçÔºåÁ±ªËøáÂ§ßÔºåÈúÄExtract class Shotgun SurgeryÔºàÊï£ÂºπÂºè‰øÆÊîπÔºâ‰∏ÄÁßçÂèòÂåñÂºïËµ∑Â§ö‰∏™Á±ª‰øÆÊîπÔºåÈúÄMove MethodÁßªÂà∞Âêå‰∏Ä‰∏™Á±ª Feature EnvyÔºà‰æùÊÅãÊÉÖÁªìÔºâÊÄªÊòØ‰∏ÄËµ∑ÂèòÂåñÁöÑ‰∏úË•øÊîæÂú®‰∏ÄÂùó Data Clumps ÔºàÊï∞ÊçÆÊ≥•Âõ¢ÔºâÂ§ö‰∏™Á±ª‰∏≠ÈáçÂ§çÁöÑÂ≠óÊÆµ„ÄÅÊñπÊ≥ï„ÄÇÈúÄExtract classÂà∞‰∏Ä‰∏™Áã¨Á´ãÂØπË±° Primitive Obsesstion ÔºàÂü∫Êú¨Á±ªÂûãÂÅèÊâßÔºâÂøÖË¶ÅÊó∂Áî®ÂØπË±°‰ª£ÊõøÂü∫Êú¨Êï∞ÊçÆ Switch StatementÔºàswitchËØ≠Âè•ÔºâÈúÄË¶ÅÊäΩÂá∫ÊñπÊ≥ïÔºåÁî®Â≠êÁ±ªÊàñstate/strategyÊ®°ÂºèÊõø‰ª£ Parallel Inheritance Hierarchies ÔºàÂπ≥Ë°åÁªßÊâø‰ΩìÁ≥ªÔºâÊï£Âºπ‰øÆÊîπÁöÑ‰∏ÄÁßçÔºåÈúÄÁî®ÂºïÁî®‰ª£ÊõøÁªßÊâø Lazy ClassÔºàÂÜó‰ΩôÁ±ªÔºâ Speculative GeneralityÔºàÂ§∏Â§∏ÂÖ∂Ë∞àÊú™Êù•ÊÄßÔºâÂ§ö‰ΩôÁöÑÊäΩË±°„ÄÅÂßîÊâò„ÄÅÂèÇÊï∞Â∫îËØ•ÂéªÈô§ Temporary Field (Ëø∑ÊÉëÁöÑÊöÇÊó∂Â≠óÊÆµ) ÂèØ‰ª•ÁöÑËØùÊèêÁÇºÂà∞‰∏Ä‰∏™Áã¨Á´ãÁöÑÁ±ª‰∏≠ Message ChainsIÔºàËøáÂ∫¶ËÄ¶ÂêàÁöÑÊ∂àÊÅØÈìæÔºâ Middle ManÔºà‰∏≠Èó¥‰∫∫ÔºâËøáÂ∫¶‰ΩøÁî®ÂßîÊâò Inappropriate Intimacy (ÁãéÊòµÂÖ≥Á≥ª) ÊãÜÊï£ËøáÊ∏°‰∫≤ÂØÜÁöÑÁ±ªÔºåMove Method Êàñ Move FieldÂà∞ÂêàÈÄÇÁöÑÂú∞ÊñπÔºõÊèêÁÇºÂÖ±ÊÄßÂà∞Êñ∞Á±ªÔºõReplace Inheritance with Delegation Alternative Classes With Different Interfaces (ÂºÇÊõ≤ÂêåÂ∑•ÁöÑÁ±ª) ÈáçÊñ∞ÂëΩÂêçÊàñÊèêÂèñË∂ÖÁ±ª Incomplete Library Class (‰∏çÂÆåÁæéÁöÑÁ±ªÂ∫ì) Data ClassÔºàÂ≠òÁ≤πÁöÑÊï∞ÊçÆÁ±ªÔºâÊ≥®ÊÑèÂ∞ÅË£ÖÂíåËÆøÈóÆÊùÉÈôê Refused BequestÔºàË¢´ÊãíÁªùÁöÑÈ¶àËµ†ÔºâÂ≠êÁ±ªÊúçÁî®ÁöÑË∂ÖÁ±ªÁöÑË°å‰∏∫ÔºàÂÆûÁé∞ÔºâÔºåÂç¥‰∏çÊÑøÊîØÊåÅË∂ÖÁ±ªÁöÑÊé•Âè£ÔºåÈúÄÈáçÊûÑÔºàËøôÈáåÊÄùËÄÉBasessoÁ±ªÁöÑ3‰∏™abstractÊñπÊ≥ïÊúâËøô‰∏™ÈóÆÈ¢òÔºå‰∏çÊÑøÊîØÊåÅË∂ÖÁ±ªÁöÑÊé•Âè£Ôºâ CommentsÔºàËøáÂ§öÊ≥®ÈáäÔºâ ###ÈáçÊñ∞ÁªÑÁªáÂáΩÊï∞ Extract MethodÔºàÊèêÁÇºÂáΩÊï∞Ôºâ Â∞Ü‰∏ÄÊÆµ‰ª£Á†ÅÊîæËøõ‰∏Ä‰∏™Áã¨Á´ãÁöÑÂáΩÊï∞‰∏≠ÔºåÂπ∂ËÆ©ÂáΩÊï∞ÂêçÁß∞Ëß£ÈáäËØ•ÂáΩÊï∞ÁöÑÁî®ÈÄî„ÄÇ Â¶ÇÊûúÊ∫êÂáΩÊï∞‰∏≠Â±ÄÈÉ®ÂèòÈáèÊØîËæÉÂ§öÔºåÂÖàÁî®Replace Temp With QueryÂáèÂ∞ë‰∏¥Êó∂ÂèòÈáèÔºåÊ∫êÂáΩÊï∞‰∏≠ËØªÂèñÁöÑ‰∏¥Êó∂ÂèòÈáèÂíåÂèÇÊï∞ÔºåÊèêÁÇºÂà∞ÁõÆÊ†áÂáΩÊï∞‰Ωú‰∏∫ÂèÇÊï∞ÔºåÂπ∂ËÄÉËôëÊòØÂê¶ÈúÄË¶ÅËøîÂõûÂÄº„ÄÇ Inline Method ÔºàÂÜÖËÅîÂáΩÊï∞Ôºâ ‰∏Ä‰∏™ÂáΩÊï∞ÂíåÊú¨‰Ωì‰∏ÄÊ†∑Ê∏ÖÊ•öÊòìÊáÇÔºåÂú®ÂáΩÊï∞Ë∞ÉÁî®ÁÇπÊèíÂÖ•ÂáΩÊï∞‰ΩìÔºåÁÑ∂ÂêéÁßªÈô§ËØ•ÂáΩÊï∞„ÄÇ Inline TempÔºàÂÜÖËÅî‰∏¥Êó∂ÂèòÈáèÔºâ Â∞Ü‰∏¥Êó∂ÂèòÈáèÊõøÊç¢‰∏∫ÂØπÂÆÉËµãÂÄºÁöÑË°®ËææÂºèÊàñÂáΩÊï∞„ÄÇ Replace Temp With QueryÔºà‰ª•Êü•ËØ¢Âèñ‰ª£‰∏¥Êó∂ÂèòÈáèÔºâ Â∞Ü‰∏¥Êó∂ÂèòÈáèÁöÑËÆ°ÁÆó‰ª£Á†ÅÊèêÁÇºÂà∞‰∏Ä‰∏™Áã¨Á´ãÁöÑÂáΩÊï∞‰∏≠ÔºåËøôÊ†∑‰∏¥Êó∂ÂèòÈáèÁöÑÂºïÁî®ÁÇπÂ∞±ÂèØ‰ª•ÊõøÊç¢‰∏∫Êñ∞ÂáΩÊï∞ÁöÑË∞ÉÁî®„ÄÇ ‰ª•Êü•ËØ¢‰ª£Êõø‰∏¥Êó∂ÂèòÈáèÂèØ‰ª•ÂáèÂ∞ë‰∏¥Êó∂ÂèòÈáèÔºåÊòØÊèêÁÇºÂáΩÊï∞ÁöÑÈáçË¶ÅÊ≠•È™§„ÄÇ Introduce Explaining Variable (ÂºïÂÖ•Ëß£ÈáäÊÄßÂèòÈáè) Â∞ÜËØ•Â§çÊùÇË°®ËææÂºèÁöÑÁªìÊûúÊîæËøõ‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáèÔºå‰ª•Ê≠§ÂèòÈáèÂêçÁß∞Êù•Ëß£ÈáäË°®ËææÂºèÁöÑ‰ΩúÁî®„ÄÇ ÊàñËÄÖExtract MethodÊù•Â§ÑÁêÜ Split Temporary Variable (ÂàÜËß£‰∏¥Êó∂ÂèòÈáè) Êüê‰∏™‰∏¥Êó∂ÂèòÈáèÔºåÊó¢‰∏çÊòØÂæ™ÁéØÂèòÈáè‰πü‰∏çÊòØÊî∂ÈõÜÂèòÈáèÔºõÈíàÂØπÊØèÊ¨°ËµãÂÄºÔºåÂàõÈÄ†‰∏Ä‰∏™Áã¨Á´ãÁöÑ„ÄÅÊúâÂêàÁêÜÂêçÁß∞ÁöÑ‰∏¥Êó∂ÂèòÈáèÊù•ÂàÜËß£ÈáçÂ§çËµãÂÄº„ÄÇ Remove Assignments to Parameters(ÁßªÈô§ÂØπÂèÇÊï∞ÁöÑËµãÂÄºÔºâ ‰ª£Á†ÅÂØπÂèÇÊï∞ËøõË°åËµãÂÄºÔºå‰ª•‰∏Ä‰∏™‰∏¥Êó∂ÂèòÈáèÂèñ‰ª£ËØ•ÂèÇÊï∞ÁöÑ‰ΩçÁΩÆ JavaÊòØÊåâÂÄº‰º†ÈÄíÁöÑ 123void aMethod(Object foo) &#123; foo.modifySomeWay(); //that's OKÔºåÂ∞ÜÊîπÂèòfooÂºïÁî®ÁöÑÂØπË±° foo = anothnerObject; //trouble will follow, ÂáΩÊï∞ËøîÂõûÂêéÂπ∂‰∏ç‰ºöÊîπÂèòfoo„ÄÇ Replace Method with Method Object(‰ª•ÂáΩÊï∞ÂØπË±°Âèñ‰ª£ÂáΩÊï∞Ôºâ Êúâ‰∏Ä‰∏™Â§ßÂûãÂáΩÊï∞ÂÖ∂‰∏≠Â≠òÂú®Â§ßÈáèÁöÑÂ±ÄÈÉ®ÂèòÈáèÔºåÂæàÈöæExtract MethodÊù•ÂàÜËß£Ëøô‰∏™ÂáΩÊï∞ÔºåÈÇ£‰πà‰ΩøÁî®ÂáΩÊï∞ÂØπË±°„ÄÇ Â∞ÜÂéüÂáΩÊï∞Êõø‰ª£ÊàêÂáΩÊï∞ÂØπË±°ÔºåËØ•ÂáΩÊï∞ÂØπË±°ÁöÑÊûÑÈÄ†ÂáΩÊï∞Êé•ÂèóÊ∫êÂØπË±°ÂíåÂéüÂáΩÊï∞ÁöÑÂèÇÊï∞‰Ωú‰∏∫ÂèÇÊï∞Ôºõ ÈíàÂØπÂéüÂáΩÊï∞ÊØè‰∏™‰∏¥Êó∂ÂèòÈáèÂíåÊØè‰∏™ÂèÇÊï∞ÔºåÂú®Êñ∞ÁöÑÂáΩÊï∞ÂØπË±°‰∏≠Âª∫Á´ã‰∏Ä‰∏™ÂØπÂ∫îÁöÑÂ≠óÊÆµ‰øùÂ≠òÔºõ ÁÑ∂ÂêéÂ∞±ÂèØ‰ª•Âú®ÂáΩÊï∞ÂØπË±°‰∏≠Extract MethodÊù•ÂàÜËß£ÂéüÂáΩÊï∞Ôºõ Substitute Algorithm (ÊõøÊç¢ÁÆóÊ≥ï) Â∞ÜÂáΩÊï∞Êú¨‰ΩìÊõøÊç¢‰∏∫Êñ∞ÁöÑÁÆóÊ≥ïÔºåÂª∫ËÆÆÂÖàËÄÉËôëÂàÜËß£ÂáΩÊï∞ÂÜçÂÅöÊõøÊç¢„ÄÇ ###Âú®ÂØπË±°‰πãÈó¥Êê¨ÁßªÁâπÊÄß Move Method (Êê¨ÁßªÂáΩÊï∞) ÂáΩÊï∞‰∏éÂÖ∂‰ªñÁ±ªËÄ¶ÂêàËøáÂ§öÔºåËÄÉËôë‰ΩøÁî®ÂßîÊâòÊàñÊê¨ÁßªÂà∞ÂêàÈÄÇÁöÑÁ±ª‰∏≠„ÄÇ Êê¨ÁßªËøáÁ®ã‰∏≠ÔºåÂΩìÁõÆÊ†áÁ±ªÈúÄË¶ÅÊ∫êÁ±ªÁâπÊÄßÊó∂Ôºå1ÔºâÂ∞ÜËøô‰∏™ÁâπÊÄß‰πüÊê¨ÁßªÂà∞ÁõÆÊ†áÁ±ª 2ÔºâÂª∫Á´ã‰ΩøÁî®ÁõÆÊ†áÁ±ªÂà∞Ê∫êÁ±ªÁöÑ‰ΩøÁî® 3ÔºâÂ∞ÜÊ∫êÂØπË±°ÊàñËØ•ÁâπÊÄßÂèòÈáè‰Ωú‰∏∫ÂèÇÊï∞‰º†ÈÄíÁªôÁõÆÊ†áÁ±ª Move Field (Êê¨ÁßªÂ≠óÊÆµ) Êüê‰∏™Â≠óÊÆµË¢´ÊâÄÈ©ªÁ±ª‰πãÂ§ñÁöÑÂè¶‰∏Ä‰∏™Á±ªÊõ¥Â§öÂú∞Áî®Âà∞ÔºåËÄÉËôëÊê¨ÁßªËøô‰∏™Â≠óÊÆµÂà∞ÁõÆÊ†áÁ±ª„ÄÇ Self EncapsulateÔºà‰ΩøÁî®Ëá™ÊàëÂ∞ÅË£ÖÔºâÂú®Â≠óÊÆµÊê¨ÁßªÂêéÔºåÂ∞±Âè™ÈúÄË¶Å‰øÆÊîπËÆøÈóÆÂáΩÊï∞ÔºàsetÔºègetÔºâÔºåËÄåÊó†ÈúÄ‰øÆÊîπÂºïÁî®ÁÇπ„ÄÇ Extract ClassÔºàÊèêÁÇºÁ±ªÔºâ Âª∫Á´ã‰∏Ä‰∏™Êñ∞Á±ªÔºåÂ∞ÜÁõ∏ÂÖ≥Â≠óÊÆµÂíåÂáΩÊï∞‰ªéÊóßÁ±ªÊê¨ÁßªÂà∞Êñ∞Á±ª„ÄÇ ÂèØËÉΩÈúÄË¶ÅÂèåÂêëËøûÊé•ÔºåÂ∞ΩÈáèÈÅøÂÖçÂª∫ËÆÆÊñ∞Á±ªÂà∞ÊóßÁ±ªÁöÑËøûÊé•ÔºõÂÜ≥ÂÆöÊòØÂê¶ÂÖ¨ÂºÄÊñ∞Á±ªÔºõ Inline ClassÔºàÂÜÖËÅîÂåñÁ±ªÔºâ Â∞ÜËøô‰∏™Á±ªÁöÑÊâÄÊúâÁâπÊÄßÊê¨ÁßªÂà∞Âè¶‰∏Ä‰∏™Á±ªÔºåÁÑ∂ÂêéÁßªÈô§Ëøô‰∏™Á±ªÔºõ Hide Delegate (ÈöêËóè‚ÄúÂßîÊâòÂÖ≥Á≥ª‚Äú) ÂÆ¢Êà∑Á±ªÈÄöËøáÂßîÊâòÁ±ªÊù•Ë∞ÉÁî®Âè¶‰∏Ä‰∏™ÂØπË±°ÔºåÂú®ÊúçÂä°Á±ª‰∏äÂª∫Á´ãÂÆ¢Êà∑ÈúÄË¶ÅÁöÑÊâÄÊúâÂßîÊâòÂáΩÊï∞ÔºåÁî®‰∫éÈöêËóèÂßîÊâòÂÖ≥Á≥ª„ÄÇ ‚Äã Remove Middle ManÔºàÁßªÈô§‰∏≠Èó¥‰∫∫Ôºâ Êüê‰∏™Á±ªÂÅö‰∫ÜËøáÂ§öÁöÑÂßîÊâòÂä®‰ΩúÔºåÈÇ£‰πàÂèØ‰ª•Áõ¥Êé•ËÆ©ÂÆ¢Êà∑Á±ªË∞ÉÁî®ÂèóÊâòÁ±ªÔºõ ÊúçÂä°Á±ª‰∏≠Âª∫Á´ã‰∏Ä‰∏™ÂáΩÊï∞ÔºåÁõ¥Êé•ËøîÂõûÂèóÊâòÁ±ªÔºåÂÆ¢Êà∑Á±ªÁõ¥Êé•Ë∞ÉÁî®ËØ•Á±ªÔºõ ÈöêËóèÂßîÊâòÂÖ≥Á≥ª‰∏éÁßªÈô§‰∏≠Èó¥‰∫∫‰∫í‰∏∫ÈÄÜÂêëÁöÑË°å‰∏∫„ÄÇ Introduce foreign Method (ÂºïÂÖ•Â§ñÂä†ÂáΩÊï∞) Âú∫ÊôØÔºö‰Ω†ÈúÄË¶Å‰∏∫Êèê‰æõÊúçÂä°ÁöÑÁ±ªÂ¢ûÂä†‰∏Ä‰∏™ÂáΩÊï∞Ôºå‰ΩÜÊòØÂç¥Êó†Ê≥ï‰øÆÊîπËøô‰∏™Á±ª Â∫îÂØπÔºöÂú®ÂÆ¢Êà∑Á±ª‰∏≠Âª∫Á´ã‰∏Ä‰∏™ÂáΩÊï∞ÔºåÂπ∂‰º†ÂÖ•‰∏Ä‰∏™ÊúçÂä°Á±ªÁöÑÂÆû‰æãÂèÇÊï∞Ôºõ Â¶ÇÊûúÈúÄË¶ÅÂ§ñÂä†Â§ö‰∏™ÂáΩÊï∞ÔºåËÄÉËôë‰ΩøÁî®ÂºïÂÖ•Êú¨Âú∞Êâ©Â±ï„ÄÇ Introduce Local Extension (ÂºïÂÖ•Êú¨Âú∞Êâ©Â±ï) Âú∫ÊôØÔºö‰Ω†ÈúÄË¶Å‰∏∫ÊúçÂä°Á±ªÊèê‰æõ‰∏Ä‰∫õÈ¢ùÂ§ñÁöÑÂáΩÊï∞Ôºå‰ΩÜÊòØ‰Ω†Êó†Ê≥ï‰øÆÊîπËøô‰∏™Á±ª Â∫îÂØπÔºöÂª∫Á´ã‰∏Ä‰∏™Êñ∞Á±ªÔºåÂåÖÂê´Ëøô‰∫õÈ¢ùÂ§ñÁöÑÂáΩÊï∞ÔºåËÆ©Ëøô‰∏™Êâ©Â±ïÂìÅÁß∞‰∏∫Ê∫êÁ±ªÁöÑÂ≠óÁ±ªÔºàsubclassÔºâÊàñÂåÖË£ÖÁ±ªÔºàwrapperÔºâÔºõ ###ÈáçÊñ∞ÁªÑÁªáÊï∞ÊçÆ Self Encapsulate Field (Ëá™Â∞ÅË£ÖÂ≠óÊÆµ) Áõ¥Êé•ËÆøÈóÆÂ≠óÊÆµÔºå‰∫ßÁîüËÄ¶ÂêàÂÖ≥Á≥ªÔºõ‰∏∫Ëøô‰∫õÂ≠óÊÆµÂª∫Á´ãget/setÂáΩÊï∞ÔºåÂπ∂‰ª•Ëøô‰∫õÂáΩÊï∞ËÆøÈóÆÂ≠óÊÆµ„ÄÇ Áõ¥Êé•ËÆøÈóÆÂ≠óÊÆµËøòÊòØÈÄöËøáget/setÂáΩÊï∞ËÆøÈóÆÂì™‰∏™Â•ΩÊ≤°ÊúâÂÆöËÆ∫„ÄÇ Replace Data Value with Object(‰ª•ÂØπË±°Âèñ‰ª£Êï∞ÊçÆÂÄº) Â¶ÇÊûúÊúâ‰∏Ä‰∏™Êï∞ÊçÆÈ°πÈúÄË¶Å‰∏éÂÖ∂‰ªñÊï∞ÊçÆÊàñËÄÖË°å‰∏∫‰∏ÄËµ∑‰ΩøÁî®ÊâçÊúâÊÑè‰πâÔºåÈÇ£‰πàÂ∞ÜÊï∞ÊçÆÂèòÊàêÂØπË±°„ÄÇ Êï∞ÊçÆÂÄº ‚Äî&gt; ÂÄºÂØπË±°,ÂÄºÂØπË±°Â∫îËØ•ÊòØ‰∏çÂèØ‰øÆÊîπÁöÑ Âå∫Âà´ÔºöÂ¶ÇÊûúÊï∞ÊçÆÂèØ‰øÆÊîπÔºå‰ΩøÁî®ÂºïÁî®ÂØπË±°ÔºåChange value to Reference Change Value into Reference(Â∞ÜÂÄºÂØπË±°Êîπ‰∏∫ÂºïÁî®ÂØπË±°) ‰ªé‰∏Ä‰∏™Á±ªË°çÁîüÂá∫Â§ö‰∏™Áõ∏Á≠âÁöÑÂÆû‰æãÔºåÂ∏åÊúõÂÆÉ‰ª¨ÊòØÂêå‰∏Ä‰∏™ÂØπË±°ÔºõÂ∞ÜÂÄºÂØπË±°ÂèòÊàêÂºïÁî®ÂØπË±°Ôºõ Â§ö‰∏™OrderÂÖ±‰∫´Âêå‰∏Ä‰∏™CustomerÂØπË±° ÂºïÁî®ÂØπË±°ÈÉΩ‰ª£Ë°®ÁúüÂÆû‰∏ñÁïå‰∏≠ÁöÑ‰∏Ä‰∏™ÂÆûÁâ©ÔºåÂèØ‰ª•Áî®==Áõ¥Êé•Ê£ÄÊü•‰∏§‰∏™ÂØπË±°ÊòØÂê¶Áõ∏Á≠âÔºõÂ¶Ç‚ÄúÂÆ¢Êà∑‚Äù„ÄÅ‚ÄúË¥¶Êà∑‚ÄùÁ≠â.. ÂÄºÂØπË±°‰∏çÂèØÂèòÔºåÂÆåÂÖ®Áî±ÂÖ∂Êï∞ÊçÆÂÄºÊù•ÂÆö‰πâÔºåÊúâÂ§ö‰∏™ÂâØÊú¨Â≠òÂú®ÔºåÈúÄË¶ÅÂ§çÂÜôequals()Âà§Êñ≠ÊòØÂê¶Áõ∏Á≠âÔºåÂ¶Ç‚ÄúÊó•Êúü‚Äù„ÄÅ‚ÄúÈí±‚Äù.. Change Reference to Value(Â∞ÜÂºïÁî®ÂØπË±°Êîπ‰∏∫ÂÄºÂØπË±°) Êúâ‰∏Ä‰∏™ÂºïÁî®ÂØπË±°ÔºåÂæàÂ∞è‰∏î‰∏çÂèØÂèòÔºåÂ∞ÜÂÆÉÊîπ‰∏∫ÂÄºÂØπË±°„ÄÇ ÂÄºÂØπË±°ÊòØ‚Äú‰∏çÂèØÂèò‚ÄùÔºàimmutableÔºâÁöÑÔºåË°®Á§∫ÂØπË±°Ëá™Ë∫´ÊòØ‰∏çÂèØÂèòÁöÑ„ÄÇÂà§Êñ≠Áõ∏Á≠âÁî®equals()ÊñπÊ≥ï Replace Array with Object(‰ª•ÂØπË±°‰ª£ÊõøÁªÑÊï∞) Êúâ‰∏Ä‰∏™Êï∞ÁªÑÔºåÂÖ∂‰∏≠ÁöÑÂÖÉÁ¥†ÂêÑËá™‰ª£Ë°®‰∏çÂêåÁöÑ‰∏úË•ø ‰ª•ÂØπË±°‰ª£ÊõøÊï∞ÁªÑÔºåÂØπ‰∫éÊï∞ÁªÑ‰∏≠ÁöÑÊØè‰∏Ä‰∏™ÂÖÉÁ¥†Ôºå‰ª•‰∏Ä‰∏™Â≠óÊÆµÊù•Ë°®Á§∫ Duplicate Observed Data(Â§çÂà∂‚ÄúË¢´ÁõëËßÜÁöÑÊï∞ÊçÆ‚Äù) Êúâ‰∏Ä‰∫õÈ¢ÜÂüüÔºàModelÔºâÊï∞ÊçÆÁΩÆË∫´‰∫éGUIÊéß‰ª∂‰∏≠ÔºåËÄåÈ¢ÜÂüüÂáΩÊï∞ÈúÄË¶ÅËÆøÈóÆÈúÄË¶ÅËÆøÈóÆËøôÊï∞ÊçÆÔºõ Â∞ÜËØ•Êï∞ÊçÆÂ§çÂà∂Âà∞È¢ÜÂüüÂØπË±°‰∏≠ÔºåÂª∫Á´ã‰∏Ä‰∏™ObserverÊ®°ÂºèÔºåÁî®‰ª•ÂêåÊ≠•È¢ÜÂüüÂØπË±°ÂíåGUIÂØπË±°ÂÜÖÁöÑÈáçÂ§çÊï∞ÊçÆÔºõ Change Unidirectional Association to Bidirectional(Â∞ÜÂçïÂêëÂÖ≥ËÅîÊîπ‰∏∫ÂèåÂêëÂÖ≥ËÅî) Âú∫ÊôØÔºö‰∏§‰∏™Á±ªÈÉΩÈúÄË¶Å‰ΩøÁî®ÂØπÊñπÁöÑÁâπÊÄßÔºå‰ΩÜÂè™Êúâ‰∏ÄÊù°ÂçïÂêëÂÖ≥ËÅî ÂÆûÁé∞ÔºöÊ∑ªÂä†‰∏Ä‰∏™ÂèçÂêëÊåáÈíàÔºåÂπ∂‰Ωø‰øÆÊîπÂáΩÊï∞ËÉΩÂ§üÂêå‰∫ãÊõ¥Êñ∞‰∏§Êù°ËøûÊé• ÂÜ≥ÂÆöÂì™‰∏™Á±ªÊòØÊéßÂà∂Á´ØÔºõÊéßÂà∂Á´ØÔºàÊèê‰æõÊéßÂà∂ÂáΩÊï∞ÔºåÁª¥Êä§ÂèçÂêëÊåáÈíàÔºâÔºå‰øÆÊîπÂáΩÊï∞Ë∞ÉÁî®ÊéßÂà∂ÂáΩÊï∞ÔºõË¢´ÊéßÂà∂Á´ØÔºàÊèê‰æõ‰∏Ä‰∏™ËæÖÂä©ÂáΩÊï∞Êèê‰æõÂèçÂêëÊåáÈíàÔºâÔºå‰øÆÊîπÂáΩÊï∞Ë∞ÉÁî®ÊéßÂà∂Á´ØÁöÑÊéßÂà∂ÂáΩÊï∞„ÄÇ Change Bidirectional Association to UnidirectionalÔºàÂ∞ÜÂèåÂêëÂÖ≥ËÅîÊîπ‰∏∫ÂçïÂêëÂÖ≥ËÅî) Âú∫ÊôØÔºö‰∏§‰∏™Á±ª‰πãÈó¥ÊúâÂèåÂêëÂÖ≥ËÅîÔºå‰ΩÜÂÖ∂‰∏≠‰∏Ä‰∏™Á±ªÂ¶Ç‰ªä‰∏çÂÜçÈúÄË¶ÅÂè¶‰∏Ä‰∏™Á±ªÁöÑÁâπÊÄßÔºõ ÂéªÈô§‰∏çÂøÖË¶ÅÁöÑÂÖ≥ËÅî Replace Magic Number with Symbolic Constant(‰ª•Â≠óÈù¢Â∏∏Èáè‰ª£ÊõøÈ≠îÊ≥ïÊï∞) ÂàõÂª∫‰∏Ä‰∏™Â∏∏ÈáèÔºåÊ†πÊçÆÂÖ∂ÊÑè‰πâÂëΩÂêçÔºåÊõøÊç¢‰∏äËø∞È≠îÊ≥ïÊï∞ Encapsulate Field(Â∞ÅË£ÖÂ≠óÊÆµ) Â∞ÜpublicÂ≠óÊÆµÂ£∞Êòé‰∏∫privateÔºåÂπ∂Êèê‰æõÁõ∏Â∫îÁöÑget/setËÆøÈóÆÂáΩÊï∞ Encapsulate Collection(Â∞ÅË£ÖÈõÜÂêà) Âú∫ÊôØÔºöÊúâ‰∏Ä‰∏™ÂáΩÊï∞ËøîÂõû‰∏Ä‰∏™ÈõÜÂêà ‰ºòÂåñÔºöËÆ©Ëøô‰∏™ÂáΩÊï∞ËøîÂõûËØ•ÈõÜÂêàÁöÑ‰∏Ä‰∏™Âè™ËØªÂâØÊú¨ÔºåÂπ∂Êèê‰æõÊ∑ªÂä†ÔºèÁßªÈô§ËØ•ÈõÜÂêàÂÖÉÁ¥†ÁöÑÊñπÊ≥ï Replace Record with Data Class(‰ª•Êï∞ÊçÆÁ±ªÂèñ‰ª£ËÆ∞ÂΩï) ‰∏∫ËÆ∞ÂΩïÁªìÊûÑÂûãÊï∞ÊçÆÂàõÂª∫‰∏Ä‰∏™Êï∞ÊçÆÂØπË±° Replace Type Code with Class(‰ª•Á±ªÂèñ‰ª£Á±ªÂûãÁ†Å) Âú∫ÊôØÔºöÁ±ª‰∏≠Âèà‰∏Ä‰∏™Êï∞ÂÄºÁ±ªÂûãÁ†ÅÔºå‰ΩÜÂÆÉÂπ∂‰∏çÂΩ±ÂìçÁ±ªÁöÑË°å‰∏∫ ‰ª•‰∏Ä‰∏™Êñ∞ÁöÑÁ±ªÊõøÊç¢ËØ•Êï∞ÂÄºÁ±ªÂûãÁ†Å Replace Type Code with Subclasses(‰ª•Â≠êÁ±ªÂèñ‰ª£Á±ªÂûãÁ†Å) Âú∫ÊôØÔºöÊúâ‰∏Ä‰∏™‰∏çÂèØÂèòÁöÑÁ±ªÂûãÁ†ÅÔºåÂÆÉ‰ºöÂΩ±ÂìçÁ±ªÁöÑË°å‰∏∫ ÈáçÊûÑÔºö‰ª•Â≠óÁ±ªÂèñ‰ª£Ëøô‰∏™Á±ªÂûãÁ†ÅÔºåÂÄüÂä©Â§öÊÄÅÂÆûÁé∞ÂèòÂåñË°å‰∏∫,Â∞ÜÂíåÁâπÂÆöÂ≠óÁ±ªÁõ∏ÂÖ≥ÁöÑÂ≠óÊÆµÔºèÂáΩÊï∞push downÂà∞Â≠óÁ±ª Replace Type Code with State/Stratege(‰ª•Áä∂ÊÄÅÔºèÁ≠ñÁï•Âèñ‰ª£Á±ªÂûãÁ†Å) Âú∫ÊôØÔºöÂ¶ÇÊûú‰∏Ä‰∏™Á±ªÂûãÁ†ÅÁöÑÂÄºÂú®ÂØπË±°ÁîüÂëΩÂë®ÊúüÂèëÁîüÂèòÂåñÊàñËÄÖÂÖ∂‰ªñÂéüÂõ†ÊòØÂÆø‰∏ªÁ±ª‰∏çËÉΩË¢´ÁªßÊâøÔºõ ÈáçÊûÑÔºö‰ª•Áä∂ÊÄÅÂØπË±°ÊàñÁ≠ñÁï•Ê®°ÂºèÂèñ‰ª£Á±ªÂûãÁ†Å Replace Subclass with Fields(‰ª•Â≠óÊÆµ‰ª£ÊõøÂ≠êÁ±ª) Âú∫ÊôØÔºöÂêÑ‰∏™Â≠êÁ±ªÁöÑÂîØ‰∏ÄÂ∑ÆÂà´Âè™Âú®‚ÄúËøîÂõûÂ∏∏ÈáèÊï∞ÊçÆ‚ÄùÁöÑÂáΩÊï∞Ë∫´‰∏ä ÈáçÊûÑÔºö‰øÆÊîπËøô‰∫õÂáΩÊï∞Ôºå‰ΩøÂÆÉ‰ª¨ËøîÂõûË∂ÖÁ±ª‰∏≠ÁöÑÊüê‰∏™ÔºàÊñ∞Â¢ûÔºâÂ≠óÊÆµÔºåÁÑ∂ÂêéÈîÄÊØÅÂ≠êÁ±ª ###ÁÆÄÂåñÊù°‰ª∂Ë°®ËææÂºè Decompose Conditional(ÁÆÄÂåñÊù°‰ª∂Ë°®ËææÂºè) Âú∫ÊôØÔºöÊúâ‰∏Ä‰∏™Â§çÊùÇÁöÑÊù°‰ª∂if-then-elseËØ≠Âè• ‰ªéif„ÄÅthen„ÄÅelseÊÆµËêΩ‰∏≠ÂàÜÂà´ÊèêÁÇºÂá∫Áã¨Á´ãÁöÑÂáΩÊï∞ÔºåÂáΩÊï∞ÂêçÂèØ‰ª•Áõ¥ËßÇÂèçÊò†Âá∫ÂáΩÊï∞ÁöÑÁî®ÈÄî Consolidate Conditional Expression(ÂêàÂπ∂Êù°‰ª∂Ë°®ËææÂºè) Âú∫ÊôØÔºöÊúâ‰∏ÄÁ≥ªÂàóÁöÑÊù°‰ª∂ÊµãËØïÔºåÂùáÂæóÂà∞Áõ∏ÂêåÁöÑÁªìÊûú ÈáçÊûÑÔºöÂ∞ÜËøô‰∫õÊµãËØïÂêàÂπ∂‰∏∫‰∏Ä‰∏™Êù°‰ª∂Ë°®ËææÂºèÔºåÂπ∂Â∞ÜËøô‰∏™Êù°‰ª∂Ë°®ËææÂºèÊèêÁÇº‰∏∫‰∏Ä‰∏™Áã¨Á´ãÁöÑÂáΩÊï∞ ‰ΩøÁî®||„ÄÅ&amp;&amp;„ÄÅÔºüÔºöÂêàÂπ∂ÊµãËØïÊù°‰ª∂ Consolidate Duplicate Conditional Fragments(ÂêàÂπ∂ÈáçÂ§çÁöÑÊù°‰ª∂ÁâáÊÆµ) Âú∫ÊôØÔºöÂú®Êù°‰ª∂Ë°®ËææÂºèÁöÑÊØè‰∏™ÂàÜÊîØ‰∏äÈÉΩÊúâÁõ∏ÂêåÁöÑ‰∏ÄÊÆµ‰ª£Á†Å ÈáçÊûÑÔºöÂ∞ÜËøôÊÆµ‰ª£Á†ÅÊê¨ÁßªÂà∞Êù°‰ª∂Ë°®ËææÂºèÂ§ñÔºåÂπ∂ÊèêÁÇºÂá∫Áã¨Á´ãÂáΩÊï∞ Remove Control Flag(ÁßªÈô§ÊéßÂà∂Ê†áËÆ∞) Âú®‰∏ÄÁ≥ªÂàóÁöÑÂ∏ÉÂ∞îË°®ËææÂºè‰∏≠ÔºåÊüê‰∏™ÂèòÈáèÂ∏¶ÊúâÊéßÂà∂Ê†áËÆ∞Ôºàcontrol flagÔºâÁöÑ‰ΩúÁî® ‰ª•breakÊàñËÄÖreturnËØ≠Âè•Âèñ‰ª£Ëøô‰∏™ÊéßÂà∂Ê†áËÆ∞ Replace Nested Conditional with Guard Clauses(‰ª•‰ΩçËØ≠Âè•Âèñ‰ª£ÂµåÂ•óÁöÑÊù°‰ª∂Ë°®ËææÂºè) Âú∫ÊôØÔºöÂáΩÊï∞‰∏≠Êù°‰ª∂ÈÄªËæë‰Ωø‰∫∫Ëø∑ÊÉë ÈáçÊûÑÔºö‰ΩøÁî®Âç´ËØ≠Âè•Ë°®Áé∞ÊâÄÊúâÁâπÊÆäÊÉÖÂÜµÔºåÁ´ãÂç≥ËøîÂõûÁªìÊûúÔºõÊúÄÂêéÂ§ÑÁêÜÊ≠£Â∏∏ÈÄªËæëÔºõ ‰ΩøÁî®Âç´ËØ≠Âè•Ê£ÄÊü•ÁâπÊÆäÊù°‰ª∂ÔºåÁ´ãÂàªËøîÂõûÊàñÊäõÂá∫ÂºÇÂ∏∏Ôºõ ÂèØ‰ª•ÂÖàÂ∞ÜÊù°‰ª∂Ë°®ËææÂºèÂèçËΩ¨ÂÆûÁé∞Âç´ËØ≠Âè•ÔºàP253ÔºâÔºõ Replace Conditional with Polymorphism(‰ª•Â§öÊÄÅÂèñ‰ª£Êù°‰ª∂Ë°®ËææÂºè) Âú∫ÊôØÔºöÊúâ‰∏Ä‰∏™Êù°‰ª∂Ë°®ËææÂºèÔºåÊ†πÊçÆÂØπË±°Á±ªÂûãÁöÑ‰∏çÂêåÈÄâÊã©‰∏çÂêåÁöÑË°å‰∏∫ ÈáçÊûÑÔºöÂ∞ÜËøô‰∏™Êù°‰ª∂Ë°®ËææÂºèÁöÑÊØè‰∏™ÂàÜÊîØÊîæËøõ‰∏Ä‰∏™Â≠êÁ±ªÁöÑÂ§çÂÜôÂáΩÊï∞‰∏≠ÔºåÁÑ∂ÂêéÂ∞ÜÂéüÂßãÁöÑÂáΩÊï∞Â£∞Êòé‰∏∫ÊäΩË±° Âú®‰ΩøÁî®Replace Coditional with Polymorphism‰πãÂâç,ÂøÖÈ°ªÂª∫Á´ã‰∏Ä‰∏™ÁªßÊâøÁªìÊûÑÔºö‰ºòÂÖà‰ΩøÁî®Repalce Type Code with SubclassÔºå‰ΩÜÊòØÂ¶ÇÊûúÈúÄË¶ÅÂú®ÂØπË±°ÂàõÂª∫Âêé‰øÆÊîπÁ±ªÂûãÁ†ÅÔºåÂ∞±‰∏çËÉΩÁî®ÁªßÊâøÊâãÊ≥ïÔºåÈÇ£‰πà‰ΩøÁî® Replace Type Code with State/Stratege; Introduce Null Object(ÂºïÂÖ•NullÂØπË±°) Âú∫ÊôØÔºö‰Ω†ÈúÄË¶ÅÂÜç‰∏âÊ£ÄÊü•Êüê‰∏™ÂØπË±°ÊòØÂê¶‰∏∫null ÈáçÊûÑÔºöÂª∫Á´ãNullÂØπË±°ÔºåÊõøÊç¢nullÂÄºÁöÑÂà§Êñ≠ Á©∫ÂØπË±°ÁªßÊâøÊ∫êÂØπË±°ÔºåÊàñËÄÖÂÆûÁé∞Null InterfaceÔºõÁ©∫ÂØπË±°‰∏ÄÂÆöÊòØ‰∏Ä‰∏™Â∏∏ÈáèÔºåÂÆÉÁöÑ‰ªª‰ΩïÊàêÂàÜÈÉΩ‰∏ç‰ºöÂèòÂåñÔºõ Introduce Assertion(ÂºïÂÖ•Êñ≠Ë®Ä) Êüê‰∏ÄÊÆµ‰ª£Á†ÅÈúÄË¶ÅÂØπÁ®ãÂ∫èÁä∂ÊÄÅ‰ΩúÂá∫ÂÅáËÆæÔºå‰ª•Êñ≠Ë®ÄÊòéÁ°ÆË°®Á§∫ËøôÁßçÂÅáËÆæ ###ÁÆÄÂåñÂáΩÊï∞Ë∞ÉÁî® Rename Method(ÂáΩÊï∞ÊîπÂêç) ÁªôÊØè‰∏Ä‰∏™ÂáΩÊï∞Âèñ‰∏Ä‰∏™ÂèØ‰ª•Êè≠Á§∫ÂáΩÊï∞Áî®ÈÄîÁöÑ„ÄÅÁõ¥ËßÇÁöÑÂêçÂ≠ó Add Parameter(Ê∑ªÂä†ÂèÇÊï∞) ‰∏∫Ê≠§ÂáΩÊï∞Ê∑ªÂä†‰∏Ä‰∏™ÂØπË±°ÂèÇÊï∞ÔºåËÆ©ËØ•ÂØπË±°ÂèÇÊï∞Â∏¶ËøõÂáΩÊï∞ÊâÄÈúÄ‰ø°ÊÅØ Remove Parameter(ÁßªÈô§ÂèÇÊï∞) ÁßªÈô§Â§ö‰ΩôÁöÑÂèÇÊï∞ Separate Query from Modifier(Â∞ÜÊü•ËØ¢ÂáΩÊï∞Âíå‰øÆÊîπÂáΩÊï∞ÂàÜÁ¶ª) Âú∫ÊôØÔºöÊüê‰∏™ÂáΩÊï∞Êó¢ËøîÂõûÂØπË±°Áä∂ÊÄÅÂÄºÔºåÊúâ‰øÆÊîπÂØπË±°Áä∂ÊÄÅ ÈáçÊûÑÔºöÂª∫Á´ã‰∏§‰∏™Áã¨Á´ãÁöÑÂáΩÊï∞Ôºå‰∏Ä‰∏™Ë¥üË¥£Êü•ËØ¢ÔºåÂè¶‰∏Ä‰∏™Ë¥üË¥£‰øÆÊîπ Ê≥®ÊÑèÂπ∂ÂèëÁºñÁ®ã‰∏≠ÔºåÂèØ‰øùÁïôÊü•ËØ¢-‰øÆÊîπÂáΩÊï∞ÔºåË∞ÉÁî®ÂêÑËá™Áã¨Á´ãÁöÑÊü•ËØ¢ÂáΩÊï∞Âíå‰øÆÊîπÂáΩÊï∞ÔºåÂπ∂Â£∞Êòé‰∏∫synchronised Parameterize Method(‰ª§ÂáΩÊï∞Êê∫Â∏¶ÂèÇÊï∞) Ëã•Âπ≤ÂáΩÊï∞ÂÅö‰∫ÜÁ±ª‰ººÁöÑÂ∑•‰ΩúÔºå‰ΩÜÂõ†Â∞ëÊï∞Âá†‰∏™ÂÄºËá¥‰ΩøË°å‰∏∫Áï•Êúâ‰∏çÂêå Âª∫Á´ãÂçï‰∏ÄÂáΩÊï∞Ôºå‰ª•ÂèÇÊï∞Ë°®ËææÈÇ£‰∫õ‰∏çÂêåÁöÑÂÄº Replace Parameter with Explicit Method(‰ª•ÊòéÁ°ÆÂáΩÊï∞Âèñ‰ª£ÂèÇÊï∞) Êúâ‰∏Ä‰∏™ÂáΩÊï∞ÂÆâÂÖ®ÂèñÂÜ≥‰∫éÂèÇÊï∞ÂÄºËÄåÈááÂèñ‰∏çÂêåÁöÑË°å‰∏∫ ÈíàÂØπËØ•ÂèÇÊï∞ÁöÑÊØè‰∏Ä‰∏™ÂèØËÉΩÂÄºÔºåÂª∫Á´ã‰∏Ä‰∏™Áã¨Á´ãÂáΩÊï∞ÔºõÁõ∏Âèç‰∏éParameterize Method Preserve Whole Object(‰øùÊåÅÂÆåÊï¥ÂØπË±°) Âú∫ÊôØÔºö‰Ω†‰ªéÂØπË±°‰∏≠ÂèñÂá∫‰∏Ä‰∫õÂÄºÔºåÂ∞ÜÂÆÉ‰ª¨‰Ωú‰∏∫ÂèÇÊï∞‰º†ÈÄíÁªôÂáΩÊï∞ ÈáçÊûÑÔºöÊîπ‰∏∫‰º†ÈÄíÊï¥‰∏™ÂØπË±° Replace Parameter with Methods(‰ª•ÂáΩÊï∞Âèñ‰ª£ÂèÇÊï∞) Âú∫ÊôØÔºöÂØπË±°Ë∞ÉÁî®‰∏Ä‰∏™ÂáΩÊï∞ÔºåÂπ∂Â∞ÜÊâÄÂæóÁöÑÁªìÊûú‰Ωú‰∏∫ÂèÇÊï∞Ôºå‰º†ÈÄíÁªôÂè¶‰∏Ä‰∏™ÂáΩÊï∞ ÈáçÊûÑÔºöËÆ©ÂèÇÊï∞Êé•Êî∂ËøôÂéªÂ§ÑËØ•È°πÂèÇÊï∞ÔºåÂπ∂Áõ¥Êé•Ë∞ÉÁî®Ââç‰∏Ä‰∏™ÂáΩÊï∞ Â¶ÇÊûúÂáΩÊï∞ÂèØ‰ª•ÈÄöËøáÂÖ∂‰ªñÈÄîÂæÑËé∑ÂèñÂèÇÊï∞ÂÄºÔºåÈÇ£‰πàÂ∞±Â∫îËØ•ÂéªÈô§ËØ•Â§ö‰ΩôÁöÑÂèÇÊï∞ Introduce Parameter Object(ÂºïÂÖ•ÂèÇÊï∞ÂØπË±°) Âú∫ÊôØÔºöÊüê‰∫õÂèÇÊï∞ÊÄªÊòØÂæàËá™ÁÑ∂ÁöÑÂêåÊó∂Âá∫Áé∞ ÈáçÊûÑÔºö‰ª•‰∏Ä‰∏™ÂØπË±°Âèñ‰ª£Ëøô‰∫õÂèÇÊï∞ÔºåÊØîÂ¶ÇRangeÊ®°ÂºèÔºåËåÉÂõ¥ÂØπË±°Âèñ‰ª£(start,end) Remove Setting Method(ÁßªÈô§ËÆæÂÄºÂáΩÊï∞) Âú∫ÊôØÔºöÁ±ª‰∏≠ÁöÑÊüê‰∏™Â≠óÊÆµÂ∫îËØ•Âú®ÂØπË±°ÂàõÂª∫ÁöÑÊó∂ÂÄôË¢´ËÆæÂÄºÔºåÁÑ∂Âêé‰∏çÂÜçÊîπÂèò ÈáçÊûÑÔºöÂéªÈô§ËØ•Â≠óÊÆµÊâÄÊúâËÆæÂÄºÂáΩÊï∞ÔºåÂêåÊó∂Â£∞ÊòéËØ•Â≠óÊÆµ‰∏∫final Hide Method(ÈöêËóèÂáΩÊï∞) Êúâ‰∏Ä‰∏™ÂáΩÊï∞‰ªéÁ±ªÊ≤°ÊúâË¢´ÂÖ∂‰ªñ‰ªª‰ΩïÁ±ªÁî®Âà∞Ëøá Â∞ÜËøô‰∏™ÂáΩÊï∞‰øÆÊîπ‰∏∫private Replace Constructor with Factory Method(‰ª•Â∑•ÂéÇÂáΩÊï∞Âèñ‰ª£ÊûÑÈÄ†ÂáΩÊï∞) Âú∫ÊôØÔºöÂú®Ê¥æÁîüÂ≠êÁ±ªÁöÑËøáÁ®ã‰∏≠ÔºåÈúÄË¶ÅÊ†πÊçÆÁ±ªÂûãÁ†ÅÔºåÂàõÂª∫Áõ∏Â∫îÁöÑÂØπË±° ÈáçÊûÑÔºö‰ΩøÁî®Â∑•ÂéÇÂáΩÊï∞Âèñ‰ª£ÊûÑÈÄ†ÂáΩÊï∞ Encapsulate Downcast(Â∞ÅË£ÖÂêë‰∏ãËΩ¨Âûã) Âú∫ÊôØÔºöÊüê‰∏™ÂáΩÊï∞ËøîÂõûÁöÑÂØπË±°ÈúÄË¶ÅÁî±ÂáΩÊï∞ÁöÑË∞ÉÁî®ËÄÖÊâßË°åÂêë‰∏ãËΩ¨Âûã ÈáçÊûÑÔºöÂ∞ÜÂêë‰∏ãËΩ¨ÂûãÁöÑÂä®‰ΩúÁßªÂà∞ÂáΩÊï∞‰∏≠ 123Object lastReading() &#123; return reading.lastElement();&#125; Êîπ‰∏∫Ôºö 123Reading lastReading() &#123; return (Reading)reading.lastElement();&#125; Replace Error Code with Exception(‰ª•ÂºÇÂ∏∏Âèñ‰ª£ÈîôËØØÁ†Å) Âú∫ÊôØÔºöÊüê‰∏™ÂáΩÊï∞ËøîÂõû‰∏Ä‰∏™ÁâπÂÆöÁöÑ‰ª£Á†ÅÔºåË°®Á§∫ÊüêÁßçÈîôËØØÁöÑÊÉÖÂÜµ ÈáçÊûÑÔºöÊîπÁî®ÂºÇÂ∏∏ 12345678int withdraw(int amount) &#123; if(amount &gt; _balance) &#123; return -1; &#125; else &#123; _balance -= amount; return 0; &#125;&#125; Êîπ‰∏∫Ôºö 1234void withdraw(int amount) throws BalanceException &#123; if(amount &gt; _balance) throw new BalanceExctption(); _balance -= amount;&#125; ÂÜ≥ÂÆöÂáΩÊï∞Â∫îËØ•ÊäõÂá∫ÂèóÊéßÂºÇÂ∏∏ÔºàcheckedÔºâËøòÊòØÈùûÂèóÊéßÂºÇÂ∏∏ÔºàuncheckedÔºâ Â¶ÇÊûúÂáΩÊï∞ÁöÑË∞ÉÁî®ËÄÖÊúâË¥£‰ªªÂú®Ë∞ÉÁî®ÂâçÊ£ÄÊü•ÂøÖË¶ÅÁä∂ÊÄÅÔºåÂ∞±ÊäõÂá∫uncheckedÂºÇÂ∏∏ ÊäõÂá∫checkedÂºÇÂ∏∏ÂèØ‰ª•Êñ∞Âª∫‰∏Ä‰∏™ÂºÇÂ∏∏Á±ªÁªßÊâøExceptionÔºåÊàñËÄÖ‰ΩøÁî®Áé∞ÊúâÁöÑcheckedÂºÇÂ∏∏Á±ª Replace Exception with Test(‰ª•ÊµãËØïÂèñ‰ª£ÂºÇÂ∏∏) Âú∫ÊôØÔºöÈù¢ÂØπ‰∏Ä‰∏™Ë∞ÉÁî®ËÄÖÂèØ‰ª•È¢ÑÂÖàÊ£ÄÊü•ÁöÑÊù°‰ª∂Ôºå‰Ω†ÊäõÂá∫‰∫Ü‰∏Ä‰∏™ÂºÇÂ∏∏ ‰øÆÊîπË∞ÉÁî®ËÄÖÔºå‰ΩøÂÆÉÂú®ÂáΩÊï∞Ë∞ÉÁî®‰πãÂâçÈ¢ÑÂÖàÊ£ÄÊü• 1234567double getValueForPeriod(int periodNumber) &#123; try &#123; return _values[periodNumber]; &#125; catch(ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125; Êîπ‰∏∫Ôºö 1234double getValueForPeriod(int periodNumber) &#123; if ( periodNumber &gt;= _values.length ) return 0; return _values[periodNumber];&#125; ÂºÇÂ∏∏Â∫îËØ•Âè™Ë¢´Áî®‰∫éÈÇ£‰∫õ‰∫ßÁîüÊÑèÊñô‰πãÂ§ñÁöÑÈîôËØØË°å‰∏∫ÔºåËÄå‰∏çÂ∫îËØ•Êàê‰∏∫Êù°‰ª∂Ê£ÄÊü•ÁöÑÂ∑•ÂÖ∑Ôºõ‰∏çË¶ÅÁî®try-catchËØ≠Âè•‰Ωú‰∏∫Êù°‰ª∂Âà§Êñ≠ËØ≠Âè•Ôºõ ###Ê¶ÇÊã¨Â§ÑÁêÜÂÖ≥Á≥ª Pull Up Field(Â≠óÊÆµ‰∏äÁßª) Â¶ÇÊûú‰∏§‰∏™Â≠êÁ±ªÊã•ÊúâÁõ∏ÂêåÁöÑÂ≠óÊÆµÔºåÂ∞ÜËØ•Â≠êÊÆµÁßªÂà∞Ë∂ÖÁ±ª Pull Up Method(ÂáΩÊï∞‰∏äÁßª) Âú∫ÊôØÔºöÊúâ‰∫õÂáΩÊï∞Âú®Â≠êÁ±ª‰∏≠‰∫ßÁîüÂÆåÂÖ®Áõ∏ÂêåÁöÑÁªìÊûú ÈáçÊûÑÔºöÂ∞ÜËØ•ÂáΩÊï∞ÁßªËá≥Ë∂ÖÁ±ª Pull Up MethodËøáÁ®ã‰∏≠ÊúÄÈ∫ªÁÉ¶ÁöÑ‰∏ÄÁÇπÂ∞±ÊòØÔºöË¢´ÊèêÂçáÁöÑÂáΩÊï∞ÂèØËÉΩ‰ºöÂºïÁî®Âè™Âá∫Áé∞Âú®Â≠êÁ±ªËÄå‰∏çÂá∫Áé∞Âú®Ë∂ÖÁ±ªÁöÑÁâπÊÄß„ÄÇ Â¶ÇÊûúË¢´ÂºïÁî®ÁöÑÊòØ‰∏Ä‰∏™ÂáΩÊï∞Ôºå‰Ω†ÂèØ‰ª•Â∞ÜËØ•ÂáΩÊï∞‰∏ÄÂêåÊèêÂçáÂà∞Ë∂ÖÁ±ªÔºõÊàñËÄÖÂú®Ë∂ÖÁ±ª‰∏≠Âª∫Á´ã‰∏Ä‰∏™ÊäΩË±°ÂáΩÊï∞ÔºõÊàñËÄÖÂª∫Á´ã‰∏Ä‰∏™ÂßîÊâòÂáΩÊï∞ Â¶ÇÊûúË¢´ÂºïÁî®ÁöÑÊòØÂ≠êÁ±ªÁöÑÂ≠óÊÆµÔºå‰Ω†ÂèØ‰ª•Â∞ÜËØ•Â≠óÊÆµ‰πüÊèêÂçáÂà∞Ë∂ÖÁ±ªÔºõÊàñËÄÖÂÖàÂú®Â≠êÁ±ª‰∏≠Ëá™Â∞ÅË£ÖÂ≠óÊÆµÔºåÁÑ∂ÂêéÂú®Ë∂ÖÁ±ª‰∏≠ÊääÂèñÂÄºÂáΩÊï∞Â£∞Êòé‰∏∫ÊäΩË±° Pull Up Constructor Body(ÊûÑÈÄ†ÂáΩÊï∞Êú¨‰Ωì‰∏äÁßª) Âú®Â≠êÁ±ª‰∏≠ÂêÑÊã•Êúâ‰∏Ä‰∫õÊûÑÈÄ†ÂáΩÊï∞ÔºåÂÆÉ‰ª¨ÁöÑÊú¨‰ΩìÂá†‰πé‰∏ÄËá¥ Âú®Ë∂ÖÁ±ª‰∏≠Êñ∞Âª∫‰∏Ä‰∏™ÊûÑÈÄ†ÂáΩÊï∞ÔºåÂπ∂Âú®Â≠êÁ±ªÊûÑÈÄ†ÂáΩÊï∞‰∏≠Ë∞ÉÁî®ÂÆÉ Pull Down Method(ÂáΩÊï∞‰∏ãÁßª) Ë∂ÖÁ±ª‰∏≠ÁöÑÊüê‰∏™ÂáΩÊï∞Âè™‰∏éÈÉ®ÂàÜÔºàËÄåÈùûÂÖ®ÈÉ®ÔºâÂ≠êÁ±ªÊúâÂÖ≥ÔºåÂ∞ÜËøô‰∏™ÂáΩÊï∞ÁßªÂà∞Áõ∏ÂÖ≥ÁöÑÈÇ£‰∫õÂ≠êÁ±ª‰∏≠Âéª Pull Down Field(Â≠óÊÆµ‰∏ãÁßª) Ë∂ÖÁ±ª‰∏≠ÁöÑÊüê‰∏™Â≠óÊÆµÂè™Ë¢´ÈÉ®ÂàÜÔºàËÄåÈùûÂÖ®ÈÉ®ÔºâÂ≠êÁ±ªÊâÄÁî®Âà∞ÔºåÂ∞ÜËøô‰∏™Â≠óÊÆµÁßªÂà∞ÈúÄË¶ÅÂÆÉÁöÑÈÇ£‰∏™Â≠êÁ±ª‰∏≠Âéª Extract SubClass(ÊèêÁÇºÂ≠êÁ±ª) Âú∫ÊôØÔºöÁ±ª‰∏≠ÁöÑÊüê‰∫õÁâπÊÄßÂè™Ë¢´Êüê‰∫õÔºàËÄåÈùûÂÖ®ÈÉ®ÔºâÂÆû‰æãÁî®Âà∞ ÈáçÊûÑÔºöÊñ∞Âª∫‰∏Ä‰∏™Â≠êÁ±ªÔºåÂ∞Ü‰∏äËø∞‰∏ÄÈÉ®ÂàÜÁâπÊÄßÁßªÂà∞Â≠êÁ±ª‰∏≠ Extract SuperClass(ÊèêÁÇºË∂ÖÁ±ª) Âú∫ÊôØÔºö‰∏§‰∏™Á±ªÂÖ∑ÊúâÁõ∏‰ººÁöÑÁâπÊÄß ÈáçÊûÑÔºö‰∏∫Ëøô‰∏§‰∏™Á±ªÂª∫Á´ã‰∏Ä‰∏™Ë∂ÖÁ±ªÔºåÂ∞ÜËøô‰∫õÁõ∏ÂêåÁöÑÁâπÊÄßÊê¨ÁßªÂà∞Ë∂ÖÁ±ª Extract Interface(ÊèêÁÇºÊé•Âè£) Âú∫ÊôØÔºöËã•Âπ≤ÂÆ¢Êà∑‰ΩøÁî®Á±ªÊé•Âè£‰∏≠ÁöÑÂêå‰∏ÄÂ≠êÈõÜÔºåÊàñËÄÖ‰∏§‰∏™Á±ªÁöÑÊé•Âè£ÊúâÁõ∏ÂêåÁöÑÈÉ®ÂàÜ ÈáçÊûÑÔºöÂ∞ÜÁõ∏ÂêåÁöÑÂ≠êÈõÜÊèêÁÇºÂà∞‰∏Ä‰∏™Áã¨Á´ãÁöÑÊé•Âè£‰∏≠ Collapse Hierarchy(ÊäòÂè†ÁªßÊâø‰ΩìÁ≥ª) Ë∂ÖÁ±ªÂíåÂ≠êÁ±ª‰πãÈó¥Êó†Â§™Â§ßÂå∫Âà´ÔºåÂ∞ÜÂÆÉ‰ª¨Âêà‰∏∫‰∏Ä‰Ωì From Template Method(Â°ëÈÄ†Ê®°ÁâàÂáΩÊï∞) Âú∫ÊôØÔºö‰Ω†Êúâ‰∏Ä‰∫õÂ≠êÁ±ªÔºåÂÖ∂‰∏≠Áõ∏Â∫îÁöÑÊüê‰∫õÂáΩÊï∞‰ª•Áõ∏ÂêåÁöÑÈ°∫Â∫èÊâßË°åÁ±ª‰ººÁöÑÊìç‰ΩúÔºå‰ΩÜÂêÑ‰∏™Êìç‰ΩúÁªÜËäÇ‰∏äÊúâÊâÄ‰∏çÂêå ÈáçÊûÑÔºöÂ∞ÜËøô‰∫õÁªÜËäÇÊìç‰ΩúÂàÜÂà´ÊîæËøõÁã¨Á´ãÁöÑÂáΩÊï∞‰∏≠ÔºåÂπ∂‰øùÊåÅÂÆÉ‰ª¨ÈÉΩÊúâÁõ∏ÂêåÁöÑÁ≠æÂêçÔºå‰∫éÊòØÂéüÂáΩÊï∞‰πüÂèòÂæóÁõ∏Âêå‰∫ÜÔºõÁÑ∂ÂêéÂ∞ÜÂéüÂáΩÊï∞‰∏äÁßªÂà∞Ë∂ÖÁ±ª Replace Inheritance with Delegation(‰ª•ÂßîÊâòÂèñ‰ª£ÁªßÊâø) Âú∫ÊôØÔºöÊüê‰∫õÂ≠êÁ±ªÂè™‰ΩøÁî®Ë∂ÖÁ±ªÊé•Âè£‰∏≠ÁöÑ‰∏ÄÈÉ®ÂàÜÔºåÊàñËÄÖÊ†πÊú¨‰∏çÈúÄË¶ÅÁªßÊâøËÄåÊù•ÁöÑÊï∞ÊçÆ ÈáçÊûÑÔºöÂú®Â≠êÁ±ª‰∏≠Êñ∞Âª∫‰∏Ä‰∏™Â≠êÊÆµÁî®‰ª•‰øùÂ≠òË∂ÖÁ±ªÔºõË∞ÉÊï¥Â≠êÁ±ªÂáΩÊï∞‰ª§ÂÆÉÂßîÊâòË∂ÖÁ±ªÔºõÁÑ∂ÂêéÂéªÊéâÁªßÊâøÂÖ≥Á≥ª Replace Delegation with Inheritance(‰ª•ÁªßÊâøÂèñ‰ª£ÂßîÊâò) Âú∫ÊôØÔºö‰Ω†Âú®‰∏§‰∏™Á±ª‰πãÈó¥‰ΩøÁî®ÂßîÊâòÂÖ≥Á≥ªÔºåÂπ∂ÁªèÂ∏∏‰∏∫Êï¥‰∏™Êé•Âè£ÁºñÂÜôÂæàÂ§öÂèäÂÖ∂ÁÆÄÂçïÁöÑÂßîÊâòÂáΩÊï∞ ÈáçÊûÑÔºöËÆ©ÂßîÊâòÁ±ªÁªßÊâøÂèóÊâòÁ±ª ###Â§ßÂûãÈáçÊûÑ Tease Apart Inheritance(Ê¢≥ÁêÜÂπ∂ÂàÜËß£ÁªßÊâø‰ΩìÁ≥ª) Âú∫ÊôØÔºöÊüê‰∏™ÁªßÊâø‰ΩìÁ≥ªÂêåÊó∂ÊâøÊãÖ‰∏§È°πË¥£‰ªª ÈáçÊûÑÔºöÂª∫Á´ã‰∏§‰∏™ÁªßÊâø‰ΩìÁ≥ªÔºåÂπ∂ÈÄöËøáÂßîÊâòÂÖ≥Á≥ªËÆ©ÂÖ∂‰∏≠‰∏Ä‰∏™ÂèØ‰ª•Ë∞ÉÁî®Âè¶‰∏Ä‰∏™ Convert Procedural Design to Objects(Â∞ÜËøáÁ®ãÂåñËÆæËÆ°ËΩ¨Âåñ‰∏∫ÂØπË±°ËÆæËÆ°) Âú∫ÊôØÔºö‰Ω†Êâã‰∏≠Êúâ‰∏Ä‰∫õ‰º†ÁªüËøáÁ®ãÂåñÈ£éÊ†ºÁöÑ‰ª£Á†Å ÈáçÊûÑÔºöÂ∞ÜÊï∞ÊçÆËÆ∞ÂΩïÂèò‰∏∫ÂØπË±°ÔºåÂ∞ÜÂ§ßÂùóË°å‰∏∫ÂàÜ‰∏∫Â∞èÂùóÔºåÂπ∂Â∞ÜË°å‰∏∫ÁßªÂÖ•Áõ∏ÂÖ≥ÂØπË±°‰πã‰∏≠ Separate Domain from Presentation(Â∞ÜÈ¢ÜÂüüÂíåÊòæÁ§∫ÂàÜÁ¶ª) Êüê‰∫õGUIÁ±ª‰∏≠ÂåÖÂê´‰∫ÜÈ¢ÜÂüüÈÄªËæë Â∞ÜÈ¢ÜÂüüÈÄªËæëÂàÜÁ¶ªÂá∫Êù•Ôºå‰∏∫ÂÆÉ‰ª¨Âª∫Á´ãÁã¨Á´ãÁöÑÈ¢ÜÂüüÁ±ª Extract Hierarchy(ÊèêÁÇºÁªßÊâø‰ΩìÁ≥ª) Âú∫ÊôØÔºö‰Ω†ÊúâÊüê‰∏™Á±ªÂÅö‰∫ÜÂ§ßÈáèÁöÑÂ∑•‰ΩúÔºåÂÖ∂‰∏≠‰∏ÄÈÉ®ÂàÜÂ∑•‰ΩúÊòØ‰ª•Â§ßÈáèÁöÑÊù°‰ª∂Ë°®ËææÂºèÂÆåÊàêÁöÑ ÈáçÊûÑÔºöÂª∫Á´ãÁªßÊâø‰ΩìÁ≥ªÔºå‰ª•‰∏Ä‰∏™Â≠êÁ±ªË°®Á§∫‰∏ÄÁßçÁâπÊÆäÊÉÖÂÜµ]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2017%2F05%2F16%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Generate static files1$ hexo generate More info: Generating Run server1$ hexo server More info: Server Deploy to remote sites1$ hexo deploy BenefitsWith this feature, now you can put all your configurations into one place (source/_data/next.yml), you don‚Äôt need to touch next/_config.yml. If there are any new options in new releases, you just need to copy those options from next/_config.yml, paste into _data/next.yml and set their values to whatever you want. How to use this feature Please ensure you are using Hexo 3 (or above) Create an file named next.yml in site‚Äôs source/_data directory (create _data directory if it did not exist) Copy NexT theme options both in site‚Äôs _config.yml and theme‚Äôs _config.yml into next.yml. Use --config source/_data/next.yml parameter to start server, generate or deploy.For example: hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml. More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
