<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[KotlinåŸºç¡€]]></title>
    <url>%2F2022%2F11%2F10%2Fkotlin%2F</url>
    <content type="text"><![CDATA[KotlinåŸºç¡€ åœ¨kotlinä¸­ï¼Œifæ˜¯è¡¨è¾¾å¼ï¼Œè€Œä¸æ˜¯è¯­å¥ 123fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125; è¡¨è¾¾å¼å‡½æ•°ä½“ 123fun max(a: Int, b: Int): Int = if(a &gt; b) a else b//è¡¨è¾¾å¼å‡½æ•°ä½“è¿˜å¯ä»¥çœç•¥è¿”å›žå€¼ç±»åž‹fun max(a: Int, b: Int) = if(a &gt; b) a else b å­—ç¬¦ä¸²æ¨¡ç‰ˆ 1println("Hello, $name!") å€¼å¯¹è±¡ ï¼Œpublicæ˜¯é»˜è®¤çš„å¯è§æ€§ï¼Œå¯ä»¥çœç•¥ 1class Person(val name: String) å±žæ€§ 1234class Person &#123; val name: String, //åªè¯»å±žæ€§ï¼šä¸€ä¸ªå­—æ®µå’Œgetter var isMarried: Boolean //å¯å†™å±žæ€§ï¼Œä¸€ä¸ªå­—æ®µã€getterã€setter&#125; è‡ªå®šä¹‰è®¿é—®å™¨ 123456class Rectangle(val height: Int, val width: Int) &#123; val isSquare: Boolean get() &#123; return height == width &#125;&#125; æžšä¸¾ æžšä¸¾å¹¶ä¸æ˜¯å€¼çš„åˆ—è¡¨ï¼Œå¯ä»¥å£°æ˜Žæžšä¸¾çš„å±žæ€§å’Œæ–¹æ³•ï¼Œæžšä¸¾å¸¸é‡å’Œæ–¹æ³•ï¼›éš”å¼€ 12345678910enum class Color &#123; RED, ORANGE, YELLOW, BLUE&#125;enum class Color(val r: Int, val g: Int, val b: Int) &#123; RED(225, 0,0), ORANGE(255, 165, 0), YELLOW(255,255,0) BLUE(0,0, 255); fun rgb() = (r * 256 + g) * 256 + b&#125; when Kotlinä¸­çš„whenå…è®¸ä½¿ç”¨ä»»ä½•å¯¹è±¡ï¼Œè€Œjavaä¸­switchå¿…é¡»ä½¿ç”¨å¸¸é‡ï¼ˆæžšä¸¾å¸¸é‡ï¼Œå­—ç¬¦ä¸²æˆ–è€…æ•°å­—ï¼‰ 123456789//å¯¼å…¥æžšä¸¾å¸¸é‡åŽä¸ç”¨é™å®šè¯å°±å¯ä»¥è®¿é—®import ch02.colors.Colorimport ch02.colors.Color*fun getWarmth(color: Color) = when(color) &#123; RED, ORANGE, YELLOW -&gt; "warm" GREEN -&gt; "neutral" BLUE, INDIGO, VIOLET -&gt; "cold"&#125; æ™ºèƒ½è½¬æ¢ kotlinä¸­çš„å˜é‡ç»è¿‡isæ£€æŸ¥ä¹‹åŽä¸å†å‘ç”Ÿå˜åŒ–çš„æƒ…å†µä¸‹æœ‰æ•ˆã€‚ 123456789101112131415161718192021222324interface Exprclass Num(val value: Int) : Exprclass Sum(val left: Expr, val right: Expr) : Expr//if è¡¨è¾¾å¼fun eval(e: Expr) : Int = if(e is Num) &#123; e.value &#125; else if(e is Sum) &#123; eval(e.right) + eval(e.left) &#125; else &#123; throw IllegalArgumentException("unknown expression") &#125;// whenfun eval(e: Expr) : Int = when(e) &#123; is Num -&gt; e.value is Sum -&gt; eval(e.right) + eval(e.left) else -&gt; throw IllegalArgumentException("unknown expression") &#125; è¿­ä»£æ•°å­—ï¼š åŒºé—´å’Œæ•°åˆ— 1234567891011//1 ï½ž 100åŒ…å«ï¼Œ æ­¥é•¿ä¸º1for( i in 1..100) &#123; print(fizzBuzz(i))&#125;//é€’å‡æ•°åˆ—ï¼Œæ­¥é•¿ä¸º2for(i in 100 downTo 1 step 2) &#123; print(fizzBuzz(i))&#125;for(x in 0 until size) ç­‰åŒäºŽ for(x in 0..size - 1) è¿­ä»£map 1234val list = arrayListOf("10", "11", "1001")for((index, element) in list.withIndex()) &#123; println("$index : $element")&#125; ä½¿ç”¨â€œinâ€æ£€æŸ¥é›†åˆå’ŒåŒºé—´çš„æˆå‘˜ 12fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'fun isNotDigit(c: Char) = c !in '0'..'9' try catch finally Kotlin ä¸­å¹¶ä¸åŒºåˆ†å—æ£€å¼‚å¸¸å’Œæœªå—æ£€å¼‚å¸¸ã€‚ä¸ç”¨æŒ‡å®šå‡½æ•°æŠ›å‡ºå¼‚å¸¸ï¼Œè€Œä¸”å¯ä»¥å¤„ç†ä¹Ÿå¯ä»¥ä¸å¤„ç†å¼‚å¸¸ã€‚ 12345678fun readNumber(reader: BufferedReader) &#123; val number = try &#123; Integer.parseInt(reader.readLine()) //æ­£å¸¸é€»è¾‘ä½¿ç”¨å€¼ &#125; catch &#123; null //å¼‚å¸¸å‘ç”Ÿæ—¶ä½¿ç”¨null &#125; print(number)&#125; å‡½æ•°çš„å®šä¹‰å’Œè°ƒç”¨ é›†åˆ kotlinä¸­é‡‡ç”¨çš„æ˜¯æ ‡å‡†çš„javaé›†åˆç±» 12345678910val set = hashSetOf(1, 7, 5)val list = arrayListOf(1, 7, 6)val map = hashMapOf(1 to "one", 7 to "seven", 5 to "five")&gt;&gt;&gt; println(set.javaClass)class java.util.HashSet&gt;&gt;&gt; println(list.javaClass)class java.util.ArrayList&gt;&gt;&gt; println(map.javaClass)class java.util.HashMap å‘½åå‚æ•° 1joinToString(collction, separator = " ", prefix = " ", postfix = ".") å¦‚æžœè°ƒç”¨æ—¶æŒ‡å®šäº†ä¸€ä¸ªå‚æ•°çš„åç§°ï¼Œé‚£ä¹ˆè¯¥å‚æ•°åŽé¢çš„æ‰€æœ‰å‚æ•°éƒ½è¦æ ‡æ˜Žåç§° å‡½æ•°é»˜è®¤å‚æ•°å€¼ 12345678fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = ", ", prefix: String = "", postfix: String ""): String &#123; ...&#125; å¦‚æžœæŒ‰ç…§å¸¸è§„è°ƒç”¨å‡½æ•°ï¼Œå¿…é¡»æŒ‰ç…§å‡½æ•°å£°æ˜Žä¸­å®šä¹‰çš„å‚æ•°é¡ºåºç»™å®šå‚æ•°ï¼Œå¯ä»¥çœç•¥çš„åªæœ‰æŽ’åœ¨æœ«å°¾çš„å‚æ•°ã€‚ å¦‚æžœç”¨å‘½åå‚æ•°è°ƒç”¨ï¼Œå¯ä»¥çœç•¥ä¸­é—´çš„ä¸€äº›å‚æ•°ï¼Œä¹Ÿå¯ä»¥ä»¥ä»»æ„é¡ºåºç»™å®šéœ€è¦çš„å‚æ•°ã€‚ 1234567//å¸¸è§„è°ƒç”¨&gt;&gt;&gt;joinToString(list, ", ", "", "")&gt;&gt;&gt;joinToString(list, ", ")&gt;&gt;&gt;joinToString(list)//å‘½åå‚æ•°&gt;&gt;&gt; joinToStirng(list, postfix = ; prefix = #)# 1, 2, 3; ç”±äºŽJavaæ²¡æœ‰å‚æ•°é»˜è®¤å€¼æ¦‚å¿µï¼Œå½“ä»Ž java è°ƒç”¨ kotlinä¸­çš„å‡½æ•°æ—¶ï¼Œå¿…é¡»æ˜¾å¼çš„åˆ¶å®šæ‰€æœ‰å‚æ•°å€¼ã€‚ ä¸ºè°ƒç”¨ç®€ä¾¿å¯ä»¥é€šè¿‡@JvmOverloadsæ³¨è§£å®ƒï¼Œç¼–è¯‘å™¨ä¼šé»˜è®¤ç”Ÿæˆå¤šä¸ªé‡è½½å‡½æ•°ï¼ˆä»Žæœ«å°¾å¼€å§‹çœç•¥çš„é‡è½½å‡½æ•°ï¼‰ã€‚ æ¶ˆé™¤é™æ€å·¥å…·ç±»ï¼šé¡¶å±‚å‡½æ•°å’Œå±žæ€§ kotlinç¼–è¯‘ç”Ÿæˆçš„ç±»çš„åç§°ï¼Œå¯¹åº”äºŽåŒ…å«å‡½æ•°æ–‡ä»¶çš„åç§°ã€‚é¡¶å±‚å‡½æ•°ç¼–è¯‘ä¸ºjavaçš„é™æ€å‡½æ•° 12345678910111213package stringsfun joinToString(...): String &#123; ... &#125;//ç¼–è¯‘åŽ/** java **/package strings;public class JoinKt &#123; public static String joinToString(...) &#123;...&#125;&#125;/* Java è°ƒç”¨ */import strings.JoinKt;JoinKt.joinToString(list, ", ", "", "") 123456789101112//ä¿®æ”¹æ–‡ä»¶çš„ç±»åï¼Œ@JvmName@file:JvmName(&quot;StringFunctions&quot;) //æŒ‡å®šjavaç±»çš„åç§°package stringsfun joinToString(...): String&#123;...&#125;//è°ƒç”¨/*Java*/import strings.StringFuncitons;StringFunctions.joinToString(list, &quot;, &quot;, &quot;&quot;, &quot;&quot;); é¡¶å±‚å±žæ€§ç¼–è¯‘åŽä¼šè¢«å­˜å‚¨åˆ°ä¸€ä¸ªé™æ€å­—æ®µä¸­ é»˜è®¤æƒ…å†µä¸‹ï¼Œé¡¶å±‚å±žæ€§å’Œå…¶ä»–ä»»æ„å±žæ€§ä¸€æ ·ï¼Œæ˜¯é€šè¿‡è®¿é—®å™¨æš´éœ²ç»™ Java ä½¿ç”¨çš„ï¼ˆvalåªæœ‰ä¸€ä¸ªgetterï¼Œ varæœ‰ä¸€å¯¹getterå’Œsetterï¼‰ 12345//å¦‚æžœæƒ³æŠŠå¸¸é‡ä»¥public static finalçš„å±žæ€§æš´éœ²ç»™javaå¯ä»¥ç”¨ constæ¥ä¿®é¥°const val UNIX_LINE_SEPARATOR = "\n"/* Java */public static final String UNIX_LINE_SEPARATOR = "\n"; ç»™åˆ«äººçš„ç±»æ·»åŠ æ–¹æ³•ï¼š æ‰©å±•å‡½æ•°å’Œå±žæ€§ 1fun String.lastChar(): Char = this.get(this.length - 1) æ³¨æ„ï¼šæ‰©å±•å‡½æ•°å¹¶ä¸å…è®¸ä½ æ‰“ç ´ç±»çš„å°è£…æ€§ã€‚ä¸Žå†…éƒ¨å®šä¹‰çš„æ–¹æ³•ä¸åŒï¼Œ*æ‰©å±•å‡½æ•°ä¸èƒ½è®¿é—®ç§æœ‰çš„æˆ–è€…å—ä¿æŠ¤çš„æˆå‘˜ã€‚ å¯¼å…¥æ‰©å±•å‡½æ•° 123456import strings.lastCharval c = "Kotlin".lastChar()// as ç”¨æ¥é‡å‘½åï¼Œè§£å†³å‘½åå†²çªé—®é¢˜import strings.lastChar as lastval c = "Kotlin".last() å®žè´¨ä¸Šï¼Œæ‰©å±•å‡½æ•°å¼å°±æ˜¯é™æ€å‡½æ•°é«˜çº§è¯­æ³•ç³–ï¼Œå®ƒæŠŠè°ƒç”¨å¯¹è±¡ä½œä¸ºå®ƒçš„ç¬¬ä¸€ä¸ªå‚æ•°ã€‚ 123//java è°ƒç”¨kotlinçš„æ‰©å±•å‡½æ•°/** java **/char c = StringUtilKt.lastChar("Java"); ä½œä¸ºæ‰©å±•å‡½æ•°çš„å·¥å…·å‡½æ•° 12345678910111213141516171819202122fun &lt;T&gt; Collection&lt;T&gt;.joinToString( separator: String = ", ", prefix: String = "", postfix: String =""): String &#123; var result = StringBuilder(prefix) for((index, element) in this.withIndex()) &#123; if(index &gt; 0) result.append(separator) result.append(element) &#125; result.append(postfix) return result.toString()&#125;&gt;&gt;&gt; val list = listOf(1, 2, 3)&gt;&gt;&gt; println(list.joinToString(separator = "; ", prefix = "(", postfix = ")")) (1; 2; 3) ç”±äºŽæ‰©å±•å‡½æ•°æœ¬è´¨æ—¶é™æ€å‡½æ•°ï¼Œæ‰€ä»¥å®ƒä¸èƒ½è¢«å­ç±»é‡å†™ï¼Œä¸å…·æœ‰å¤šæ€ã€‚ 1234567891011fun View.showOff() = println("I am a View!")fun Button.showOff() = prinln("I am a Button!")&gt;&gt;&gt; val view: View = Button()&gt;&gt;&gt; view.showOff() //é™æ€è§£æžI am a View!/* java */&gt;&gt;&gt; View view = new Button();&gt;&gt;&gt; ExtensionsKt.showOff(view); //showOff å‡½æ•°å£°æ˜Žåœ¨Extension.ktæ–‡ä»¶ä¸­I am a View! æ‰©å±•å±žæ€§ 1234567891011var StringBuild.lastChar: Char get() = get(length - 1) //getter å±žæ€§ set(value: Char) &#123; //setter å±žæ€§ this.setCharAt(length - 1, value) &#125;&gt;&gt;&gt; println("kotlin".lastChar)n/* java è°ƒç”¨ */StringUtilKt.getLastChar("Java"); å¯å˜å‚æ•°ï¼šè®©å‡½æ•°æ”¯æŒä»»æ„æ•°é‡çš„å‚æ•° 12345678var list = listOf(2, 3, 5, 6, 11)// vararg å¯å˜å‚æ•°fun listOf&lt;T&gt;(vararg values: T): List&lt;T&gt; &#123;...&#125;// å±•å¼€è¿ç®—ç¬¦ *, kotlinæ˜¾ç¤ºè§£åŒ…æ•°ç»„fun main(args: Array&lt;String&gt;) &#123; val list = listOf("args: ", *args) println(list)&#125; é”®å€¼å¯¹çš„å¤„ç†ï¼šä¸­ç¼€è°ƒç”¨å’Œè§£æž„å£°æ˜Ž 12345678//ä¸­ç¼€è°ƒç”¨ toï¼Œ toå‡½æ•°ä¸€ä¸ªæ³›åž‹çš„æ‰©å±•å‡½æ•°val map = mapOf( 1 to "one", 2 to "two", 5 to "five")//ä¸­ç¼€ç¬¦å·è°ƒç”¨å‡½æ•°,toè¿”å›žçš„æ˜¯ä¸€ä¸ªPairç±»åž‹å¯¹è±¡infix fun Any.to(other: Any) = Pair(this, other)//è§£æž„å£°æ˜Žval (num, name) = 1 to "one" 12//mapOfå‡½æ•°å£°æ˜Žfun &lt;K,V&gt; mapOf(vararg values: Pair&lt;K,V&gt;): Map&lt;K,V&gt; å­—ç¬¦ä¸²å’Œæ­£åˆ™è¡¨è¾¾å¼çš„å¤„ç† åˆ†å‰²å­—ç¬¦ä¸² 12345//æ˜¾ç¤ºçš„ä¼ å…¥ä¸€ä¸ªæ­£åˆ™è¡¨è¾¾å¼&gt;&gt;&gt; println("12.3456-6.A".split("\\.|-".toRegex()))//æŒ‡å®šä»»æ„æ•°é‡çš„çº¯æ–‡æœ¬åˆ†éš”ç¬¦&gt;&gt;&gt; println("12.3456-6.A".split(".", "-"))[12, 345, 6, A] æ­£åˆ™è¡¨è¾¾å¼å’Œä¸‰é‡å¼•å·å­—ç¬¦ä¸² 123456789101112131415161718192021222324fun parsePath(path: String) &#123; val directory = path.substringBeforeLast("/") val fullName = path.substringAfterLast("/") val fileName = fullName.substringBeforeLast(".") val extension = fullName.substringAfter(".") println("Dir $directory, name: $fileName, ext:$extension")&#125;&gt;&gt;&gt; parsePath("/Users/yole/koltin-book/chapter.adoc")Dir /Users/yole/kotlin-book, name: chapter, ext: adoc//ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è§£æžæ–‡ä»¶è·¯å¾„//(.+)åŒ¹é…å¤šä¸ªä»»æ„å­—ç¬¦è´ªå©ªï¼Œç¬¬ä¸€ä¸ªï¼ˆ.+ï¼‰ç›®å½•,ç¬¬äºŒä¸ªï¼ˆ.+ï¼‰æ–‡ä»¶å,ç¬¬ä¸‰ä¸ªï¼ˆ.+ï¼‰æ‰©å±•å//ä¸‰é‡å¼•å·ä¸éœ€è¦å†è½¬ä¹‰ï¼ŒåŒ¹é…/ åŒ¹é….ç”¨\.è€Œä¸æ˜¯\\.fun parsePath(path: String) &#123; val regrex = """(.+)/(.+)\.(.+)""" val matchResult = regex.matchEntire(path) if(matchResult != null) &#123; val (directory, filename, extension) = matchResult.destructrued println("Dir $directory, name: $fileName, ext:$extension") &#125;&#125; å±€éƒ¨å‡½æ•°å’Œæ‰©å±• æå–å±€éƒ¨å‡½æ•°é¿å…é‡å¤çš„ä»£ç ï¼› å±€éƒ¨å‡½æ•°å¯ä»¥è®¿é—®å¤–éƒ¨å‡½æ•°çš„å‚æ•° åœ¨æ‰©å±•å‡½æ•°çš„å±€éƒ¨å‡½æ•°ä¸­ï¼Œå¯ä»¥è®¿é—®æ‰©å±•ç±»çš„å±žæ€§ ç±»ã€å¯¹è±¡å’ŒæŽ¥å£ Kotlinçš„ç±»é»˜è®¤æ˜¯final å’Œ publicçš„ï¼ŒåµŒå¥—çš„ç±»é»˜è®¤å¹¶ä¸æ˜¯å†…éƒ¨ç±»ã€‚ Kotlinçš„æŽ¥å£ Kotlin ä¸­çš„overrideä¿®é¥°ç¬¦æ˜¯å¼ºåˆ¶è¦æ±‚çš„ã€‚ 12345678interface Clickable &#123; fun click() fun showOff() = pritln("I am clickable!") //é»˜è®¤å®žçŽ°çš„æ–¹æ³•&#125;class Button : Clickable &#123; override fun click() = println("I was clicked")&#125; å¦‚æžœåŒæ ·çš„ç»§æ‰¿æˆå‘˜ä¸æ­¢ä¸€ä¸ªå®žçŽ°ï¼Œå¿…é¡»æä¾›ä¸€ä¸ªæ˜¾ç¤ºå®žçŽ° 12345678910class Button : Clickable, Focusable &#123; override fun click() = println("I was clicked") //åŒæ ·çš„ç»§æ‰¿ä¸æ­¢ä¸€ä¸ªï¼Œå¿…é¡»æ˜¾å¼è°ƒç”¨ override fun showOff() &#123; super&lt;Clickable&gt;.showOff() //ä½¿ç”¨å°–æ‹¬å·+çˆ¶ç±»åž‹è°ƒç”¨çˆ¶æ–¹æ³• super&lt;Focuable&gt;.showOff() &#125; &#125; 1234/** Java */Clickable.super.showOff()/** Kotlin */super&lt;Clickable&gt;.showOff() Openã€finalå’Œabstractä¿®é¥°ç¬¦ï¼š é»˜è®¤ä¸ºfinal Javaçš„ç±»å’Œæ–¹æ³•é»˜è®¤æ˜¯opençš„ï¼Œè€Œkotlinä¸­é»˜è®¤éƒ½æ˜¯finalçš„ 1234567891011//ç±»æ˜¯opençš„ï¼Œå…¶ä»–ç±»å¯ä»¥ç»§æ‰¿å®ƒopen class RichButton : Clickable &#123; //é»˜è®¤æ˜¯finalï¼Œå­ç±»ä¸­ä¸èƒ½é‡å†™ fun disable() &#123;&#125; //openï¼Œå­ç±»ä¸­å¯ä»¥é‡å†™ open fun animate() &#123;&#125; //openï¼Œå¯ä»¥é‡å†™ override fun click() &#123;&#125; // finalçš„ï¼Œå­ç±»ä¸­ä¸èƒ½é‡å†™ final override fun click1()&#123;&#125;&#125; æŠ½è±¡ç±» 12345678910//æŠ½è±¡ç±»å§‹ç»ˆæ˜¯opençš„abstract class Animated &#123; //æŠ½è±¡å‡½æ•°ï¼Œå­ç±»ä¸­å¿…é¡»é‡å†™ abstract fun animate() //opençš„å‡½æ•°ï¼Œå­ç±»å¯ä»¥é‡å†™ open fun stopAnimating() &#123; &#125; //final,å­ç±»ä¸­ä¸èƒ½é‡å†™ fun animateTwice()&#123;&#125;&#125; final, ä¸èƒ½è¢«é‡å†™ï¼Œç±»ä¸­æˆå‘˜é»˜è®¤ä½¿ç”¨ openï¼Œå¯ä»¥é‡å†™ï¼Œéœ€è¦æ˜Žç¡®è¡¨æ˜Ž abstractï¼Œå¿…é¡»é‡å†™ï¼ŒæŠ½è±¡ç±»å£°æ˜Žï¼Œå­ç±»ä¸­å¿…é¡»é‡å†™ overrideï¼Œé‡å†™çˆ¶ç±»æˆ–æŽ¥å£ä¸­çš„æˆå‘˜ï¼Œé‡å†™çš„æˆå‘˜é»˜è®¤ä¹Ÿæ˜¯opençš„ å¯è§æ€§ä¿®é¥°ç¬¦ kotlinä¸­å¯è§æ€§é»˜è®¤æ˜¯publicçš„ï¼Œç±»çš„æ‰©å±•å‡½æ•°ä¸èƒ½è®¿é—®å®ƒçš„privateå’Œprotected æˆå‘˜ ä¿®å¤ç¬¦ ç±»æˆå‘˜ é¡¶å±‚å£°æ˜Ž publicï¼ˆé»˜è®¤ï¼‰ æ‰€æœ‰åœ°æ–¹å¯è§ æ‰€æœ‰åœ°æ–¹å¯è§ internal æ¨¡å—ä¸­å¯è§ æ¨¡å—ä¸­å¯è§ protected å­ç±»ä¸­å¯è§ â€” private ç±»ä¸­å¯è§ æ–‡ä»¶ä¸­å¯è§ å†…éƒ¨ç±»å’ŒåµŒå¥—ç±»ï¼š é»˜è®¤æ˜¯åµŒå¥—ç±» Kotlinä¸­æ²¡æœ‰æ˜¾å¼ä¿®é¥°ç¬¦çš„åµŒå¥—ç±»ä¸ŽJavaä¸­çš„staticåµŒå¥—ç±»æ˜¯ä¸€æ ·çš„ Kotlinä¸­è¦å£°æ˜Žä¸€ä¸ªå†…éƒ¨ç±»æŒæœ‰å¤–éƒ¨ç±»çš„å¼•ç”¨çš„è¯ï¼Œä½¿ç”¨innerä¿®é¥°ç¬¦ ç±»Aåœ¨å¦ä¸€ä¸ªç±»Bä¸­å£°æ˜Ž Java kotlin åµŒå¥—ç±»ï¼ˆä¸å­˜å‚¨å¤–éƒ¨ç±»å¼•ç”¨ï¼‰ static class A class A å†…éƒ¨ç±»ï¼ˆå­˜å‚¨å¤–éƒ¨ç±»å¼•ç”¨ï¼‰ class A innter class A 12345class Outer &#123; innter class Inner&#123; fun getOuterReference(): Outer = this@Outer &#125;&#125; å¯†å°ç±»ï¼šå®šä¹‰å—é™çš„ç±»ç»§æ‰¿ç»“æž„ å¯†å°ç±»ï¼šæ‰€æœ‰çš„å­ç±»å¿…é¡»åµŒå¥—åœ¨çˆ¶ç±»ä¸­ï¼Œé»˜è®¤open 1234567891011sealed class Expr &#123; //å°†æ‰€æœ‰å¯èƒ½çš„ç±»ä½œä¸ºåµŒå¥—ç±»åˆ—å‡º class Num(val value: Int) : Expr() class Sum(val left: Expr, val right: Expr) : Expr()&#125;fun eval(e : Expr) : Int = when (e) &#123; is Expr.Num -&gt; e.value is Expr.Sum -&gt; eval(e.right) + eval(e.left) &#125; å£°æ˜Žä¸€ä¸ªå¸¦éžé»˜è®¤æž„é€ æ–¹æ³•æˆ–å±žæ€§çš„ç±» 12345678910111213141516//1.class User constructor(_nickname : String) &#123; val nickname: String //åˆå§‹åŒ–è¯­å¥å— init &#123; nickname = _nickname &#125;&#125;//2.class User(_nickname: String) &#123; val nickname = _nickname&#125;//3. ä¸Ž1.2.æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œ valæ„å‘³ç€ç›¸åº”çš„å±žæ€§ä¼šç”¨æž„é€ å‡½æ•°çš„å‚æ•°æ¥åˆå§‹åŒ–class User(val nickname: String) 123456789open class User(val nickname: String) &#123; ... &#125;class TwitterUser(nickname: String) : User(nickname) &#123; ... &#125;//å¿…é¡»æ˜¾å¼çš„è°ƒç”¨çˆ¶ç±»çš„æž„é€ æ–¹æ³•ï¼Œå³ä½¿å®ƒæ²¡æœ‰å‚æ•°open class Buttonclass RadioButton: Button()//æ³¨æ„å’ŒæŽ¥å£çš„åŒºåˆ«ï¼ŒæŽ¥å£ä¸ç”¨åŠ ()//ä¸€ä¸ªprivateæž„é€ æ–¹æ³•class Secretive private constructor() &#123;&#125; æž„é€ æ–¹æ³•ï¼š ç”¨ä¸åŒçš„æ–¹å¼æ¥åˆå§‹åŒ–çˆ¶ç±» javaä¸­å¤šé‡‡ç”¨é‡è½½å¤šä¸ªæž„é€ æ–¹æ³•ï¼Œkotlinä¸­ä¸€èˆ¬ç›´æŽ¥æ ‡æ˜Žé»˜è®¤å€¼ã€‚ 1234567891011121314151617181920open class View &#123; //ä»Žæž„é€ å‡½æ•° constructor(ctx: Context)&#123; //some code &#125; //ä»Žæž„é€ å‡½æ•° constructor(ctx: Context, attr: AttributeSet)&#123; //some code &#125;&#125;class MyButton: View &#123; //è°ƒç”¨çˆ¶ç±»æž„é€ å‡½æ•° constructor(ctx: Context): super(ctx, MY_STYLE)&#123; //... &#125; constructor(ctx: Context, attr: AttribueSet): super(ctx, attr)&#123; //... &#125;&#125; å®žçŽ°åœ¨æŽ¥å£ä¸­çš„å£°æ˜Žçš„å±žæ€§ Kotlin ä¸­æŽ¥å£å¯ä»¥åŒ…å«æŠ½è±¡å±žæ€§å£°æ˜Ž 12345678910111213141516171819202122interface User &#123; //æŠ½è±¡å±žæ€§å£°æ˜Žï¼Œå®ƒçš„å®žçŽ°ç±»éœ€è¦æä¾›ä¸€ä¸ªæ”¯æŒå­—æ®µæˆ–è€…getteræ–¹æ³•èŽ·å– val nickname: String&#125;//ä¸»æž„é€ å‡½æ•°ï¼Œé‡å†™äº†æ”¯æŒå­—æ®µclass PrivateUser(override val nickname: String) : User//æ¯æ¬¡é€šè¿‡getterè®¡ç®—èŽ·å–class SubscribingUser(val email: String) : User &#123; override val nickname: String get() = email.substringBefore('@')&#125;//é€šè¿‡æ”¯æŒå­—æ®µå­˜å‚¨åˆå§‹åŒ–çš„å€¼class FacebookUser(val accountId: Int) : User &#123; override val nickname = getFacebookName(accountId)&#125;interface User &#123; val email: String val nickname: String get() = email.substringBefore('@') //æŽ¥å£ä¸­å±žæ€§æ²¡æœ‰æ”¯æŒå­—æ®µï¼Œgetteréœ€è¦æ¯æ¬¡è®¡ç®—å¾—åˆ°&#125; é€šè¿‡getterå’Œsetterè®¿é—®æ”¯æŒå­—æ®µ åœ¨getterå’Œsetterå‡½æ•°ä¸­ï¼Œä½¿ç”¨ç‰¹æ®Šçš„æ ‡è¯†ç¬¦field æ¥è®¿é—®æ”¯æŒå­—æ®µçš„å€¼ã€‚ 123456789class User(val name: String) &#123; val address: String = "unspecified" set(value: Stirng) &#123; println(""" Address was changed for $name: "$field" -&gt; "$value".""".trimIndent()) //è¯»å–æ”¯æŒå­—æ®µçš„å€¼ field = value //æ›´æ–°æ”¯æŒå­—æ®µçš„å€¼ &#125;&#125; ä¿®æ”¹è®¿é—®å™¨çš„å¯è§è¡Œ 12345678class LengthCounter &#123; var counter: Int = 0 private set //ä¸èƒ½åœ¨ç±»çš„å¤–éƒ¨ç›´æŽ¥ä¿®æ”¹è¿™ä¸ªå±žæ€§ï¼Œåªèƒ½é€šè¿‡è°ƒç”¨addWordä¿®æ”¹ fun addWord(word: String) &#123; counter += word.length &#125;&#125; æ•°æ®ç±»å’Œå§”æ‰˜ å’ŒJavaä¸€æ ·ï¼Œç±»çš„é€šç”¨å¯¹è±¡æ–¹æ³•å­—ç¬¦ä¸²è¡¨ç¤ºtoString() equals() : åœ¨kotlinä¸­ï¼Œ==è¿ç®—ç¬¦è¡¨ç¤ºä¸¤ä¸ªå¯¹è±¡ç›¸ç­‰ï¼Œæœ¬è´¨ä¸Šæ˜¯è°ƒç”¨äº†equals()ã€‚ å¦‚æžœæƒ³æ¯”è¾ƒå¼•ç”¨ï¼Œä½¿ç”¨ ===è¿ç®—ç¬¦ hashCode(): é‡å†™äº†equals()åŒæ—¶å¿…é¡»é‡å†™hashCode() æ•°æ®ç±»ï¼šè‡ªåŠ¨ç”Ÿæˆequalsã€hashCodeã€toString equalså’ŒhashCode ä¼šå°†æ‰€æœ‰åœ¨ä¸»æž„é€ å‡½æ•°ä¸­å£°æ˜Žçš„å±žæ€§çº³å…¥è®¡ç®—ã€‚ 1data class Client(val name: String, val postalCode: Int) æ•°æ®ç±»å’Œä¸å¯å˜æ€§ï¼šcopyæ–¹æ³• 123456789class Client(val name: String, val postalCode: Int) &#123; ... fun copy(name: String = this.name, postalCode: Int = this.postalCode) = Client(name, postalCode)&#125;&gt;&gt;&gt; val bob = Client("Bob", 973)&gt;&gt;&gt; println(bob.copy(postalCode = 382))Client(name = Bob, postalCoe = 382) ç±»å§”æ‰˜ï¼šä½¿ç”¨â€˜â€™byâ€˜â€™ å…³é”®å­— Kotlin ä½¿ç”¨by å…³é”®å­—å°†æŽ¥å£çš„å®žçŽ°å§”æ‰˜åˆ°å¦ä¸€ä¸ªå¯¹è±¡ã€‚ ç±»ä¼¼äºŽjava ä¸­çš„åŒ…è£…ç±»ï¼Œå§”æ‰˜ç»™å†…éƒ¨æŒæœ‰çš„å¯¹è±¡ã€‚ 1234class DelegatingCollection&lt;T&gt; ( val innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;() ) : Collection&lt;T&gt; by innerList &#123;&#125;//å°†DelegatingCollection çš„å®žçŽ°å§”æ‰˜ç»™ innerList 12345678910111213141516class CountingSet&lt;T&gt;( val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;() ) : MutableColletion&lt;T&gt; by innerSet &#123; var objectsAdded = 0 override fun add(element: T): Boolean &#123; objectsAdded++ return innerSet.add(element) &#125; //ä¸å®žç”¨é»˜è®¤å§”æ‰˜ï¼Œé‡å†™ä¸€ä¸ªä¸åŒçš„å®žçŽ° override fun addArll(c: Collection&lt;T&gt;): Boolean &#123; objectsAdded += c.size return innerSet.add(c) &#125;&#125; â€œobjectâ€ å…³é”®å­—ï¼š å°†å£°æ˜Žä¸€ä¸ªç±»ä¸Žåˆ›å»ºä¸€ä¸ªå®žä¾‹ç»“åˆèµ·æ¥ å¯¹è±¡å£°æ˜Žï¼šï¼ˆå¯¹äºŽjavaé‡Œçš„å•åˆ—ï¼‰å®šä¹‰ä¸€ä¸ªç±»å’Œä¸€ä¸ªè¯¥ç±»çš„å˜é‡ ä¼´ç”Ÿå¯¹è±¡å¯ä»¥æŒæœ‰å·¥åŽ‚æ–¹æ³•å’Œå…¶ä»–ä¸Žè¿™ä¸ªç±»åŽ¿éª¨å¹²ï¼Œä½†åœ¨è°ƒç”¨æ—¶å¹¶ä¸ä¾èµ–ç±»å®žä¾‹çš„æ–¹æ³•ã€‚ æˆå‘˜å¯ä»¥é€šè¿‡ç±»åæ¥è®¿é—® å¯¹è±¡è¡¨è¾¾å¼ç”¨æ¥æ›¿ä»£javaä¸­çš„åŒ¿åå†…éƒ¨ç±» 12345678910111213//å¯¹è±¡å£°æ˜Žï¼šjavaä¸­çš„å•åˆ—æ¨¡å¼object Payroll &#123; val allEmployees = arrayListOf&lt;Person&gt;() fun calculateSalary() &#123; for(person in allEmployees) &#123; ... &#125; &#125;&#125;//è°ƒç”¨&gt;&gt;&gt; Payroll.allEmployees.add(Person(...))&gt;&gt;&gt; Payroll.calculateSalary() 1234567//åµŒå¥—ç±»å®žçŽ°Comparatordata class Person(val name: String) &#123; object NameComparator : Comparator&lt;Person&gt; &#123; override fun compare(p1: Person, p2: Person) : Int = p1.name.compareTo(p2.name) &#125;&#125; åœ¨Java ä¸­è°ƒç”¨Kotlinå¯¹è±¡ï¼Œå¯ä»¥é€šè¿‡è®¿é—®é™æ€çš„INSTANCEå­—æ®µ: 12/** java **/Person.NameComparator.INSTANCE.compare(p1, p2); ä¼´ç”Ÿå¯¹è±¡ï¼š å·¥åŽ‚æ–¹æ³•å’Œé™æ€æˆå‘˜çš„åœ°ç›˜ companion å¯ä»¥ç›´æŽ¥é€šè¿‡ç±»åæ¥è®¿é—®è¿™ä¸ªå¯¹è±¡çš„æ–¹æ³•å’Œå±žæ€§ï¼Œç±»ä¼¼javaçš„é™æ€æ–¹æ³•è°ƒç”¨ 12345678910class A &#123; companion object &#123; fun bar() &#123; println("Companion object called") &#125; &#125;&#125;&gt;&gt;&gt; A.bar()Companion object called ä¼´ç”Ÿå¯¹è±¡å¯ä»¥è®¿é—®ç±»ä¸­çš„privateæˆå‘˜ï¼ŒåŒ…æ‹¬privateæž„é€ æ–¹æ³•ï¼Œæ˜¯å®žçŽ°å·¥åŽ‚æ¨¡å¼çš„ç†æƒ³åœ°æ–¹ 1234567891011class User private constructor(val nickname: String) &#123;//ä¸»æž„é€ å‡½æ•°æ ‡è®°ä¸ºç§æœ‰ companion object &#123; //ä¼´ç”Ÿå¯¹è±¡ï¼Œç±»ä¼¼javaä¸­é™æ€å·¥åŽ‚æ–¹æ³•ï¼Œå¯ä»¥è®¿é—® privateå±žæ€§ fun newSubscribingUser(email: String) = User(email.substringBefore('@')) fun newFacebookUser(accountId: Int) = User(getFacebookName(accountId)) &#125;&#125; ä½œä¸ºæ™®é€šå¯¹è±¡ä½¿ç”¨çš„ä¼´ç”Ÿå¯¹è±¡ å¦‚æžœçœç•¥äº†ä¼´ç”Ÿå¯¹è±¡çš„åå­—ï¼Œé»˜è®¤çš„åå­—ä¸ºCompanion 12345678910//å£°æ˜Žä¸€ä¸ªå‘½åä¼´ç”Ÿå¯¹è±¡class Person(val name: String) &#123; companion object Loader &#123; fun fromJSON(jsonText: String): Person = ... &#125;&#125;// ä¸¤ç§è°ƒç”¨æ–¹å¼éƒ½å¯ä»¥&gt;&gt;&gt; person = Person.Loader.fromJSON("&#123;name: 'Dmity'&#125;")&gt;&gt;&gt; person = Person.fromJSON("&#123;name: 'Dmity'&#125;") ç±»çš„ä¼´ç”Ÿå¯¹è±¡è¢«ç¼–è¯‘ä¸ºä¸€ä¸ªå¸¸è§„å¯¹è±¡ï¼šç±»ä¸­çš„ä¸€ä¸ªå¼•ç”¨äº†å®ƒçš„å®žä¾‹çš„é™æ€å­—æ®µã€‚ 12/* Java */Person.Companion.fromJSON("...") ä¼´ç”Ÿå¯¹è±¡å®šä¹‰æ‰©å±•å‡½æ•° 12345678910111213//business logic moduleclass Person(val firstName: String, val lastName: String) &#123; companion object&#123; //å£°æ˜Žä¸€ä¸ªç©ºçš„ä¼´ç”Ÿå¯¹è±¡ &#125;&#125;//client/server communication module//å£°æ˜Žä¸€ä¸ªæ‰©å±•å‡½æ•°fun Person.Companion.fromJSON(json: String) : Person &#123; &#125;val p = Person.fromJSON(json) å¯¹è±¡è¡¨è¾¾å¼ï¼šjavaä¸­çš„åŒ¿åå†…éƒ¨ç±» 1234567891011121314151617window.addMouseListener( //å£°æ˜Žä¸€ä¸ªç»§æ‰¿MouseAdpterçš„åŒ¿åå†…éƒ¨ç±»ï¼Œå¹¶éžå•åˆ— object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent)&#123; //... &#125; override fun mouseEntered(e: MouseEvent) &#123; /... &#125; &#125; )//åˆ†é…åå­—ï¼Œå­˜å‚¨åˆ°ä¸€ä¸ªå˜é‡ä¸­val listener = object : MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123;...&#125; override fun mouseEntered(e: MouseEvent) &#123;...&#125;&#125; ä¸ŽJava åŒ¿åå†…éƒ¨ç±»åªèƒ½æ‰©å±•ä¸€ä¸ªç±»æˆ–å®žçŽ°ä¸€ä¸ªæŽ¥å£ä¸åŒï¼Œkotlinçš„åŒ¿åå¯¹è±¡å¯ä»¥å®žçŽ°å¤šä¸ªæŽ¥å£æˆ–è€…ä¸å®žçŽ°æŽ¥å£ã€‚è€Œä¸”è®¿é—®æ²¡æœ‰è¢«é™åˆ¶åœ¨finalå˜é‡ï¼Œè¿˜å¯ä»¥åœ¨å¯¹è±¡è¡¨è¾¾å¼ä¸­ä¿®æ”¹å˜é‡çš„å€¼ã€‚ 1234567891011fun countClicks(window: Window) &#123; //å£°æ˜Žå±€éƒ¨å˜é‡ var clickCount = 0 window.addMouseListener(object: MouseAdapter() &#123; override fun mouseClicked(e: MouseEvent) &#123; //æ›´æ–°å˜é‡çš„å€¼ clickCount++ &#125; &#125;)&#125; Lambda ç¼–ç¨‹ Lambdaè¡¨è¾¾å¼çš„è¯­æ³• 12&#123; x: Int, y: Int -&gt; x + y &#125; å‚æ•° å‡½æ•°ä½“ kotlinä¸­çš„lambdaè¡¨è¾¾å¼å§‹ç»ˆç”¨èŠ±æ‹¬å·åŒ…å›´ï¼Œç®­å¤´æŠŠå®žå‚åˆ—è¡¨å’Œå‡½æ•°ä½“éš”å¼€ 1234567891011121314151617181920212223&gt;&gt;&gt; val people = listOf(Person("Alice, 29"), Person("Bob", 31))&gt;&gt;&gt; println(people.maxBy &#123; it.age &#125;)Person(name=Bob, age=31)//å®Œæ•´çš„ä½¿ç”¨lambdapeople.maxBy(&#123; p: Person -&gt; p.age &#125;)//å½“lambdaè¡¨è¾¾å¼å¼å‡½æ•°è°ƒç”¨çš„æœ€åŽä¸€ä¸ªå®žå‚ï¼Œå®ƒå¯ä»¥æ”¾åˆ°æ‹¬å·å¤–é¢people.maxBy()&#123; p: Person -&gt; p.age &#125;//å½“lambdaæ˜¯å‡½æ•°çš„å”¯ä¸€ä¸€ä¸ªå‚æ•°æ˜¯ï¼Œï¼Œå¯ä»¥çœç•¥ç©ºæ‹¬å·people.maxBy&#123; p: Person -&gt; p.age &#125;//çœç•¥lambdaçš„å‚æ•°ç±»åž‹people.maxBy&#123; p -&gt; p.age &#125;//ä½¿ç”¨é»˜è®¤å‚æ•°åç§°itä»£æ›¿å‘½åå‚æ•°people.maxBy&#123; it.age &#125; //ä»…ä»…åœ¨å®žå‚æ²¡æœ‰æ˜¾å¼æŒ‡å®šæ—¶æ‰ä¼šé»˜è®¤ç”Ÿæˆit//lambdaçš„æœ€åŽä¸€ä¸ªè¡¨è¾¾å¼å°±æ˜¯lambdaçš„ç»“æžœ&gt;&gt;&gt; val sum = &#123; x: Int, y: Int -&gt; println("Computing the sum of $x and $y...") x + y &#125;&gt;&gt;&gt; println(sum(1, 2))Computing the sum of 1 and 2...3 å’Œ Java ä¸åŒï¼ŒKotlinä¸­å…è®¸åœ¨lambdaå†…éƒ¨è®¿é—®éžfinalå˜é‡ç”šè‡³ä¿®æ”¹å®ƒä»¬ï¼Œç§°ä¸ºè¿™äº›å˜é‡è¢«lambdaæ•æ‰ã€‚ Javaä¸­çš„lambdaåªå…è®¸æ•æ‰finalå˜é‡ï¼Œå¦‚æžœæƒ³æ•æ‰å¯å˜å˜é‡ï¼Œéœ€è¦åˆ›å»ºå…ƒç´ çš„finalæ•°ç»„ï¼Œå…¶ä¸­å­˜å‚¨å¯å˜å€¼ã€‚ kotlinå¯ä»¥æ•æ‰å¯å˜å˜é‡ï¼Œå®žçŽ°ç»†èŠ‚ï¼š è¯­è¨€å±‚é¢ç›¸å½“äºŽé»˜è®¤åˆ›å»ºäº†ä¸€ä¸ªåŒ…è£…ç±»çš„å®žä¾‹ï¼Œå…¶ä¸­å­˜å‚¨è¦æ”¹å˜çš„å€¼çš„å¼•ç”¨ã€‚ 123456//æ³¨æ„äº‹é¡¹: è™½ç„¶onClickså¯ä»¥ä¿®æ”¹clicksçš„å€¼ï¼Œä½†æ˜¯å‡½æ•°è¿”å›žå§‹ç»ˆæ˜¯0ï¼ŒonClicksæ˜¯åœ¨å‡½æ•°è¿”å›žåŽè°ƒç”¨çš„fun tryToCounteButtonClicks(button : Button) : Int &#123; var clicks = 0 button.onClicks&#123; clicks++ &#125; return clicks&#125; æˆå‘˜å¼•ç”¨ 12345678// ç±»::æˆå‘˜val getAge = Person::age//ç­‰åŒä¸Žval getAge = &#123;person: Person -&gt; person.age &#125;//è¿˜å¯ä»¥å¼•ç”¨æ‰©å±•å‡½æ•°fun Person.isAdult() = age &gt;= 21val predicate = Person::isAdult é›†åˆçš„å‡½æ•°å¼API åŸºç¡€ï¼šfilter å’Œmap 12345678910111213data class Person(val name: String, val age: Int)&gt;&gt;&gt; val people = listOf(Person("Alice", 29), Person("Bob",31))&gt;&gt;&gt; println(people.map &#123; it.name &#125;)[Alice, Bob]//ç­‰æ•ˆäºŽ&gt;&gt;&gt;people.map(Person:name)// è¿‡æ»¤åˆ†ç»„ä¸­å¹´é¾„æœ€å¤§çš„äººï¼Œ æ³¨æ„æ­¤å¤„ä¼šé‡å¤æ‰§è¡Œpeople.maxBy()people.filter&#123; it.age == people.maxBy(Person::age).age &#125;//ä¼˜åŒ–ï¼šåªè®¡ç®—ä¸€æ¬¡val maxAge = people.maxBy(Person::age)!!.agepeople.filter&#123; it.age == maxAge &#125; filterKeys å’Œ mapKeys è¿‡æ»¤å’Œå˜æ¢mapçš„é”®ï¼Œ filterValues å’Œ mapValues è¿‡æ»¤å’Œå˜æ¢å¯¹åº”çš„å€¼ 123val numbers = mapof(0 to &quot;Zero&quot;, 1 to &quot;one&quot;)&gt;&gt;&gt; println(numbers.mapValues&#123; it.value.toUpperCase() &#125;)&#123;0=ZERO, 1=ONE&#125; all any count å’Œ find ï¼šå¯¹é›†åˆåº”ç”¨åˆ¤æ–­å¼ 1234567891011121314151617val canBeInClub27 = &#123; p: Person -&gt; p.age &lt;= 27 &#125;&gt;&gt;&gt; val people = listof(Person("Alice", 27), Person("Bob", 31))// all æ‰€æœ‰å…ƒç´ éƒ½æ»¡è¶³åˆ¤æ–­å¼&gt;&gt; println(people.all(canBeInClub27))false// any è‡³å°‘å­˜åœ¨ä¸€ä¸ªå…ƒç´ éƒ½æ»¡è¶³åˆ¤æ–­å¼&gt;&gt;&gt; println(people.any(canBeInClub27))true// æœ‰å¤šå°‘ä¸ªæ»¡è¶³åˆ¤æ–­å¼&gt;&gt;&gt; println(people.count(canBeInClub27))1//æ‰¾åˆ°ä¸€ä¸ªæ»¡è¶³åˆ¤æ–­å¼çš„å…ƒç´ ï¼Œå¦‚æžœæœ‰å¤šä¸ªåŒ¹é…å°±è¿”å›žå…¶ä¸­çš„ç¬¬ä¸€ä¸ª,æ²¡æœ‰åŒ¹é…è¿”å›žnull&gt;&gt;&gt; println(people.find(canBeInClub27))Person(name=Alice, age=27)//ç­‰åŒäºŽ&gt;&gt; println(people.firstOrNull(canBeInClub27)) groupByï¼š æŠŠåˆ—è¡¨è½¬æ¢æˆåˆ†ç»„çš„map 12345678910//groupByçš„æ“ä½œç»“æžœå¼ä¸€ä¸ªmap&gt;&gt;&gt; val people = listof(Person("Alice", 31), Person("Bob", 29), Person("Carol", 31))&gt;&gt;&gt; println(people.groupBy&#123; it.age &#125;)//ç»“æžœç±»åž‹æ˜¯Map&lt;Int, List&lt;Person&gt;&gt;val list = listof("a", "ab", "b")&gt;&gt;&gt; println(list.groupBy(String::first))&#123;a=[a, ab], b=[b]&#125; flatMap å’Œ flattenï¼š å¤„ç†åµŒå¥—é›†åˆä¸­çš„å…ƒç´  12345678class Book(val title: String, val authors: List&lt;String&gt;)&gt;&gt;&gt; val books = listOf(Book("One", listOf("Jasper Fforde")), Book("Two", listOf("Terry Pratchett")), Book("Three", listOf("Terry Pratchett", "Neil Gaiman"))) &gt;&gt;&gt; println(books.flatMap&#123; it.authors &#125;.toSet())["Jasper Fforde","Terry Pratchett","Neil Gaiman"] æƒ°æ€§é›†åˆæ“ä½œï¼šåºåˆ— 12345// filter å’Œ mapéƒ½ä¼šè¿”å›žä¸€ä¸ªåˆ—è¡¨ï¼Œ åˆ›å»ºäº†ä¸´æ—¶ä¸­é—´å¯¹è±¡people.map(Person:name).filter&#123; it.startWith("A")&#125;//è½¬æˆåºåˆ—, ä¸ä¼šåˆ›å»ºä»»ä½•ç”¨äºŽå­˜å‚¨å…ƒç´ çš„ä¸­é—´é›†åˆpeople.asSequence().map(Person:name).filter&#123; it.startWith("A") &#125;.toList() Sequence æŽ¥å£é€‚ç”¨äºŽæ•°é‡å·¨å¤§çš„å…ƒç´ é›†åˆï¼Œ ç”¨ asSequenceæŠŠä»»æ„é›†åˆè½¬æˆåºåˆ—ï¼Œè°ƒç”¨toListæŠŠåºåˆ—è½¬æˆé›†åˆï¼Œæƒ°æ€§æ±‚å€¼çœåŽ»äº†ä¸ºä¸­é—´ç»“æžœé‡æ–°åˆ†é…çš„å·¨å¤§å¼€é”€ã€‚ æ‰§è¡Œåºåˆ—æ“ä½œï¼šä¸­é—´å’Œæœ«ç«¯æ“ä½œ åºåˆ—çš„ä¸­é—´æ“ä½œæ˜¯æƒ°æ€§çš„ï¼Œåªæœ‰æœ«ç«¯è¢«è°ƒç”¨çš„æ—¶å€™æ‰ä¼šèŽ·å–ç»“æžœ 1234567891011&gt;&gt;&gt; listOf(1, 2, 3, 4).asSequence() .map&#123; print("map($it) "; it * it)&#125; .filter&#123; print("filter($it) "); it % 2 == 0&#125;//ä¸Šé¢çš„ä»£ç ä¸ä¼šæœ‰ä»»ä½•è¾“å‡º&gt;&gt;&gt; listOf(1, 2, 3, 4).asSequence() .map&#123; print("map($it) "; it * it)&#125; .filter&#123; print("filter($it) "); it % 2 == 0&#125; .toList()map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16) åŠæ—©æ±‚å€¼å¯¹æ•´ä¸ªé›†åˆçš„æ‰€æœ‰å…ƒç´ ä¸Šæ‰§è¡Œæ¯ä¸ªæ“ä½œï¼›æƒ°æ€§æ±‚å€¼åˆ™é€ä¸ªå¤„ç†æ¯ä¸ªå…ƒç´  ä½¿ç”¨Javaçš„å‡½æ•°å¼æŽ¥å£ å‡½æ•°å¼æŽ¥å£ï¼šSAMæŽ¥å£ SAM ä»£è¡¨å•ä¸ªæŠ½è±¡æ–¹æ³•ï¼Œæ¯”å¦‚OnClickLister æŽ¥å£ï¼ŒRunableã€Callable æŽ¥å£ã€‚ æ¯ä¸ªlambdaè¡¨è¾¾å¼éƒ½ä¼šè¢«ç¼–è¯‘æˆä¸€ä¸ªåŒ¿åç±»ï¼Œä½†æ˜¯å†…è”å‡½æ•°é™¤å¤–ï¼ˆkotlinä¸­é›†åˆçš„æ‰©å±•æ–¹æ³•å¤§å¤šæ•°æ ‡è®°æˆäº†inlineï¼‰ã€‚ 1button.setOnClickListener&#123; view -&gt; ...&#125; SAMæž„é€ æ–¹æ³•ï¼šæ˜¾å¼åœ°æŠŠlambdaè½¬æ¢æˆå‡½æ•°æŽ¥å£ 123456789101112//ä½¿ç”¨SAMæž„é€ æ–¹æ³•æ¥é‡ç”¨listenerå®žä¾‹val listener = OnClickListener &#123; view -&gt; val text = when(view.id) &#123; R.id.button1 -&gt; "First button" R.id.button2 -&gt; "Second button" else -&gt; "Unkown button" &#125; toast(text) &#125;button1.setOnClickListener(listener)button2.setOnClickListener(listener) ä½¿ç”¨SAMæž„é€ æ–¹æ³•è¿™ç§lambda å†…éƒ¨æ²¡æœ‰ åŒ¿åå¯¹è±¡é‚£æ ·çš„thisï¼šæ²¡æœ‰åŠžæ³•å¼•ç”¨åˆ°lambdaè½¬æ¢æˆçš„åŒ¿åå®žä¾‹ã€‚ lamdaæ˜¯ä¸€ä¸ªä»£ç å—ï¼Œä¸æ˜¯ä¸€ä¸ªå¯¹è±¡ã€‚ é’ˆå¯¹äº‹ä»¶ç›‘å¬å™¨åœ¨å¤„ç†äº‹ä»¶æ˜¯è¿˜éœ€è¦å–æ¶ˆç›‘å¬ï¼Œé‚£ä¹ˆä¸èƒ½ç”¨ä»¥ä¸Šlambda ï¼Œè€Œè¦ä½¿ç”¨å®žçŽ°äº†æŽ¥å£çš„åŒ¿åå¯¹è±¡ã€‚ å¸¦æŽ¥å—è€…çš„lambdaï¼šâ€œwithâ€ å’Œ â€œapplyâ€ With å…è®¸è°ƒç”¨ä¸€ä¸ªå¯¹è±¡å¤šä¸ªæ–¹æ³•ï¼Œè€Œä¸éœ€è¦åå¤å†™å‡ºè¿™ä¸ªå¯¹è±¡å¼•ç”¨ 12345678//with å‡½æ•°, thisæŒ‡å‘æŽ¥å—è€…ï¼Œè¿”å›žlambdaæœ€åŽä¸€å¥çš„ç»“æžœfun alphabet() = with(StringBuilder()) &#123; for(letter in 'A'..'Z') &#123; append(letter) &#125; append("\n Now I know the alphabet!") toString()&#125; å¦‚æžœé‡åˆ°withå¯¹è±¡çš„æ–¹æ³•å’Œæ­£åœ¨ä½¿ç”¨withçš„ç±»ä¸­çš„æ–¹æ³•å†²çªï¼Œå‡è®¾alphabetæ˜¯ç±»OuterClassçš„ä¸€ä¸ªæ–¹æ³•ï¼Œå¦‚æžœæƒ³è°ƒç”¨å¤–éƒ¨ç±»çš„toStringæ–¹æ³•ï¼Œé‚£ä¹ˆè¿™æ ·å†™ï¼š this@OuterClass.toString() apply å‡½æ•°å¯ä»¥æ›¿ä»£å»ºé€ è€…æ¨¡å¼ï¼Œåˆå§‹åŒ–å¯¹è±¡ 1234567//apply è¿”å›žå¯¹è±¡æœ¬èº«fun alphabet = StringBuild().apply &#123; for(letter in 'A'..'Z') &#123; append(letter) &#125; append("\n Now I know the alphabet!")&#125;.toString() Kotlinçš„ç±»åž‹ç³»ç»Ÿå¯ç©ºç±»åž‹ kotlinçš„å¯ç©ºç±»åž‹æ£€æŸ¥å‘ç”Ÿåœ¨ç¼–è¯‘æœŸï¼Œè¿è¡Œæ—¶å¯ç©ºå’Œéžç©ºçš„å¯¹è±¡æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ã€‚kotlinçš„å¯ç©ºç±»åž‹å¹¶ä¸ä¼šåœ¨è¿è¡Œæ—¶å¸¦æ¥é¢å¤–çš„å¼€é”€ã€‚ å®‰å…¨è°ƒç”¨è¿ç®—ç¬¦ï¼šâ€œ ?. â€ 123456s?.toUpperCase()//ç­‰æ•ˆäºŽif( s!= null) s.toUpperCase() else null//å®‰å…¨è°ƒç”¨ç¬¦åªä¼šè°ƒç”¨éžç©ºå€¼çš„æ–¹æ³•foo?.bar()==&gt; foo != null--&gt; foo.bar() foo == null--&gt; null è¿žæŽ¥å¤šä¸ªå®‰å…¨è°ƒç”¨ 12345678910111213141516class Address(val streetAddress: String, val zipCode: Int, val city: String, val country: String)class Company(val name: String, val address: Address?)class Person(val name: String, val company: Company?)fun Person.countryName(): String &#123; val country = this.company?.address?.country return if(county != null) country else "Unknown"&#125;&gt;&gt;&gt; val person = Person("Dmitry", null)&gt;&gt;&gt; println(person.countryName())Unknown Elvisè¿ç®—ç¬¦ï¼š â€œ ?: â€ 12345foo ?: bar ==&gt; foo != null -&gt; foo foo == null -&gt; bar//ç»“åˆå®‰å…¨è°ƒç”¨ç¬¦ç®€åŒ–ä»£ç fun Person.countryName() = company?.address?.country ?: "unknown" ?:è¿ç®—ç¬¦å¯ä»¥ç»“åˆthrow å’Œreturn, æŠŠè¡¨è¾¾å¼å†™åœ¨Elvisè¿ç®—ç¬¦å³è¾¹è¿”å›žæˆ–æŠ›å‡ºå¼‚å¸¸ã€‚ å®‰å…¨è½¬æ¢ï¼š â€œ asï¼Ÿâ€ 12foo as? Type ==&gt; foo is Type -&gt; foo as Type foo !is Type -&gt; null ç»å¸¸æŠŠ å®‰å…¨è½¬æ¢å’ŒElvis è¿ç®—ç¬¦ç»“åˆä½¿ç”¨ã€‚æ¯”å¦‚å®žçŽ°equals æ–¹æ³• 123456789101112131415class Person(val firstName: String, val lastName: String) &#123; override fun equals(o: Any?): Boolean &#123; val otherPerson = o as? Person ?: return false; //å®‰å…¨è½¬æ¢åŽï¼Œå˜é‡è¢«æ™ºèƒ½çš„è½¬æ¢ä¸ºPersonç±»åž‹ return otherPeron.firstName == firstName &amp;&amp; otherPerson.lastName == lastName &#125;&#125;&gt;&gt;&gt; val p1 = Person("Dmitry", "Jemerov")&gt;&gt;&gt; val p2 = Person("Dmitry", "Jemerov")&gt;&gt;&gt; println( p1 == p2) // == è¿ç®—ç¬¦ä¼šè°ƒç”¨equalsæ–¹æ³•true&gt;&gt;&gt; println(p1.equals(42))false éžç©ºæ–­è¨€ï¼š â€œ !! â€ éžç©ºæ–­è¨€æŠŠä»»ä½•å€¼è½¬æ¢æˆéžç©ºç±»åž‹ï¼Œ å¦‚æžœå¯¹null å€¼åšéžç©ºæ–­è¨€ï¼Œåˆ™ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚ 1234567891011foo!! ==&gt; foo != null -&gt; foo foo == null -&gt; NullPointerException fun ignoreNulls(s: String?) &#123; val sNotNull: String = s!! println(sNotNull.length)&#125;&gt;&gt;&gt; ignoreNulls(null)Exception in thread &quot;main&quot; kotlin.KotlinNullPointerException at&lt;...&gt; ignoreNulls(07_NotnullAssertions.kt:2) ä½•æ—¶ä½¿ç”¨éžç©ºæ–­è¨€ï¼Ÿ å½“åœ¨ä¸€ä¸ªå‡½æ•°æ£€æŸ¥ä¸€ä¸ªå€¼æ˜¯å¦ä¸ºnullï¼Œè€Œåœ¨å¦ä¸€ä¸ªå‡½æ•°ä¸­ä½¿ç”¨è¿™ä¸ªå€¼æ—¶ï¼Œç¼–è¯‘å™¨æ— æ³•è¯†åˆ«è¿™ç§ç”¨æ³•æ˜¯å¦å®‰å…¨ã€‚ å¯ä»¥ä½¿ç”¨ !!é¿å…é‡å¤æ£€æŸ¥ã€‚ â€œ let â€ å‡½æ•° å’Œå®‰å…¨è°ƒç”¨ç¬¦ç»“åˆä½¿ç”¨ï¼Œæ–¹ä¾¿ä¼ é€’å¯ç©ºå‚æ•°ç»™éžç©ºå‚æ•°çš„å‡½æ•° 1234567891011 fun sendEmailTo(email: String) &#123;...&#125;//é»˜è®¤ä¸èƒ½æŠŠå¯ç©ºç±»åž‹çš„å€¼ä¼ ç»™éžç©ºå‚æ•°çš„å‡½æ•°&gt;&gt;&gt; val email:String? = ...&gt;&gt;&gt; sendEmail(email)ERROR: Type mismach: inferred type is String? but String was expected// å¿…é¡»æ˜¾ç¤ºæ£€æŸ¥ä¸ä¸ºnullif(email != null) sendEmailTo(email)//ä½¿ç”¨letemail?.let &#123; email -&gt; sendEmailTo(email) &#125;email?.let &#123; sendEmailTo(it) &#125; 123foo?.let &#123; ==&gt; foo != null -&gt; åœ¨lambdaå†…éƒ¨ it å°±æ˜¯éžç©ºçš„ ...it... foo == null -&gt; ä»€ä¹ˆéƒ½ä¸åš &#125; å»¶è¿Ÿåˆå§‹åŒ–å±žæ€§ 123456789101112131415161718class MyService &#123; fun performAction(): String = "foo"&#125;class MyTest &#123; //å£°æ˜Žä¸€ä¸ªä¸éœ€è¦åˆå§‹åŒ–çš„éžç©ºç±»åž‹å±žæ€§ private lateinit var myService: MyService @Before fun setUp() &#123; //åœ¨ä½¿ç”¨å‰åˆå§‹åŒ–ï¼Œéžæž„é€ å‡½æ•° myService = MyService() &#125; @Test fun testAction() &#123; //ä¸éœ€è¦nullæ£€æŸ¥ï¼Œç›´æŽ¥è®¿é—®å±žæ€§ Assert.assertEquals("foo", myService.performAction()) &#125;&#125; æ³¨æ„âš ï¸ï¼š å»¶è¿Ÿåˆå§‹åŒ–çš„å±žæ€§å¿…é¡»æ˜¯varï¼Œ å› ä¸ºéœ€è¦åœ¨æž„é€ å‡½æ•°å¤–ä¿®æ”¹å®ƒçš„å€¼ï¼Œè€Œvalå±žæ€§ä¼šè¢«ç¼–è¯‘æˆå¿…é¡»åœ¨æž„é€ æ–¹æ³•ä¸­åˆå§‹åŒ–çš„finalå­—æ®µã€‚ lateinit var ä¿®é¥°çš„å±žæ€§æ˜¯éžç©ºå±žæ€§ï¼Œä¸éœ€è¦åœ¨æž„é€ å‡½æ•°åˆå§‹åŒ–å®ƒï¼›å¦‚æžœåœ¨å±žæ€§åˆå§‹åŒ–ä¹‹å‰å°±è®¿é—®å®ƒï¼Œä¼šå¾—åˆ°å¼‚å¸¸&quot;lateinit property myService has not been initialized.&quot; å¯ç©ºæ€§çš„æ‰©å±• Java ä¸­ï¼Œthisæ°¸è¿œæ˜¯éžç©ºçš„ï¼Œå› ä¸ºå¼•ç”¨çš„æ˜¯å½“å‰ç±»çš„å®žä¾‹ã€‚ kotlinä¸­ï¼Œè¿™å¹¶ä¸æˆç«‹ï¼šåœ¨ä»»ä½•å¯ç©ºç±»åž‹çš„æ‰©å±•å‡½æ•°ä¸­ï¼Œthiså¯ä»¥ä¸ºnull 1234567891011121314fun verifyUserInput(input: String?) &#123; if(input.isNullOrBlank()) &#123; //è¿™é‡Œä¸éœ€è¦å®‰å…¨è°ƒç”¨ï¼Œ isNullOrBlankä¸ä¼šå¯¼è‡´ç©ºå¼‚å¸¸ println("Please fill in the required fields") &#125;&#125;&gt;&gt;&gt; verifyUserInput(" ")Please fill in the required fields&gt;&gt;&gt; verifyUserInput(null)Please fill in the required fields//å®šä¹‰å¯ç©ºå­—ç¬¦ä¸²çš„æ‰©å±•fun String?.isNullOrBlanck(): Boolean = this == null || this.isBlank() ç±»åž‹å‚æ•°çš„å¯ç©ºæ€§ Kotlin ä¸­æ‰€æœ‰çš„æ³›åž‹ç±»å’Œæ³›åž‹å‡½æ•°çš„ç±»åž‹å‚æ•°é»˜è®¤éƒ½æ˜¯å¯ç©ºçš„ã€‚ 1234567891011121314fun &lt;T&gt; printHashCode(t: T) &#123; println(t?.hashCode()) // t å¯èƒ½ä¸ºnullï¼Œæ‰€ä»¥å¿…é¡»ç”¨å®‰å…¨è°ƒç”¨&#125;&gt;&gt;&gt;printHashCode(null) //"T" è¢«æŽ¨å¯¼æˆç±»åž‹ "Anyï¼Ÿ"null//å¦‚æžœè¦æ˜¯ç±»åž‹å‚æ•°éžç©ºï¼Œå¿…é¡»æŒ‡å®šä¸€ä¸ªéžç©ºçš„ä¸Šç•Œfun &lt;T: Any&gt; printHashCode(t: T) &#123; println(t.hashCode()) //è¿™æ · â€œTâ€ å°±æ˜¯ä¸å¯ç©ºçš„&#125;&gt;&gt;&gt; printlnHashCode(null) //ç¼–è¯‘å¤±è´¥ï¼Œä¸èƒ½ä¼ é€’null&gt;&gt;&gt; printlnHashCode(42)42 å¯ç©ºæ€§å’ŒJava Javaçš„ç±»åž‹ç³»ç»Ÿä¸æ”¯æŒå¯ç©ºæ€§ï¼Œå¦‚ä½•æ··åˆä½¿ç”¨ï¼Ÿ 1234//æ ¹æ®Javaç±»åž‹æ³¨è§£ï¼Œåœ¨kotlinä¸­è¡¨ç¤ºä¸ºå¯ç©ºç±»åž‹å’Œéžç©ºç±»åž‹//-----java----- --kotlin--@Nullable + Type = Typeï¼Ÿ@NotNull + Type = Type å¹³å°ç±»åž‹ï¼š Javaç±»åž‹åœ¨kotlinä¸­è¡¨ç¤ºä¸ºå¹³å°ç±»åž‹ï¼Œæ—¢å¯ä»¥å½“ä½œå¯ç©ºç±»åž‹ï¼Œä¹Ÿå¯ä»¥å½“ä½œéžç©ºç±»åž‹ 123//Javaçš„å±žæ€§åŠå¯ä»¥è¢«å½“ä½œå¯ç©ºï¼Œä¹Ÿå¯ä»¥å½“ä½œéžç©ºç±»åž‹&gt;&gt;&gt; val s: String? = person.name&gt;&gt;&gt; val s: String = person.name å¤§éƒ¨åˆ†Java APIéƒ½æ²¡æœ‰å¯ç©ºæ€§æ³¨è§£ï¼Œä½¿ç”¨æ—¶è¦æžæ¸…æ¥šä»€ä¹ˆæ—¶å€™è¿”å›žnullï¼Œå¹¶ç»™å“ªäº›è°ƒç”¨åŠ ä¸Šç©ºæ£€æŸ¥ ç»§æ‰¿ 1234567891011121314151617181920/* Java */interface StringProcessor &#123; void process(String value)&#125;/* kotlin */class StringPrinter : StringProcessor &#123; override fun process(value: String) &#123; println(value) &#125;&#125;//orclass StringPrinter : StringProcessor &#123; override fun process(value: String?) &#123; println(value) &#125;&#125;//Kotlinä¸­ä¸¤ç§å®žçŽ°éƒ½å¯ä»¥æŽ¥å—ï¼Œä½†ä¸€å®šè¦æ¸…æ¥šå®ƒçš„å¯ç©ºæ€§//Kotlinç¼–è¯‘å™¨ä¼šä¸ºå£°æ˜Žçš„éžç©ºå‚æ•°ç”Ÿæˆæ–­è¨€ï¼Œå¦‚æžœjavaä»£ç ä¼ é€’ç»™è¿™ä¸ªå‚æ•°ä¸€ä¸ªnullå€¼ï¼Œå°†ä¼šå‡ºå‘æ–­è¨€ã€‚ åŸºæœ¬æ•°æ®ç±»åž‹å’Œå…¶ä»–åŸºæœ¬ç±»åž‹ åŸºæœ¬æ•°æ®ç±»åž‹ï¼šIntã€Booleanâ€¦ Kotlin å¹¶ä¸åŒºåˆ†åŸºæœ¬æ•°æ®ç±»åž‹int å’ŒåŒ…è£…ç±»åž‹ Integerï¼Œ æ°¸è¿œä½¿ç”¨Intã€‚ å¤§å¤šæ•°æƒ…å†µä¸‹Kotlinçš„Intç±»åž‹ä¼šè¢«ç¼–è¯‘æˆjavaçš„åŸºæœ¬æ•°æ®ç±»åž‹intï¼Œ ä½†æ˜¯æ³›åž‹ç±»å’Œé›†åˆçš„ç±»åž‹å‚æ•°ä¼šè¢«ç¼–è¯‘æˆjavaçš„åŒ…è£…ç±»åž‹ã€‚ å¯ç©ºçš„åŸºæœ¬æ•°æ®ç±»åž‹ï¼š Intï¼Ÿã€Boolean? â€¦ å› ä¸ºnullåªèƒ½è¢«å­˜å‚¨åœ¨Javaçš„å¼•ç”¨ç±»åž‹çš„å˜é‡ä¸­ï¼Œæ‰€ä»¥kotlinçš„å¯ç©ºåŸºæœ¬æ•°æ®ç±»åž‹ä¼šè¢«ç¼–è¯‘æˆjavaçš„åŒ…è£…ç±»åž‹ã€‚ 123456789data class Person &#123;val name: String, val age: Int? = null) &#123; fun isOlderThan(other: Person): Boolean? &#123; if(age == null || other.age == null) return null return age &gt; other.age &#125; &#125; æ•°å­—è½¬æ¢ Kotlin åŒºåˆ«äºŽJavaï¼Œå¹¶ä¸ä¼šè‡ªåŠ¨è½¬æ¢æ•°å­—ç±»åž‹ï¼Œå¿…é¡»æ˜¾å¼çš„è½¬æ¢ 12345val i = 1val l: Long = i &lt;==é”™è¯¯ï¼šç±»åž‹ä¸åŒ¹é…val i = 1val l: Long = i.toLong() &lt;== æ˜¾ç¤ºè½¬æ¢ åŸºæœ¬æ•°æ®ç±»åž‹å­—é¢å€¼ï¼Œ å¯ä»¥è‡ªåŠ¨è½¬æ¢ç±»åž‹ 12345123L ==&gt; Long0.12ã€ 2.0 ==&gt; Double12.3 ==&gt; Float0x12ac ã€ 0X12BD ==&gt; åå…­è¿›åˆ¶ ob0001 =&gt; äºŒè¿›åˆ¶å­—é¢å€¼ 123456fun foo(l: Long) = println(l)&gt;&gt;&gt; val b: Byte = 1&gt;&gt;&gt; val l = b + 1L //+ å¯ä»¥è¿›è¡Œå­—èŠ‚ç±»åž‹å’Œé•¿æ•´å½¢çš„è®¡ç®—&gt;&gt;&gt; foo(42) //ç¼–è¯‘å™¨è®¤ä¸º42æ˜¯ä¸€ä¸ªé•¿æ•´åž‹42 â€œAnyâ€ å’Œ â€œAnyï¼Ÿâ€ï¼šè·Ÿç±»åž‹ åœ¨kotlinä¸­Anyæ˜¯æ‰€æœ‰ç±»åž‹çš„è¶…ç±»åž‹ï¼ŒåŒ…æ‹¬åƒIntè¿™æ ·çš„åŸºæœ¬æ•°æ®ç±»åž‹ï¼Œç±»ä¼¼äºŽJavaä¸­çš„Objectã€‚ å¦‚æžœéœ€è¦æ”¯æŒnullçš„ä»»æ„ç±»åž‹ï¼Œåˆ™éœ€ä½¿ç”¨Anyï¼Ÿ 1val answer: Any = 42 &lt;== Anyæ˜¯å¼•ç”¨ç±»åž‹ï¼Œæ‰€ä»¥å€¼42ä¼šè¢«è£…ç®± Unitç±»åž‹ï¼šKotlinçš„ â€œvoidâ€ 12345678910interface Processor&lt;T&gt; &#123; fun process(): T&#125;class NoResultProcessor : Processor&lt;Unit&gt; &#123; override fun process() &#123; //è¿”å›žUnitï¼Œæ­¤å¤„çœç•¥äº†è¿”å›žç±»åž‹ //do stuff //ä¸éœ€è¦æ˜¾å¼returnï¼Œ ç¼–è¯‘å™¨éšå¼åŠ ä¸Šäº† return Unit &#125;&#125; Nothing ç±»åž‹ï¼š â€œè¿™ä¸ªå‡½æ•°æ°¸ä¸è¿”å›žâ€ 12345678fun fail(message: String) : Nothing &#123; throw IllegalStateException(message)&#125;&gt;&gt;&gt; fail("Error occured")//ç»“åˆElvisè¿ç®—ç¬¦æ¥åšå³è¾¹æ¡ä»¶æ£€æŸ¥val address = company.address ?: fail("No address")println(address.city) é›†åˆå’Œæ•°ç»„ å¯ç©ºæ€§å’Œé›†åˆ 1234567891011// åˆ—è¡¨ä¸­çš„å•ä¸ªå€¼æ˜¯å¯ç©ºçš„,éœ€è¦æ£€æŸ¥å…ƒç´ æ˜¯å¦ä¸ºnullList&lt;Int?&gt;// æ•´ä¸ªåˆ—è¡¨æ˜¯å¯ç©ºçš„List&lt;Int&gt;?fun addValidNumber(numbers: List&lt;Int?&gt; ) &#123; //validNumbersçš„ç±»åž‹æ˜¯List&lt;Int&gt; val validNumbers = numbers.filterNotNull() println("sum of valid numbers: $&#123;validNumbers.sum()&#125;") println("Invalid numbers: $&#123;numbsers.size - validNumbers.size&#125;")&#125; åªè¯»é›†åˆå’Œå¯å˜é›†åˆ 12345678910111213141516171819202122232425Collection &lt;--------- MultableCollection-size add()-iterator() remove()-contains() clear()//MutableColletion ç»§æ‰¿äº† Collection å¹¶å¢žåŠ äº†ä¿®æ”¹é›†åˆæ–¹æ³•//ä½¿ç”¨åªè¯»é›†åˆå’Œå¯å˜é›†åˆfun &lt;T&gt; copyElements(source: Collection&lt;T&gt;, target: MutableCollection&lt;T&gt; )&#123; for(item in source) &#123; target.add(item) //å‘å¯å˜é›†åˆæ·»åŠ å…ƒç´  &#125;&#125;&gt;&gt;&gt; val source: Colletion&lt;Int&gt; = arrayListOf(3, 5, 7)&gt;&gt;&gt; val target: MutableColletion&lt;Int&gt; = arrayListOf(1)&gt;&gt;&gt; copy(source, target)&gt;&gt;&gt; println(target)[1, 3, 5, 7]//ä¸èƒ½æŠŠåªè¯»ç»“åˆç±»åž‹å˜é‡ä½œä¸ºtargetå‚æ•°ç©¿ç»™å‡½æ•°&gt;&gt;&gt; val source: Colletion&lt;Int&gt; = arrayListOf(3, 5, 7)&gt;&gt;&gt; val target: Colletion&lt;Int&gt; = arrayListOf(1)&gt;&gt;&gt; copy(source, target)Error: Type mismatch: inferred type is Collection&lt;Int&gt; but MutableCollection&lt;Int&gt; was expected åªè¯»é›†åˆä¸ä¸€å®šæ˜¯ä¸å¯å˜çš„ï¼šå› ä¸ºä¸¤ä¸ªä¸åŒçš„å¼•ç”¨ï¼Œä¸€ä¸ªåªè¯»ï¼Œå¦ä¸€ä¸ªå¯å˜ï¼Œå®ƒä»¬å¯ä»¥æŒ‡å‘åŒä¸€ä¸ªé›†åˆå¯¹è±¡ åœ¨å¤šçº¿ç¨‹ä¸‹ï¼Œåªè¯»é›†åˆå¹¶ä¸æ€»æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œä»æœ‰å¯èƒ½å‘ç”ŸconcurrentModificationExceptionï¼Œå¹¶å‘ä¿®æ”¹é”™è¯¯ã€‚ Kotliné›†åˆæŽ¥å£å’Œ Javaé›†åˆæŽ¥å£ Javaé›†åˆæŽ¥å£åœ¨Kotlin ä¸­éƒ½æœ‰ä¸¤ç§ï¼Œåªè¯»å’Œå¯å˜ï¼› Iterableã€MuableIterableï¼›Collectionã€MutableCollectionï¼›Listã€MutableListï¼› Setã€MutableSetï¼› å¯å˜æŽ¥å£ç›´æŽ¥å¯¹åº”java.util åŒ…ä¸­çš„JavaæŽ¥å£ï¼Œåªè¯»ç‰ˆæœ¬åªæ˜¯ç¼ºå°‘äº†æ‰€æœ‰ä¿®æ”¹çš„æ–¹æ³•ï¼› é›†åˆåˆ›å»ºå‡½æ•° é›†åˆç±»åž‹ åªè¯» å¯å˜ List listOf mutableListOfã€arrayListOf Set setOf mutableSetOfã€hashSetOfã€linkedSetOfã€sortedSetOf Map mapOf mutableMapOfã€hashMapOfã€linkedMapOfã€sortedMapOf æ³¨æ„âš ï¸ï¼šJava å¹¶ä¸åŒºåˆ†åªè¯»è¿˜æ˜¯å¯å˜é›†åˆï¼Œå³ä½¿åœ¨kotlinä¸­æŠŠé›†åˆå£°æ˜Žä¸ºåªè¯»ï¼Œä»å¯ä»¥åœ¨Javaä¸­ä¿®æ”¹è¿™ä¸ªé›†åˆã€‚ ä½œä¸ºå¹³å°ç±»åž‹çš„é›†åˆ Kotlinæ²¡æœ‰å…³äºŽå¹³å°ç±»åž‹çš„å¯ç©ºæ€§ã€‚åŒæ ·ï¼ŒJavaä¸­å£°æ˜Žçš„é›†åˆç±»åž‹çš„å˜é‡è¢«Kotlin è§†ä¸ºå¹³å°ç±»åž‹ï¼Œå¯å˜æ€§æœªçŸ¥ã€‚ ðŸš©åœ¨ç»§æ‰¿Javaçš„æŽ¥å£æˆ–è€…é‡å†™æ–¹æ³•æ—¶ï¼Œkotlinéœ€è¦è€ƒè™‘é›†åˆç±»åž‹çš„å¯ç©ºæ€§å’Œå¯å˜æ€§ï¼š é›†åˆæ˜¯å¦å¯ç©ºï¼Ÿ é›†åˆçš„å…ƒç´ æ˜¯å¦å¯ç©ºï¼Ÿ ä½ çš„æ–¹æ³•ä¼šä¸ä¼šä¿®æ”¹é›†åˆï¼Ÿ æ‰€ä»¥Javaç±»åž‹çš„List&lt;String&gt; åœ¨koltinä¸­éœ€è¦ç»“åˆå®žé™…æƒ…å†µé€‰æ‹©List&lt;String&gt;? è¿˜æ˜¯MutableList&lt;String?&gt; å¯¹è±¡å’ŒåŸºæœ¬æ•°æ®ç±»åž‹çš„æ•°ç»„ 123456789101112131415161718192021fun main(args: Array&lt;String&gt;) &#123; for(i in args.indices) &#123; //ä½¿ç”¨æ‰©å±•å±žæ€§array.indices åœ¨ä¸‹æ ‡èŒƒå›´å†…è¿­ä»£ println("Argument $i is: $&#123;args[i]&#125;") &#125;&#125;//kotlin ä¸­åˆ›å»ºåŒ…è£…ç±»åž‹æ•°ç»„val letters0 : Array&lt;String&gt; = arrayOf("a", "b", "c")println(letters0.toList())val letters1 = arrayOfNulls&lt;String&gt;( 3)println(letters1.joinToString("") )val letters2 = Array&lt;String&gt;(26)&#123; i -&gt; ('a' + i).toString() &#125;println(letters2.joinToString("") )//å‘varargä¼ é€’é›†åˆval string = listOf("a" , "b", "c")println("%s/%s/%s".format(*strings.toTypeArray()))a/b/c Array&lt;Int&gt;æ˜¯åŒ…è£…ç±»åž‹, å¦‚æžœè¦é¿å…è£…ç®±ä½¿ç”¨åŸºæœ¬ç±»åž‹æ•°ç»„ï¼Œkoltinæä¾›äº†IntArrayã€ByteArrayã€CharArrayã€BooleanArray 123456789101112131415161718192021//Kotlin ä¸­åˆ›å»ºåŸºæœ¬ç±»åž‹æ•°ç»„val fiveZero = IntArray(5)println(fiveZero.toList())val fiveZero1 = intArrayOf(0,0,0,0,2)println(fiveZero1.toList())val fiveZero3 = IntArray(5) &#123;i -&gt; (i + 1) * ( i + 1)&#125;println(fiveZero3.toList())&gt;&gt;&gt;[0, 0, 0, 0, 0][0, 0, 0, 0, 2][1, 4, 9, 16, 25]//å¯¹æ•°ç»„ä½¿ç”¨forEachIndexedfun main(args: Array&lt;String&gt; )&#123; args.forEachIndexed &#123; index, element -&gt; println("Argument $index is: $element") &#125;&#125; è¿ç®—ç¬¦é‡è½½ä»¥åŠå…¶ä»–çº¦å®šé‡è½½ç®—æ•°è¿ç®—ç¬¦ 12345678910data class Point(val x: Int, val y: Int) &#123; operator fun plus(other: Point) : Point &#123; return Point(x + other.x, y + other.y) &#125;&#125;&gt;&gt;&gt; val p1 = Point(10, 20)&gt;&gt;&gt; val p2 = Point(30, 40)&gt;&gt;&gt; println(p1 + p2)Point(x=40, y=60) è¡¨è¾¾å¼ å‡½æ•°å a * b times a / b div a % b mod a + b plus a- b minus Kotlin æ²¡æœ‰ä¸ºæ ‡å‡†æ•°å­—ç±»åž‹å®šä¹‰ä»»ä½•ä½è¿ç®—ç¬¦ï¼Œä½†æä¾›äº†æ‰§è¡Œä½è¿ç®—çš„å‡½æ•°åˆ—è¡¨ 123456789101112/*** shl å¸¦ç¬¦å·å·¦ç§»* shr å¸¦ç¬¦å·å³ç§»* ushr æ— ç¬¦å·å³ç§»åŠ¨* and æŒ‰ä½ä¸Ž* or æŒ‰ä½æˆ–* xor æŒ‰ä½å¼‚æˆ–* inv æŒ‰ä½å–å**/&gt;&gt;&gt; println( 0x0F and 0xF0)0 é‡è½½å¤åˆè¿ç®—ç¬¦å· 12345678operator fun &lt;T&gt; MultableCollection&lt;T&gt;.plusAssign(element : T) &#123; this.add(element)&#125;&gt;&gt;&gt; val numbers = ArrayList&lt;Int&gt;()&gt;&gt;&gt; numbers += 42&gt;&gt;&gt; println(numbers[0])42 é‡è½½ä¸€å…ƒè¿ç®—ç¬¦ è¡¨è¾¾å¼ å‡½æ•°å +a unaryPlus -a unaryMinus !a not ++a, a++ inc â€“a,aâ€“ dec 123456operator fun BigDecimal.inc() = this + BigDecimal.ONE&gt;&gt;&gt; val bd = BigDecimal.ZERO&gt;&gt;&gt; println(bd++)0&gt;&gt;&gt; println(++bd)2 é‡è½½æ¯”è¾ƒè¿ç®—ç¬¦ ç­‰å·å…ƒç®—ç¬¦ï¼š â€œequalsâ€ a == b =====&gt; a?.equals(b) ?: (b == null) 1234567class Point(val x: Int, val y: Int) &#123; override fun equals(obj: Any?): Boolean &#123; if(obj === this) return true //æ’ç­‰è¿ç®—ç¬¦æ£€æŸ¥å‚æ•°ï¼Œç­‰åŒäºŽjavaä¸­çš„== if(obj !is Point) return false return obj.x == x &amp;&amp; obj.y == y &#125;&#125; æŽ’åºè¿ç®—ç¬¦ï¼š compareTo a &gt;= b =&gt; a.compareTo(b) &gt;= 0 12345678class Person ( val firstName : String, val lastName: String ) : Comparable&lt;Person&gt; &#123; override fun compareTo(other : Person): Int &#123; return compareValuesBy(this, other, Person::lastName, Person::firstName) &#125; &#125; é›†åˆä¸ŽåŒºé—´çš„çº¦å®š é€šè¿‡ä¸‹è¡¨æ¥è®¿é—®å…ƒç´ ï¼š â€œgetâ€ å’Œ â€œsetâ€ ä½¿ç”¨ä¸‹æ ‡è¿ç®—ç¬¦è¯»å–å…ƒç´ ä¼šè¢«è½¬æ¢get æˆ– set è¿ç®—ç¬¦çš„æ–¹æ³•è°ƒç”¨ x[a,b] ==&gt; x.get(a, b) x[a,b] = c ==&gt; x.set(a, b, c) 1234567891011121314151617181920212223242526272829operator fun Point.get(index: Int): Int &#123; return when(index) &#123; 0 -&gt; x 1 -&gt; y else -&gt; throw IndexOutOfBoundsException("Invalid coordinate $index") &#125; &#125;&gt;&gt;&gt; val p = Point(10, 20)&gt;&gt;&gt; println(p[1])20data class MultablePoint(var x: Int, var y: Int) &#123; operator fun MutablePoint.set(index: Int, value: Int) &#123; when(index) &#123; 0 -&gt; x = value 1 -&gt; y = value else -&gt; throw IndexOutOfBoundsException("Invalid $index") &#125; &#125;&#125;&gt;&gt;&gt; val p = Mutable(10, 20)&gt;&gt;&gt; p[1] = 42&gt;&gt;&gt; println(p)MutablePoint(x=10, y=42)]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ANRæ—¥å¿—åˆ†æžå…¨é¢è§£æž]]></title>
    <url>%2F2021%2F06%2F21%2FANR%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[å¹²è´§ï¼šANRæ—¥å¿—åˆ†æžå…¨é¢è§£æžä¸€ã€æ¦‚è¿°è§£å†³ANRä¸€ç›´æ˜¯Android å¼€å‘è€…éœ€è¦æŽŒæ¡çš„é‡è¦æŠ€å·§ï¼Œä¸€èˆ¬ä»Žä¸‰ä¸ªæ–¹é¢ç€æ‰‹ã€‚ å¼€å‘é˜¶æ®µï¼šé€šè¿‡å·¥å…·æ£€æŸ¥å„ä¸ªæ–¹æ³•çš„è€—æ—¶ï¼Œå¡é¡¿æƒ…å†µï¼Œå‘çŽ°ä¸€å¤„ä¿®æ”¹ä¸€å¤„ã€‚ çº¿ä¸Šé˜¶æ®µï¼šè¿™ä¸ªé˜¶æ®µä¸»è¦ä¾é ç›‘æŽ§å·¥å…·å‘çŽ°ANRå¹¶ä¸ŠæŠ¥ï¼Œæ¯”å¦‚matrixã€‚ åˆ†æžé˜¶æ®µï¼šå¦‚æžœçº¿ä¸Šç”¨æˆ·å‘ç”ŸANRï¼Œå¹¶ä¸”ä½ èŽ·å–äº†ä¸€ä»½æ—¥å¿—ï¼Œè¿™å°±æ¶‰åŠäº†æœ¬æ–‡è¦åˆ†äº«çš„å†…å®¹â€”â€”ANRæ—¥å¿—åˆ†æžæŠ€å·§ã€‚ äºŒã€ANRäº§ç”Ÿæœºåˆ¶ç½‘ä¸Šé€šä¿—çš„ä¸€æ®µé¢è¯•ç­”é¢˜ ANRâ€”â€”åº”ç”¨æ— å“åº”ï¼ŒActivityæ˜¯5ç§’ï¼ŒBroadCastReceiveræ˜¯10ç§’ï¼ŒServiceæ˜¯20ç§’ã€‚ è¿™å¥è¯è¯´çš„å¾ˆç¬¼ç»Ÿï¼Œè¦æƒ³æ·±å…¥åˆ†æžå®šä½ANRï¼Œéœ€è¦çŸ¥é“æ›´å¤šçŸ¥è¯†ç‚¹ï¼Œä¸€èˆ¬æ¥è¯´ï¼ŒANRæŒ‰äº§ç”Ÿæœºåˆ¶ï¼Œåˆ†ä¸º4ç±»ï¼š 2.1 è¾“å…¥äº‹ä»¶è¶…æ—¶(5s)InputEvent Timeout 123456a.InputDispatcherå‘é€keyäº‹ä»¶ç»™ å¯¹åº”çš„è¿›ç¨‹çš„ Focused Window ï¼Œå¯¹åº”çš„windowä¸å­˜åœ¨ã€å¤„äºŽæš‚åœæ€ã€æˆ–é€šé“(input channel)å æ»¡ã€é€šé“æœªæ³¨å†Œã€é€šé“å¼‚å¸¸ã€æˆ–5så†…æ²¡æœ‰å¤„ç†å®Œä¸€ä¸ªäº‹ä»¶ï¼Œå°±ä¼šå‘ç”ŸANRb.InputDispatcherå‘é€MotionEventäº‹ä»¶æœ‰ä¸ªä¾‹å¤–ä¹‹å¤„ï¼šå½“å¯¹åº”Touched Windowçš„ input waitQueueä¸­æœ‰è¶…è¿‡0.5sçš„äº‹ä»¶ï¼ŒinputDispatcherä¼šæš‚åœè¯¥äº‹ä»¶ï¼Œå¹¶ç­‰å¾…5sï¼Œå¦‚æžœä»æ—§æ²¡æœ‰æ”¶åˆ°windowçš„â€˜finishâ€™äº‹ä»¶ï¼Œåˆ™è§¦å‘ANRc.ä¸‹ä¸€ä¸ªäº‹ä»¶åˆ°è¾¾ï¼Œå‘çŽ°æœ‰ä¸€ä¸ªè¶…æ—¶äº‹ä»¶æ‰ä¼šè§¦å‘ANRå¤åˆ¶ä»£ç  2.2 å¹¿æ’­ç±»åž‹è¶…æ—¶ï¼ˆå‰å°15sï¼ŒåŽå°60sï¼‰BroadcastReceiver Timeout 12345678910a.é™æ€æ³¨å†Œçš„å¹¿æ’­å’Œæœ‰åºå¹¿æ’­ä¼šANRï¼ŒåŠ¨æ€æ³¨å†Œçš„éžæœ‰åºå¹¿æ’­å¹¶ä¸ä¼šANRb.å¹¿æ’­å‘é€æ—¶ï¼Œä¼šåˆ¤æ–­è¯¥è¿›ç¨‹æ˜¯å¦å­˜åœ¨ï¼Œä¸å­˜åœ¨åˆ™åˆ›å»ºï¼Œåˆ›å»ºè¿›ç¨‹çš„è€—æ—¶ä¹Ÿç®—åœ¨è¶…æ—¶æ—¶é—´é‡Œc.åªæœ‰å½“è¿›ç¨‹å­˜åœ¨å‰å°æ˜¾ç¤ºçš„Activityæ‰ä¼šå¼¹å‡ºANRå¯¹è¯æ¡†ï¼Œå¦åˆ™ä¼šç›´æŽ¥æ€æŽ‰å½“å‰è¿›ç¨‹d.å½“onReceiveæ‰§è¡Œè¶…è¿‡é˜ˆå€¼ï¼ˆå‰å°15sï¼ŒåŽå°60sï¼‰ï¼Œå°†äº§ç”ŸANRe.å¦‚ä½•å‘é€å‰å°å¹¿æ’­ï¼šIntent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND)å¤åˆ¶ä»£ç  2.3 æœåŠ¡è¶…æ—¶ï¼ˆå‰å°20sï¼ŒåŽå°200sï¼‰Service Timeout 123456789a.Serviceçš„ä»¥ä¸‹æ–¹æ³•éƒ½ä¼šè§¦å‘ANRï¼šonCreate(),onStartCommand(), onStart(), onBind(), onRebind(), onTaskRemoved(), onUnbind(),onDestroy().b.å‰å°Serviceè¶…æ—¶æ—¶é—´ä¸º20sï¼ŒåŽå°Serviceè¶…æ—¶æ—¶é—´ä¸º200sc.å¦‚ä½•åŒºåˆ†å‰å°ã€åŽå°æ‰§è¡Œâ€”â€”â€”â€”å½“å‰APPå¤„äºŽç”¨æˆ·æ€ï¼Œæ­¤æ—¶æ‰§è¡Œçš„Serviceåˆ™ä¸ºå‰å°æ‰§è¡Œã€‚d.ç”¨æˆ·æ€ï¼šæœ‰å‰å°activityã€æœ‰å‰å°å¹¿æ’­åœ¨æ‰§è¡Œã€æœ‰foreground serviceæ‰§è¡Œå¤åˆ¶ä»£ç  2.4 ContentProvider ç±»åž‹12345a.ContentProvideråˆ›å»ºå‘å¸ƒè¶…æ—¶å¹¶ä¸ä¼šANRb.ä½¿ç”¨ContentProviderclientæ¥è®¿é—®ContentProverderå¯ä»¥è‡ªä¸»é€‰æ‹©è§¦å‘ANRï¼Œè¶…æ—¶æ—¶é—´è‡ªå·±å®šclient.setDetectNotResponding(PROVIDER_ANR_TIMEOUT);å¤åˆ¶ä»£ç  psï¼šActivityç”Ÿå‘½å‘¨æœŸè¶…æ—¶ä¼šä¸ä¼šANRï¼Ÿâ€”â€”ç»æµ‹è¯•å¹¶ä¸ä¼šã€‚ 123456override fun onCreate(savedInstanceState: Bundle?) &#123; Thread.sleep(60000) super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125;å¤åˆ¶ä»£ç  ä¸‰ã€å¯¼è‡´ANRçš„åŽŸå› å¾ˆå¤šå¼€å‘è€…è®¤ä¸ºï¼Œé‚£å°±æ˜¯è€—æ—¶æ“ä½œå¯¼è‡´ANRï¼Œå…¨éƒ¨æ˜¯appåº”ç”¨å±‚çš„é—®é¢˜ã€‚å®žé™…ä¸Šï¼Œçº¿ä¸ŠçŽ¯å¢ƒå¤§éƒ¨åˆ†ANRç”±ç³»ç»ŸåŽŸå› å¯¼è‡´ã€‚ 3.1 åº”ç”¨å±‚å¯¼è‡´ANRï¼ˆè€—æ—¶æ“ä½œï¼‰123456a. å‡½æ•°é˜»å¡žï¼šå¦‚æ­»å¾ªçŽ¯ã€ä¸»çº¿ç¨‹IOã€å¤„ç†å¤§æ•°æ®b. é”å‡ºé”™ï¼šä¸»çº¿ç¨‹ç­‰å¾…å­çº¿ç¨‹çš„é”c. å†…å­˜ç´§å¼ ï¼šç³»ç»Ÿåˆ†é…ç»™ä¸€ä¸ªåº”ç”¨çš„å†…å­˜æ˜¯æœ‰ä¸Šé™çš„ï¼Œé•¿æœŸå¤„äºŽå†…å­˜ç´§å¼ ï¼Œä¼šå¯¼è‡´é¢‘ç¹å†…å­˜äº¤æ¢ï¼Œè¿›è€Œå¯¼è‡´åº”ç”¨çš„ä¸€äº›æ“ä½œè¶…æ—¶å¤åˆ¶ä»£ç  3.2 ç³»ç»Ÿå¯¼è‡´ANR123456a. CPUè¢«æŠ¢å ï¼šä¸€èˆ¬æ¥è¯´ï¼Œå‰å°åœ¨çŽ©æ¸¸æˆï¼Œå¯èƒ½ä¼šå¯¼è‡´ä½ çš„åŽå°å¹¿æ’­è¢«æŠ¢å CPUb. ç³»ç»ŸæœåŠ¡æ— æ³•åŠæ—¶å“åº”ï¼šæ¯”å¦‚èŽ·å–ç³»ç»Ÿè”ç³»äººç­‰ï¼Œç³»ç»Ÿçš„æœåŠ¡éƒ½æ˜¯Binderæœºåˆ¶ï¼ŒæœåŠ¡èƒ½åŠ›ä¹Ÿæ˜¯æœ‰é™çš„ï¼Œæœ‰å¯èƒ½ç³»ç»ŸæœåŠ¡é•¿æ—¶é—´ä¸å“åº”å¯¼è‡´ANRc. å…¶ä»–åº”ç”¨å ç”¨çš„å¤§é‡å†…å­˜å¤åˆ¶ä»£ç  å››ã€åˆ†æžæ—¥å¿—å‘ç”ŸANRçš„æ—¶å€™ï¼Œç³»ç»Ÿä¼šäº§ç”Ÿä¸€ä»½anræ—¥å¿—æ–‡ä»¶ï¼ˆæ‰‹æœºçš„/data/anr ç›®å½•ä¸‹ï¼Œæ–‡ä»¶åç§°å¯èƒ½å„åŽ‚å•†ä¸ä¸€æ ·ï¼Œä¸šå†…å¤§å¤šç§°å‘¼ä¸ºtraceæ–‡ä»¶ï¼‰ï¼Œå†…å«å¦‚ä¸‹å‡ é¡¹é‡è¦ä¿¡æ¯ã€‚ åŽä¸ºæ‰‹æœºå¯ä»¥å¯¼å‡ºAnråˆ†æžæ—¥å¿—å‘½ä»¤ï¼š adb bugreport 4.1 CPU è´Ÿè½½1234567Load: 2.62 / 2.55 / 2.25CPU usage from 0ms to 1987ms later (2020-03-10 08:31:55.169 to 2020-03-10 08:32:17.156): 41% 2080/system_server: 28% user + 12% kernel / faults: 76445 minor 180 major 26% 9378/com.xiaomi.store: 20% user + 6.8% kernel / faults: 68408 minor 68 major........çœç•¥Nè¡Œ.....66% TOTAL: 20% user + 15% kernel + 28% iowait + 0.7% irq + 0.7% softirqå¤åˆ¶ä»£ç  å¦‚ä¸Šæ‰€ç¤ºï¼š ç¬¬ä¸€è¡Œï¼š1ã€5ã€15 åˆ†é’Ÿå†…æ­£åœ¨ä½¿ç”¨å’Œç­‰å¾…ä½¿ç”¨CPU çš„æ´»åŠ¨è¿›ç¨‹çš„å¹³å‡æ•° ç¬¬äºŒè¡Œï¼šè¡¨æ˜Žè´Ÿè½½ä¿¡æ¯æŠ“å–åœ¨ANRå‘ç”Ÿä¹‹åŽçš„0~1987msã€‚åŒæ—¶ä¹ŸæŒ‡æ˜Žäº†ANRçš„æ—¶é—´ç‚¹ï¼š2020-03-10 08:31:55.169 ä¸­é—´éƒ¨åˆ†ï¼šå„ä¸ªè¿›ç¨‹å ç”¨çš„CPUçš„è¯¦ç»†æƒ…å†µ æœ€åŽä¸€è¡Œï¼šå„ä¸ªè¿›ç¨‹åˆè®¡å ç”¨çš„CPUä¿¡æ¯ã€‚ åè¯è§£é‡Šï¼š 12345678a. user:ç”¨æˆ·æ€,kernel:å†…æ ¸æ€b. faults:å†…å­˜ç¼ºé¡µï¼Œminorâ€”â€”è½»å¾®çš„ï¼Œmajorâ€”â€”é‡åº¦ï¼Œéœ€è¦ä»Žç£ç›˜æ‹¿æ•°æ®c. iowait:IOä½¿ç”¨ï¼ˆç­‰å¾…ï¼‰å æ¯”d. irq:ç¡¬ä¸­æ–­ï¼Œsoftirq:è½¯ä¸­æ–­å¤åˆ¶ä»£ç  æ³¨æ„ï¼š iowaitå æ¯”å¾ˆé«˜ï¼Œæ„å‘³ç€æœ‰å¾ˆå¤§å¯èƒ½ï¼Œæ˜¯ioè€—æ—¶å¯¼è‡´ANRï¼Œå…·ä½“è¿›ä¸€æ­¥æŸ¥çœ‹æœ‰æ²¡æœ‰è¿›ç¨‹faults majoræ¯”è¾ƒå¤šã€‚ å•è¿›ç¨‹CPUçš„è´Ÿè½½å¹¶ä¸æ˜¯ä»¥100%ä¸ºä¸Šé™ï¼Œè€Œæ˜¯æœ‰å‡ ä¸ªæ ¸ï¼Œå°±æœ‰ç™¾åˆ†ä¹‹å‡ ç™¾ï¼Œå¦‚4æ ¸ä¸Šé™ä¸º400%ã€‚ 4.2 å†…å­˜ä¿¡æ¯12345678910111213141516Total number of allocations 476778 è¿›ç¨‹åˆ›å»ºåˆ°çŽ°åœ¨ä¸€å…±åˆ›å»ºäº†å¤šå°‘å¯¹è±¡Total bytes allocated 52MB è¿›ç¨‹åˆ›å»ºåˆ°çŽ°åœ¨ä¸€å…±ç”³è¯·äº†å¤šå°‘å†…å­˜Total bytes freed 52MB è¿›ç¨‹åˆ›å»ºåˆ°çŽ°åœ¨ä¸€å…±é‡Šæ”¾äº†å¤šå°‘å†…å­˜Free memory 777KB ä¸æ‰©å±•å †çš„æƒ…å†µä¸‹å¯ç”¨çš„å†…å­˜Free memory until GC 777KB GCå‰çš„å¯ç”¨å†…å­˜Free memory until OOME 383MB OOMä¹‹å‰çš„å¯ç”¨å†…å­˜Total memory å½“å‰æ€»å†…å­˜ï¼ˆå·²ç”¨+å¯ç”¨ï¼‰Max memory 384MB è¿›ç¨‹æœ€å¤šèƒ½ç”³è¯·çš„å†…å­˜å¤åˆ¶ä»£ç  ä»Žå«ä¹‰å¯ä»¥å¾—å‡ºç»“è®ºï¼šFree memory until OOME çš„å€¼å¾ˆå°çš„æ—¶å€™ï¼Œå·²ç»å¤„äºŽå†…å­˜ç´§å¼ çŠ¶æ€ã€‚åº”ç”¨å¯èƒ½æ˜¯å ç”¨äº†è¿‡å¤šå†…å­˜ã€‚ å¦å¤–ï¼Œé™¤äº†traceæ–‡ä»¶ä¸­æœ‰å†…å­˜ä¿¡æ¯ï¼Œæ™®é€šçš„eventlogæ—¥å¿—ä¸­ï¼Œä¹Ÿæœ‰å†…å­˜ä¿¡æ¯ï¼ˆä¸ä¸€å®šæ‰“å°ï¼‰ 1204-02 22:00:08.195 1531 1544 I am_meminfo: [350937088,41086976,492830720,427937792,291887104]å¤åˆ¶ä»£ç  ä»¥ä¸Šå››ä¸ªå€¼åˆ†åˆ«æŒ‡çš„æ˜¯ï¼š Cached Free, Zram, Kernel,Native Cached+Freeçš„å†…å­˜ä»£è¡¨ç€å½“å‰æ•´ä¸ªæ‰‹æœºçš„å¯ç”¨å†…å­˜ï¼Œå¦‚æžœå€¼å¾ˆå°ï¼Œæ„å‘³ç€å¤„äºŽå†…å­˜ç´§å¼ çŠ¶æ€ã€‚ä¸€èˆ¬ä½Žå†…å­˜çš„åˆ¤å®šé˜ˆå€¼ä¸ºï¼š4G å†…å­˜æ‰‹æœºä»¥ä¸‹é˜€å€¼ï¼š350MBï¼Œä»¥ä¸Šé˜€å€¼åˆ™ä¸ºï¼š450MB ps:å¦‚æžœANRæ—¶é—´ç‚¹å‰åŽï¼Œæ—¥å¿—é‡Œæœ‰æ‰“å°onTrimMemoryï¼Œä¹Ÿå¯ä»¥ä½œä¸ºå†…å­˜ç´§å¼ çš„ä¸€ä¸ªå‚è€ƒåˆ¤æ–­ 4.3 å †æ ˆæ¶ˆæ¯å †æ ˆä¿¡æ¯æ˜¯æœ€é‡è¦çš„ä¸€ä¸ªä¿¡æ¯ï¼Œå±•ç¤ºäº†ANRå‘ç”Ÿçš„è¿›ç¨‹å½“å‰æ‰€æœ‰çº¿ç¨‹çš„çŠ¶æ€ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041suspend all histogram: Sum: 2.834s 99% C.I. 5.738us-7145.919us Avg: 607.155us Max: 41543usDALVIK THREADS (248):&quot;main&quot; prio=5 tid=1 Native | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x74b17080 self=0x7bb7a14c00 | sysTid=2080 nice=-2 cgrp=default sched=0/0 handle=0x7c3e82b548 | state=S schedstat=( 757205342094 583547320723 2145008 ) utm=52002 stm=23718 core=5 HZ=100 | stack=0x7fdc995000-0x7fdc997000 stackSize=8MB | held mutexes= kernel: __switch_to+0xb0/0xbc kernel: SyS_epoll_wait+0x288/0x364 kernel: SyS_epoll_pwait+0xb0/0x124 kernel: cpu_switch_to+0x38c/0x2258 native: #00 pc 000000000007cd8c /system/lib64/libc.so (__epoll_pwait+8) native: #01 pc 0000000000014d48 /system/lib64/libutils.so (android::Looper::pollInner(int)+148) native: #02 pc 0000000000014c18 /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+60) native: #03 pc 0000000000127474 /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44) at android.os.MessageQueue.nativePollOnce(Native method) at android.os.MessageQueue.next(MessageQueue.java:330) at android.os.Looper.loop(Looper.java:169) at com.android.server.SystemServer.run(SystemServer.java:508) at com.android.server.SystemServer.main(SystemServer.java:340) at java.lang.reflect.Method.invoke(Native method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:536) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:856) ........çœç•¥Nè¡Œ..... &quot;OkHttp ConnectionPool&quot; daemon prio=5 tid=251 TimedWaiting | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x13daea90 self=0x7bad32b400 | sysTid=29998 nice=0 cgrp=default sched=0/0 handle=0x7b7d2614f0 | state=S schedstat=( 951407 137448 11 ) utm=0 stm=0 core=3 HZ=100 | stack=0x7b7d15e000-0x7b7d160000 stackSize=1041KB | held mutexes= at java.lang.Object.wait(Native method) - waiting on &lt;0x05e5732e&gt; (a com.android.okhttp.ConnectionPool) at com.android.okhttp.ConnectionPool$1.run(ConnectionPool.java:103) - locked &lt;0x05e5732e&gt; (a com.android.okhttp.ConnectionPool) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641) at java.lang.Thread.run(Thread.java:764)å¤åˆ¶ä»£ç  å¦‚ä¸Šæ—¥å¿—æ‰€ç¤ºï¼Œæœ¬æ–‡æˆªå›¾äº†ä¸¤ä¸ªçº¿ç¨‹ä¿¡æ¯ï¼Œä¸€ä¸ªæ˜¯ä¸»çº¿ç¨‹mainï¼Œå®ƒçš„çŠ¶æ€æ˜¯nativeã€‚ å¦ä¸€ä¸ªæ˜¯OkHttp ConnectionPoolï¼Œå®ƒçš„çŠ¶æ€æ˜¯TimeWaitingã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œæ•™ç§‘ä¹¦ä¸Šè¯´çº¿ç¨‹çŠ¶æ€æœ‰5ç§ï¼šæ–°å»ºã€å°±ç»ªã€æ‰§è¡Œã€é˜»å¡žã€æ­»äº¡ã€‚è€ŒJavaä¸­çš„çº¿ç¨‹çŠ¶æ€æœ‰6ç§ï¼Œ6ç§çŠ¶æ€éƒ½å®šä¹‰åœ¨ï¼šjava.lang.Thread.Stateä¸­ é—®é¢˜æ¥äº†ï¼Œä¸Šè¿°mainçº¿ç¨‹çš„nativeæ˜¯ä»€ä¹ˆçŠ¶æ€ï¼Œå“ªæ¥çš„ï¼Ÿå…¶å®žtraceæ–‡ä»¶ä¸­çš„çŠ¶æ€æ˜¯æ˜¯CPPä»£ç ä¸­å®šä¹‰çš„çŠ¶æ€ï¼Œä¸‹é¢æ˜¯ä¸€å¼ å¯¹åº”å…³ç³»è¡¨ã€‚ ç”±æ­¤å¯çŸ¥ï¼Œmainå‡½æ•°çš„nativeçŠ¶æ€æ˜¯æ­£åœ¨æ‰§è¡ŒJNIå‡½æ•°ã€‚å †æ ˆä¿¡æ¯æ˜¯æˆ‘ä»¬åˆ†æžANRçš„ç¬¬ä¸€ä¸ªé‡è¦çš„ä¿¡æ¯ï¼Œä¸€èˆ¬æ¥è¯´ï¼š mainçº¿ç¨‹å¤„äºŽ BLOCKã€WAITINGã€TIMEWAITINGçŠ¶æ€ï¼Œé‚£åŸºæœ¬ä¸Šæ˜¯å‡½æ•°é˜»å¡žå¯¼è‡´ANRï¼› å¦‚æžœmainçº¿ç¨‹æ— å¼‚å¸¸ï¼Œåˆ™åº”è¯¥æŽ’æŸ¥CPUè´Ÿè½½å’Œå†…å­˜çŽ¯å¢ƒã€‚ äº”ã€å…¸åž‹æ¡ˆä¾‹åˆ†æž5.1 ä¸»çº¿ç¨‹æ— å¡é¡¿ï¼Œå¤„äºŽæ­£å¸¸çŠ¶æ€å †æ ˆ12345678910111213141516171819202122&quot;main&quot; prio=5 tid=1 Native | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x74b38080 self=0x7ad9014c00 | sysTid=23081 nice=0 cgrp=default sched=0/0 handle=0x7b5fdc5548 | state=S schedstat=( 284838633 166738594 505 ) utm=21 stm=7 core=1 HZ=100 | stack=0x7fc95da000-0x7fc95dc000 stackSize=8MB | held mutexes= kernel: __switch_to+0xb0/0xbc kernel: SyS_epoll_wait+0x288/0x364 kernel: SyS_epoll_pwait+0xb0/0x124 kernel: cpu_switch_to+0x38c/0x2258 native: #00 pc 000000000007cd8c /system/lib64/libc.so (__epoll_pwait+8) native: #01 pc 0000000000014d48 /system/lib64/libutils.so (android::Looper::pollInner(int)+148) native: #02 pc 0000000000014c18 /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+60) native: #03 pc 00000000001275f4 /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44) at android.os.MessageQueue.nativePollOnce(Native method) at android.os.MessageQueue.next(MessageQueue.java:330) at android.os.Looper.loop(Looper.java:169) at android.app.ActivityThread.main(ActivityThread.java:7073) at java.lang.reflect.Method.invoke(Native method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:536) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:876)å¤åˆ¶ä»£ç  ä¸Šè¿°ä¸»çº¿ç¨‹å †æ ˆå°±æ˜¯ä¸€ä¸ªå¾ˆæ­£å¸¸çš„ç©ºé—²å †æ ˆï¼Œè¡¨æ˜Žä¸»çº¿ç¨‹æ­£åœ¨ç­‰å¾…æ–°çš„æ¶ˆæ¯ã€‚ å¦‚æžœANRæ—¥å¿—é‡Œä¸»çº¿ç¨‹æ˜¯è¿™æ ·ä¸€ä¸ªçŠ¶æ€ï¼Œé‚£å¯èƒ½æœ‰ä¸¤ä¸ªåŽŸå› ï¼š è¯¥ANRæ˜¯CPUæŠ¢å æˆ–å†…å­˜ç´§å¼ ç­‰å…¶ä»–å› ç´ å¼•èµ· è¿™ä»½ANRæ—¥å¿—æŠ“å–çš„æ—¶å€™ï¼Œä¸»çº¿ç¨‹å·²ç»æ¢å¤æ­£å¸¸ é‡åˆ°è¿™ç§ç©ºé—²å †æ ˆï¼Œå¯ä»¥æŒ‰ç…§ç¬¬3èŠ‚çš„æ–¹æ³•åŽ»åˆ†æžCPUã€å†…å­˜çš„æƒ…å†µã€‚å…¶æ¬¡å¯ä»¥å…³æ³¨æŠ“å–æ—¥å¿—çš„æ—¶é—´å’ŒANRå‘ç”Ÿçš„æ—¶é—´æ˜¯å¦ç›¸éš”è¿‡ä¹…ï¼Œæ—¶é—´è¿‡ä¹…è¿™ä¸ªå †æ ˆå°±æ²¡æœ‰åˆ†æžæ„ä¹‰äº†ã€‚ 5.2 ä¸»çº¿ç¨‹æ‰§è¡Œè€—æ—¶æ“ä½œ12345678910111213141516171819&quot;main&quot; prio=5 tid=1 Runnable | group=&quot;main&quot; sCount=0 dsCount=0 flags=0 obj=0x72deb848 self=0x7748c10800 | sysTid=8968 nice=-10 cgrp=default sched=0/0 handle=0x77cfa75ed0 | state=R schedstat=( 24783612979 48520902 756 ) utm=2473 stm=5 core=5 HZ=100 | stack=0x7fce68b000-0x7fce68d000 stackSize=8192KB | held mutexes= &quot;mutator lock&quot;(shared held) at com.example.test.MainActivity$onCreate$2.onClick(MainActivity.kt:20)â€”â€”å…³é”®è¡Œï¼ï¼ï¼ at android.view.View.performClick(View.java:7187) at android.view.View.performClickInternal(View.java:7164) at android.view.View.access$3500(View.java:813) at android.view.View$PerformClick.run(View.java:27640) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:230) at android.app.ActivityThread.main(ActivityThread.java:7725) at java.lang.reflect.Method.invoke(Native method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:526) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1034)å¤åˆ¶ä»£ç  ä¸Šè¿°æ—¥å¿—è¡¨æ˜Žï¼Œä¸»çº¿ç¨‹æ­£å¤„äºŽæ‰§è¡ŒçŠ¶æ€ï¼Œçœ‹å †æ ˆä¿¡æ¯å¯çŸ¥ä¸æ˜¯å¤„äºŽç©ºé—²çŠ¶æ€ï¼Œå‘ç”ŸANRæ˜¯å› ä¸ºä¸€å¤„clickç›‘å¬å‡½æ•°é‡Œæ‰§è¡Œäº†è€—æ—¶æ“ä½œã€‚ 5.3 ä¸»çº¿ç¨‹è¢«é”é˜»å¡ž12345678910111213141516171819202122232425262728293031323334353637&quot;main&quot; prio=5 tid=1 Blocked | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x72deb848 self=0x7748c10800 | sysTid=22838 nice=-10 cgrp=default sched=0/0 handle=0x77cfa75ed0 | state=S schedstat=( 390366023 28399376 279 ) utm=34 stm=5 core=1 HZ=100 | stack=0x7fce68b000-0x7fce68d000 stackSize=8192KB | held mutexes= at com.example.test.MainActivity$onCreate$1.onClick(MainActivity.kt:15) - waiting to lock &lt;0x01aed1da&gt; (a java.lang.Object) held by thread 3 â€”â€”â€”â€”â€”â€”å…³é”®è¡Œï¼ï¼ï¼ at android.view.View.performClick(View.java:7187) at android.view.View.performClickInternal(View.java:7164) at android.view.View.access$3500(View.java:813) at android.view.View$PerformClick.run(View.java:27640) at android.os.Handler.handleCallback(Handler.java:883) at android.os.Handler.dispatchMessage(Handler.java:100) at android.os.Looper.loop(Looper.java:230) at android.app.ActivityThread.main(ActivityThread.java:7725) at java.lang.reflect.Method.invoke(Native method) at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:526) at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:1034) ........çœç•¥Nè¡Œ..... &quot;WQW TEST&quot; prio=5 tid=3 TimeWating | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x12c44230 self=0x772f0ec000 | sysTid=22938 nice=0 cgrp=default sched=0/0 handle=0x77391fbd50 | state=S schedstat=( 274896 0 1 ) utm=0 stm=0 core=1 HZ=100 | stack=0x77390f9000-0x77390fb000 stackSize=1039KB | held mutexes= at java.lang.Thread.sleep(Native method) - sleeping on &lt;0x043831a6&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:440) - locked &lt;0x043831a6&gt; (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:356) at com.example.test.MainActivity$onCreate$2$thread$1.run(MainActivity.kt:22) - locked &lt;0x01aed1da&gt; (a java.lang.Object)â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”å…³é”®è¡Œï¼ï¼ï¼ at java.lang.Thread.run(Thread.java:919)å¤åˆ¶ä»£ç  è¿™æ˜¯ä¸€ä¸ªå…¸åž‹çš„ä¸»çº¿ç¨‹è¢«é”é˜»å¡žçš„ä¾‹å­ï¼› 12waiting to lock &lt;0x01aed1da&gt; (a java.lang.Object) held by thread 3å¤åˆ¶ä»£ç  å…¶ä¸­ç­‰å¾…çš„é”æ˜¯ï¼Œè¿™ä¸ªé”çš„æŒæœ‰è€…æ˜¯çº¿ç¨‹ 3ã€‚è¿›ä¸€æ­¥æœç´¢ â€œtid=3â€ æ‰¾åˆ°çº¿ç¨‹3ï¼Œ å‘çŽ°å®ƒæ­£åœ¨TimeWatingã€‚ é‚£ä¹ˆANRçš„åŽŸå› æ‰¾åˆ°äº†ï¼šçº¿ç¨‹3æŒæœ‰äº†ä¸€æŠŠé”ï¼Œå¹¶ä¸”è‡ªèº«é•¿æ—¶é—´ä¸é‡Šæ”¾ï¼Œä¸»çº¿ç¨‹ç­‰å¾…è¿™æŠŠé”å‘ç”Ÿè¶…æ—¶ã€‚åœ¨çº¿ä¸ŠçŽ¯å¢ƒä¸­ï¼Œå¸¸è§å› é”è€ŒANRçš„åœºæ™¯æ˜¯SharePreferenceå†™å…¥ã€‚ 5.4 CPUè¢«æŠ¢å 123456CPU usage from 0ms to 10625ms later (2020-03-09 14:38:31.633 to 2020-03-09 14:38:42.257): 543% 2045/com.alibaba.android.rimet: 54% user + 89% kernel / faults: 4608 minor 1 major â€”â€”â€”â€”å…³é”®è¡Œï¼ï¼ï¼ 99% 674/android.hardware.camera.provider@2.4-service: 81% user + 18% kernel / faults: 403 minor 24% 32589/com.wang.test: 22% user + 1.4% kernel / faults: 7432 minor 1 major ........çœç•¥Nè¡Œ.....å¤åˆ¶ä»£ç  å¦‚ä¸Šæ—¥å¿—ï¼Œç¬¬äºŒè¡Œæ˜¯é’‰é’‰çš„è¿›ç¨‹ï¼Œå æ®CPUé«˜è¾¾543%ï¼ŒæŠ¢å äº†å¤§éƒ¨åˆ†CPUèµ„æºï¼Œå› è€Œå¯¼è‡´å‘ç”ŸANRã€‚ 5.5 å†…å­˜ç´§å¼ å¯¼è‡´ANRå¦‚æžœæœ‰ä¸€ä»½æ—¥å¿—ï¼ŒCPUå’Œå †æ ˆéƒ½å¾ˆæ­£å¸¸ï¼ˆä¸è´´å‡ºæ¥äº†ï¼‰ï¼Œä»æ—§å‘ç”ŸANRï¼Œè€ƒè™‘æ˜¯å†…å­˜ç´§å¼ ã€‚ ä»ŽCPUç¬¬ä¸€è¡Œä¿¡æ¯å¯ä»¥å‘çŽ°ï¼ŒANRçš„æ—¶é—´ç‚¹æ˜¯2020-10-31 22:38:58.468â€”CPU usage from 0ms to 21752ms later (2020-10-31 22:38:58.468 to 2020-10-31 22:39:20.220) æŽ¥ç€åŽ»ç³»ç»Ÿæ—¥å¿—é‡Œæœç´¢am_meminfoï¼Œ è¿™ä¸ªæ²¡æœ‰æœç´¢åˆ°ã€‚å†æ¬¡æœç´¢onTrimMemoryï¼Œæžœç„¶å‘çŽ°äº†å¾ˆå¤šæ¡è®°å½•ï¼› 12345610-31 22:37:19.749 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher010-31 22:37:33.458 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher010-31 22:38:00.153 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher010-31 22:38:58.731 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher010-31 22:39:02.816 20733 20733 E Runtime : onTrimMemory level:80,pid:com.xxx.xxx:Launcher0å¤åˆ¶ä»£ç  å¯ä»¥çœ‹å‡ºï¼Œåœ¨å‘ç”ŸANRçš„æ—¶é—´ç‚¹å‰åŽï¼Œå†…å­˜éƒ½å¤„äºŽç´§å¼ çŠ¶æ€ï¼Œlevelç­‰çº§æ˜¯80ï¼ŒæŸ¥çœ‹Android API æ–‡æ¡£ï¼› 1234567 /** * Level for &#123;@link #onTrimMemory(int)&#125;: the process is nearing the end * of the background LRU list, and if more memory isn&apos;t found soon it will * be killed. */ static final int TRIM_MEMORY_COMPLETE = 80;å¤åˆ¶ä»£ç  å¯çŸ¥80è¿™ä¸ªç­‰çº§æ˜¯å¾ˆä¸¥é‡çš„ï¼Œåº”ç”¨é©¬ä¸Šå°±è¦è¢«æ€æ­»ï¼Œè¢«æ€æ­»çš„è¿™ä¸ªåº”ç”¨ä»Žåå­—å¯ä»¥çœ‹å‡ºæ¥æ˜¯æ¡Œé¢ï¼Œè¿žæ¡Œé¢éƒ½å¿«è¦è¢«æ€æ­»ï¼Œé‚£æ™®é€šåº”ç”¨èƒ½å¥½åˆ°å“ªé‡ŒåŽ»å‘¢ï¼Ÿ ä¸€èˆ¬æ¥è¯´ï¼Œå‘ç”Ÿå†…å­˜ç´§å¼ ï¼Œä¼šå¯¼è‡´å¤šä¸ªåº”ç”¨å‘ç”ŸANRï¼Œæ‰€ä»¥åœ¨æ—¥å¿—ä¸­å¦‚æžœå‘çŽ°æœ‰å¤šä¸ªåº”ç”¨ä¸€èµ·ANRäº†ï¼Œå¯ä»¥åˆæ­¥åˆ¤å®šï¼Œæ­¤ANRä¸Žä½ çš„åº”ç”¨æ— å…³ã€‚ 5.6 ç³»ç»ŸæœåŠ¡è¶…æ—¶å¯¼è‡´ANRç³»ç»ŸæœåŠ¡è¶…æ—¶ä¸€èˆ¬ä¼šåŒ…å«BinderProxy.transactNativeå…³é”®å­—ï¼Œè¯·çœ‹å¦‚ä¸‹æ—¥å¿—ï¼š 1234567891011121314151617181920212223242526272829&quot;main&quot; prio=5 tid=1 Native | group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x727851e8 self=0x78d7060e00 | sysTid=4894 nice=0 cgrp=default sched=0/0 handle=0x795cc1e9a8 | state=S schedstat=( 8292806752 1621087524 7167 ) utm=707 stm=122 core=5 HZ=100 | stack=0x7febb64000-0x7febb66000 stackSize=8MB | held mutexes= kernel: __switch_to+0x90/0xc4 kernel: binder_thread_read+0xbd8/0x144c kernel: binder_ioctl_write_read.constprop.58+0x20c/0x348 kernel: binder_ioctl+0x5d4/0x88c kernel: do_vfs_ioctl+0xb8/0xb1c kernel: SyS_ioctl+0x84/0x98 kernel: cpu_switch_to+0x34c/0x22c0 native: #00 pc 000000000007a2ac /system/lib64/libc.so (__ioctl+4) native: #01 pc 00000000000276ec /system/lib64/libc.so (ioctl+132) native: #02 pc 00000000000557d4 /system/lib64/libbinder.so (android::IPCThreadState::talkWithDriver(bool)+252) native: #03 pc 0000000000056494 /system/lib64/libbinder.so (android::IPCThreadState::waitForResponse(android::Parcel*, int*)+60) native: #04 pc 00000000000562d0 /system/lib64/libbinder.so (android::IPCThreadState::transact(int, unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+216) native: #05 pc 000000000004ce1c /system/lib64/libbinder.so (android::BpBinder::transact(unsigned int, android::Parcel const&amp;, android::Parcel*, unsigned int)+72) native: #06 pc 00000000001281c8 /system/lib64/libandroid_runtime.so (???) native: #07 pc 0000000000947ed4 /system/framework/arm64/boot-framework.oat (Java_android_os_BinderProxy_transactNative__ILandroid_os_Parcel_2Landroid_os_Parcel_2I+196) at android.os.BinderProxy.transactNative(Native method) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”å…³é”®è¡Œï¼ï¼ï¼ at android.os.BinderProxy.transact(Binder.java:804) at android.net.IConnectivityManager$Stub$Proxy.getActiveNetworkInfo(IConnectivityManager.java:1204)â€”å…³é”®è¡Œï¼ at android.net.ConnectivityManager.getActiveNetworkInfo(ConnectivityManager.java:800) at com.xiaomi.NetworkUtils.getNetworkInfo(NetworkUtils.java:2) at com.xiaomi.frameworkbase.utils.NetworkUtils.getNetWorkType(NetworkUtils.java:1) at com.xiaomi.frameworkbase.utils.NetworkUtils.isWifiConnected(NetworkUtils.java:1)å¤åˆ¶ä»£ç  ä»Žå †æ ˆå¯ä»¥çœ‹å‡ºèŽ·å–ç½‘ç»œä¿¡æ¯å‘ç”Ÿäº†ANRï¼šgetActiveNetworkInfoã€‚ å‰æ–‡æœ‰è®²è¿‡ï¼šç³»ç»Ÿçš„æœåŠ¡éƒ½æ˜¯Binderæœºåˆ¶ï¼ˆ16ä¸ªçº¿ç¨‹ï¼‰ï¼ŒæœåŠ¡èƒ½åŠ›ä¹Ÿæ˜¯æœ‰é™çš„ï¼Œæœ‰å¯èƒ½ç³»ç»ŸæœåŠ¡é•¿æ—¶é—´ä¸å“åº”å¯¼è‡´ANRã€‚å¦‚æžœå…¶ä»–åº”ç”¨å ç”¨äº†æ‰€æœ‰Binderçº¿ç¨‹ï¼Œé‚£ä¹ˆå½“å‰åº”ç”¨åªèƒ½ç­‰å¾…ã€‚ å¯è¿›ä¸€æ­¥æœç´¢ï¼šblockUntilThreadAvailableå…³é”®å­—ï¼š 12at android.os.Binder.blockUntilThreadAvailable(Native method)å¤åˆ¶ä»£ç  å¦‚æžœæœ‰å‘çŽ°æŸä¸ªçº¿ç¨‹çš„å †æ ˆï¼ŒåŒ…å«æ­¤å­—æ ·ï¼Œå¯è¿›ä¸€æ­¥çœ‹å…¶å †æ ˆï¼Œç¡®å®šæ˜¯è°ƒç”¨äº†ä»€ä¹ˆç³»ç»ŸæœåŠ¡ã€‚æ­¤ç±»ANRä¹Ÿæ˜¯å±žäºŽç³»ç»ŸçŽ¯å¢ƒçš„é—®é¢˜ï¼Œå¦‚æžœæŸç±»åž‹æœºå™¨ä¸Šé¢‘ç¹å‘ç”Ÿæ­¤é—®é¢˜ï¼Œåº”ç”¨å±‚å¯ä»¥è€ƒè™‘è§„é¿ç­–ç•¥ã€‚ å…­ã€ç»“è¯­æœ¬æ–‡æ€»ç»“çš„æŠ€å·§æ¥è‡ªç¬”è€…å·¥ä½œä¸­çš„å¤§é‡ANRæ—¥å¿—åˆ†æžç»éªŒï¼Œå¦‚æœ‰é”™æ¼è¯·ç•™è¨€æŒ‡å‡ºï¼Œäº¤æµä¿ƒä½¿è¿›æ­¥ï¼ ä½œè€…ï¼švivoäº’è”ç½‘å®¢æˆ·ç«¯å›¢é˜Ÿâ€”Wang Qinwei]]></content>
      <categories>
        <category>å®žæˆ˜</category>
      </categories>
      <tags>
        <tag>ANR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Annotation Processor]]></title>
    <url>%2F2021%2F01%2F03%2F%E8%87%AA%E5%AE%9A%E4%B9%89Java%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Java Annotation Processoræœ¬æ–‡ä»‹ç»äº†å¦‚ä½•è‡ªå®šä¹‰Javaæ³¨è§£å¤„ç†å™¨åŠæ¶‰åŠåˆ°çš„ç›¸å…³çŸ¥è¯†ï¼Œçœ‹å®Œæœ¬æ–‡å¯ä»¥å¾ˆè½»æ¾çœ‹æ‡‚å¹¶ç†è§£å„å¤§å¼€æºæ¡†æž¶çš„æ³¨è§£å¤„ç†å™¨çš„åº”ç”¨ã€‚ å…³äºŽè‡ªå®šä¹‰Javaæ³¨è§£è¯·æŸ¥çœ‹è‡ªå®šä¹‰æ³¨è§£ã€‚ æœ¬æ–‡è½¬è½½è‡ªè‡ªå®šä¹‰Javaæ³¨è§£å¤„ç†å™¨ åŸºæœ¬å®žçŽ°å®žçŽ°ä¸€ä¸ªè‡ªå®šä¹‰æ³¨è§£å¤„ç†å™¨éœ€è¦æœ‰ä¸¤ä¸ªæ­¥éª¤ï¼Œç¬¬ä¸€æ˜¯å®žçŽ°ProcessoræŽ¥å£å¤„ç†æ³¨è§£ï¼Œç¬¬äºŒæ˜¯æ³¨å†Œæ³¨è§£å¤„ç†å™¨ã€‚ å®žçŽ°ProcessoræŽ¥å£é€šè¿‡å®žçŽ°ProcessoræŽ¥å£å¯ä»¥è‡ªå®šä¹‰æ³¨è§£å¤„ç†å™¨ï¼Œè¿™é‡Œæˆ‘ä»¬é‡‡ç”¨æ›´ç®€å•çš„æ–¹æ³•é€šè¿‡ç»§æ‰¿AbstractProcessorç±»å®žçŽ°è‡ªå®šä¹‰æ³¨è§£å¤„ç†å™¨ã€‚å®žçŽ°æŠ½è±¡æ–¹æ³•processå¤„ç†æˆ‘ä»¬æƒ³è¦çš„åŠŸèƒ½ã€‚ 123456public class CustomProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123; return false; &#125;&#125; é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘ä»¬è¿˜éœ€è¦æŒ‡å®šæ”¯æŒçš„æ³¨è§£ç±»åž‹ä»¥åŠæ”¯æŒçš„Javaç‰ˆæœ¬é€šè¿‡é‡å†™getSupportedAnnotationTypesæ–¹æ³•å’ŒgetSupportedSourceVersionæ–¹æ³•ï¼š 1234567891011121314151617public class CustomProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123; return false; &#125; @Override public Set&lt;String&gt; getSupportedAnnotationTypes() &#123; Set&lt;String&gt; annotataions = new LinkedHashSet&lt;String&gt;(); annotataions.add(CustomAnnotation.class.getCanonicalName()); return annotataions; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125;&#125; å¯¹äºŽæŒ‡å®šæ”¯æŒçš„æ³¨è§£ç±»åž‹ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡æ³¨è§£çš„æ–¹å¼è¿›è¡ŒæŒ‡å®šï¼š 1234567891011@SupportedAnnotationTypes(&#123;"io.github.yuweiguocn.annotation.CustomAnnotation"&#125;)public class CustomProcessor extends AbstractProcessor &#123; @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnvironment) &#123; return false; &#125; @Override public SourceVersion getSupportedSourceVersion() &#123; return SourceVersion.latestSupported(); &#125;&#125; å› ä¸ºAndroidå¹³å°å¯èƒ½ä¼šæœ‰å…¼å®¹é—®é¢˜ï¼Œå»ºè®®ä½¿ç”¨é‡å†™getSupportedAnnotationTypesæ–¹æ³•æŒ‡å®šæ”¯æŒçš„æ³¨è§£ç±»åž‹ã€‚ æ³¨å†Œæ³¨è§£å¤„ç†å™¨æœ€åŽæˆ‘ä»¬è¿˜éœ€è¦å°†æˆ‘ä»¬è‡ªå®šä¹‰çš„æ³¨è§£å¤„ç†å™¨è¿›è¡Œæ³¨å†Œã€‚æ–°å»ºresæ–‡ä»¶å¤¹ï¼Œç›®å½•ä¸‹æ–°å»ºMETA-INFæ–‡ä»¶å¤¹ï¼Œç›®å½•ä¸‹æ–°å»ºservicesæ–‡ä»¶å¤¹ï¼Œç›®å½•ä¸‹æ–°å»ºjavax.annotation.processing.Processoræ–‡ä»¶ï¼Œç„¶åŽå°†æˆ‘ä»¬è‡ªå®šä¹‰æ³¨è§£å¤„ç†å™¨çš„å…¨ç±»åå†™åˆ°æ­¤æ–‡ä»¶ï¼š 1io.github.yuweiguocn.processor.CustomProcessor ä¸Šé¢è¿™ç§æ³¨å†Œçš„æ–¹å¼å¤ªéº»çƒ¦äº†ï¼Œè°·æ­Œå¸®æˆ‘ä»¬å†™äº†ä¸€ä¸ªæ³¨è§£å¤„ç†å™¨æ¥ç”Ÿæˆè¿™ä¸ªæ–‡ä»¶ã€‚githubåœ°å€ï¼šhttps://github.com/google/autoæ·»åŠ ä¾èµ–ï¼š 1compile 'com.google.auto.service:auto-service:1.0-rc2' æ·»åŠ æ³¨è§£ï¼š 1234@AutoService(Processor.class)public class CustomProcessor extends AbstractProcessor &#123; ...&#125; æžå®šï¼Œä½“ä¼šåˆ°æ³¨è§£å¤„ç†å™¨çš„å¼ºå¤§æœ¨æœ‰ã€‚åŽé¢æˆ‘ä»¬åªéœ€å…³æ³¨æ³¨è§£å¤„ç†å™¨ä¸­çš„å¤„ç†é€»è¾‘å³å¯ã€‚ æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹æœ€ç»ˆçš„é¡¹ç›®ç»“æž„ï¼š åŸºæœ¬æ¦‚å¿µæŠ½è±¡ç±»ä¸­è¿˜æœ‰ä¸€ä¸ªinitæ–¹æ³•ï¼Œè¿™æ˜¯ProcessoræŽ¥å£ä¸­æä¾›çš„ä¸€ä¸ªæ–¹æ³•ï¼Œå½“æˆ‘ä»¬ç¼–è¯‘ç¨‹åºæ—¶æ³¨è§£å¤„ç†å™¨å·¥å…·ä¼šè°ƒç”¨æ­¤æ–¹æ³•å¹¶ä¸”æä¾›å®žçŽ°ProcessingEnvironmentæŽ¥å£çš„å¯¹è±¡ä½œä¸ºå‚æ•°ã€‚ 1234@Overridepublic synchronized void init(ProcessingEnvironment processingEnvironment) &#123; super.init(processingEnvironment);&#125; æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ProcessingEnvironmentèŽ·å–ä¸€äº›å®žç”¨ç±»ä»¥åŠèŽ·å–é€‰é¡¹å‚æ•°ç­‰ï¼š æ–¹æ³• è¯´æ˜Ž Elements getElementUtils() è¿”å›žå®žçŽ°ElementsæŽ¥å£çš„å¯¹è±¡ï¼Œç”¨äºŽæ“ä½œå…ƒç´ çš„å·¥å…·ç±»ã€‚ Filer getFiler() è¿”å›žå®žçŽ°FileræŽ¥å£çš„å¯¹è±¡ï¼Œç”¨äºŽåˆ›å»ºæ–‡ä»¶ã€ç±»å’Œè¾…åŠ©æ–‡ä»¶ã€‚ Messager getMessager() è¿”å›žå®žçŽ°MessageræŽ¥å£çš„å¯¹è±¡ï¼Œç”¨äºŽæŠ¥å‘Šé”™è¯¯ä¿¡æ¯ã€è­¦å‘Šæé†’ã€‚ Map getOptions() è¿”å›žæŒ‡å®šçš„å‚æ•°é€‰é¡¹ã€‚ Types getTypeUtils() è¿”å›žå®žçŽ°TypesæŽ¥å£çš„å¯¹è±¡ï¼Œç”¨äºŽæ“ä½œç±»åž‹çš„å·¥å…·ç±»ã€‚ å…ƒç´ Elementå…ƒç´ æ˜¯ä¸€ä¸ªæŽ¥å£ï¼Œè¡¨ç¤ºä¸€ä¸ªç¨‹åºå…ƒç´ ï¼Œæ¯”å¦‚åŒ…ã€ç±»æˆ–è€…æ–¹æ³•ã€‚ä»¥ä¸‹å…ƒç´ ç±»åž‹æŽ¥å£å…¨éƒ¨ç»§æ‰¿è‡ªElementæŽ¥å£ï¼š ç±»åž‹ è¯´æ˜Ž ExecutableElement è¡¨ç¤ºæŸä¸ªç±»æˆ–æŽ¥å£çš„æ–¹æ³•ã€æž„é€ æ–¹æ³•æˆ–åˆå§‹åŒ–ç¨‹åºï¼ˆé™æ€æˆ–å®žä¾‹ï¼‰ï¼ŒåŒ…æ‹¬æ³¨è§£ç±»åž‹å…ƒç´ ã€‚ PackageElement è¡¨ç¤ºä¸€ä¸ªåŒ…ç¨‹åºå…ƒç´ ã€‚æä¾›å¯¹æœ‰å…³åŒ…åŠå…¶æˆå‘˜çš„ä¿¡æ¯çš„è®¿é—®ã€‚ TypeElement è¡¨ç¤ºä¸€ä¸ªç±»æˆ–æŽ¥å£ç¨‹åºå…ƒç´ ã€‚æä¾›å¯¹æœ‰å…³ç±»åž‹åŠå…¶æˆå‘˜çš„ä¿¡æ¯çš„è®¿é—®ã€‚æ³¨æ„ï¼Œæžšä¸¾ç±»åž‹æ˜¯ä¸€ç§ç±»ï¼Œè€Œæ³¨è§£ç±»åž‹æ˜¯ä¸€ç§æŽ¥å£ã€‚ TypeParameterElement è¡¨ç¤ºä¸€èˆ¬ç±»ã€æŽ¥å£ã€æ–¹æ³•æˆ–æž„é€ æ–¹æ³•å…ƒç´ çš„å½¢å¼ç±»åž‹å‚æ•°ã€‚ VariableElement è¡¨ç¤ºä¸€ä¸ªå­—æ®µã€enum å¸¸é‡ã€æ–¹æ³•æˆ–æž„é€ æ–¹æ³•å‚æ•°ã€å±€éƒ¨å˜é‡æˆ–å¼‚å¸¸å‚æ•°ã€‚ å¦‚æžœæˆ‘ä»¬è¦åˆ¤æ–­ä¸€ä¸ªå…ƒç´ çš„ç±»åž‹ï¼Œåº”è¯¥ä½¿ç”¨Element.getKind()æ–¹æ³•é…åˆElementKindæžšä¸¾ç±»è¿›è¡Œåˆ¤æ–­ã€‚å°½é‡é¿å…ä½¿ç”¨instanceofè¿›è¡Œåˆ¤æ–­ï¼Œå› ä¸ºæ¯”å¦‚TypeElementæ—¢è¡¨ç¤ºç±»åˆè¡¨ç¤ºä¸€ä¸ªæŽ¥å£ï¼Œè¿™æ ·åˆ¤æ–­çš„ç»“æžœå¯èƒ½ä¸æ˜¯ä½ æƒ³è¦çš„ã€‚ä¾‹å¦‚æˆ‘ä»¬åˆ¤æ–­ä¸€ä¸ªå…ƒç´ æ˜¯ä¸æ˜¯ä¸€ä¸ªç±»ï¼š 123456if (element instanceof TypeElement) &#123; //é”™è¯¯ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯ä¸€ä¸ªæŽ¥å£&#125;if (element.getKind() == ElementKind.CLASS) &#123; //æ­£ç¡® //doSomething&#125; ä¸‹è¡¨ä¸ºElementKindæžšä¸¾ç±»ä¸­çš„éƒ¨åˆ†å¸¸é‡ï¼Œè¯¦ç»†ä¿¡æ¯è¯·æŸ¥çœ‹å®˜æ–¹æ–‡æ¡£ã€‚ ç±»åž‹ è¯´æ˜Ž PACKAGE ä¸€ä¸ªåŒ…ã€‚ ENUM ä¸€ä¸ªæžšä¸¾ç±»åž‹ã€‚ CLASS æ²¡æœ‰ç”¨æ›´ç‰¹æ®Šçš„ç§ç±»ï¼ˆå¦‚ ENUMï¼‰æè¿°çš„ç±»ã€‚ ANNOTATION_TYPE ä¸€ä¸ªæ³¨è§£ç±»åž‹ã€‚ INTERFACE æ²¡æœ‰ç”¨æ›´ç‰¹æ®Šçš„ç§ç±»ï¼ˆå¦‚ ANNOTATION_TYPEï¼‰æè¿°çš„æŽ¥å£ã€‚ ENUM_CONSTANT ä¸€ä¸ªæžšä¸¾å¸¸é‡ã€‚ FIELD æ²¡æœ‰ç”¨æ›´ç‰¹æ®Šçš„ç§ç±»ï¼ˆå¦‚ ENUM_CONSTANTï¼‰æè¿°çš„å­—æ®µã€‚ PARAMETER æ–¹æ³•æˆ–æž„é€ æ–¹æ³•çš„å‚æ•°ã€‚ LOCAL_VARIABLE å±€éƒ¨å˜é‡ã€‚ METHOD ä¸€ä¸ªæ–¹æ³•ã€‚ CONSTRUCTOR ä¸€ä¸ªæž„é€ æ–¹æ³•ã€‚ TYPE_PARAMETER ä¸€ä¸ªç±»åž‹å‚æ•°ã€‚ ç±»åž‹TypeMirroræ˜¯ä¸€ä¸ªæŽ¥å£ï¼Œè¡¨ç¤º Java ç¼–ç¨‹è¯­è¨€ä¸­çš„ç±»åž‹ã€‚è¿™äº›ç±»åž‹åŒ…æ‹¬åŸºæœ¬ç±»åž‹ã€å£°æ˜Žç±»åž‹ï¼ˆç±»å’ŒæŽ¥å£ç±»åž‹ï¼‰ã€æ•°ç»„ç±»åž‹ã€ç±»åž‹å˜é‡å’Œ null ç±»åž‹ã€‚è¿˜å¯ä»¥è¡¨ç¤ºé€šé…ç¬¦ç±»åž‹å‚æ•°ã€executable çš„ç­¾åå’Œè¿”å›žç±»åž‹ï¼Œä»¥åŠå¯¹åº”äºŽåŒ…å’Œå…³é”®å­— void çš„ä¼ªç±»åž‹ã€‚ä»¥ä¸‹ç±»åž‹æŽ¥å£å…¨éƒ¨ç»§æ‰¿è‡ªTypeMirroræŽ¥å£ï¼š ç±»åž‹ è¯´æ˜Ž ArrayType è¡¨ç¤ºä¸€ä¸ªæ•°ç»„ç±»åž‹ã€‚å¤šç»´æ•°ç»„ç±»åž‹è¢«è¡¨ç¤ºä¸ºç»„ä»¶ç±»åž‹ä¹Ÿæ˜¯æ•°ç»„ç±»åž‹çš„æ•°ç»„ç±»åž‹ã€‚ DeclaredType è¡¨ç¤ºæŸä¸€å£°æ˜Žç±»åž‹ï¼Œæ˜¯ä¸€ä¸ªç±» (class) ç±»åž‹æˆ–æŽ¥å£ (interface) ç±»åž‹ã€‚è¿™åŒ…æ‹¬å‚æ•°åŒ–çš„ç±»åž‹ï¼ˆæ¯”å¦‚ java.util.Setï¼‰å’ŒåŽŸå§‹ç±»åž‹ã€‚TypeElement è¡¨ç¤ºä¸€ä¸ªç±»æˆ–æŽ¥å£å…ƒç´ ï¼Œè€Œ DeclaredType è¡¨ç¤ºä¸€ä¸ªç±»æˆ–æŽ¥å£ç±»åž‹ï¼ŒåŽè€…å°†æˆä¸ºå‰è€…çš„ä¸€ç§ä½¿ç”¨ï¼ˆæˆ–è°ƒç”¨ï¼‰ã€‚ ErrorType è¡¨ç¤ºæ— æ³•æ­£å¸¸å»ºæ¨¡çš„ç±»æˆ–æŽ¥å£ç±»åž‹ã€‚ ExecutableType è¡¨ç¤º executable çš„ç±»åž‹ã€‚executable æ˜¯ä¸€ä¸ªæ–¹æ³•ã€æž„é€ æ–¹æ³•æˆ–åˆå§‹åŒ–ç¨‹åºã€‚ NoType åœ¨å®žé™…ç±»åž‹ä¸é€‚åˆçš„åœ°æ–¹ä½¿ç”¨çš„ä¼ªç±»åž‹ã€‚ NullType è¡¨ç¤º null ç±»åž‹ã€‚ PrimitiveType è¡¨ç¤ºä¸€ä¸ªåŸºæœ¬ç±»åž‹ã€‚è¿™äº›ç±»åž‹åŒ…æ‹¬ booleanã€byteã€shortã€intã€longã€charã€float å’Œ doubleã€‚ ReferenceType è¡¨ç¤ºä¸€ä¸ªå¼•ç”¨ç±»åž‹ã€‚è¿™äº›ç±»åž‹åŒ…æ‹¬ç±»å’ŒæŽ¥å£ç±»åž‹ã€æ•°ç»„ç±»åž‹ã€ç±»åž‹å˜é‡å’Œ null ç±»åž‹ã€‚ TypeVariable è¡¨ç¤ºä¸€ä¸ªç±»åž‹å˜é‡ã€‚ WildcardType è¡¨ç¤ºé€šé…ç¬¦ç±»åž‹å‚æ•°ã€‚ åŒæ ·ï¼Œå¦‚æžœæˆ‘ä»¬æƒ³åˆ¤æ–­ä¸€ä¸ªTypeMirrorçš„ç±»åž‹ï¼Œåº”è¯¥ä½¿ç”¨TypeMirror.getKind()æ–¹æ³•é…åˆTypeKindæžšä¸¾ç±»è¿›è¡Œåˆ¤æ–­ã€‚å°½é‡é¿å…ä½¿ç”¨instanceofè¿›è¡Œåˆ¤æ–­ï¼Œå› ä¸ºæ¯”å¦‚DeclaredTypeæ—¢è¡¨ç¤ºç±» (class) ç±»åž‹åˆè¡¨ç¤ºæŽ¥å£ (interface) ç±»åž‹ï¼Œè¿™æ ·åˆ¤æ–­çš„ç»“æžœå¯èƒ½ä¸æ˜¯ä½ æƒ³è¦çš„ã€‚ TypeKindæžšä¸¾ç±»ä¸­çš„éƒ¨åˆ†å¸¸é‡ï¼Œè¯¦ç»†ä¿¡æ¯è¯·æŸ¥çœ‹å®˜æ–¹æ–‡æ¡£ã€‚ ç±»åž‹ è¯´æ˜Ž BOOLEAN åŸºæœ¬ç±»åž‹ booleanã€‚ INT åŸºæœ¬ç±»åž‹ intã€‚ LONG åŸºæœ¬ç±»åž‹ longã€‚ FLOAT åŸºæœ¬ç±»åž‹ floatã€‚ DOUBLE åŸºæœ¬ç±»åž‹ doubleã€‚ VOID å¯¹åº”äºŽå…³é”®å­— void çš„ä¼ªç±»åž‹ã€‚ NULL null ç±»åž‹ã€‚ ARRAY æ•°ç»„ç±»åž‹ã€‚ PACKAGE å¯¹åº”äºŽåŒ…å…ƒç´ çš„ä¼ªç±»åž‹ã€‚ EXECUTABLE æ–¹æ³•ã€æž„é€ æ–¹æ³•æˆ–åˆå§‹åŒ–ç¨‹åºã€‚ åˆ›å»ºæ–‡ä»¶FileræŽ¥å£æ”¯æŒé€šè¿‡æ³¨è§£å¤„ç†å™¨åˆ›å»ºæ–°æ–‡ä»¶ã€‚å¯ä»¥åˆ›å»ºä¸‰ç§æ–‡ä»¶ç±»åž‹ï¼šæºæ–‡ä»¶ã€ç±»æ–‡ä»¶å’Œè¾…åŠ©èµ„æºæ–‡ä»¶ã€‚ 1.åˆ›å»ºæºæ–‡ä»¶ 123JavaFileObject createSourceFile(CharSequence name, Element... originatingElements) throws IOException åˆ›å»ºä¸€ä¸ªæ–°çš„æºæ–‡ä»¶ï¼Œå¹¶è¿”å›žä¸€ä¸ªå¯¹è±¡ä»¥å…è®¸å†™å…¥å®ƒã€‚æ–‡ä»¶çš„åç§°å’Œè·¯å¾„ï¼ˆç›¸å¯¹äºŽæºæ–‡ä»¶çš„æ ¹ç›®å½•è¾“å‡ºä½ç½®ï¼‰åŸºäºŽè¯¥æ–‡ä»¶ä¸­å£°æ˜Žçš„ç±»åž‹ã€‚å¦‚æžœå£°æ˜Žçš„ç±»åž‹ä¸æ­¢ä¸€ä¸ªï¼Œåˆ™åº”è¯¥ä½¿ç”¨ä¸»è¦é¡¶å±‚ç±»åž‹çš„åç§°ï¼ˆä¾‹å¦‚ï¼Œå£°æ˜Žä¸º public çš„é‚£ä¸ªï¼‰ã€‚è¿˜å¯ä»¥åˆ›å»ºæºæ–‡ä»¶æ¥ä¿å­˜æœ‰å…³æŸä¸ªåŒ…çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬åŒ…æ³¨è§£ã€‚è¦ä¸ºæŒ‡å®šåŒ…åˆ›å»ºæºæ–‡ä»¶ï¼Œå¯ä»¥ç”¨ name ä½œä¸ºåŒ…åç§°ï¼ŒåŽè·Ÿ â€œ.package-infoâ€ï¼›è¦ä¸ºæœªæŒ‡å®šçš„åŒ…åˆ›å»ºæºæ–‡ä»¶ï¼Œå¯ä»¥ä½¿ç”¨ â€œpackage-infoâ€ã€‚ 2.åˆ›å»ºç±»æ–‡ä»¶ 123JavaFileObject createClassFile(CharSequence name, Element... originatingElements) throws IOException åˆ›å»ºä¸€ä¸ªæ–°çš„ç±»æ–‡ä»¶ï¼Œå¹¶è¿”å›žä¸€ä¸ªå¯¹è±¡ä»¥å…è®¸å†™å…¥å®ƒã€‚æ–‡ä»¶çš„åç§°å’Œè·¯å¾„ï¼ˆç›¸å¯¹äºŽç±»æ–‡ä»¶çš„æ ¹ç›®å½•è¾“å‡ºä½ç½®ï¼‰åŸºäºŽå°†å†™å…¥çš„ç±»åž‹åç§°ã€‚è¿˜å¯ä»¥åˆ›å»ºç±»æ–‡ä»¶æ¥ä¿å­˜æœ‰å…³æŸä¸ªåŒ…çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬åŒ…æ³¨è§£ã€‚è¦ä¸ºæŒ‡å®šåŒ…åˆ›å»ºç±»æ–‡ä»¶ï¼Œå¯ä»¥ç”¨ name ä½œä¸ºåŒ…åç§°ï¼ŒåŽè·Ÿ â€œ.package-infoâ€ï¼›ä¸ºæœªæŒ‡å®šçš„åŒ…åˆ›å»ºç±»æ–‡ä»¶ä¸å—æ”¯æŒã€‚ 3.åˆ›å»ºè¾…åŠ©èµ„æºæ–‡ä»¶ 12345FileObject createResource(JavaFileManager.Location location, CharSequence pkg, CharSequence relativeName, Element... originatingElements) throws IOException åˆ›å»ºä¸€ä¸ªç”¨äºŽå†™å…¥æ“ä½œçš„æ–°è¾…åŠ©èµ„æºæ–‡ä»¶ï¼Œå¹¶ä¸ºå®ƒè¿”å›žä¸€ä¸ªæ–‡ä»¶å¯¹è±¡ã€‚è¯¥æ–‡ä»¶å¯ä»¥ä¸Žæ–°åˆ›å»ºçš„æºæ–‡ä»¶ã€æ–°åˆ›å»ºçš„äºŒè¿›åˆ¶æ–‡ä»¶æˆ–è€…å…¶ä»–å—æ”¯æŒçš„ä½ç½®ä¸€èµ·è¢«æŸ¥æ‰¾ã€‚ä½ç½® CLASS_OUTPUT å’Œ SOURCE_OUTPUT å¿…é¡»å—æ”¯æŒã€‚èµ„æºå¯ä»¥æ˜¯ç›¸å¯¹äºŽæŸä¸ªåŒ…ï¼ˆè¯¥åŒ…æ˜¯æºæ–‡ä»¶å’Œç±»æ–‡ä»¶ï¼‰æŒ‡å®šçš„ï¼Œå¹¶é€šè¿‡ç›¸å¯¹è·¯å¾„åä»Žä¸­å–å‡ºã€‚ä»Žä¸å¤ªä¸¥æ ¼çš„è§’åº¦è¯´ï¼Œæ–°æ–‡ä»¶çš„å®Œå…¨è·¯å¾„åå°†æ˜¯ locationã€ pkg å’Œ relativeName çš„ä¸²è”ã€‚ å¯¹äºŽç”ŸæˆJavaæ–‡ä»¶ï¼Œè¿˜å¯ä»¥ä½¿ç”¨Squareå…¬å¸çš„å¼€æºç±»åº“JavaPoetï¼Œæ„Ÿå…´è¶£çš„åŒå­¦å¯ä»¥äº†è§£ä¸‹ã€‚ æ‰“å°é”™è¯¯ä¿¡æ¯MessageræŽ¥å£æä¾›æ³¨è§£å¤„ç†å™¨ç”¨æ¥æŠ¥å‘Šé”™è¯¯æ¶ˆæ¯ã€è­¦å‘Šå’Œå…¶ä»–é€šçŸ¥çš„æ–¹å¼ã€‚ æ³¨æ„ï¼šæˆ‘ä»¬åº”è¯¥å¯¹åœ¨å¤„ç†è¿‡ç¨‹ä¸­å¯èƒ½å‘ç”Ÿçš„å¼‚å¸¸è¿›è¡Œæ•èŽ·ï¼Œé€šè¿‡MessageræŽ¥å£æä¾›çš„æ–¹æ³•é€šçŸ¥ç”¨æˆ·ã€‚æ­¤å¤–ï¼Œä½¿ç”¨å¸¦æœ‰Elementå‚æ•°çš„æ–¹æ³•è¿žæŽ¥åˆ°å‡ºé”™çš„å…ƒç´ ï¼Œç”¨æˆ·å¯ä»¥ç›´æŽ¥ç‚¹å‡»é”™è¯¯ä¿¡æ¯è·³åˆ°å‡ºé”™æºæ–‡ä»¶çš„ç›¸åº”è¡Œã€‚å¦‚æžœä½ åœ¨process()ä¸­æŠ›å‡ºä¸€ä¸ªå¼‚å¸¸ï¼Œé‚£ä¹ˆè¿è¡Œæ³¨è§£å¤„ç†å™¨çš„JVMå°†ä¼šå´©æºƒï¼ˆå°±åƒå…¶ä»–Javaåº”ç”¨ä¸€æ ·ï¼‰ï¼Œè¿™æ ·ç”¨æˆ·ä¼šä»Žjavacä¸­å¾—åˆ°ä¸€ä¸ªéžå¸¸éš¾æ‡‚å‡ºé”™ä¿¡æ¯ã€‚ æ–¹æ³• è¯´æ˜Ž void printMessage(Diagnostic.Kind kind, CharSequence msg) æ‰“å°æŒ‡å®šç§ç±»çš„æ¶ˆæ¯ã€‚ void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e) åœ¨å…ƒç´ çš„ä½ç½®ä¸Šæ‰“å°æŒ‡å®šç§ç±»çš„æ¶ˆæ¯ã€‚ void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a) åœ¨å·²æ³¨è§£å…ƒç´ çš„æ³¨è§£é•œåƒä½ç½®ä¸Šæ‰“å°æŒ‡å®šç§ç±»çš„æ¶ˆæ¯ã€‚ void printMessage(Diagnostic.Kind kind, CharSequence msg, Element e, AnnotationMirror a, AnnotationValue v) åœ¨å·²æ³¨è§£å…ƒç´ çš„æ³¨è§£é•œåƒå†…éƒ¨æ³¨è§£å€¼çš„ä½ç½®ä¸Šæ‰“å°æŒ‡å®šç§ç±»çš„æ¶ˆæ¯ã€‚ é…ç½®é€‰é¡¹å‚æ•°æˆ‘ä»¬å¯ä»¥é€šè¿‡getOptions()æ–¹æ³•èŽ·å–é€‰é¡¹å‚æ•°ï¼Œåœ¨gradleæ–‡ä»¶ä¸­é…ç½®é€‰é¡¹å‚æ•°å€¼ã€‚ä¾‹å¦‚æˆ‘ä»¬é…ç½®äº†ä¸€ä¸ªåä¸ºyuweiguoCustomAnnotationçš„å‚æ•°å€¼ã€‚ 123456789android &#123; defaultConfig &#123; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [ yuweiguoCustomAnnotation : 'io.github.yuweiguocn.customannotation.MyCustomAnnotation' ] &#125; &#125; &#125;&#125; åœ¨æ³¨è§£å¤„ç†å™¨ä¸­é‡å†™getSupportedOptionsæ–¹æ³•æŒ‡å®šæ”¯æŒçš„é€‰é¡¹å‚æ•°åç§°ã€‚é€šè¿‡getOptionsæ–¹æ³•èŽ·å–é€‰é¡¹å‚æ•°å€¼ã€‚ 12345678910111213141516171819202122232425public static final String CUSTOM_ANNOTATION = "yuweiguoCustomAnnotation";@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; try &#123; String resultPath = processingEnv.getOptions().get(CUSTOM_ANNOTATION); if (resultPath == null) &#123; ... return false; &#125; ... &#125; catch (Exception e) &#123; e.printStackTrace(); ... &#125; return true;&#125;@Overridepublic Set&lt;String&gt; getSupportedOptions() &#123; Set&lt;String&gt; options = new LinkedHashSet&lt;String&gt;(); options.add(CUSTOM_ANNOTATION); return options;&#125; å¤„ç†è¿‡ç¨‹Javaå®˜æ–¹æ–‡æ¡£ç»™å‡ºçš„æ³¨è§£å¤„ç†è¿‡ç¨‹çš„å®šä¹‰ï¼šæ³¨è§£å¤„ç†è¿‡ç¨‹æ˜¯ä¸€ä¸ªæœ‰åºçš„å¾ªçŽ¯è¿‡ç¨‹ã€‚åœ¨æ¯æ¬¡å¾ªçŽ¯ä¸­ï¼Œä¸€ä¸ªå¤„ç†å™¨å¯èƒ½è¢«è¦æ±‚åŽ»å¤„ç†é‚£äº›åœ¨ä¸Šä¸€æ¬¡å¾ªçŽ¯ä¸­äº§ç”Ÿçš„æºæ–‡ä»¶å’Œç±»æ–‡ä»¶ä¸­çš„æ³¨è§£ã€‚ç¬¬ä¸€æ¬¡å¾ªçŽ¯çš„è¾“å…¥æ˜¯è¿è¡Œæ­¤å·¥å…·çš„åˆå§‹è¾“å…¥ã€‚è¿™äº›åˆå§‹è¾“å…¥ï¼Œå¯ä»¥çœ‹æˆæ˜¯è™šæ‹Ÿçš„ç¬¬0æ¬¡çš„å¾ªçŽ¯çš„è¾“å‡ºã€‚è¿™ä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å®žçŽ°çš„processæ–¹æ³•æœ‰å¯èƒ½ä¼šè¢«è°ƒç”¨å¤šæ¬¡ï¼Œå› ä¸ºæˆ‘ä»¬ç”Ÿæˆçš„æ–‡ä»¶ä¹Ÿæœ‰å¯èƒ½ä¼šåŒ…å«ç›¸åº”çš„æ³¨è§£ã€‚ä¾‹å¦‚ï¼Œæˆ‘ä»¬çš„æºæ–‡ä»¶ä¸ºSourceActivity.classï¼Œç”Ÿæˆçš„æ–‡ä»¶ä¸ºGenerated.classï¼Œè¿™æ ·å°±ä¼šæœ‰ä¸‰æ¬¡å¾ªçŽ¯ï¼Œç¬¬ä¸€æ¬¡è¾“å…¥ä¸ºSourceActivity.classï¼Œè¾“å‡ºä¸ºGenerated.classï¼›ç¬¬äºŒæ¬¡è¾“å…¥ä¸ºGenerated.classï¼Œè¾“å‡ºå¹¶æ²¡æœ‰äº§ç”Ÿæ–°æ–‡ä»¶ï¼›ç¬¬ä¸‰æ¬¡è¾“å…¥ä¸ºç©ºï¼Œè¾“å‡ºä¸ºç©ºã€‚ æ¯æ¬¡å¾ªçŽ¯éƒ½ä¼šè°ƒç”¨processæ–¹æ³•ï¼Œprocessæ–¹æ³•æä¾›äº†ä¸¤ä¸ªå‚æ•°ï¼Œç¬¬ä¸€ä¸ªæ˜¯æˆ‘ä»¬è¯·æ±‚å¤„ç†æ³¨è§£ç±»åž‹çš„é›†åˆï¼ˆä¹Ÿå°±æ˜¯æˆ‘ä»¬é€šè¿‡é‡å†™getSupportedAnnotationTypesæ–¹æ³•æ‰€æŒ‡å®šçš„æ³¨è§£ç±»åž‹ï¼‰ï¼Œç¬¬äºŒä¸ªæ˜¯æœ‰å…³å½“å‰å’Œä¸Šä¸€æ¬¡ å¾ªçŽ¯çš„ä¿¡æ¯çš„çŽ¯å¢ƒã€‚è¿”å›žå€¼è¡¨ç¤ºè¿™äº›æ³¨è§£æ˜¯å¦ç”±æ­¤ Processor å£°æ˜Žï¼Œå¦‚æžœè¿”å›ž trueï¼Œåˆ™è¿™äº›æ³¨è§£å·²å£°æ˜Žå¹¶ä¸”ä¸è¦æ±‚åŽç»­ Processor å¤„ç†å®ƒä»¬ï¼›å¦‚æžœè¿”å›ž falseï¼Œåˆ™è¿™äº›æ³¨è§£æœªå£°æ˜Žå¹¶ä¸”å¯èƒ½è¦æ±‚åŽç»­ Processor å¤„ç†å®ƒä»¬ã€‚ 12public abstract boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) èŽ·å–æ³¨è§£å…ƒç´ æˆ‘ä»¬å¯ä»¥é€šè¿‡RoundEnvironmentæŽ¥å£èŽ·å–æ³¨è§£å…ƒç´ ã€‚processæ–¹æ³•ä¼šæä¾›ä¸€ä¸ªå®žçŽ°RoundEnvironmentæŽ¥å£çš„å¯¹è±¡ã€‚ æ–¹æ³• è¯´æ˜Ž Set&lt;? extends Element&gt; getElementsAnnotatedWith(Class&lt;? extends Annotation&gt; a) è¿”å›žè¢«æŒ‡å®šæ³¨è§£ç±»åž‹æ³¨è§£çš„å…ƒç´ é›†åˆã€‚ Set&lt;? extends Element&gt; getElementsAnnotatedWith(TypeElement a) è¿”å›žè¢«æŒ‡å®šæ³¨è§£ç±»åž‹æ³¨è§£çš„å…ƒç´ é›†åˆã€‚ processingOver() å¦‚æžœå¾ªçŽ¯å¤„ç†å®Œæˆè¿”å›žtrueï¼Œå¦åˆ™è¿”å›žfalseã€‚ ç¤ºä¾‹äº†è§£å®Œäº†ç›¸å…³çš„åŸºæœ¬æ¦‚å¿µï¼ŒæŽ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªç¤ºä¾‹ï¼Œæœ¬ç¤ºä¾‹åªä¸ºæ¼”ç¤ºæ— å®žé™…æ„ä¹‰ã€‚ä¸»è¦åŠŸèƒ½ä¸ºè‡ªå®šä¹‰ä¸€ä¸ªæ³¨è§£ï¼Œæ­¤æ³¨è§£åªèƒ½ç”¨åœ¨publicçš„æ–¹æ³•ä¸Šï¼Œæˆ‘ä»¬é€šè¿‡æ³¨è§£å¤„ç†å™¨æ‹¿åˆ°ç±»åå’Œæ–¹æ³•åå­˜å‚¨åˆ°Listé›†åˆä¸­ï¼Œç„¶åŽç”Ÿæˆé€šè¿‡å‚æ•°é€‰é¡¹æŒ‡å®šçš„æ–‡ä»¶ï¼Œé€šè¿‡æ­¤æ–‡ä»¶å¯ä»¥èŽ·å–Listé›†åˆã€‚ è‡ªå®šä¹‰æ³¨è§£ï¼š 12345@Documented@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface CustomAnnotation &#123;&#125; æ³¨è§£å¤„ç†å™¨ä¸­å…³é”®ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102@Overridepublic boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; try &#123; String resultPath = processingEnv.getOptions().get(CUSTOM_ANNOTATION); if (resultPath == null) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "No option " + CUSTOM_ANNOTATION + " passed to annotation processor"); return false; &#125; round++; messager.printMessage(Diagnostic.Kind.NOTE, "round " + round + " process over " + roundEnv.processingOver()); Iterator&lt;? extends TypeElement&gt; iterator = annotations.iterator(); while (iterator.hasNext()) &#123; messager.printMessage(Diagnostic.Kind.NOTE, "name is " + iterator.next().getSimpleName().toString()); &#125; if (roundEnv.processingOver()) &#123; if (!annotations.isEmpty()) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected processing state: annotations still available after processing over"); return false; &#125; &#125; if (annotations.isEmpty()) &#123; return false; &#125; for (Element element : roundEnv.getElementsAnnotatedWith(CustomAnnotation.class)) &#123; if (element.getKind() != ElementKind.METHOD) &#123; messager.printMessage( Diagnostic.Kind.ERROR, String.format("Only methods can be annotated with @%s", CustomAnnotation.class.getSimpleName()), element); return true; // é€€å‡ºå¤„ç† &#125; if (!element.getModifiers().contains(Modifier.PUBLIC)) &#123; messager.printMessage(Diagnostic.Kind.ERROR, "Subscriber method must be public", element); return true; &#125; ExecutableElement execElement = (ExecutableElement) element; TypeElement classElement = (TypeElement) execElement.getEnclosingElement(); result.add(classElement.getSimpleName().toString() + "#" + execElement.getSimpleName().toString()); &#125; if (!result.isEmpty()) &#123; generateFile(resultPath); &#125; else &#123; messager.printMessage(Diagnostic.Kind.WARNING, "No @CustomAnnotation annotations found"); &#125; result.clear(); &#125; catch (Exception e) &#123; e.printStackTrace(); messager.printMessage(Diagnostic.Kind.ERROR, "Unexpected error in CustomProcessor: " + e); &#125; return true;&#125;private void generateFile(String path) &#123; BufferedWriter writer = null; try &#123; JavaFileObject sourceFile = filer.createSourceFile(path); int period = path.lastIndexOf('.'); String myPackage = period &gt; 0 ? path.substring(0, period) : null; String clazz = path.substring(period + 1); writer = new BufferedWriter(sourceFile.openWriter()); if (myPackage != null) &#123; writer.write("package " + myPackage + ";\n\n"); &#125; writer.write("import java.util.ArrayList;\n"); writer.write("import java.util.List;\n\n"); writer.write("/** This class is generated by CustomProcessor, do not edit. */\n"); writer.write("public class " + clazz + " &#123;\n"); writer.write(" private static final List&lt;String&gt; ANNOTATIONS;\n\n"); writer.write(" static &#123;\n"); writer.write(" ANNOTATIONS = new ArrayList&lt;&gt;();\n\n"); writeMethodLines(writer); writer.write(" &#125;\n\n"); writer.write(" public static List&lt;String&gt; getAnnotations() &#123;\n"); writer.write(" return ANNOTATIONS;\n"); writer.write(" &#125;\n\n"); writer.write("&#125;\n"); &#125; catch (IOException e) &#123; throw new RuntimeException("Could not write source for " + path, e); &#125; finally &#123; if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; //Silent &#125; &#125; &#125;&#125;private void writeMethodLines(BufferedWriter writer) throws IOException &#123; for (int i = 0; i &lt; result.size(); i++) &#123; writer.write(" ANNOTATIONS.add(\"" + result.get(i) + "\");\n"); &#125;&#125; ç¼–è¯‘è¾“å‡ºï¼š 1234Note: round 1 process over falseNote: name is CustomAnnotationNote: round 2 process over falseNote: round 3 process over true èŽ·å–å®Œæ•´ä»£ç ï¼šhttps://github.com/yuweiguocn/CustomAnnotation å…³äºŽä¸Šä¼ è‡ªå®šä¹‰æ³¨è§£å¤„ç†å™¨åˆ°jcenterä¸­ï¼Œè¯·æŸ¥çœ‹ä¸Šä¼ ç±»åº“åˆ°jcenterã€‚ å¾ˆé«˜å…´ä½ èƒ½é˜…è¯»åˆ°è¿™é‡Œï¼Œæ­¤æ—¶å†åŽ»çœ‹EventBus 3.0ä¸­çš„æ³¨è§£å¤„ç†å™¨çš„æºç ï¼Œç›¸ä¿¡ä½ å¯ä»¥å¾ˆè½»æ¾åœ°ç†è§£å®ƒçš„åŽŸç†ã€‚ æ³¨æ„ï¼šå¦‚æžœä½ cloneäº†å·¥ç¨‹ä»£ç ï¼Œä½ å¯èƒ½ä¼šå‘çŽ°æ³¨è§£å’Œæ³¨è§£å¤„ç†å™¨æ˜¯å•ç‹¬çš„moduleã€‚æœ‰ä¸€ç‚¹å¯ä»¥è‚¯å®šçš„æ˜¯æˆ‘ä»¬çš„æ³¨è§£å¤„ç†å™¨åªéœ€è¦åœ¨ç¼–è¯‘çš„æ—¶å€™ä½¿ç”¨ï¼Œå¹¶ä¸éœ€è¦æ‰“åŒ…åˆ°APKä¸­ã€‚å› æ­¤ä¸ºäº†ç”¨æˆ·è€ƒè™‘ï¼Œæˆ‘ä»¬éœ€è¦å°†æ³¨è§£å¤„ç†å™¨åˆ†ç¦»ä¸ºå•ç‹¬çš„moduleã€‚ åº”ç”¨æ¡ˆä¾‹ https://github.com/greenrobot/EventBus Android optimized event bus that simplifies communication between Activities, Fragments, Threads, Services, etc. Less code, better quality. https://github.com/frankiesardo/icepick Android Instance State made easy https://github.com/sockeqwe/fragmentargs Annotation Processor for setting arguments in android fragments http://parceler.org/ Android Parcelable code generator for Google Android https://github.com/JakeWharton/butterknife Bind Android views and callbacks to fields and methods. https://github.com/bluelinelabs/LoganSquare Screaming fast JSON parsing and serialization library for Android. https://github.com/google/auto A collection of source code generators for Java. å‚è€ƒ https://www.race604.com/annotation-processing/ http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/package-summary.html http://tool.oschina.net/uploads/apidocs/jdk-zh/ https://github.com/greenrobot/EventBus http://hannesdorfmann.com/annotation-processing/annotationprocessing101 https://github.com/sockeqwe/annotationprocessing101]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus æºç è¯¦è§£]]></title>
    <url>%2F2021%2F01%2F03%2FEventBus%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[EventBus æºç è¯¦è§£æˆ‘ä»¬çŸ¥é“ï¼ŒEventBus åœ¨æœ‰æ¶ˆæ¯è¢«å‘é€å‡ºæ¥æ—¶ï¼Œå¯ä»¥ç›´æŽ¥ä¸ºæˆ‘ä»¬å›žè°ƒè¯¥æ¶ˆæ¯çš„æ‰€æœ‰ç›‘å¬æ–¹æ³•ï¼Œå›žè°ƒæ“ä½œæ˜¯é€šè¿‡åå°„ method.invoke æ¥å®žçŽ°çš„ã€‚é‚£ä¹ˆ EventBus åœ¨å›žè°ƒä¹‹å‰ä¹Ÿå¿…é¡»å…ˆæ‹¿åˆ°æ‰€æœ‰çš„ç›‘å¬æ–¹æ³•æ‰è¡Œï¼Œè¿™æ ·æ‰çŸ¥é“è¯¥æ¶ˆæ¯ç±»åž‹å¯¹åº”ä»€ä¹ˆç›‘å¬æ–¹æ³•ä»¥åŠå¯¹åº”å¤šå°‘ç›‘å¬æ–¹æ³• EventBus èŽ·å–ç›‘å¬æ–¹æ³•çš„æ–¹å¼æœ‰ä¸¤ç§ï¼š ä¸é…ç½®æ³¨è§£å¤„ç†å™¨ã€‚åœ¨ subscriber è¿›è¡Œ register æ—¶é€šè¿‡åå°„èŽ·å–åˆ°ï¼Œè¿™ç§æ–¹å¼æ˜¯åœ¨è¿è¡Œæ—¶å®žçŽ°çš„ é…ç½®æ³¨è§£å¤„ç†å™¨ã€‚é¢„å…ˆè§£æžç›‘å¬æ–¹æ³•åˆ°è¾…åŠ©æ–‡ä»¶ä¸­ï¼Œåœ¨è¿è¡Œæ—¶å°±å¯ä»¥ç›´æŽ¥æ‹¿åˆ°æ‰€æœ‰çš„è§£æžç»“æžœè€Œä¸å¿…ä¾é åå°„æ¥å®žçŽ°ï¼Œè¿™ç§æ–¹å¼æ˜¯åœ¨ç¼–è¯‘é˜¶æ®µå®žçŽ°çš„ï¼Œç›¸æ¯”ç¬¬ä¸€ç§æ–¹å¼æ€§èƒ½ä¼šé«˜å¾ˆå¤š è¿™é‡Œå…ˆä»‹ç»ç¬¬ä¸€ç§æ–¹å¼ï¼Œè¿™ç§æ–¹å¼åªéœ€è¦å¯¼å…¥å¦‚ä¸‹ä¾èµ–å³å¯ 1implementation "org.greenrobot:eventbus:3.2.0" ä¸€ã€æ³¨å†ŒEventBus.java123456789public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; EventBus çš„æ³¨å†Œæ“ä½œæ˜¯é€šè¿‡ register(Object)æ–¹æ³•æ¥å®Œæˆçš„ã€‚è¯¥æ–¹æ³•ä¼šå¯¹æ³¨å†Œç±»è¿›è¡Œè§£æžï¼Œå°†æ³¨å†Œç±»åŒ…å«çš„æ‰€æœ‰å£°æ˜Žäº† @Subscribe æ³¨è§£çš„æ–¹æ³•çš„ç­¾åä¿¡æ¯ä¿å­˜åˆ°å†…å­˜ä¸­ï¼Œè¿™æ ·å½“æœ‰æ¶ˆæ¯è¢« Post æ—¶ï¼Œå°±å¯ä»¥ç›´æŽ¥åœ¨å†…å­˜ä¸­æŸ¥æ‰¾åˆ°ç›®æ ‡æ–¹æ³•äº† ä»Ž SubscriberMethod ç±»åŒ…å«çš„æ‰€æœ‰å‚æ•°å¯ä»¥çœ‹å‡ºæ¥ï¼Œå®ƒåŒ…å«äº†æˆ‘ä»¬å¯¹ @Subscribe çš„é…ç½®ä¿¡æ¯ä»¥åŠå¯¹åº”çš„æ–¹æ³•ç­¾åä¿¡æ¯ 123456789101112public class SubscriberMethod &#123; final Method method; final ThreadMode threadMode; final Class&lt;?&gt; eventType; final int priority; final boolean sticky; /** Used for efficient comparison */ String methodString; Â·Â·Â·&#125; è¿™ä¸ªæŸ¥æ‰¾çš„è¿‡ç¨‹æ˜¯é€šè¿‡ SubscriberMethodFinder ç±»æ¥å®Œæˆçš„ SubscriberMethodFinder.javaè¿™é‡Œæ¥çœ‹ä¸‹ SubscriberMethodFinderæ˜¯å¦‚ä½•éåŽ†èŽ·å–åˆ°æ‰€æœ‰å£°æ˜Žäº†@Subscribe æ³¨è§£çš„æ–¹æ³• 12345678910111213141516171819202122private static final Map&lt;Class&lt;?&gt;, List&lt;SubscriberMethod&gt;&gt; METHOD_CACHE = new ConcurrentHashMap&lt;&gt;();List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) &#123; List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass); if (subscriberMethods != null) &#123; return subscriberMethods; &#125; if (ignoreGeneratedIndex) &#123; subscriberMethods = findUsingReflection(subscriberClass); &#125; else &#123; subscriberMethods = findUsingInfo(subscriberClass); &#125; if (subscriberMethods.isEmpty()) &#123; //å¦‚æžœä¸ºç©ºï¼Œè¯´æ˜Žä¸åŒ…å«ä½¿ç”¨ @Subscribe æ³¨è§£çš„æ–¹æ³•ï¼Œé‚£ä¹ˆ register æ“ä½œå°±æ˜¯æ²¡æœ‰æ„ä¹‰çš„ï¼Œç›´æŽ¥æŠ›å‡ºå¼‚å¸¸ throw new EventBusException("Subscriber " + subscriberClass + " and its super classes have no public methods with the @Subscribe annotation"); &#125; else &#123; METHOD_CACHE.put(subscriberClass, subscriberMethods); return subscriberMethods; &#125;&#125; SubscriberMethodFinder ä¼šå°†æ¯æ¬¡çš„æŸ¥æ‰¾ç»“æžœç¼“å­˜åˆ° METHOD_CACHEä¸­ï¼Œè¿™å¯¹æŸäº›ä¼šå…ˆåŽç»åŽ†å¤šæ¬¡æ³¨å†Œå’Œåæ³¨å†Œæ“ä½œçš„é¡µé¢æ¥è¯´ä¼šæ¯”è¾ƒæœ‰ç”¨ï¼Œå› ä¸ºæ¯æ¬¡æŸ¥æ‰¾å¯èƒ½éœ€è¦ä¾é å¤šæ¬¡å¾ªçŽ¯éåŽ†å’Œåå°„æ“ä½œï¼Œä¼šç¨å¾®æœ‰ç‚¹æ¶ˆè€—æ€§èƒ½ å› ä¸ºignoreGeneratedIndexé»˜è®¤å€¼æ˜¯ falseï¼Œæ‰€ä»¥è¿™é‡Œç›´æŽ¥çœ‹ findUsingInfo(subscriberClass) æ–¹æ³• å…¶ä¸»è¦é€»è¾‘æ˜¯ï¼š é€šè¿‡ prepareFindState() æ–¹æ³•ä»Žå¯¹è±¡æ±  FIND_STATE_POOL ä¸­èŽ·å–ç©ºé—²çš„ FindState å¯¹è±¡ï¼Œå¦‚æžœä¸å­˜åœ¨åˆ™åˆå§‹åŒ–ä¸€ä¸ªæ–°çš„ï¼Œå¹¶åœ¨ä½¿ç”¨è¿‡åŽé€šè¿‡ getMethodsAndRelease æ–¹æ³•å°†å¯¹è±¡è¿˜ç»™å¯¹è±¡æ± ã€‚é€šè¿‡å¯¹è±¡æ± æ¥é¿å…æ— é™åˆ¶åœ°åˆ›å»º FindState å¯¹è±¡ï¼Œè¿™ä¹Ÿç®—åšæ˜¯ä¸€ä¸ªä¼˜åŒ–ç‚¹ åœ¨ä¸ä½¿ç”¨æ³¨è§£å¤„ç†å™¨çš„æƒ…å†µä¸‹ findState.subscriberInfo å’Œ subscriberInfoIndexesé»˜è®¤éƒ½æ˜¯ç­‰äºŽ null çš„ï¼Œæ‰€ä»¥ä¸»è¦çœ‹ findUsingReflectionInSingleClass æ–¹æ³•å³å¯ï¼Œä»Žè¯¥æ–¹æ³•åå¯çŸ¥æ˜¯é€šè¿‡åå°„æ“ä½œæ¥è¿›è¡Œè§£æžçš„ã€‚è§£æžç»“æžœä¼šè¢«å­˜åˆ° findStateä¸­ å› ä¸ºçˆ¶ç±»æ³¨å†Œçš„ç›‘å¬æ–¹æ³•ä¼šè¢«å­ç±»ç»§æ‰¿åˆ°ï¼Œè€Œè§£æžè¿‡ç¨‹æ˜¯ä¼šä»Žå­ç±»å‘å…¶çˆ¶ç±»ä¾æ¬¡éåŽ†çš„ï¼Œæ‰€ä»¥åœ¨è§£æžå®Œå­ç±»åŽéœ€è¦é€šè¿‡ findState.moveToSuperclass() æ–¹æ³•å°†ä¸‹ä¸€ä¸ªæŸ¥æ‰¾çš„ class å¯¹è±¡æŒ‡å‘çˆ¶ç±» 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 private static final int POOL_SIZE = 4; private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; //æ­¥éª¤1 FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; //æ­¥éª¤2 findUsingReflectionInSingleClass(findState); &#125; //æ­¥éª¤3 findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125;private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) &#123; List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods); findState.recycle(); synchronized (FIND_STATE_POOL) &#123; //å›žæ”¶ findStateï¼Œå°è¯•å°†ä¹‹å­˜åˆ°å¯¹è±¡æ± ä¸­ for (int i = 0; i &lt; POOL_SIZE; i++) &#123; if (FIND_STATE_POOL[i] == null) &#123; FIND_STATE_POOL[i] = findState; break; &#125; &#125; &#125; return subscriberMethods; &#125;//å¦‚æžœå¯¹è±¡æ± ä¸­æœ‰å¯ç”¨çš„å¯¹è±¡åˆ™å–å‡ºæ¥ä½¿ç”¨ï¼Œå¦åˆ™çš„è¯å°±æž„å»ºä¸€ä¸ªæ–°çš„ private FindState prepareFindState() &#123; synchronized (FIND_STATE_POOL) &#123; for (int i = 0; i &lt; POOL_SIZE; i++) &#123; FindState state = FIND_STATE_POOL[i]; if (state != null) &#123; FIND_STATE_POOL[i] = null; return state; &#125; &#125; &#125; return new FindState(); &#125; è¿™é‡Œæ¥ä¸»è¦çœ‹ä¸‹ findUsingReflectionInSingleClass æ–¹æ³•æ˜¯å¦‚ä½•å®Œæˆåå°„æ“ä½œçš„ã€‚å¦‚æžœè§£æžåˆ°çš„æ–¹æ³•ç­¾åä¸ç¬¦åˆè¦æ±‚ï¼Œåˆ™ä¼šåœ¨å¼€å¯äº†ä¸¥æ ¼æ£€æŸ¥çš„æƒ…å†µä¸‹ä¼šç›´æŽ¥æŠ›å‡ºå¼‚å¸¸ï¼›å¦‚æžœæ–¹æ³•ç­¾åç¬¦åˆè¦æ±‚ï¼Œåˆ™ä¼šå°†æ–¹æ³•ç­¾åä¿å­˜åˆ°subscriberMethodsä¸­ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private void findUsingReflectionInSingleClass(FindState findState) &#123; Method[] methods; try &#123; // This is faster than getMethods, especially when subscribers are fat classes like Activities //èŽ·å– clazz åŒ…å«çš„æ‰€æœ‰æ–¹æ³•ï¼Œä¸åŒ…å«ç»§æ‰¿å¾—æ¥çš„æ–¹æ³• methods = findState.clazz.getDeclaredMethods(); &#125; catch (Throwable th) &#123; // Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149 try &#123; //èŽ·å– clazz ä»¥åŠå…¶çˆ¶ç±»çš„æ‰€æœ‰ public æ–¹æ³• methods = findState.clazz.getMethods(); &#125; catch (LinkageError error) &#123; // super class of NoClassDefFoundError to be a bit more broad... String msg = "Could not inspect methods of " + findState.clazz.getName(); if (ignoreGeneratedIndex) &#123; msg += ". Please consider using EventBus annotation processor to avoid reflection."; &#125; else &#123; msg += ". Please make this class visible to EventBus annotation processor to avoid reflection."; &#125; throw new EventBusException(msg, error); &#125; //ç”±äºŽ getDeclaredMethods() éƒ½æŠ›å‡ºå¼‚å¸¸äº†ï¼Œå°±ä¸å†ç»§ç»­å‘ä¸‹å¾ªçŽ¯äº†ï¼Œæ‰€ä»¥æŒ‡å®šä¸‹æ¬¡å¾ªçŽ¯æ—¶å¿½ç•¥çˆ¶ç±» findState.skipSuperClasses = true; &#125; for (Method method : methods) &#123; int modifiers = method.getModifiers(); if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) &#123; //method æ˜¯ public çš„ï¼Œä¸”ä¸æ˜¯ ABSTRACTã€STATICã€BRIDGEã€SYNTHETIC Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (parameterTypes.length == 1) &#123; //æ–¹æ³•åŒ…å«çš„å‚æ•°ä¸ªæ•°æ˜¯ä¸€ Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class); if (subscribeAnnotation != null) &#123; //æ–¹æ³•ç­¾ååŒ…å« Subscribe æ³¨è§£ Class&lt;?&gt; eventType = parameterTypes[0]; if (findState.checkAdd(method, eventType)) &#123; //æ ¡éªŒé€šè¿‡åŽï¼Œå°±å°† Subscribe æ³¨è§£çš„é…ç½®ä¿¡æ¯åŠ method æ–¹æ³•ç­¾åä¿å­˜èµ·æ¥ ThreadMode threadMode = subscribeAnnotation.threadMode(); findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(), subscribeAnnotation.sticky())); &#125; &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; //å› ä¸º EventBus åªæ”¯æŒåŒ…å«ä¸€ä¸ªå…¥å‚å‚æ•°çš„æ³¨è§£å‡½æ•°ï¼Œæ‰€ä»¥å¦‚æžœå¼€å¯äº†ä¸¥æ ¼çš„æ–¹æ³•æ ¡éªŒé‚£ä¹ˆå°±æŠ›å‡ºå¼‚å¸¸ String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException("@Subscribe method " + methodName + "must have exactly 1 parameter but has " + parameterTypes.length); &#125; &#125; else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123; //å¦‚æžœ method çš„æ–¹æ³•ç­¾åä¸ç¬¦åˆè¦æ±‚ä¸”å¼€å¯äº†ä¸¥æ ¼çš„æ–¹æ³•æ ¡éªŒé‚£ä¹ˆå°±æŠ›å‡ºå¼‚å¸¸ String methodName = method.getDeclaringClass().getName() + "." + method.getName(); throw new EventBusException(methodName + " is a illegal @Subscribe method: must be public, non-static, and non-abstract"); &#125; &#125; &#125; SubscriberMethodFinder.FindStatefindUsingReflectionInSingleClassæ–¹æ³•çš„ä¸€ä¸ªé‡ç‚¹æ˜¯ findState.checkAddæ–¹æ³•ã€‚å¦‚æžœå¾€ç®€å•äº†æƒ³ï¼Œåªè¦æŠŠæ³¨å†Œç±»æ¯ä¸ªå£°æ˜Žäº† Subscribe æ³¨è§£çš„æ–¹æ³•éƒ½ç»™ä¿å­˜èµ·æ¥å°±å¯ä»¥äº†ï¼Œå¯æ˜¯è¿˜éœ€è¦è€ƒè™‘ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼š Java ä¸­ç±»æ˜¯å¯ä»¥æœ‰ç»§æ‰¿å…³ç³»çš„ï¼Œå¦‚æžœçˆ¶ç±»å£°æ˜Žäº† Subscribe æ–¹æ³•ï¼Œé‚£ä¹ˆå°±ç›¸å½“äºŽå­ç±»ä¹ŸæŒæœ‰äº†è¯¥ç›‘å¬æ–¹æ³•ï¼Œé‚£ä¹ˆå­ç±»åœ¨ register åŽå°±éœ€è¦æ‹¿åˆ°çˆ¶ç±»çš„æ‰€æœ‰ Subscribe æ–¹æ³• å¦‚æžœå­ç±»ç»§æ‰¿å¹¶é‡å†™äº†çˆ¶ç±»çš„ Subscribe æ–¹æ³•ï¼Œé‚£ä¹ˆå­ç±»åœ¨ register åŽå°±éœ€è¦ä»¥è‡ªå·±é‡å†™åŽçš„æ–¹æ³•ä¸ºå‡†ï¼Œå¿½ç•¥çˆ¶ç±»çš„ç›¸åº”æ–¹æ³• checkAdd æ–¹æ³•å°±ç”¨äºŽè¿›è¡Œä¸Šè¿°åˆ¤æ–­ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//ä»¥ eventType ä½œä¸º keyï¼Œmethod æˆ–è€… FindState ä½œä¸º value final Map&lt;Class, Object&gt; anyMethodByEventType = new HashMap&lt;&gt;(); //ä»¥ methodKey ä½œä¸º keyï¼ŒmethodClass ä½œä¸º value final Map&lt;String, Class&gt; subscriberClassByMethodKey = new HashMap&lt;&gt;(); boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required. // Usually a subscriber doesn't have methods listening to the same event type. Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; //existing ç­‰äºŽ null è¯´æ˜Žä¹‹å‰æœªè§£æžåˆ°ç›‘å¬ç›¸åŒäº‹ä»¶çš„æ–¹æ³•ï¼Œæ£€æŸ¥é€šè¿‡ //å› ä¸ºå¤§éƒ¨åˆ†æƒ…å†µä¸‹ç›‘å¬è€…ä¸ä¼šå£°æ˜Žå¤šä¸ªç›‘å¬ç›¸åŒäº‹ä»¶çš„æ–¹æ³•ï¼Œæ‰€ä»¥å…ˆè¿›è¡Œè¿™æ­¥æ£€æŸ¥æ•ˆçŽ‡ä¸Šä¼šæ¯”è¾ƒé«˜ return true; &#125; else &#123; //existing ä¸ç­‰äºŽ null è¯´æ˜Žä¹‹å‰å·²ç»è§£æžåˆ°åŒæ ·ç›‘å¬è¿™ä¸ªäº‹ä»¶çš„æ–¹æ³•äº† if (existing instanceof Method) &#123; if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; // Put any non-Method object to "consume" the existing Method //ä¼šæ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜Žå­˜åœ¨å¤šä¸ªæ–¹æ³•ç›‘å¬åŒä¸ª Eventï¼Œé‚£ä¹ˆå°†å°† eventType å¯¹åº”çš„ value ç½®ä¸º this //é¿å…å¤šæ¬¡æ£€æŸ¥ï¼Œè®©å…¶ç›´æŽ¥åŽ»æ‰§è¡Œ checkAddWithMethodSignature æ–¹æ³• anyMethodByEventType.put(eventType, this); &#125; return checkAddWithMethodSignature(method, eventType); &#125; &#125; private boolean checkAddWithMethodSignature(Method method, Class&lt;?&gt; eventType) &#123; methodKeyBuilder.setLength(0); methodKeyBuilder.append(method.getName()); methodKeyBuilder.append('&gt;').append(eventType.getName()); //ä»¥ methodName&gt;eventTypeName å­—ç¬¦ä¸²ä½œä¸º key //é€šè¿‡è¿™ä¸ª key æ¥åˆ¤æ–­æ˜¯å¦å­˜åœ¨å­ç±»é‡å†™äº†çˆ¶ç±»æ–¹æ³•çš„æƒ…å†µ String methodKey = methodKeyBuilder.toString(); //èŽ·å–å£°æ˜Žäº† method çš„ç±»å¯¹åº”çš„ class å¯¹è±¡ Class&lt;?&gt; methodClass = method.getDeclaringClass(); Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass); //1. å¦‚æžœ methodClassOld == null ä¸º trueï¼Œè¯´æ˜Ž method æ˜¯ç¬¬ä¸€æ¬¡è§£æžåˆ°ï¼Œå…è®¸æ·»åŠ  //2. å¦‚æžœ methodClassOld.isAssignableFrom(methodClass) ä¸º true //2.1ã€è¯´æ˜Ž methodClassOld æ˜¯ methodClass çš„çˆ¶ç±»ï¼Œéœ€è¦ä»¥å­ç±»é‡å†™çš„æ–¹æ³• method ä¸ºå‡†ï¼Œå…è®¸æ·»åŠ  // å®žé™…ä¸Šåº”è¯¥ä¸å­˜åœ¨è¿™ç§æƒ…å†µï¼Œå› ä¸º EventBus æ˜¯ä»Žå­ç±»å¼€å§‹å‘çˆ¶ç±»è¿›è¡ŒéåŽ†çš„ //2.2ã€è¯´æ˜Ž methodClassOld æ˜¯ methodClass æ˜¯åŒä¸ªç±»ï¼Œå³ methodClass å£°æ˜Žäº†å¤šä¸ªæ–¹æ³•å¯¹åŒä¸ªäº‹ä»¶è¿›è¡Œç›‘å¬ ï¼Œä¹Ÿå…è®¸æ·»åŠ  if (methodClassOld == null || methodClassOld.isAssignableFrom(methodClass)) &#123; // Only add if not already found in a sub class return true; &#125; else &#123; // Revert the put, old class is further down the class hierarchy //ç”±äºŽ EventBus æ˜¯ä»Žå­ç±»å‘çˆ¶ç±»è¿›è¡Œè§£æž //ä¼šæ‰§è¡Œåˆ°è¿™é‡Œå°±è¯´æ˜Žä¹‹å‰å·²ç»è§£æžåˆ°äº†ç›¸åŒ key çš„æ–¹æ³•ï¼Œå¯¹åº”å­ç±»é‡å†™äº†çˆ¶ç±»æ–¹æ³•çš„æƒ…å†µ //æ­¤æ—¶éœ€è¦ä»¥å­ç±»é‡å†™çš„æ–¹æ³• method ä¸ºå‡†ï¼Œæ‰€ä»¥åˆå°† methodClassOld é‡æ–°è®¾å›žåŽ» subscriberClassByMethodKey.put(methodKey, methodClassOld); return false; &#125; &#125; EventBus.javaè¿›è¡Œä¸Šè¿°æ“ä½œåŽï¼Œå°±æ‹¿åˆ°äº†æ³¨å†Œç±»æ‰€æœ‰çš„åŒ…å«äº†æ³¨è§£å£°æ˜Žçš„æ–¹æ³•äº†ï¼Œè¿™äº›æ–¹æ³•éƒ½ä¼šä¿å­˜åˆ° List&lt;SubscriberMethod&gt; ä¸­ã€‚æ‹¿åˆ°æ‰€æœ‰æ–¹æ³•åŽï¼Œå°±éœ€è¦å¯¹æ³¨å†Œè€…åŠå…¶æ‰€æœ‰ç›‘å¬æ–¹æ³•è¿›è¡Œå½’ç±»äº† å½’ç±»çš„ç›®çš„æ˜¯æ—¢æ˜¯ä¸ºäº†æ–¹ä¾¿åŽç»­æ“ä½œä¹Ÿæ˜¯ä¸ºäº†æé«˜æ•ˆçŽ‡ã€‚ å› ä¸ºåœ¨åŒä¸ªé¡µé¢æˆ–è€…å¤šä¸ªé¡µé¢é—´å¯èƒ½å­˜åœ¨å¤šä¸ªå¯¹åŒç§ç±»åž‹æ¶ˆæ¯çš„ç›‘å¬æ–¹æ³•ï¼Œé‚£ä¹ˆå°±éœ€è¦å°†æ¯ç§æ¶ˆæ¯ç±»åž‹å’Œå…¶å½“å‰çš„æ‰€æœ‰ç›‘å¬æ–¹æ³•å¯¹åº”èµ·æ¥ï¼Œæé«˜æ¶ˆæ¯çš„å‘é€æ•ˆçŽ‡ã€‚è€Œä¸”åœ¨ subscriber è§£é™¤æ³¨å†Œæ—¶ï¼Œä¹Ÿéœ€è¦å°† subscriber åŒ…å«çš„æ‰€æœ‰ç›‘å¬æ–¹æ³•éƒ½ç»™ç§»é™¤æŽ‰ï¼Œé‚£ä¹ˆå°±éœ€è¦é¢„å…ˆè¿›è¡Œå½’ç±»ã€‚ç›‘å¬æ–¹æ³•ä¹Ÿå¯ä»¥è®¾å®šè‡ªå·±å¯¹æ¶ˆæ¯å¤„ç†çš„ä¼˜å…ˆçº§é¡ºåºï¼Œæ‰€ä»¥éœ€è¦é¢„å…ˆå¯¹ç›‘å¬æ–¹æ³•è¿›è¡ŒæŽ’åº 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType; private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber; // Must be called in synchronized block private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Class&lt;?&gt; eventType = subscriberMethod.eventType; Subscription newSubscription = new Subscription(subscriber, subscriberMethod); //subscriptionsByEventType ä»¥æ¶ˆæ¯ç±»åž‹ eventType ä½œä¸º keyï¼Œvalue å­˜å‚¨äº†æ‰€æœ‰å¯¹è¯¥ eventType çš„è®¢é˜…è€…ï¼Œæé«˜åŽç»­åœ¨å‘é€æ¶ˆæ¯æ—¶çš„æ•ˆçŽ‡ CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions); &#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; //è¯´æ˜ŽæŸä¸ª Subscriber é‡å¤æ³¨å†Œäº† throw new EventBusException("Subscriber " + subscriber.getClass() + " already registered to event " + eventType); &#125; &#125; //å°†è®¢é˜…è€…æ ¹æ®æ¶ˆæ¯ä¼˜å…ˆçº§é«˜ä½Žè¿›è¡ŒæŽ’åº int size = subscriptions.size(); for (int i = 0; i &lt;= size; i++) &#123; if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123; subscriptions.add(i, newSubscription); break; &#125; &#125; //typesBySubscriber ä»¥è®¢é˜…è€… subscriber ä½œä¸º keyï¼Œvalue å­˜å‚¨äº†å…¶è®¢é˜…çš„æ‰€æœ‰ eventType //ç”¨äºŽå‘å¤–æä¾›æŸä¸ªç±»æ˜¯å¦å·²æ³¨å†Œçš„åŠŸèƒ½ï¼Œä¹Ÿæ–¹ä¾¿åŽç»­åœ¨ unregister æ—¶ç§»é™¤ subscriber ä¸‹çš„æ‰€æœ‰ç›‘å¬æ–¹æ³• List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; subscribedEvents.add(eventType); //ä¸‹é¢æ˜¯å…³äºŽç²˜æ€§äº‹ä»¶çš„å¤„ç†ï¼ŒåŽç»­å†è¿›è¡Œä»‹ç» if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; äºŒã€å‘é€æ¶ˆæ¯1ã€æ¶ˆæ¯çš„æ‰§è¡Œç­–ç•¥åœ¨ä»‹ç»æ¶ˆæ¯çš„å…·ä½“å‘é€æ­¥éª¤å‰ï¼Œå…ˆæ¥äº†è§£ä¸‹ EventBus å‡ ç§ä¸åŒçš„æ¶ˆæ¯æ‰§è¡Œç­–ç•¥ã€‚æ‰§è¡Œç­–ç•¥ç”±æžšä¸¾ ThreadMode æ¥æ‰§è¡Œï¼Œåœ¨ Subscribe æ³¨è§£ä¸­è¿›è¡Œå£°æ˜Žã€‚æ‰§è¡Œç­–ç•¥å†³å®šäº†æ¶ˆæ¯æŽ¥æ”¶æ–¹æ˜¯åœ¨å“ªä¸€ä¸ªçº¿ç¨‹æŽ¥æ”¶åˆ°æ¶ˆæ¯çš„ ThreadMode æ‰§è¡Œçº¿ç¨‹ POSTING åœ¨å‘é€äº‹ä»¶çš„çº¿ç¨‹ä¸­æ‰§è¡Œ ç›´æŽ¥è°ƒç”¨æ¶ˆæ¯æŽ¥æ”¶æ–¹ MAIN åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œ å¦‚æžœäº‹ä»¶å°±æ˜¯åœ¨ä¸»çº¿ç¨‹å‘é€çš„ï¼Œåˆ™ç›´æŽ¥è°ƒç”¨æ¶ˆæ¯æŽ¥æ”¶æ–¹ï¼Œå¦åˆ™é€šè¿‡ mainThreadPoster è¿›è¡Œå¤„ç† MAIN_ORDERED åœ¨ä¸»çº¿ç¨‹ä¸­æŒ‰é¡ºåºæ‰§è¡Œ é€šè¿‡ mainThreadPoster è¿›è¡Œå¤„ç†ï¼Œä»¥æ­¤ä¿è¯æ¶ˆæ¯å¤„ç†çš„æœ‰åºæ€§ BACKGROUND åœ¨åŽå°çº¿ç¨‹ä¸­æŒ‰é¡ºåºæ‰§è¡Œ å¦‚æžœäº‹ä»¶æ˜¯åœ¨ä¸»çº¿ç¨‹å‘é€çš„ï¼Œåˆ™æäº¤ç»™ backgroundPoster å¤„ç†ï¼Œå¦åˆ™ç›´æŽ¥è°ƒç”¨æ¶ˆæ¯æŽ¥æ”¶æ–¹ï¼Œç”¨synchronizeå’Œflagä¿æŒåªæœ‰ä¸€ä¸ªä»»åŠ¡åœ¨æ‰§è¡Œ ASYNC æäº¤ç»™ç©ºé—²çš„åŽå°çº¿ç¨‹æ‰§è¡Œ å°†æ¶ˆæ¯æäº¤åˆ° asyncPoster è¿›è¡Œå¤„ç† æ‰§è¡Œç­–ç•¥çš„å…·ä½“ç»†åˆ†é€»è¾‘æ˜¯åœ¨ postToSubscription æ–¹æ³•å®Œæˆçš„ 12345678910111213141516171819202122232425262728293031323334private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) &#123; switch (subscription.subscriberMethod.threadMode) &#123; case POSTING: invokeSubscriber(subscription, event); break; case MAIN: if (isMainThread) &#123; invokeSubscriber(subscription, event); &#125; else &#123; mainThreadPoster.enqueue(subscription, event); &#125; break; case MAIN_ORDERED: if (mainThreadPoster != null) &#123; mainThreadPoster.enqueue(subscription, event); &#125; else &#123; // temporary: technically not correct as poster not decoupled from subscriber invokeSubscriber(subscription, event); &#125; break; case BACKGROUND: if (isMainThread) &#123; backgroundPoster.enqueue(subscription, event); &#125; else &#123; invokeSubscriber(subscription, event); &#125; break; case ASYNC: asyncPoster.enqueue(subscription, event); break; default: throw new IllegalStateException("Unknown thread mode: " + subscription.subscriberMethod.threadMode); &#125; &#125; ä¾‹å¦‚ï¼Œå¯¹äºŽ AsyncPoster æ¥è¯´ï¼Œå…¶æ¯æŽ¥æ”¶åˆ°ä¸€ä¸ªæ¶ˆæ¯ï¼Œéƒ½ä¼šç›´æŽ¥åœ¨ enqueue æ–¹æ³•ä¸­å°†è‡ªå·±ï¼ˆRunnableï¼‰æäº¤ç»™çº¿ç¨‹æ± è¿›è¡Œå¤„ç†ï¼Œè€Œä½¿ç”¨çš„çº¿ç¨‹æ± é»˜è®¤æ˜¯ Executors.newCachedThreadPool()ï¼Œè¯¥çº¿ç¨‹æ± æ¯æŽ¥æ”¶åˆ°ä¸€ä¸ªä»»åŠ¡éƒ½ä¼šé©¬ä¸Šäº¤ç”±çº¿ç¨‹è¿›è¡Œå¤„ç†ï¼Œæ‰€ä»¥ AsyncPosterå¹¶ä¸ä¿è¯æ¶ˆæ¯å¤„ç†çš„æœ‰åºæ€§ï¼Œä½†åœ¨æ¶ˆæ¯å¤„ç†çš„åŠæ—¶æ€§æ–¹é¢ä¼šæ¯”è¾ƒé«˜ï¼Œä¸”æ¯æ¬¡æäº¤ç»™ AsyncPoster çš„æ¶ˆæ¯å¯èƒ½éƒ½æ˜¯ç”±ä¸åŒçš„çº¿ç¨‹æ¥å¤„ç† 1234567891011121314151617181920212223242526class AsyncPoster implements Runnable, Poster &#123; private final PendingPostQueue queue; private final EventBus eventBus; AsyncPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); queue.enqueue(pendingPost); eventBus.getExecutorService().execute(this); &#125; @Override public void run() &#123; PendingPost pendingPost = queue.poll(); if(pendingPost == null) &#123; throw new IllegalStateException("No pending post available"); &#125; eventBus.invokeSubscriber(pendingPost); &#125;&#125; è€Œ BackgroundPoster åªä¼šåœ¨å½“å‰è‡ªå·±å¹¶æ²¡æœ‰æ­£åœ¨å¤„ç†æ¶ˆæ¯çš„æƒ…å†µä¸‹æ‰ä¼šå°†è‡ªå·±ï¼ˆRunnableï¼‰æäº¤ç»™çº¿ç¨‹æ± è¿›è¡Œå¤„ç†ï¼Œæ‰€ä»¥ BackgroundPoster ä¼šä¿è¯æ¶ˆæ¯é˜Ÿåˆ—åœ¨å¤„ç†æ—¶çš„æœ‰åºæ€§ï¼Œä½†åœ¨æ¶ˆæ¯å¤„ç†çš„åŠæ—¶æ€§æ–¹é¢ç›¸æ¯” AsyncPoster è¦ä½Žä¸€äº› 12345678910111213141516171819202122232425final class BackgroundPoster implements Runnable, Poster &#123; private final PendingPostQueue queue; private final EventBus eventBus; private volatile boolean executorRunning; BackgroundPoster(EventBus eventBus) &#123; this.eventBus = eventBus; queue = new PendingPostQueue(); &#125; public void enqueue(Subscription subscription, Object event) &#123; PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event); synchronized (this) &#123; queue.enqueue(pendingPost); if (!executorRunning) &#123; executorRunning = true; eventBus.getExecutorService().execute(this); &#125; &#125; &#125; Â·Â·Â·&#125; è€Œä¸ç®¡æ˜¯ä½¿ç”¨ä»€ä¹ˆæ¶ˆæ¯å¤„ç†ç­–ç•¥ï¼Œæœ€ç»ˆéƒ½æ˜¯é€šè¿‡è°ƒç”¨ä»¥ä¸‹æ–¹æ³•æ¥å®Œæˆç›‘å¬æ–¹æ³•çš„åå°„è°ƒç”¨ 123456789101112131415161718void invokeSubscriber(PendingPost pendingPost) &#123; Object event = pendingPost.event; Subscription subscription = pendingPost.subscription; PendingPost.releasePendingPost(pendingPost); if (subscription.active) &#123; invokeSubscriber(subscription, event); &#125;&#125;void invokeSubscriber(Subscription subscription, Object event) &#123; try &#123; subscription.subscriberMethod.method.invoke(subscription.subscriber, event); &#125; catch (InvocationTargetException e) &#123; handleSubscriberException(subscription, event, e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new IllegalStateException("Unexpected exception", e); &#125;&#125; 2ã€å‘é€éžé»æ€§æ¶ˆæ¯EventBus.getDefault().post(Any)æ–¹æ³•ç”¨äºŽå‘é€éžé»æ€§æ¶ˆæ¯ã€‚EventBus ä¼šé€šè¿‡ ThreadLocal ä¸ºæ¯ä¸ªå‘é€æ¶ˆæ¯çš„çº¿ç¨‹ç»´æŠ¤ä¸€ä¸ª PostingThreadState å¯¹è±¡ï¼Œç”¨äºŽä¸ºæ¯ä¸ªçº¿ç¨‹ç»´æŠ¤ä¸€ä¸ªæ¶ˆæ¯é˜Ÿåˆ—åŠå…¶å®ƒè¾…åŠ©å‚æ•° 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * For ThreadLocal, much faster to set (and get multiple values). */ final static class PostingThreadState &#123; final List&lt;Object&gt; eventQueue = new ArrayList&lt;&gt;(); boolean isPosting; boolean isMainThread; Subscription subscription; Object event; boolean canceled; &#125; private final ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal&lt;PostingThreadState&gt;() &#123; @Override protected PostingThreadState initialValue() &#123; return new PostingThreadState(); &#125; &#125;; /** * Posts the given event to the event bus. */ public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; //å°†æ¶ˆæ¯æ·»åŠ åˆ°æ¶ˆæ¯é˜Ÿåˆ— eventQueue.add(event); if (!postingState.isPosting) &#123; //æ˜¯å¦åœ¨ä¸»çº¿ç¨‹å‘é€çš„æ¶ˆæ¯ postingState.isMainThread = isMainThread(); //æ ‡è®°å½“å‰æ­£åœ¨å‘é€æ¶ˆæ¯ä¸­ postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException("Internal error. Abort state was not reset"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125; æ¯æ¬¡ post è¿›æ¥çš„æ¶ˆæ¯éƒ½ä¼šå…ˆå­˜åˆ°æ¶ˆæ¯é˜Ÿåˆ— eventQueueä¸­ï¼Œç„¶åŽé€šè¿‡ while å¾ªçŽ¯è¿›è¡Œå¤„ç†ï¼Œæ¶ˆæ¯å¤„ç†é€»è¾‘æ˜¯é€šè¿‡ postSingleEventæ–¹æ³•æ¥å®Œæˆçš„ å…¶ä¸»è¦é€»è¾‘æ˜¯ï¼š å‡è®¾ EventA ç»§æ‰¿äºŽ EventBï¼Œé‚£ä¹ˆå½“å‘é€çš„æ¶ˆæ¯ç±»åž‹æ˜¯ EventA æ—¶ï¼Œå°±éœ€è¦è€ƒè™‘ EventB çš„ç›‘å¬æ–¹æ³•æ˜¯å¦å¯ä»¥æŽ¥æ”¶åˆ° EventAï¼Œå³éœ€è¦è€ƒè™‘æ¶ˆæ¯ç±»åž‹æ˜¯å¦å…·æœ‰ç»§æ‰¿å…³ç³» å…·æœ‰ç»§æ‰¿å…³ç³»ã€‚æ­¤æ—¶å°±éœ€è¦æ‹¿åˆ° EventA çš„æ‰€æœ‰çˆ¶ç±»åž‹ï¼Œç„¶åŽæ ¹æ® EventA æœ¬èº«å’Œå…¶çˆ¶ç±»åž‹å…³è”åˆ°çš„æ‰€æœ‰ç›‘å¬æ–¹æ³•ä¾æ¬¡è¿›è¡Œæ¶ˆæ¯å‘é€ ä¸å…·æœ‰ç»§æ‰¿å…³ç³»ã€‚æ­¤æ—¶åªéœ€è¦å‘ EventA çš„ç›‘å¬æ–¹æ³•è¿›è¡Œæ¶ˆæ¯å‘é€å³å¯ å¦‚æžœå‘é€çš„æ¶ˆæ¯æœ€ç»ˆæ²¡æœ‰æ‰¾åˆ°ä»»ä½•æŽ¥æ”¶è€…ï¼Œä¸” sendNoSubscriberEvent ä¸º trueï¼Œé‚£ä¹ˆå°±ä¸»åŠ¨å‘é€ä¸€ä¸ª NoSubscriberEvent äº‹ä»¶ï¼Œç”¨äºŽå‘å¤–é€šçŸ¥æ¶ˆæ¯æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æŽ¥æ”¶è€… ç›‘å¬æ–¹æ³•ä¹‹é—´å¯ä»¥è®¾å®šæ¶ˆæ¯å¤„ç†çš„ä¼˜å…ˆçº§é«˜ä½Žï¼Œé«˜ä¼˜å…ˆçº§çš„æ–¹æ³•å¯ä»¥é€šè¿‡è°ƒç”¨ cancelEventDelivery æ–¹æ³•æ¥æ‹¦æˆªäº‹ä»¶ï¼Œä¸å†ç»§ç»­å‘ä¸‹å‘é€ã€‚ä½†åªæœ‰åœ¨ POSTING æ¨¡å¼ä¸‹æ‰èƒ½æ‹¦æˆªäº‹ä»¶ï¼Œå› ä¸ºåªæœ‰åœ¨è¿™ä¸ªæ¨¡å¼ä¸‹æ‰èƒ½ä¿è¯ç›‘å¬æ–¹æ³•æ˜¯æŒ‰ç…§ä¸¥æ ¼çš„å…ˆåŽé¡ºåºè¢«æ‰§è¡Œçš„ æœ€ç»ˆï¼Œå‘é€çš„æ¶ˆæ¯éƒ½ä¼šé€šè¿‡ postToSubscriptionæ–¹æ³•æ¥å®Œæˆï¼Œæ ¹æ®æŽ¥æ”¶è€…æ–¹æ³•ä¸åŒçš„å¤„ç†ç­–ç•¥è¿›è¡Œå¤„ç† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void postSingleEvent(Object event, PostingThreadState postingState) throws Error &#123; Class&lt;?&gt; eventClass = event.getClass(); //ç”¨äºŽæ ‡è®°æ˜¯å¦æœ‰æ‰¾åˆ°æ¶ˆæ¯çš„æŽ¥æ”¶è€… boolean subscriptionFound = false; if (eventInheritance) &#123; //æ­¥éª¤2 List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass); int countTypes = eventTypes.size(); for (int h = 0; h &lt; countTypes; h++) &#123; Class&lt;?&gt; clazz = eventTypes.get(h); subscriptionFound |= postSingleEventForEventType(event, postingState, clazz); &#125; &#125; else &#123; //æ­¥éª¤3 subscriptionFound = postSingleEventForEventType(event, postingState, eventClass); &#125; if (!subscriptionFound) &#123; if (logNoSubscriberMessages) &#123; logger.log(Level.FINE, "No subscribers registered for event " + eventClass); &#125; if (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123; //æ­¥éª¤4 post(new NoSubscriberEvent(this, event)); &#125; &#125; &#125;private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass) &#123; CopyOnWriteArrayList&lt;Subscription&gt; subscriptions; synchronized (this) &#123; //æ‰¾åˆ°æ‰€æœ‰ç›‘å¬è€… subscriptions = subscriptionsByEventType.get(eventClass); &#125; if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) &#123; for (Subscription subscription : subscriptions) &#123; postingState.event = event; postingState.subscription = subscription; boolean aborted; try &#123; postToSubscription(subscription, event, postingState.isMainThread); aborted = postingState.canceled; &#125; finally &#123; postingState.event = null; postingState.subscription = null; postingState.canceled = false; &#125; //æ­¥éª¤5 if (aborted) &#123; break; &#125; &#125; return true; &#125; return false; &#125; 3ã€å‘é€é»æ€§æ¶ˆæ¯é»æ€§æ¶ˆæ¯çš„æ„ä¹‰æ˜¯ä¸ºäº†ä½¿å¾—åœ¨æ¶ˆæ¯å‘å‡ºæ¥åŽï¼Œå³ä½¿æ˜¯åŽç»­å†è¿›è¡Œ register çš„ subscriber ä¹Ÿå¯ä»¥æ”¶åˆ°ä¹‹å‰å‘é€çš„æ¶ˆæ¯ï¼Œè¿™éœ€è¦ @Subscribe æ³¨è§£çš„ sticky å±žæ€§è®¾ä¸º trueï¼Œå³è¡¨æ˜Žæ¶ˆæ¯æŽ¥æ”¶æ–¹å¸Œæœ›æŽ¥æ”¶é»æ€§æ¶ˆæ¯ EventBus.getDefault().postSticky(Any)æ–¹æ³•å°±ç”¨äºŽå‘é€é»æ€§æ¶ˆæ¯ã€‚é»æ€§äº‹ä»¶ä¼šè¢«ä¿å­˜åˆ° stickyEvents è¿™ä¸ª Map ä¸­ï¼Œkey æ˜¯ event çš„ Class å¯¹è±¡ï¼Œvalue æ˜¯ event æœ¬èº«ï¼Œè¿™ä¹Ÿè¯´æ˜Žå¯¹äºŽåŒä¸€ç±»åž‹çš„é»æ€§æ¶ˆæ¯æ¥è¯´ï¼Œåªä¼šä¿å­˜å…¶æœ€åŽä¸€ä¸ªæ¶ˆæ¯ 12345678910111213 private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;/** * Posts the given event to the event bus and holds on to the event (because it is sticky). The most recent sticky * event of an event's type is kept in memory for future access by subscribers using &#123;@link Subscribe#sticky()&#125;. */ public void postSticky(Object event) &#123; synchronized (stickyEvents) &#123; stickyEvents.put(event.getClass(), event); &#125; // Should be posted after it is putted, in case the subscriber wants to remove immediately post(event); &#125; å¯¹äºŽä¸€ä¸ªé»æ€§æ¶ˆæ¯ï¼Œä¼šæœ‰ä¸¤ç§ä¸åŒçš„æ—¶æœºè¢« subscriber æŽ¥æ”¶åˆ° è°ƒç”¨ postSticky æ–¹æ³•æ—¶ï¼Œè¢«å…¶çŽ°æœ‰çš„ subscriber ç›´æŽ¥æŽ¥æ”¶åˆ°ï¼Œè¿™ç§æ–¹å¼é€šè¿‡åœ¨ postSticky æ–¹æ³•é‡Œè°ƒç”¨ post æ–¹æ³•æ¥å®žçŽ° è°ƒç”¨ register æ–¹æ³•æ—¶ï¼Œæ–°æ·»åŠ çš„ subscriber ä¼šåˆ¤æ–­ stickyEvents ä¸­æ˜¯å¦å­˜åœ¨å…³è”çš„ event éœ€è¦è¿›è¡Œåˆ†å‘ è¿™é‡Œä¸»è¦çœ‹ç¬¬äºŒç§æƒ…å†µã€‚register æ“ä½œä¼šåœ¨ subscribe æ–¹æ³•é‡Œå®Œæˆé»æ€§äº‹ä»¶çš„åˆ†å‘ã€‚å’Œ post æ“ä½œä¸€æ ·ï¼Œå‘é€é»æ€§äº‹ä»¶æ—¶ä¹Ÿéœ€è¦è€ƒè™‘ event çš„ç»§æ‰¿å…³ç³» 123456789101112131415161718192021222324252627282930313233343536private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) &#123; Â·Â·Â· if (subscriberMethod.sticky) &#123; if (eventInheritance) &#123; // Existing sticky events of all subclasses of eventType have to be considered. // Note: Iterating over all events may be inefficient with lots of sticky events, // thus data structure should be changed to allow a more efficient lookup // (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;). //äº‹ä»¶ç±»åž‹éœ€è¦è€ƒè™‘å…¶ç»§æ‰¿å…³ç³» //å› æ­¤éœ€è¦åˆ¤æ–­æ¯ä¸€ä¸ª stickyEvent çš„çˆ¶ç±»åž‹æ˜¯å¦å­˜åœ¨ç›‘å¬è€…ï¼Œæœ‰çš„è¯å°±éœ€è¦éƒ½è¿›è¡Œå›žè°ƒ Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; //äº‹ä»¶ç±»åž‹ä¸éœ€è¦è€ƒè™‘å…¶ç»§æ‰¿å…³ç³» Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) &#123; if (stickyEvent != null) &#123; // If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) // --&gt; Strange corner case, which we don't take care of here. postToSubscription(newSubscription, stickyEvent, isMainThread()); &#125; &#125; 4ã€ç§»é™¤é»æ€§äº‹ä»¶ç§»é™¤æŒ‡å®šçš„é»æ€§äº‹ä»¶å¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹æ³•æ¥å®žçŽ°ï¼Œéƒ½æ˜¯ç”¨äºŽå°†æŒ‡å®šäº‹ä»¶ä»Ž stickyEvents ä¸­ç§»é™¤ 12345678910111213141516171819202122232425262728/** * Remove and gets the recent sticky event for the given event type. * * @see #postSticky(Object) */ public &lt;T&gt; T removeStickyEvent(Class&lt;T&gt; eventType) &#123; synchronized (stickyEvents) &#123; return eventType.cast(stickyEvents.remove(eventType)); &#125; &#125; /** * Removes the sticky event if it equals to the given event. * * @return true if the events matched and the sticky event was removed. */ public boolean removeStickyEvent(Object event) &#123; synchronized (stickyEvents) &#123; Class&lt;?&gt; eventType = event.getClass(); Object existingEvent = stickyEvents.get(eventType); if (event.equals(existingEvent)) &#123; stickyEvents.remove(eventType); return true; &#125; else &#123; return false; &#125; &#125; &#125; ä¸‰ã€è§£é™¤æ³¨å†Œè§£é™¤æ³¨å†Œçš„ç›®çš„æ˜¯ä¸ºäº†é¿å…å†…å­˜æ³„éœ²ï¼ŒEventBus ä½¿ç”¨äº†å•ä¾‹æ¨¡å¼ï¼Œå¦‚æžœä¸ä¸»åŠ¨è§£é™¤æ³¨å†Œçš„è¯ï¼ŒEventBus å°±ä¼šä¸€ç›´æŒæœ‰æ³¨å†Œå¯¹è±¡ã€‚è§£é™¤æ³¨å†Œçš„æ“ä½œæ˜¯é€šè¿‡ unregisteræ–¹æ³•æ¥å®žçŽ°çš„ï¼Œè¯¥æ–¹æ³•é€»è¾‘ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œåªæ˜¯å°† subscriber ä»¥åŠå…¶å…³è”çš„æ‰€æœ‰ method å¯¹è±¡ä»Žé›†åˆä¸­ç§»é™¤è€Œå·² è€Œæ­¤å¤„è™½ç„¶ä¼šå°†å…³äºŽ subscriber çš„ä¿¡æ¯å‡ç»™ç§»é™¤æŽ‰ï¼Œä½†æ˜¯åœ¨ SubscriberMethodFinder ä¸­çš„é™æ€æˆå‘˜å˜é‡ METHOD_CACHE ä¾ç„¶ä¼šç¼“å­˜ç€å·²ç»æ³¨å†Œè¿‡çš„ subscriber çš„ä¿¡æ¯ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºäº†åœ¨æŸäº›é¡µé¢ä¼šå…ˆåŽå¤šæ¬¡æ³¨å†Œ EventBus æ—¶å¯ä»¥åšåˆ°ä¿¡æ¯å¤ç”¨ï¼Œé¿å…å¤šæ¬¡å¾ªçŽ¯åå°„ 123456789101112131415161718192021222324252627282930313233/** * Unregisters the given subscriber from all event classes. */ public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; logger.log(Level.WARNING, "Subscriber to unregister was not registered before: " + subscriber.getClass()); &#125; &#125; /** * Only updates subscriptionsByEventType, not typesBySubscriber! Caller must update typesBySubscriber. */ private void unsubscribeByEventType(Object subscriber, Class&lt;?&gt; eventType) &#123; List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType); if (subscriptions != null) &#123; int size = subscriptions.size(); for (int i = 0; i &lt; size; i++) &#123; Subscription subscription = subscriptions.get(i); if (subscription.subscriber == subscriber) &#123; subscription.active = false; subscriptions.remove(i); i--; size--; &#125; &#125; &#125; &#125; å››ã€æ³¨è§£å¤„ç†å™¨ä½¿ç”¨æ³¨è§£å¤„ç†å™¨å¯ä»¥é¿å… subscriber è¿›è¡Œæ³¨å†Œæ—¶çš„å¤šæ¬¡å¾ªçŽ¯åå°„æ“ä½œï¼Œæžå¤§æå‡äº† EventBus çš„è¿è¡Œæ•ˆçŽ‡ APT(Annotation Processing Tool) å³æ³¨è§£å¤„ç†å™¨ï¼Œæ˜¯ä¸€ç§æ³¨è§£å¤„ç†å·¥å…·ï¼Œç”¨æ¥åœ¨ç¼–è¯‘æœŸæ‰«æå’Œå¤„ç†æ³¨è§£ï¼Œé€šè¿‡æ³¨è§£æ¥ç”Ÿæˆ Java æ–‡ä»¶ã€‚å³ä»¥æ³¨è§£ä½œä¸ºæ¡¥æ¢ï¼Œé€šè¿‡é¢„å…ˆè§„å®šå¥½çš„ä»£ç ç”Ÿæˆè§„åˆ™æ¥è‡ªåŠ¨ç”Ÿæˆ Java æ–‡ä»¶ã€‚æ­¤ç±»æ³¨è§£æ¡†æž¶çš„ä»£è¡¨æœ‰ ButterKnifeã€Dragger2ã€EventBus ç­‰ Java API å·²ç»æä¾›äº†æ‰«ææºç å¹¶è§£æžæ³¨è§£çš„æ¡†æž¶ï¼Œå¼€å‘è€…å¯ä»¥é€šè¿‡ç»§æ‰¿ AbstractProcessor ç±»æ¥å®žçŽ°è‡ªå·±çš„æ³¨è§£è§£æžé€»è¾‘ã€‚APT çš„åŽŸç†å°±æ˜¯åœ¨æ³¨è§£äº†æŸäº›ä»£ç å…ƒç´ ï¼ˆå¦‚å­—æ®µã€å‡½æ•°ã€ç±»ç­‰ï¼‰åŽï¼Œåœ¨ç¼–è¯‘æ—¶ç¼–è¯‘å™¨ä¼šæ£€æŸ¥ AbstractProcessor çš„å­ç±»ï¼Œå¹¶ä¸”è‡ªåŠ¨è°ƒç”¨å…¶ process() æ–¹æ³•ï¼Œç„¶åŽå°†æ·»åŠ äº†æŒ‡å®šæ³¨è§£çš„æ‰€æœ‰ä»£ç å…ƒç´ ä½œä¸ºå‚æ•°ä¼ é€’ç»™è¯¥æ–¹æ³•ï¼Œå¼€å‘è€…å†æ ¹æ®æ³¨è§£å…ƒç´ åœ¨ç¼–è¯‘æœŸè¾“å‡ºå¯¹åº”çš„ Java ä»£ç  å…³äºŽ APT æŠ€æœ¯çš„åŽŸç†å’Œåº”ç”¨å¯ä»¥çœ‹è¿™ç¯‡æ–‡ç« ï¼šAndroid APT å®žä¾‹è®²è§£ åœ¨ Kotlin çŽ¯å¢ƒå¼•å…¥æ³¨è§£å¤„ç†å™¨çš„æ–¹æ³•å¦‚ä¸‹æ‰€ç¤ºï¼š 123456789101112apply plugin: 'kotlin-kapt'kapt &#123; arguments &#123; arg('eventBusIndex', 'github.leavesc.demo.MyEventBusIndex') &#125;&#125;dependencies &#123; implementation "org.greenrobot:eventbus:3.2.0" kapt "org.greenrobot:eventbus-annotation-processor:3.2.0"&#125; å½“ä¸­ï¼Œgithub.leavesc.demo.MyEventBusIndex å°±æ˜¯ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶çš„åŒ…åè·¯å¾„ï¼Œå¯ä»¥ç”±æˆ‘ä»¬è‡ªå·±å®šä¹‰ åŽŸå§‹æ–‡ä»¶ï¼š 123456789101112131415161718192021222324/** * ä½œè€…ï¼šleavesC * æ—¶é—´ï¼š2020/10/01 12:17 * æè¿°ï¼š * GitHubï¼šhttps://github.com/leavesC */class MainActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) &#125; @Subscribe fun fun1(msg: String) &#123; &#125; @Subscribe(threadMode = ThreadMode.MAIN, priority = 100) fun fun2(msg: String) &#123; &#125;&#125; ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶å¦‚ä¸‹æ‰€ç¤ºã€‚å¯ä»¥çœ‹å‡ºï¼ŒMyEventBusIndex æ–‡ä»¶ä¸­å°è£…äº† subscriber å’Œå…¶æ‰€æœ‰ç›‘å¬æ–¹æ³•çš„ç­¾åä¿¡æ¯ï¼Œè¿™æ ·æˆ‘ä»¬å°±æ— éœ€åœ¨è¿è¡Œæ—¶å†æ¥è¿›è¡Œè§£æžäº†ï¼Œè€Œæ˜¯ç›´æŽ¥åœ¨ç¼–è¯‘é˜¶æ®µå°±æ‹¿åˆ°äº† 12345678910111213141516171819202122232425262728/** This class is generated by EventBus, do not edit. */public class MyEventBusIndex implements SubscriberInfoIndex &#123; private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX; static &#123; SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;(); putIndex(new SimpleSubscriberInfo(MainActivity.class, true, new SubscriberMethodInfo[] &#123; new SubscriberMethodInfo("fun1", String.class), new SubscriberMethodInfo("fun2", String.class, ThreadMode.MAIN, 100, false), &#125;)); &#125; private static void putIndex(SubscriberInfo info) &#123; SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info); &#125; @Override public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123; SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass); if (info != null) &#123; return info; &#125; else &#123; return null; &#125; &#125;&#125; éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨ç”Ÿæˆäº†è¾…åŠ©æ–‡ä»¶åŽï¼Œè¿˜éœ€è¦é€šè¿‡è¿™äº›ç±»æ–‡ä»¶æ¥åˆå§‹åŒ– EventBus 1EventBus.builder().addIndex(MyEventBusIndex()).installDefaultEventBus(); æ³¨å…¥çš„è¾…åŠ©æ–‡ä»¶ä¼šè¢«ä¿å­˜åˆ° SubscriberMethodFinder ç±»çš„æˆå‘˜å˜é‡ subscriberInfoIndexes ä¸­ï¼ŒfindUsingInfo æ–¹æ³•ä¼šå…ˆå°è¯•ä»Žè¾…åŠ©æ–‡ä»¶ä¸­èŽ·å– SubscriberMethodï¼Œåªæœ‰åœ¨èŽ·å–ä¸åˆ°çš„æ—¶å€™æ‰ä¼šé€šè¿‡æ€§èƒ½è¾ƒä½Žçš„åå°„æ“ä½œæ¥å®Œæˆ 12345678910111213141516171819202122232425262728293031323334353637383940414243private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) &#123; FindState findState = prepareFindState(); findState.initForSubscriber(subscriberClass); while (findState.clazz != null) &#123; //åœ¨æ²¡æœ‰ä½¿ç”¨æ³¨è§£å¤„ç†å™¨çš„æƒ…å†µä¸‹ï¼ŒfindState.subscriberInfo å’Œ subscriberInfoIndexes çš„é»˜è®¤å€¼éƒ½æ˜¯ä¸º nullï¼Œæ‰€ä»¥ getSubscriberInfo ä¼šè¿”å›ž null //æ­¤æ—¶å°±éœ€è¦é€šè¿‡ findUsingReflectionInSingleClass æ–¹æ³•æ¥è¿›è¡Œåå°„èŽ·å– //è€Œåœ¨æœ‰ä½¿ç”¨æ³¨è§£å¤„ç†å™¨çš„æƒ…å†µä¸‹ï¼ŒsubscriberInfoIndexes å°±å­˜å‚¨äº†è‡ªåŠ¨ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶ï¼Œæ­¤æ—¶ getSubscriberInfo å°±å¯ä»¥ä»Žè¾…åŠ©æ–‡ä»¶ä¸­æ‹¿åˆ°ç›®æ ‡ä¿¡æ¯ //ä»Žè€Œé¿å…äº†åå°„æ“ä½œ findState.subscriberInfo = getSubscriberInfo(findState); if (findState.subscriberInfo != null) &#123; SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods(); for (SubscriberMethod subscriberMethod : array) &#123; if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123; findState.subscriberMethods.add(subscriberMethod); &#125; &#125; &#125; else &#123; findUsingReflectionInSingleClass(findState); &#125; findState.moveToSuperclass(); &#125; return getMethodsAndRelease(findState); &#125; private SubscriberInfo getSubscriberInfo(FindState findState) &#123; if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) &#123; SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo(); if (findState.clazz == superclassInfo.getSubscriberClass()) &#123; return superclassInfo; &#125; &#125; if (subscriberInfoIndexes != null) &#123; for (SubscriberInfoIndex index : subscriberInfoIndexes) &#123; SubscriberInfo info = index.getSubscriberInfo(findState.clazz); if (info != null) &#123; return info; &#125; &#125; &#125; return null; &#125; äº”ã€ä¸€äº›å‘1ã€å¥‡æ€ªçš„ç»§æ‰¿å…³ç³»ä¸Šæ–‡æœ‰ä»‹ç»åˆ°ï¼Œå­ç±»å¯ä»¥ç»§æ‰¿çˆ¶ç±»çš„ Subscribe æ–¹æ³•ã€‚ä½†æœ‰ä¸€ä¸ªæ¯”è¾ƒå¥‡æ€ªçš„åœ°æ–¹æ˜¯ï¼šå¦‚æžœå­ç±»é‡å†™äº†çˆ¶ç±»å¤šä¸ª Subscribe æ–¹æ³•çš„è¯ï¼Œå°±ä¼šæŠ›å‡º IllegalStateExceptionã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸‹é¢çš„ä¾‹å­ä¸­ã€‚çˆ¶ç±» BaseActivity å£°æ˜Žäº†ä¸¤ä¸ª Subscribe æ–¹æ³•ï¼Œå­ç±» MainActivity é‡å†™äº†è¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œæ­¤æ—¶è¿è¡ŒåŽå°±ä¼šæŠ›å‡º IllegalStateExceptionã€‚è€Œå¦‚æžœ MainActivity ä¸é‡å†™æˆ–è€…åªé‡å†™ä¸€ä¸ªæ–¹æ³•çš„è¯ï¼Œå°±å¯ä»¥æ­£å¸¸è¿è¡Œ 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * ä½œè€…ï¼šleavesC * æ—¶é—´ï¼š2020/10/01 12:49 * æè¿°ï¼š * GitHubï¼šhttps://github.com/leavesC */open class BaseActivity : AppCompatActivity() &#123; @Subscribe open fun fun1(msg: String) &#123; &#125; @Subscribe open fun fun2(msg: String) &#123; &#125;&#125;class MainActivity : BaseActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) EventBus.getDefault().register(this) &#125; override fun onDestroy() &#123; super.onDestroy() EventBus.getDefault().unregister(this) &#125; @Subscribe override fun fun1(msg: String) &#123; &#125; @Subscribe override fun fun2(msg: String) &#123; &#125;&#125; æŒ‰é“ç†æ¥è¯´ï¼Œå¦‚æžœå­ç±»é‡å†™äº†çˆ¶ç±»ä¸€ä¸ª Subscribe æ–¹æ³•éƒ½å¯ä»¥æ­£å¸¸ä½¿ç”¨çš„è¯ï¼Œé‚£ä¹ˆé‡å†™ä¸¤ä¸ªä¹Ÿåº”è¯¥å¯ä»¥æ­£å¸¸ä½¿ç”¨æ‰å¯¹ã€‚å¯æ˜¯ä¸Šè¿°ä¾‹å­å°±è¡¨çŽ°å¾— EventBus å¥½åƒæœ‰ bug ä¼¼çš„ã€‚é€šè¿‡å®šä½å †æ ˆä¿¡æ¯ï¼Œå¯ä»¥å‘çŽ°æ˜¯åœ¨ FindState çš„ checkAdd æ–¹æ³•æŠ›å‡ºäº†å¼‚å¸¸ å…¶æŠ›å‡ºå¼‚å¸¸çš„æ­¥éª¤æ˜¯è¿™æ ·çš„ï¼š EventBus å¯¹ Subscribe æ–¹æ³•çš„è§£æžæ–¹å‘æ˜¯å­ç±»å‘çˆ¶ç±»è¿›è¡Œçš„ï¼ŒåŒä¸ªç±»ä¸‹çš„ Subscribe æ–¹æ³•æŒ‰ç…§å£°æ˜Žé¡ºåºè¿›è¡Œè§£æž å½“ checkAdd æ–¹æ³•å¼€å§‹è§£æž BaseActivity çš„ fun2 æ–¹æ³•æ—¶ï¼Œexisting å¯¹è±¡å°±æ˜¯ BaseActivity.fun1ï¼Œæ­¤æ—¶å°±ä¼šæ‰§è¡Œåˆ°æ“ä½œ1ï¼Œè€Œç”±äºŽå­ç±»å·²ç»é‡å†™äº† fun1 æ–¹æ³•ï¼Œæ­¤æ—¶ checkAddWithMethodSignature æ–¹æ³•å°±ä¼šè¿”å›ž falseï¼Œæœ€ç»ˆå¯¼è‡´æŠ›å‡ºå¼‚å¸¸ 12345678910111213141516171819boolean checkAdd(Method method, Class&lt;?&gt; eventType) &#123; // 2 level check: 1st level with event type only (fast), 2nd level with complete signature when required. // Usually a subscriber doesn't have methods listening to the same event type. Object existing = anyMethodByEventType.put(eventType, method); if (existing == null) &#123; return true; &#125; else &#123; if (existing instanceof Method) &#123; //æ“ä½œ1 if (!checkAddWithMethodSignature((Method) existing, eventType)) &#123; // Paranoia check throw new IllegalStateException(); &#125; // Put any non-Method object to "consume" the existing Method anyMethodByEventType.put(eventType, this); &#125; return checkAddWithMethodSignature(method, eventType); &#125;&#125; EventBus ä¸­æœ‰ä¸€ä¸ª issues ä¹Ÿåé¦ˆäº†è¿™ä¸ªé—®é¢˜ï¼šissuesï¼Œè¯¥é—®é¢˜åœ¨ 2018 å¹´æ—¶å°±å·²ç»å­˜åœ¨äº†ï¼ŒEeventBus çš„ä½œè€…ä¹Ÿåªæ˜¯å›žå¤è¯´ï¼šåªåœ¨å­ç±»è¿›è¡Œæ–¹æ³•ç›‘å¬ 2ã€ç§»é™¤é»æ€§æ¶ˆæ¯removeStickyEvent æ–¹æ³•ä¼šæœ‰ä¸€ä¸ªæ¯”è¾ƒè®©äººè¯¯è§£çš„ç‚¹ï¼šå¯¹äºŽé€šè¿‡ EventBus.getDefault().postSticky(XXX)æ–¹æ³•å‘é€çš„é»æ€§æ¶ˆæ¯æ— æ³•é€šè¿‡ removeStickyEvent æ–¹æ³•æ¥ä½¿çŽ°æœ‰çš„ç›‘å¬è€…æ‹¦æˆªè¯¥äº‹ä»¶ ä¾‹å¦‚ï¼Œå‡è®¾ä¸‹é¢çš„ä¸¤ä¸ªæ–¹æ³•éƒ½å·²ç»å¤„äºŽæ³¨å†ŒçŠ¶æ€äº†ï¼ŒpostSticky åŽï¼Œå³ä½¿åœ¨ fun1 æ–¹æ³•ä¸­ç§»é™¤äº†é»æ€§æ¶ˆæ¯ï¼Œfun2 æ–¹æ³•ä¹Ÿå¯ä»¥æŽ¥æ”¶åˆ°æ¶ˆæ¯ã€‚è¿™æ˜¯å› ä¸º postSticky æ–¹æ³•æœ€ç»ˆä¹Ÿæ˜¯è¦é è°ƒç”¨ post æ–¹æ³•æ¥å®Œæˆæ¶ˆæ¯å‘é€ï¼Œè€Œ post æ–¹æ³•å¹¶ä¸å— stickyEvents çš„å½±å“ 123456789@Subscribe(sticky = true)fun fun1(msg: String) &#123; EventBus.getDefault().removeStickyEvent(msg)&#125;@Subscribe(sticky = true)fun fun2(msg: String) &#123; &#125; è€Œå¦‚æžœ EventBus ä¸­å·²ç»å­˜å‚¨äº†é»æ€§äº‹ä»¶ï¼Œé‚£ä¹ˆåœ¨ä¸Šè¿°ä¸¤ä¸ªæ–¹æ³•åˆš register æ—¶ï¼Œfun1 æ–¹æ³•å°±å¯ä»¥æ‹¦æˆªä½æ¶ˆæ¯ä½¿ fun2 æ–¹æ³•æŽ¥æ”¶ä¸åˆ°æ¶ˆæ¯ã€‚è¿™æ˜¯å› ä¸º register æ–¹æ³•æ˜¯åœ¨ for å¾ªçŽ¯ä¸­éåŽ† methodï¼Œå¦‚æžœä¹‹å‰çš„æ–¹æ³•å·²ç»ç§»é™¤äº†é»æ€§æ¶ˆæ¯çš„è¯ï¼Œé‚£ä¹ˆåŽç»­æ–¹æ³•å°±æ²¡æœ‰é»æ€§æ¶ˆæ¯éœ€è¦å¤„ç†äº† 12345678910public void register(Object subscriber) &#123; Class&lt;?&gt; subscriberClass = subscriber.getClass(); List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; //åœ¨ for å¾ªçŽ¯ä¸­éåŽ† method for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125;&#125; å…­ã€æ€»ç»“EventBus çš„æºç è§£æžåˆ°è¿™é‡Œå°±ç»“æŸäº†ï¼Œæœ¬æ–‡æ‰€è®²çš„å†…å®¹åº”è¯¥ä¹Ÿå·²ç»æ¶µç›–äº†å¤§éƒ¨åˆ†å†…å®¹äº†ã€‚è¿™é‡Œå†æ¥ä¸º EventBus çš„å®žçŽ°æµç¨‹åšä¸€ä¸ªæ€»ç»“ EventBus åŒ…å« register å’Œ unregister æ–¹æ³•ç”¨äºŽæ ‡è®°å½“å‰ subscriber æ˜¯å¦éœ€è¦æŽ¥æ”¶æ¶ˆæ¯ï¼Œå†…éƒ¨å¯¹åº”å‘ CopyOnWriteArrayList æ·»åŠ å’Œç§»é™¤å…ƒç´ è¿™ä¸¤ä¸ªæ“ä½œ æ¯å½“æœ‰ event è¢« post å‡ºæ¥æ—¶ï¼Œå°±éœ€è¦æ ¹æ® eventClass å¯¹è±¡æ‰¾åˆ°æ‰€æœ‰æ‰€æœ‰å£°æ˜Žäº† @Subscribe æ³¨è§£ä¸”å¯¹è¿™ç§æ¶ˆæ¯ç±»åž‹è¿›è¡Œç›‘å¬çš„æ–¹æ³•ï¼Œè¿™äº›æ–¹æ³•éƒ½æ˜¯åœ¨ subscriber è¿›è¡Œ register çš„æ—¶å€™ï¼Œä»Ž subscriber ä¸­èŽ·å–åˆ°çš„ ä»Ž subscriber ä¸­èŽ·å–æ‰€æœ‰å£°æ˜Žäº† @Subscribe æ³¨è§£çš„æ–¹æ³•æœ‰ä¸¤ç§ã€‚ç¬¬ä¸€ç§æ˜¯é€šè¿‡åå°„çš„æ–¹å¼æ‹¿åˆ° subscriber è¿™ä¸ªç±»ä¸­åŒ…å«çš„æ‰€æœ‰å£°æ˜Žäº† @Subscribe æ³¨è§£çš„æ–¹æ³•ï¼Œå¯¹åº”çš„æ˜¯æ²¡æœ‰é…ç½®æ³¨è§£å¤„ç†å™¨çš„æƒ…å†µã€‚ç¬¬äºŒç§å¯¹åº”çš„æ˜¯æœ‰é…ç½®æ³¨è§£å¤„ç†å™¨çš„æƒ…å†µï¼Œé€šè¿‡åœ¨ç¼–è¯‘é˜¶æ®µå…¨å±€æ‰«æ @Subscribe æ³¨è§£å¹¶ç”Ÿæˆè¾…åŠ©æ–‡ä»¶ï¼Œä»Žè€Œåœ¨ register çš„æ—¶å€™çœåŽ»äº†æ•ˆçŽ‡ä½Žä¸‹çš„åå°„æ“ä½œã€‚ä¸ç®¡æ˜¯é€šè¿‡ä»€ä¹ˆæ–¹å¼è¿›è¡ŒèŽ·å–ï¼Œæ‹¿åˆ°æ‰€æœ‰æ–¹æ³•åŽéƒ½ä¼šå°† methods æŒ‰ç…§æ¶ˆæ¯ç±»åž‹ eventType è¿›è¡Œå½’ç±»ï¼Œæ–¹ä¾¿åŽç»­éåŽ† æ¯å½“æœ‰æ¶ˆæ¯è¢«å‘é€å‡ºæ¥æ—¶ï¼Œå°±æ ¹æ® event å¯¹åº”çš„ Class å¯¹è±¡æ‰¾åˆ°ç›¸åº”çš„ç›‘å¬æ–¹æ³•ï¼Œç„¶åŽé€šè¿‡åå°„çš„æ–¹å¼æ¥å›žè°ƒæ–¹æ³•ã€‚å¤–éƒ¨å¯ä»¥åœ¨åˆå§‹åŒ– EventBus çš„æ—¶å€™é€‰æ‹©æ˜¯å¦è¦è€ƒè™‘ event çš„ç»§æ‰¿å…³ç³»ï¼Œå³åœ¨ event è¢« Post å‡ºæ¥æ—¶ï¼Œå¯¹ event çš„çˆ¶ç±»åž‹è¿›è¡Œç›‘å¬çš„æ–¹æ³•æ˜¯å¦éœ€è¦è¢«å›žè°ƒ EventBus çš„å®žçŽ°æ€è·¯å¹¶ä¸ç®—å¤šéš¾ï¼Œéš¾çš„æ˜¯åœ¨å®žçŽ°çš„æ—¶å€™å¯ä»¥æ–¹æ–¹é¢é¢éƒ½è€ƒè™‘å‘¨å…¨ï¼Œåšåˆ°ç¨³å®šé«˜æ•ˆï¼Œä»Ž 2018 å¹´åˆ°çŽ°åœ¨ 2020 å¹´ä¹Ÿæ‰å‘å¸ƒäº†ä¸¤ä¸ªç‰ˆæœ¬ï¼ˆä¹Ÿè®¸æ˜¯ä½œè€…æ‡’å¾—æ›´æ–°ï¼Ÿï¼‰ã€‚]]></content>
      <categories>
        <category>æ‹†è½®å­</category>
      </categories>
      <tags>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARouter æºç è¯¦è§£]]></title>
    <url>%2F2021%2F01%2F02%2FARouter%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ä¸€ã€ARouterè·¯ç”±æ¡†æž¶åœ¨å¤§åž‹é¡¹ç›®ä¸­æ¯”è¾ƒå¸¸è§ï¼Œç‰¹åˆ«æ˜¯åœ¨é¡¹ç›®ä¸­æ‹¥æœ‰å¤šä¸ª moudle çš„æ—¶å€™ã€‚ä¸ºäº†å®žçŽ°ç»„ä»¶åŒ–ï¼Œå¤šä¸ª module é—´çš„é€šä¿¡å°±ä¸èƒ½ç›´æŽ¥ä»¥æ¨¡å—é—´çš„å¼•ç”¨æ¥å®žçŽ°ï¼Œæ­¤æ—¶å°±éœ€è¦ä¾èµ–è·¯ç”±æ¡†æž¶æ¥å®žçŽ°æ¨¡å—é—´çš„é€šä¿¡å’Œè§£è€¦:sunglasses: è€Œ ARouter å°±æ˜¯ä¸€ä¸ªç”¨äºŽå¸®åŠ© Android App è¿›è¡Œç»„ä»¶åŒ–æ”¹é€ çš„æ¡†æž¶ï¼Œæ”¯æŒæ¨¡å—é—´çš„è·¯ç”±ã€é€šä¿¡ã€è§£è€¦ã€‚ 1ã€æ”¯æŒçš„åŠŸèƒ½ æ”¯æŒç›´æŽ¥è§£æžæ ‡å‡†URLè¿›è¡Œè·³è½¬ï¼Œå¹¶è‡ªåŠ¨æ³¨å…¥å‚æ•°åˆ°ç›®æ ‡é¡µé¢ä¸­ æ”¯æŒå¤šæ¨¡å—å·¥ç¨‹ä½¿ç”¨ æ”¯æŒæ·»åŠ å¤šä¸ªæ‹¦æˆªå™¨ï¼Œè‡ªå®šä¹‰æ‹¦æˆªé¡ºåº æ”¯æŒä¾èµ–æ³¨å…¥ï¼Œå¯å•ç‹¬ä½œä¸ºä¾èµ–æ³¨å…¥æ¡†æž¶ä½¿ç”¨ æ”¯æŒInstantRun æ”¯æŒMultiDex(Googleæ–¹æ¡ˆ) æ˜ å°„å…³ç³»æŒ‰ç»„åˆ†ç±»ã€å¤šçº§ç®¡ç†ï¼ŒæŒ‰éœ€åˆå§‹åŒ– æ”¯æŒç”¨æˆ·æŒ‡å®šå…¨å±€é™çº§ä¸Žå±€éƒ¨é™çº§ç­–ç•¥ é¡µé¢ã€æ‹¦æˆªå™¨ã€æœåŠ¡ç­‰ç»„ä»¶å‡è‡ªåŠ¨æ³¨å†Œåˆ°æ¡†æž¶ æ”¯æŒå¤šç§æ–¹å¼é…ç½®è½¬åœºåŠ¨ç”» æ”¯æŒèŽ·å–Fragment å®Œå…¨æ”¯æŒKotlinä»¥åŠæ··ç¼–(é…ç½®è§æ–‡æœ« å…¶ä»–#5) æ”¯æŒç¬¬ä¸‰æ–¹ App åŠ å›º(ä½¿ç”¨ arouter-register å®žçŽ°è‡ªåŠ¨æ³¨å†Œ) æ”¯æŒç”Ÿæˆè·¯ç”±æ–‡æ¡£ æä¾› IDE æ’ä»¶ä¾¿æ·çš„å…³è”è·¯å¾„å’Œç›®æ ‡ç±» 2ã€å…¸åž‹åº”ç”¨ ä»Žå¤–éƒ¨URLæ˜ å°„åˆ°å†…éƒ¨é¡µé¢ï¼Œä»¥åŠå‚æ•°ä¼ é€’ä¸Žè§£æž è·¨æ¨¡å—é¡µé¢è·³è½¬ï¼Œæ¨¡å—é—´è§£è€¦ æ‹¦æˆªè·³è½¬è¿‡ç¨‹ï¼Œå¤„ç†ç™»é™†ã€åŸ‹ç‚¹ç­‰é€»è¾‘ è·¨æ¨¡å—APIè°ƒç”¨ï¼Œé€šè¿‡æŽ§åˆ¶åè½¬æ¥åšç»„ä»¶è§£è€¦ ä»¥ä¸Šä»‹ç»æ¥è‡ªäºŽ ARouter çš„ Github å®˜ç½‘ï¼šREADME_CN æœ¬æ–‡å°±åŸºäºŽå…¶å½“å‰ï¼ˆ2020/10/04ï¼‰ARouter çš„æœ€æ–°ç‰ˆæœ¬ï¼Œå¯¹ ARouter è¿›è¡Œä¸€æ¬¡å…¨é¢çš„æºç è§£æžå’ŒåŽŸç†ä»‹ç»ï¼Œåšåˆ°çŸ¥å…¶ç„¶ä¹ŸçŸ¥å…¶æ‰€ä»¥ç„¶ï¼Œå¸Œæœ›å¯¹ä½ æœ‰æ‰€å¸®åŠ©ðŸ˜ðŸ˜ 1234dependencies &#123; implementation 'com.alibaba:arouter-api:1.5.0' kapt 'com.alibaba:arouter-compiler:1.2.2'&#125; äºŒã€å‰è¨€å‡è®¾å­˜åœ¨ä¸€ä¸ªåŒ…å«å¤šä¸ª moudle çš„é¡¹ç›®ï¼Œåœ¨åä¸º user çš„ moudle ä¸­å­˜åœ¨ä¸€ä¸ª UserHomeActivityï¼Œå…¶å¯¹åº”çš„è·¯ç”±è·¯å¾„æ˜¯ /account/userHomeã€‚é‚£ä¹ˆï¼Œå½“æˆ‘ä»¬è¦ä»Žå…¶å®ƒ moudle è·³è½¬åˆ°è¯¥é¡µé¢æ—¶ï¼Œåªéœ€è¦æŒ‡å®š path æ¥è·³è½¬å³å¯ 1234567891011121314151617181920package github.leavesc.user/** * ä½œè€…ï¼šleavesC * æ—¶é—´ï¼š2020/10/3 18:05 * æè¿°ï¼š * GitHubï¼šhttps://github.com/leavesC */@Route(path = RoutePath.USER_HOME)class UserHomeActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_user_home) &#125;&#125;//å…¶å®ƒé¡µé¢ä½¿ç”¨å¦‚ä¸‹ä»£ç æ¥è·³è½¬åˆ° UserHomeActivityARouter.getInstance().build(RoutePath.USER_HOME).navigation() åªæ ¹æ®ä¸€ä¸ª pathï¼ŒARouter æ˜¯å¦‚ä½•å®šä½åˆ°ç‰¹å®šçš„ Activity çš„å‘¢ï¼Ÿ è¿™å°±éœ€è¦é€šè¿‡åœ¨ç¼–è¯‘é˜¶æ®µç”Ÿæˆè¾…åŠ©ä»£ç æ¥å®žçŽ°äº†ã€‚æˆ‘ä»¬éƒ½çŸ¥é“ï¼Œæƒ³è¦è·³è½¬åˆ°æŸä¸ª Activityï¼Œé‚£ä¹ˆå°±éœ€è¦æ‹¿åˆ°è¯¥ Activity çš„ Class å¯¹è±¡æ‰è¡Œã€‚åœ¨ç¼–è¯‘é˜¶æ®µï¼ŒARouter ä¼šæ ¹æ®æˆ‘ä»¬è®¾å®šçš„è·¯ç”±è·³è½¬è§„åˆ™æ¥è‡ªåŠ¨ç”Ÿæˆæ˜ å°„æ–‡ä»¶ï¼Œæ˜ å°„æ–‡ä»¶ä¸­å°±åŒ…å«äº† path å’Œ ActivityClass ä¹‹é—´çš„å¯¹åº”å…³ç³» ä¾‹å¦‚ï¼Œå¯¹äºŽ UserHomeActivityï¼Œåœ¨ç¼–è¯‘é˜¶æ®µå°±ä¼šè‡ªåŠ¨ç”Ÿæˆä»¥ä¸‹è¾…åŠ©æ–‡ä»¶ã€‚å¯ä»¥çœ‹åˆ°ï¼ŒARouter$$Group$$account ç±»ä¸­å°±å°† path å’Œ ActivityClass ä½œä¸ºé”®å€¼å¯¹ä¿å­˜åˆ°äº† Map ä¸­ã€‚ARouter å°±æ˜¯ä¾é æ­¤æ¥è¿›è¡Œè·³è½¬çš„ 12345678910package com.alibaba.android.arouter.routes;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Group$$account implements IRouteGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put("/account/userHome", RouteMeta.build(RouteType.ACTIVITY, UserHomeActivity.class, "/account/userhome", "account", null, -1, -2147483648)); &#125;&#125; è¿˜æœ‰ä¸€ä¸ªé‡ç‚¹éœ€è¦æ³¨æ„ï¼Œå°±æ˜¯è¿™ç±»è‡ªåŠ¨ç”Ÿæˆçš„æ–‡ä»¶çš„åŒ…åè·¯å¾„éƒ½æ˜¯ com.alibaba.android.arouter.routesï¼Œä¸”ç±»åå‰ç¼€ä¹Ÿæ˜¯æœ‰ç‰¹å®šè§„åˆ™çš„ã€‚è™½ç„¶ ARouter$$Group$$account ç±»å®žçŽ°äº†å°†å¯¹åº”å…³ç³»ä¿å­˜åˆ° Map çš„é€»è¾‘ï¼Œä½†æ˜¯ loadInto æ–¹æ³•è¿˜æ˜¯éœ€è¦ç”± ARouter åœ¨è¿è¡Œæ—¶æ¥è°ƒç”¨ï¼Œé‚£ä¹ˆ ARouter å°±éœ€è¦æ‹¿åˆ° ARouter$$Group$$account è¿™ä¸ªç±»æ‰è¡Œï¼Œè€Œ ARouter å°±æ˜¯é€šè¿‡æ‰«æ com.alibaba.android.arouter.routesè¿™ä¸ªåŒ…åè·¯å¾„æ¥èŽ·å–æ‰€æœ‰è¾…åŠ©æ–‡ä»¶çš„ ARouter çš„åŸºæœ¬å®žçŽ°æ€è·¯å°±æ˜¯ï¼š å¼€å‘è€…è‡ªå·±ç»´æŠ¤ç‰¹å®š path å’Œç‰¹å®šçš„ç›®æ ‡ç±»ä¹‹é—´çš„å¯¹åº”å…³ç³»ï¼ŒARouter åªè¦æ±‚å¼€å‘è€…ä½¿ç”¨åŒ…å«äº† path çš„ @Route æ³¨è§£ä¿®é¥°ç›®æ ‡ç±» ARouter åœ¨ç¼–è¯‘é˜¶æ®µé€šè¿‡æ³¨è§£å¤„ç†å™¨æ¥è‡ªåŠ¨ç”Ÿæˆ path å’Œç‰¹å®šçš„ç›®æ ‡ç±»ä¹‹é—´çš„å¯¹åº”å…³ç³»ï¼Œå³å°† path ä½œä¸º keyï¼Œå°†ç›®æ ‡ç±»çš„ Class å¯¹è±¡ä½œä¸º value ä¹‹ä¸€å­˜åˆ° Map ä¹‹ä¸­ åœ¨è¿è¡Œé˜¶æ®µï¼Œåº”ç”¨é€šè¿‡ path æ¥å‘èµ·è¯·æ±‚ï¼ŒARouter æ ¹æ® path ä»Ž Map ä¸­å–å€¼ï¼Œä»Žè€Œæ‹¿åˆ°ç›®æ ‡ç±» ä¸‰ã€åˆå§‹åŒ–ARouter çš„ä¸€èˆ¬æ˜¯æ”¾åœ¨ Application ä¸­è°ƒç”¨ init æ–¹æ³•æ¥å®Œæˆåˆå§‹åŒ–çš„ï¼Œè¿™é‡Œå…ˆæ¥çœ‹ä¸‹å…¶åˆå§‹åŒ–æµç¨‹ 123456789101112131415161718/** * ä½œè€…ï¼šleavesC * æ—¶é—´ï¼š2020/10/4 18:05 * æè¿°ï¼š * GitHubï¼šhttps://github.com/leavesC */class MyApp : Application() &#123; override fun onCreate() &#123; super.onCreate() if (BuildConfig.DEBUG) &#123; ARouter.openDebug() ARouter.openLog() &#125; ARouter.init(this) &#125;&#125; ARouter ç±»ä½¿ç”¨äº†å•ä¾‹æ¨¡å¼ï¼Œé€»è¾‘æ¯”è¾ƒç®€å•ï¼Œå› ä¸º ARouter ç±»åªæ˜¯è´Ÿè´£å¯¹å¤–æš´éœ²å¯ä»¥ç”±å¤–éƒ¨è°ƒç”¨çš„ APIï¼Œå¤§éƒ¨åˆ†çš„å®žçŽ°é€»è¾‘è¿˜æ˜¯è½¬äº¤ç”± _ARouter ç±»æ¥å®Œæˆ 123456789101112131415161718192021222324252627282930313233343536373839404142434445public final class ARouter &#123; private volatile static ARouter instance = null; private ARouter() &#123; &#125; /** * Get instance of router. A * All feature U use, will be starts here. */ public static ARouter getInstance() &#123; if (!hasInit) &#123; throw new InitException("ARouter::Init::Invoke init(context) first!"); &#125; else &#123; if (instance == null) &#123; synchronized (ARouter.class) &#123; if (instance == null) &#123; instance = new ARouter(); &#125; &#125; &#125; return instance; &#125; &#125; /** * Init, it must be call before used router. */ public static void init(Application application) &#123; if (!hasInit) &#123; //é˜²æ­¢é‡å¤åˆå§‹åŒ– logger = _ARouter.logger; _ARouter.logger.info(Consts.TAG, "ARouter init start."); //é€šè¿‡ _ARouter æ¥å®Œæˆåˆå§‹åŒ– hasInit = _ARouter.init(application); if (hasInit) &#123; _ARouter.afterInit(); &#125; _ARouter.logger.info(Consts.TAG, "ARouter init over."); &#125; &#125; Â·Â·Â· &#125; _ARouter ç±»æ˜¯åŒ…ç§æœ‰æƒé™ï¼Œä¹Ÿä½¿ç”¨äº†å•ä¾‹æ¨¡å¼ï¼Œå…¶ init(Application) æ–¹æ³•çš„é‡ç‚¹å°±åœ¨äºŽ LogisticsCenter.init(mContext, executor) 1234567891011121314151617181920212223242526272829303132333435final class _ARouter &#123; private volatile static _ARouter instance = null; private _ARouter() &#123; &#125; protected static _ARouter getInstance() &#123; if (!hasInit) &#123; throw new InitException("ARouterCore::Init::Invoke init(context) first!"); &#125; else &#123; if (instance == null) &#123; synchronized (_ARouter.class) &#123; if (instance == null) &#123; instance = new _ARouter(); &#125; &#125; &#125; return instance; &#125; &#125; protected static synchronized boolean init(Application application) &#123; mContext = application; //é‡ç‚¹ LogisticsCenter.init(mContext, executor); logger.info(Consts.TAG, "ARouter init success!"); hasInit = true; mHandler = new Handler(Looper.getMainLooper()); return true; &#125; Â·Â·Â· &#125; LogisticsCenter å°±å®žçŽ°äº†å‰æ–‡è¯´çš„æ‰«æç‰¹å®šåŒ…åè·¯å¾„æ‹¿åˆ°æ‰€æœ‰è‡ªåŠ¨ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶çš„é€»è¾‘ï¼Œå³åœ¨è¿›è¡Œåˆå§‹åŒ–çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±éœ€è¦åŠ è½½åˆ°å½“å‰é¡¹ç›®ä¸€å…±åŒ…å«çš„æ‰€æœ‰ groupï¼Œä»¥åŠæ¯ä¸ª group å¯¹åº”çš„è·¯ç”±ä¿¡æ¯è¡¨ï¼Œå…¶ä¸»è¦é€»è¾‘æ˜¯ï¼š å¦‚æžœå½“å‰å¼€å¯äº† debug æ¨¡å¼æˆ–è€…é€šè¿‡æœ¬åœ° SP ç¼“å­˜åˆ¤æ–­å‡º app çš„ç‰ˆæœ¬å‰åŽå‘ç”Ÿäº†å˜åŒ–ï¼Œé‚£ä¹ˆå°±é‡æ–°èŽ·å–å…¨å±€è·¯ç”±ä¿¡æ¯ï¼Œå¦åˆ™å°±ä»Žä½¿ç”¨ä¹‹å‰ç¼“å­˜åˆ° SP ä¸­çš„æ•°æ® èŽ·å–å…¨å±€è·¯ç”±ä¿¡æ¯æ˜¯ä¸€ä¸ªæ¯”è¾ƒè€—æ—¶çš„æ“ä½œï¼Œæ‰€ä»¥ ARouter å°±é€šè¿‡å°†å…¨å±€è·¯ç”±ä¿¡æ¯ç¼“å­˜åˆ° SP ä¸­æ¥å®žçŽ°å¤ç”¨ã€‚ä½†ç”±äºŽåœ¨å¼€å‘é˜¶æ®µå¼€å‘è€…å¯èƒ½éšæ—¶å°±ä¼šæ·»åŠ æ–°çš„è·¯ç”±è¡¨ï¼Œè€Œæ¯æ¬¡å‘å¸ƒæ–°ç‰ˆæœ¬æ­£å¸¸æ¥è¯´éƒ½æ˜¯ä¼šåŠ å¤§åº”ç”¨çš„ç‰ˆæœ¬å·çš„ï¼Œæ‰€ä»¥ ARouter å°±åªåœ¨å¼€å¯äº† debug æ¨¡å¼æˆ–è€…æ˜¯ç‰ˆæœ¬å·å‘ç”Ÿäº†å˜åŒ–çš„æ—¶å€™æ‰ä¼šé‡æ–°èŽ·å–è·¯ç”±ä¿¡æ¯ èŽ·å–åˆ°çš„è·¯ç”±ä¿¡æ¯ä¸­åŒ…å«äº†åœ¨ com.alibaba.android.arouter.routes è¿™ä¸ªåŒ…ä¸‹è‡ªåŠ¨ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶çš„å…¨è·¯å¾„ï¼Œé€šè¿‡åˆ¤æ–­è·¯å¾„åçš„å‰ç¼€å­—ç¬¦ä¸²ï¼Œå°±å¯ä»¥çŸ¥é“è¯¥ç±»æ–‡ä»¶å¯¹åº”ä»€ä¹ˆç±»åž‹ï¼Œç„¶åŽé€šè¿‡åå°„æž„å»ºä¸åŒç±»åž‹çš„å¯¹è±¡ï¼Œé€šè¿‡è°ƒç”¨å¯¹è±¡çš„æ–¹æ³•å°†è·¯ç”±ä¿¡æ¯å­˜åˆ° Warehouse çš„ Map ä¸­ã€‚è‡³æ­¤ï¼Œæ•´ä¸ªåˆå§‹åŒ–æµç¨‹å°±ç»“æŸäº† 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class LogisticsCenter &#123; /** * LogisticsCenter init, load all metas in memory. Demand initialization */ public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException &#123; mContext = context; executor = tpe; try &#123; long startInit = System.currentTimeMillis(); //billy.qi modified at 2017-12-06 //load by plugin first loadRouterMap(); if (registerByPlugin) &#123; logger.info(TAG, "Load router map by arouter-auto-register plugin."); &#125; else &#123; Set&lt;String&gt; routerMap; //å¦‚æžœå½“å‰å¼€å¯äº† debug æ¨¡å¼æˆ–è€…é€šè¿‡æœ¬åœ° SP ç¼“å­˜åˆ¤æ–­å‡º app çš„ç‰ˆæœ¬å‰åŽå‘ç”Ÿäº†å˜åŒ– //é‚£ä¹ˆå°±é‡æ–°èŽ·å–è·¯ç”±ä¿¡æ¯ï¼Œå¦åˆ™å°±ä»Žä½¿ç”¨ä¹‹å‰ç¼“å­˜åˆ° SP ä¸­çš„æ•°æ® // It will rebuild router map every times when debuggable. if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123; logger.info(TAG, "Run with debug mode or new install, rebuild router map."); // These class was generated by arouter-compiler. //èŽ·å– ROUTE_ROOT_PAKCAGE åŒ…åè·¯å¾„ä¸‹åŒ…å«çš„æ‰€æœ‰çš„ ClassName routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE); if (!routerMap.isEmpty()) &#123; //ç¼“å­˜åˆ° SP ä¸­ context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply(); &#125; //æ›´æ–° App çš„ç‰ˆæœ¬ä¿¡æ¯ PackageUtils.updateVersion(context); // Save new version name when router map update finishes. &#125; else &#123; logger.info(TAG, "Load router map from cache."); routerMap = new HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet&lt;String&gt;())); &#125; logger.info(TAG, "Find router map finished, map size = " + routerMap.size() + ", cost " + (System.currentTimeMillis() - startInit) + " ms."); startInit = System.currentTimeMillis(); for (String className : routerMap) &#123; //é€šè¿‡ className çš„å‰ç¼€æ¥åˆ¤æ–­è¯¥ class å¯¹åº”çš„ä»€ä¹ˆç±»åž‹ï¼Œå¹¶åŒæ—¶ç¼“å­˜åˆ° Warehouse ä¸­ //1.IRouteRoot //2.IInterceptorGroup //3.IProviderGroup if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123; // This one of root elements, load root. ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex); &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123; // Load interceptorMeta ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex); &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123; // Load providerIndex ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex); &#125; &#125; &#125; Â·Â·Â· &#125; catch (Exception e) &#123; throw new HandlerException(TAG + "ARouter init logistics center exception! [" + e.getMessage() + "]"); &#125; &#125; &#125; å¯¹äºŽç¬¬ä¸‰æ­¥ï¼Œå¯ä»¥ä¸¾ä¸ªä¾‹å­æ¥åŠ å¼ºç†è§£ã€‚å¯¹äºŽä¸Šæ–‡æ‰€è®²çš„ UserHomeActivityï¼Œå…¶å¯¹åº”çš„ path æ˜¯ /account/userHomeï¼ŒARouter é»˜è®¤ä¼šå°† path çš„ç¬¬ä¸€ä¸ªå•è¯å³ account ä½œä¸ºå…¶ groupï¼Œè€Œä¸” UserHomeActivity æ˜¯æ”¾åœ¨åä¸º user çš„ module ä¸­ è€Œ ARouter åœ¨é€šè¿‡æ³¨è§£å¤„ç†å™¨ç”Ÿæˆè¾…åŠ©æ–‡ä»¶çš„æ—¶å€™ï¼Œç±»åå°±ä¼šæ ¹æ®ä»¥ä¸Šä¿¡æ¯æ¥ç”Ÿæˆï¼Œæ‰€ä»¥æœ€ç»ˆå°±ä¼šç”Ÿæˆä»¥ä¸‹ä¸¤ä¸ªæ–‡ä»¶ï¼š 12345678910package com.alibaba.android.arouter.routes;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Root$$user implements IRouteRoot &#123; @Override public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123; routes.put("account", ARouter$$Group$$account.class); &#125;&#125; 12345678910package com.alibaba.android.arouter.routes;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Group$$account implements IRouteGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put("/account/userHome", RouteMeta.build(RouteType.ACTIVITY, UserHomeActivity.class, "/account/userhome", "account", null, -1, -2147483648)); &#125;&#125; LogisticsCenter çš„ init æ–¹æ³•å°±ä¼šæ ¹æ®æ–‡ä»¶åçš„å›ºå®šå‰ç¼€ ARouter$$Root$$ å®šä½åˆ° ARouter$$Root$$user è¿™ä¸ªç±»ï¼Œç„¶åŽé€šè¿‡åå°„æž„å»ºå‡ºè¯¥å¯¹è±¡ï¼Œç„¶åŽé€šè¿‡è°ƒç”¨å…¶ loadInto æ–¹æ³•å°†é”®å€¼å¯¹ä¿å­˜åˆ° Warehouse.groupsIndex ä¸­ã€‚ç­‰åˆ°åŽç»­éœ€è¦è·³è½¬åˆ° group ä¸º account çš„é¡µé¢æ—¶ï¼Œå°±ä¼šå†æ¥åå°„è°ƒç”¨ ARouter$$Group$$account çš„ loadInto æ–¹æ³•ï¼Œå³æŒ‰éœ€åŠ è½½ï¼Œç­‰åˆ°éœ€è¦çš„æ—¶å€™å†æ¥èŽ·å–è¯¦ç»†çš„è·¯ç”±å¯¹åº”ä¿¡æ¯ å› ä¸ºå¯¹äºŽä¸€ä¸ªå¤§åž‹çš„ App æ¥è¯´ï¼Œå¯èƒ½åŒ…å«ä¸€ç™¾æˆ–è€…å‡ ç™¾ä¸ªé¡µé¢ï¼Œå¦‚æžœä¸€æ¬¡æ€§å°†æ‰€æœ‰è·¯ç”±ä¿¡æ¯éƒ½åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå¯¹äºŽå†…å­˜çš„åŽ‹åŠ›æ˜¯æ¯”è¾ƒå¤§çš„ï¼Œè€Œç”¨æˆ·æ¯æ¬¡ä½¿ç”¨å¯èƒ½ä¹Ÿåªä¼šæ‰“å¼€åå‡ ä¸ªé¡µé¢ï¼Œæ‰€ä»¥è¿™é‡Œå¿…é¡»æ˜¯æŒ‰éœ€åŠ è½½ å››ã€è·³è½¬åˆ° Activityè®²å®Œåˆå§‹åŒ–æµç¨‹ï¼Œé‚£å°±å†æ¥çœ‹ä¸‹ ARouter å®žçŽ° Activity è·³è½¬çš„æµç¨‹ è·³è½¬åˆ° Activity æœ€ç®€å•çš„æ–¹å¼å°±æ˜¯åªæŒ‡å®š pathï¼š 1ARouter.getInstance().build(RoutePath.USER_HOME).navigation() build() æ–¹æ³•ä¼šé€šè¿‡ ARouter ä¸­è½¬è°ƒç”¨åˆ° _ARouter çš„ build() æ–¹æ³•ï¼Œæœ€ç»ˆè¿”å›žä¸€ä¸ª Postcard å¯¹è±¡ 123456789101112131415161718192021222324252627282930313233/** * Build postcard by path and default group */protected Postcard build(String path) &#123; if (TextUtils.isEmpty(path)) &#123; throw new HandlerException(Consts.TAG + "Parameter is invalid!"); &#125; else &#123; PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); if (null != pService) &#123; //ç”¨äºŽè·¯å¾„æ›¿æ¢ï¼Œè¿™å¯¹äºŽæŸäº›éœ€è¦æŽ§åˆ¶é¡µé¢è·³è½¬æµç¨‹çš„åœºæ™¯æ¯”è¾ƒæœ‰ç”¨ //ä¾‹å¦‚ï¼Œå¦‚æžœæŸä¸ªé¡µé¢éœ€è¦ç™»å½•æ‰å¯ä»¥å±•ç¤ºçš„è¯ //å°±å¯ä»¥é€šè¿‡ PathReplaceService å°† path æ›¿æ¢ loginPagePath path = pService.forString(path); &#125; //ä½¿ç”¨å­—ç¬¦ä¸² path åŒ…å«çš„ç¬¬ä¸€ä¸ªå•è¯ä½œä¸º group return build(path, extractGroup(path)); &#125;&#125;/** * Build postcard by path and group */protected Postcard build(String path, String group) &#123; if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) &#123; throw new HandlerException(Consts.TAG + "Parameter is invalid!"); &#125; else &#123; PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class); if (null != pService) &#123; path = pService.forString(path); &#125; return new Postcard(path, group); &#125;&#125; è¿”å›žçš„ Postcard å¯¹è±¡å¯ä»¥ç”¨äºŽä¼ å…¥ä¸€äº›è·³è½¬é…ç½®å‚æ•°ï¼Œä¾‹å¦‚ï¼šæºå¸¦å‚æ•° mBundleã€å¼€å¯ç»¿è‰²é€šé“ greenChannel ã€è·³è½¬åŠ¨ç”» optionsCompat ç­‰ 123456789101112public final class Postcard extends RouteMeta &#123; // Base private Uri uri; private Object tag; // A tag prepare for some thing wrong. private Bundle mBundle; // Data to transform private int flags = -1; // Flags of route private int timeout = 300; // Navigation timeout, TimeUnit.Second private IProvider provider; // It will be set value, if this postcard was provider. private boolean greenChannel; private SerializationService serializationService; &#125; Postcard çš„ navigation() æ–¹æ³•åˆä¼šè°ƒç”¨åˆ° _ARouter çš„ä»¥ä¸‹æ–¹æ³•æ¥å®Œæˆ Activity çš„è·³è½¬ã€‚è¯¥æ–¹æ³•é€»è¾‘ä¸Šå¹¶ä¸å¤æ‚ï¼Œæ³¨é‡Šä¹Ÿå†™å¾—å¾ˆæ¸…æ¥šäº† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133final class _ARouter &#123; /** * Use router navigation. * * @param context Activity or null. * @param postcard Route metas * @param requestCode RequestCode * @param callback cb */ protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; PretreatmentService pretreatmentService = ARouter.getInstance().navigation(PretreatmentService.class); if (null != pretreatmentService &amp;&amp; !pretreatmentService.onPretreatment(context, postcard)) &#123; // Pretreatment failed, navigation canceled. //ç”¨äºŽæ‰§è¡Œè·³è½¬å‰çš„é¢„å¤„ç†æ“ä½œï¼Œå¯ä»¥é€šè¿‡ onPretreatment æ–¹æ³•çš„è¿”å›žå€¼å†³å®šæ˜¯å¦å–æ¶ˆè·³è½¬ return null; &#125; try &#123; LogisticsCenter.completion(postcard); &#125; catch (NoRouteFoundException ex) &#123; //æ²¡æœ‰æ‰¾åˆ°åŒ¹é…çš„ç›®æ ‡ç±» //ä¸‹é¢å°±æ‰§è¡Œä¸€äº›æç¤ºæ“ä½œå’Œäº‹ä»¶å›žè°ƒé€šçŸ¥ logger.warning(Consts.TAG, ex.getMessage()); if (debuggable()) &#123; // Show friendly tips for user. runInMainThread(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(mContext, "There's no route matched!\n" + " Path = [" + postcard.getPath() + "]\n" + " Group = [" + postcard.getGroup() + "]", Toast.LENGTH_LONG).show(); &#125; &#125;); &#125; if (null != callback) &#123; callback.onLost(postcard); &#125; else &#123; // No callback for this invoke, then we use the global degrade service. DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class); if (null != degradeService) &#123; degradeService.onLost(context, postcard); &#125; &#125; return null; &#125; if (null != callback) &#123; //æ‰¾åˆ°äº†åŒ¹é…çš„ç›®æ ‡ç±» callback.onFound(postcard); &#125; if (!postcard.isGreenChannel()) &#123; // It must be run in async thread, maybe interceptor cost too mush time made ANR. //æ²¡æœ‰å¼€å¯ç»¿è‰²é€šé“ï¼Œé‚£ä¹ˆå°±è¿˜éœ€è¦æ‰§è¡Œæ‰€æœ‰æ‹¦æˆªå™¨ //å¤–éƒ¨å¯ä»¥é€šè¿‡æ‹¦æˆªå™¨å®žçŽ°ï¼šæŽ§åˆ¶æ˜¯å¦å…è®¸è·³è½¬ã€æ›´æ”¹è·³è½¬å‚æ•°ç­‰é€»è¾‘ interceptorService.doInterceptions(postcard, new InterceptorCallback() &#123; /** * Continue process * * @param postcard route meta */ @Override public void onContinue(Postcard postcard) &#123; //æ‹¦æˆªå™¨å…è®¸è·³è½¬ _navigation(context, postcard, requestCode, callback); &#125; /** * Interrupt process, pipeline will be destory when this method called. * * @param exception Reson of interrupt. */ @Override public void onInterrupt(Throwable exception) &#123; if (null != callback) &#123; callback.onInterrupt(postcard); &#125; logger.info(Consts.TAG, "Navigation failed, termination by interceptor : " + exception.getMessage()); &#125; &#125;); &#125; else &#123; //å¼€å¯äº†ç»¿è‰²é€šé“ï¼Œç›´æŽ¥è·³è½¬ï¼Œä¸éœ€è¦éåŽ†æ‹¦æˆªå™¨ return _navigation(context, postcard, requestCode, callback); &#125; return null; &#125; //ç”±äºŽæœ¬ä¾‹å­çš„ç›®æ ‡é¡µé¢æ˜¯ Activityï¼Œæ‰€ä»¥åªçœ‹ ACTIVITY å³å¯ private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; final Context currentContext = null == context ? mContext : context; switch (postcard.getType()) &#123; case ACTIVITY: // Build intent //Destination å°±æ˜¯æŒ‡å‘ç›®æ ‡ Activity çš„ class å¯¹è±¡ final Intent intent = new Intent(currentContext, postcard.getDestination()); //å¡žå…¥æºå¸¦çš„å‚æ•° intent.putExtras(postcard.getExtras()); // Set flags. int flags = postcard.getFlags(); if (-1 != flags) &#123; intent.setFlags(flags); &#125; else if (!(currentContext instanceof Activity)) &#123; // Non activity, need less one flag. intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); &#125; // Set Actions String action = postcard.getAction(); if (!TextUtils.isEmpty(action)) &#123; intent.setAction(action); &#125; // Navigation in main looper. //æœ€ç»ˆåœ¨ä¸»çº¿ç¨‹å®Œæˆè·³è½¬ runInMainThread(new Runnable() &#123; @Override public void run() &#123; startActivity(requestCode, currentContext, intent, postcard, callback); &#125; &#125;); break; Â·Â·Â· //çœç•¥å…¶å®ƒç±»åž‹åˆ¤æ–­ &#125; return null; &#125;&#125; navigation æ–¹æ³•çš„é‡ç‚¹åœ¨äºŽ LogisticsCenter.completion(postcard) è¿™ä¸€å¥ä»£ç ã€‚åœ¨è®² ARouter åˆå§‹åŒ–æµç¨‹çš„æ—¶å€™æœ‰è®²åˆ°ï¼šç­‰åˆ°åŽç»­éœ€è¦è·³è½¬åˆ° group ä¸º account çš„é¡µé¢æ—¶ï¼Œå°±ä¼šå†æ¥åå°„è°ƒç”¨ ARouter$$Group$$account çš„ loadInto æ–¹æ³•ï¼Œå³æŒ‰éœ€åŠ è½½ï¼Œç­‰åˆ°éœ€è¦çš„æ—¶å€™å†æ¥èŽ·å–è¯¦ç»†çš„è·¯ç”±å¯¹åº”ä¿¡æ¯ completion æ–¹æ³•å°±æ˜¯ç”¨æ¥èŽ·å–è¯¦ç»†çš„è·¯ç”±å¯¹åº”ä¿¡æ¯çš„ã€‚è¯¥æ–¹æ³•ä¼šé€šè¿‡ postcard æºå¸¦çš„ path å’Œ group ä¿¡æ¯ä»Ž Warehouse å–å€¼ï¼Œå¦‚æžœå€¼ä¸ä¸º null çš„è¯å°±å°†ä¿¡æ¯ä¿å­˜åˆ° postcard ä¸­ï¼Œå¦‚æžœå€¼ä¸º null çš„è¯å°±æŠ›å‡º NoRouteFoundException 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * Completion the postcard by route metas * * @param postcard Incomplete postcard, should complete by this method. */ public synchronized static void completion(Postcard postcard) &#123; if (null == postcard) &#123; throw new NoRouteFoundException(TAG + "No postcard!"); &#125; RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath()); if (null == routeMeta) &#123; //ä¸º null è¯´æ˜Žç›®æ ‡ç±»ä¸å­˜åœ¨æˆ–è€…æ˜¯è¯¥ group è¿˜æœªåŠ è½½è¿‡ Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup()); // Load route meta. if (null == groupMeta) &#123; //groupMeta ä¸º nullï¼Œè¯´æ˜Ž postcard çš„ path å¯¹åº”çš„ group ä¸å­˜åœ¨ï¼ŒæŠ›å‡ºå¼‚å¸¸ throw new NoRouteFoundException(TAG + "There is no route match the path [" + postcard.getPath() + "], in group [" + postcard.getGroup() + "]"); &#125; else &#123; // Load route and cache it into memory, then delete from metas. try &#123; if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), "The group [%s] starts loading, trigger by [%s]", postcard.getGroup(), postcard.getPath())); &#125; //ä¼šæ‰§è¡Œåˆ°è¿™é‡Œï¼Œè¯´æ˜Žæ­¤ group è¿˜æœªåŠ è½½è¿‡ï¼Œé‚£ä¹ˆå°±æ¥åå°„åŠ è½½ group å¯¹åº”çš„æ‰€æœ‰ path ä¿¡æ¯ //èŽ·å–åŽå°±ä¿å­˜åˆ° Warehouse.routes IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance(); iGroupInstance.loadInto(Warehouse.routes); //ç§»é™¤æ­¤ group Warehouse.groupsIndex.remove(postcard.getGroup()); if (ARouter.debuggable()) &#123; logger.debug(TAG, String.format(Locale.getDefault(), "The group [%s] has already been loaded, trigger by [%s]", postcard.getGroup(), postcard.getPath())); &#125; &#125; catch (Exception e) &#123; throw new HandlerException(TAG + "Fatal exception when loading group meta. [" + e.getMessage() + "]"); &#125; //é‡æ–°æ‰§è¡Œä¸€é completion(postcard); // Reload &#125; &#125; else &#123; //æ‹¿åˆ°è¯¦ç»†çš„è·¯ç”±ä¿¡æ¯äº†ï¼Œå°†è¿™äº›ä¿¡æ¯å­˜åˆ° postcard ä¸­ postcard.setDestination(routeMeta.getDestination()); postcard.setType(routeMeta.getType()); postcard.setPriority(routeMeta.getPriority()); postcard.setExtra(routeMeta.getExtra()); //çœç•¥ä¸€äº›å’Œæœ¬ä¾‹å­æ— å…³çš„ä»£ç  Â·Â·Â· &#125; &#125; äº”ã€è·³è½¬åˆ° Activity å¹¶æ³¨å…¥å‚æ•°ARouter ä¹Ÿæ”¯æŒåœ¨è·³è½¬åˆ° Activity çš„åŒæ—¶å‘ç›®æ ‡é¡µé¢è‡ªåŠ¨æ³¨å…¥å‚æ•° åœ¨è·³è½¬çš„æ—¶å€™æŒ‡å®šè¦æºå¸¦çš„é”®å€¼å¯¹å‚æ•°ï¼š 1234567891011121314ARouter.getInstance().build(RoutePath.USER_HOME) .withLong(RoutePath.USER_HOME_PARAMETER_ID, 20) .withString(RoutePath.USER_HOME_PARAMETER_NAME, "leavesC") .navigation()object RoutePath &#123; const val USER_HOME = "/account/userHome" const val USER_HOME_PARAMETER_ID = "userHomeId" const val USER_HOME_PARAMETER_NAME = "userName"&#125; åœ¨ç›®æ ‡é¡µé¢é€šè¿‡ @Autowired æ³¨è§£ä¿®é¥°å˜é‡ã€‚æ³¨è§£å¯ä»¥åŒæ—¶å£°æ˜Žå…¶ name å‚æ•°ï¼Œç”¨äºŽå’Œä¼ é€’çš„é”®å€¼å¯¹ä¸­çš„ key å¯¹åº”ä¸Šï¼Œè¿™æ · ARouter æ‰çŸ¥é“åº”è¯¥å‘å“ªä¸ªå˜é‡èµ‹å€¼ã€‚å¦‚æžœæ²¡æœ‰å£°æ˜Ž name å‚æ•°ï¼Œé‚£ä¹ˆ name å‚æ•°å°±é»˜è®¤å’Œå˜é‡åç›¸ç­‰ è¿™æ ·ï¼Œåœ¨æˆ‘ä»¬è°ƒç”¨ ARouter.getInstance().inject(this) åŽï¼ŒARouter å°±ä¼šè‡ªåŠ¨å®Œæˆå‚æ•°çš„èµ‹å€¼ 123456789101112131415161718192021222324252627package github.leavesc.user/** * ä½œè€…ï¼šleavesC * æ—¶é—´ï¼š2020/10/4 14:05 * æè¿°ï¼š * GitHubï¼šhttps://github.com/leavesC */@Route(path = RoutePath.USER_HOME)class UserHomeActivity : AppCompatActivity() &#123; @Autowired(name = RoutePath.USER_HOME_PARAMETER_ID) @JvmField var userId: Long = 0 @Autowired @JvmField var userName = "" override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_user_home) ARouter.getInstance().inject(this) tv_hint.text = "$userId $userName" &#125;&#125; ARouter å®žçŽ°å‚æ•°è‡ªåŠ¨æ³¨å…¥ä¹Ÿéœ€è¦ä¾é æ³¨è§£å¤„ç†å™¨ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶æ¥å®žçŽ°ï¼Œå³ä¼šç”Ÿæˆä»¥ä¸‹çš„è¾…åŠ©ä»£ç ï¼š 1234567891011121314151617package github.leavesc.user;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class UserHomeActivity$$ARouter$$Autowired implements ISyringe &#123; //ç”¨äºŽå®žçŽ°åºåˆ—åŒ–å’Œååºåˆ—åŒ– private SerializationService serializationService; @Override public void inject(Object target) &#123; serializationService = ARouter.getInstance().navigation(SerializationService.class); UserHomeActivity substitute = (UserHomeActivity)target; substitute.userId = substitute.getIntent().getLongExtra("userHomeId", substitute.userId); substitute.userName = substitute.getIntent().getStringExtra("userName"); &#125;&#125; å› ä¸ºåœ¨è·³è½¬åˆ° Activity æ—¶æºå¸¦çš„å‚æ•°ä¹Ÿæ˜¯éœ€è¦æ”¾åˆ° Intent é‡Œçš„ï¼Œæ‰€ä»¥ inject æ–¹æ³•ä¹Ÿåªæ˜¯å¸®æˆ‘ä»¬å®žçŽ°äº†ä»Ž Intent å–å€¼ç„¶åŽå‘å˜é‡èµ‹å€¼çš„é€»è¾‘è€Œå·²ï¼Œè¿™å°±è¦æ±‚ç›¸åº”çš„å˜é‡å¿…é¡»æ˜¯ public çš„ï¼Œè¿™å°±æ˜¯åœ¨ Kotlin ä»£ç ä¸­éœ€è¦åŒæ—¶å‘å˜é‡åŠ ä¸Š @JvmFieldæ³¨è§£çš„åŽŸå›  çŽ°åœ¨æ¥çœ‹ä¸‹ ARouter æ˜¯å¦‚ä½•å®žçŽ°å‚æ•°è‡ªåŠ¨æ³¨å…¥çš„ï¼Œå…¶èµ·å§‹æ–¹æ³•å°±æ˜¯ï¼šARouter.getInstance().inject(this)ï¼Œå…¶æœ€ç»ˆä¼šè°ƒç”¨åˆ°ä»¥ä¸‹æ–¹æ³• 12345678910final class _ARouter &#123; static void inject(Object thiz) &#123; AutowiredService autowiredService = ((AutowiredService) ARouter.getInstance().build("/arouter/service/autowired").navigation()); if (null != autowiredService) &#123; autowiredService.autowire(thiz); &#125; &#125; &#125; ARouter é€šè¿‡æŽ§åˆ¶åè½¬çš„æ–¹å¼æ‹¿åˆ° AutowiredService å¯¹åº”çš„å®žçŽ°ç±» AutowiredServiceImplçš„å®žä¾‹å¯¹è±¡ï¼Œç„¶åŽè°ƒç”¨å…¶ autowire æ–¹æ³•å®Œæˆå‚æ•°æ³¨å…¥ ç”±äºŽç”Ÿæˆçš„å‚æ•°æ³¨å…¥è¾…åŠ©ç±»çš„ç±»åå…·æœ‰å›ºå®šçš„åŒ…åå’Œç±»åï¼Œå³åŒ…åå’Œç›®æ ‡ç±»æ‰€åœ¨åŒ…åä¸€è‡´ï¼Œç±»åæ˜¯ç›®æ ‡ç±»ç±»å+ $$ARouter$$Autowiredï¼Œæ‰€ä»¥åœ¨ AutowiredServiceImpl ä¸­å°±å¯ä»¥æ ¹æ®ä¼ å…¥çš„ instance å‚æ•°å’Œåå°„æ¥ç”Ÿæˆè¾…åŠ©ç±»å¯¹è±¡ï¼Œæœ€ç»ˆè°ƒç”¨å…¶ inject æ–¹æ³•å®Œæˆå‚æ•°æ³¨å…¥ 1234567891011121314151617181920212223242526272829303132@Route(path = "/arouter/service/autowired")public class AutowiredServiceImpl implements AutowiredService &#123; private LruCache&lt;String, ISyringe&gt; classCache; private List&lt;String&gt; blackList; @Override public void init(Context context) &#123; classCache = new LruCache&lt;&gt;(66); blackList = new ArrayList&lt;&gt;(); &#125; @Override public void autowire(Object instance) &#123; String className = instance.getClass().getName(); try &#123; //å¦‚æžœåœ¨ç™½åå•ä¸­äº†çš„è¯ï¼Œé‚£ä¹ˆå°±ä¸å†æ‰§è¡Œå‚æ•°æ³¨å…¥ if (!blackList.contains(className)) &#123; ISyringe autowiredHelper = classCache.get(className); if (null == autowiredHelper) &#123; // No cache. autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance(); &#125; //å®Œæˆå‚æ•°æ³¨å…¥ autowiredHelper.inject(instance); //ç¼“å­˜èµ·æ¥ï¼Œé¿å…é‡å¤åå°„ classCache.put(className, autowiredHelper); &#125; &#125; catch (Exception ex) &#123; //å¦‚æžœå‚æ•°æ³¨å…¥è¿‡ç¨‹æŠ›å‡ºå¼‚å¸¸ï¼Œé‚£ä¹ˆå°±å°†å…¶åŠ å…¥ç™½åå•ä¸­ blackList.add(className); // This instance need not autowired. &#125; &#125;&#125; å…­ã€æŽ§åˆ¶åè½¬ä¸Šä¸€èŠ‚æ‰€è®²çš„è·³è½¬åˆ° Activity å¹¶è‡ªåŠ¨æ³¨å…¥å‚æ•°å±žäºŽä¾èµ–æ³¨å…¥çš„ä¸€ç§ï¼ŒARouter åŒæ—¶ä¹Ÿæ”¯æŒæŽ§åˆ¶åè½¬ï¼šé€šè¿‡æŽ¥å£æ¥èŽ·å–å…¶å®žçŽ°ç±»å®žä¾‹ ä¾‹å¦‚ï¼Œå‡è®¾å­˜åœ¨ä¸€ä¸ª ISayHelloService æŽ¥å£ï¼Œæˆ‘ä»¬éœ€è¦æ‹¿åˆ°å…¶å®žçŽ°ç±»å®žä¾‹ï¼Œä½†æ˜¯ä¸å¸Œæœ›åœ¨ä½¿ç”¨çš„æ—¶å€™å’Œç‰¹å®šçš„å®žçŽ°ç±» SayHelloService ç»‘å®šåœ¨ä¸€èµ·ä»Žè€Œé€ æˆå¼ºè€¦åˆï¼Œæ­¤æ—¶å°±å¯ä»¥ä½¿ç”¨ ARouter çš„æŽ§åˆ¶åè½¬åŠŸèƒ½ï¼Œä½†è¿™ä¹Ÿè¦æ±‚ ISayHelloService æŽ¥å£ç»§æ‰¿äº† IProvider æŽ¥å£æ‰è¡Œ 123456789101112131415161718192021222324/** * ä½œè€…ï¼šleavesC * æ—¶é—´ï¼š2020/10/4 13:49 * æè¿°ï¼š * GitHubï¼šhttps://github.com/leavesC */interface ISayHelloService : IProvider &#123; fun sayHello()&#125;@Route(path = RoutePath.SERVICE_SAY_HELLO)class SayHelloService : ISayHelloService &#123; override fun init(context: Context) &#123; &#125; override fun sayHello() &#123; Log.e("SayHelloService", "$this sayHello") &#125;&#125; åœ¨ä½¿ç”¨çš„æ—¶å€™ç›´æŽ¥ä¼ é€’ ISayHelloService çš„ Class å¯¹è±¡å³å¯ï¼ŒARouter ä¼šå°† SayHelloService ä»¥å•ä¾‹æ¨¡å¼çš„å½¢å¼è¿”å›žï¼Œæ— éœ€å¼€å‘è€…æ‰‹åŠ¨åŽ»æž„å»º SayHelloService å¯¹è±¡ï¼Œä»Žè€Œè¾¾åˆ°è§£è€¦çš„ç›®çš„ 1ARouter.getInstance().navigation(ISayHelloService::class.java).sayHello() å’Œå®žçŽ° Activity è·³è½¬çš„æ—¶å€™ä¸€æ ·ï¼ŒARouter ä¹Ÿä¼šè‡ªåŠ¨ç”Ÿæˆä»¥ä¸‹å‡ ä¸ªæ–‡ä»¶ï¼ŒåŒ…å«äº†è·¯ç”±è¡¨çš„æ˜ å°„å…³ç³» 12345678910111213141516171819202122232425262728package com.alibaba.android.arouter.routes;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Group$$account implements IRouteGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas.put("/account/sayHelloService", RouteMeta.build(RouteType.PROVIDER, SayHelloService.class, "/account/sayhelloservice", "account", null, -1, -2147483648)); &#125;&#125;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Providers$$user implements IProviderGroup &#123; @Override public void loadInto(Map&lt;String, RouteMeta&gt; providers) &#123; providers.put("github.leavesc.user.ISayHelloService", RouteMeta.build(RouteType.PROVIDER, SayHelloService.class, "/account/sayHelloService", "account", null, -1, -2147483648)); &#125;&#125;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Root$$user implements IRouteRoot &#123; @Override public void loadInto(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes) &#123; routes.put("account", ARouter$$Group$$account.class); &#125;&#125; è¿™é‡Œå†æ¥çœ‹ä¸‹å…¶å…·ä½“çš„å®žçŽ°åŽŸç† åœ¨è®²åˆå§‹åŒ–æµç¨‹çš„æ—¶å€™æœ‰è®²åˆ°ï¼ŒLogisticsCenter å®žçŽ°äº†æ‰«æç‰¹å®šåŒ…åè·¯å¾„æ‹¿åˆ°æ‰€æœ‰è‡ªåŠ¨ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶çš„é€»è¾‘ã€‚æ‰€ä»¥ï¼Œæœ€ç»ˆ Warehouse ä¸­å°±ä¼šåœ¨åˆå§‹åŒ–çš„æ—¶å€™æ‹¿åˆ°ä»¥ä¸‹æ•°æ® Warehouse.groupsIndexï¼š account -&gt; class com.alibaba.android.arouter.routes.ARouter$$Group$$account Warehouse.providersIndexï¼š github.leavesc.user.ISayHelloService -&gt; RouteMeta.build(RouteType.PROVIDER, SayHelloService.class, &quot;/account/sayHelloService&quot;, &quot;account&quot;, null, -1, -2147483648) ARouter.getInstance().navigation(ISayHelloService::class.java) æœ€ç»ˆä¼šä¸­è½¬è°ƒç”¨åˆ° _ARouter çš„ä»¥ä¸‹æ–¹æ³• 1234567891011121314151617181920212223protected &lt;T&gt; T navigation(Class&lt;? extends T&gt; service) &#123; try &#123; //ä»Ž Warehouse.providersIndex å–å€¼æ‹¿åˆ° RouteMeta ä¸­å­˜å‚¨çš„ path å’Œ group Postcard postcard = LogisticsCenter.buildProvider(service.getName()); // Compatible 1.0.5 compiler sdk. // Earlier versions did not use the fully qualified name to get the service if (null == postcard) &#123; // No service, or this service in old version. postcard = LogisticsCenter.buildProvider(service.getSimpleName()); &#125; if (null == postcard) &#123; return null; &#125; //é‡ç‚¹ LogisticsCenter.completion(postcard); return (T) postcard.getProvider(); &#125; catch (NoRouteFoundException ex) &#123; logger.warning(Consts.TAG, ex.getMessage()); return null; &#125; &#125; LogisticsCenter.completion(postcard) æ–¹æ³•çš„æµç¨‹å’Œä¹‹å‰è®²è§£çš„å·®ä¸å¤šï¼Œåªæ˜¯åœ¨èŽ·å–å¯¹è±¡å®žä¾‹çš„æ—¶å€™åŒæ—¶å°†å®žä¾‹ç¼“å­˜èµ·æ¥ï¼Œç•™å¾…ä¹‹åŽå¤ç”¨ï¼Œè‡³æ­¤å°±å®Œæˆäº†æŽ§åˆ¶åè½¬çš„æµç¨‹äº† 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Completion the postcard by route metas * * @param postcard Incomplete postcard, should complete by this method. */ public synchronized static void completion(Postcard postcard) &#123; ... //çœç•¥ä¹‹å‰å·²ç»è®²è§£è¿‡çš„ä»£ç  RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath()); switch (routeMeta.getType()) &#123; case PROVIDER: // if the route is provider, should find its instance // Its provider, so it must implement IProvider //æ‹¿åˆ° SayHelloService Class å¯¹è±¡ Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination(); IProvider instance = Warehouse.providers.get(providerMeta); if (null == instance) &#123; // There's no instance of this provider //instance ç­‰äºŽ null è¯´æ˜Žæ˜¯ç¬¬ä¸€æ¬¡å–å€¼ //é‚£ä¹ˆå°±é€šè¿‡åå°„æž„å»º SayHelloService å¯¹è±¡ï¼Œç„¶åŽå°†ä¹‹ç¼“å­˜åˆ° Warehouse.providers ä¸­ //æ‰€ä»¥é€šè¿‡æŽ§åˆ¶åè½¬èŽ·å–çš„å¯¹è±¡åœ¨åº”ç”¨çš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸå†…åªä¼šæœ‰ä¸€ä¸ªå®žä¾‹ IProvider provider; try &#123; provider = providerMeta.getConstructor().newInstance(); provider.init(mContext); Warehouse.providers.put(providerMeta, provider); instance = provider; &#125; catch (Exception e) &#123; throw new HandlerException("Init provider failed! " + e.getMessage()); &#125; &#125; //å°†èŽ·å–åˆ°çš„å®žä¾‹å­˜èµ·æ¥ postcard.setProvider(instance); postcard.greenChannel(); // Provider should skip all of interceptors break; case FRAGMENT: postcard.greenChannel(); // Fragment needn't interceptors default: break; &#125; &#125; ä¸ƒã€æ‹¦æˆªå™¨ARouter çš„æ‹¦æˆªå™¨å¯¹äºŽæŸäº›éœ€è¦æŽ§åˆ¶é¡µé¢è·³è½¬æµç¨‹çš„ä¸šåŠ¡é€»è¾‘æ¥è¯´æ˜¯ååˆ†æœ‰ç”¨çš„åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œç”¨æˆ·å¦‚æžœè¦è·³è½¬åˆ°ä¸ªäººèµ„æ–™é¡µé¢æ—¶ï¼Œæˆ‘ä»¬å°±å¯ä»¥é€šè¿‡æ‹¦æˆªå™¨æ¥åˆ¤æ–­ç”¨æˆ·æ˜¯å¦å¤„äºŽå·²ç™»å½•çŠ¶æ€ï¼Œè¿˜æœªç™»å½•çš„è¯å°±å¯ä»¥æ‹¦æˆªè¯¥è¯·æ±‚ï¼Œç„¶åŽè‡ªåŠ¨ä¸ºç”¨æˆ·æ‰“å¼€ç™»å½•é¡µé¢ æˆ‘ä»¬å¯ä»¥åŒæ—¶è®¾å®šå¤šä¸ªæ‹¦æˆªå™¨ï¼Œæ¯ä¸ªæ‹¦æˆªå™¨è®¾å®šä¸åŒçš„ä¼˜å…ˆçº§ 12345678910111213141516171819202122232425262728293031323334353637383940/** * ä½œè€…ï¼šleavesC * æ—¶é—´ï¼š2020/10/5 11:49 * æè¿°ï¼š * GitHubï¼šhttps://github.com/leavesC */@Interceptor(priority = 100, name = "å•¥ä¹Ÿä¸åšçš„æ‹¦æˆªå™¨")class NothingInterceptor : IInterceptor &#123; override fun init(context: Context) &#123; &#125; override fun process(postcard: Postcard, callback: InterceptorCallback) &#123; //ä¸æ‹¦æˆªï¼Œä»»å…¶è·³è½¬ callback.onContinue(postcard) &#125;&#125;@Interceptor(priority = 200, name = "ç™»é™†æ‹¦æˆªå™¨")class LoginInterceptor : IInterceptor &#123; override fun init(context: Context) &#123; &#125; override fun process(postcard: Postcard, callback: InterceptorCallback) &#123; if (postcard.path == RoutePath.USER_HOME) &#123; //æ‹¦æˆª callback.onInterrupt(null) //è·³è½¬åˆ°ç™»é™†é¡µ ARouter.getInstance().build(RoutePath.USER_LOGIN).navigation() &#125; else &#123; //ä¸æ‹¦æˆªï¼Œä»»å…¶è·³è½¬ callback.onContinue(postcard) &#125; &#125;&#125; è¿™æ ·ï¼Œå½“æˆ‘ä»¬æ‰§è¡Œ ARouter.getInstance().build(RoutePath.USER_HOME).navigation() æƒ³è¦è·³è½¬çš„æ—¶å€™ï¼Œå°±ä¼šå‘çŽ°æ‰“å¼€çš„å…¶å®žæ˜¯ç™»å½•é¡µ RoutePath.USER_LOGIN æ¥çœ‹ä¸‹æ‹¦æˆªå™¨æ˜¯å¦‚ä½•å®žçŽ°çš„ å¯¹äºŽä»¥ä¸Šçš„ä¸¤ä¸ªæ‹¦æˆªå™¨ï¼Œä¼šç”Ÿæˆä»¥ä¸‹çš„è¾…åŠ©æ–‡ä»¶ã€‚è¾…åŠ©æ–‡ä»¶ä¼šæ‹¿åˆ°æ‰€æœ‰æˆ‘ä»¬è‡ªå®šä¹‰çš„æ‹¦æˆªå™¨å®žçŽ°ç±»å¹¶æ ¹æ®ä¼˜å…ˆçº§é«˜ä½Žå­˜åˆ° Map ä¸­ 1234567891011package com.alibaba.android.arouter.routes;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Interceptors$$user implements IInterceptorGroup &#123; @Override public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123; interceptors.put(100, NothingInterceptor.class); interceptors.put(200, LoginInterceptor.class); &#125;&#125; è€Œè¿™äº›æ‹¦æˆªå™¨ä¸€æ ·æ˜¯ä¼šåœ¨åˆå§‹åŒ–çš„æ—¶å€™ï¼Œé€šè¿‡LogisticsCenter.initæ–¹æ³•å­˜åˆ° Warehouse.interceptorsIndexä¸­ 123456789101112131415161718192021222324/** * LogisticsCenter init, load all metas in memory. Demand initialization */ public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException &#123; Â·Â·Â· for (String className : routerMap) &#123; if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123; // This one of root elements, load root. ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex); &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123; // Load interceptorMeta //æ‹¿åˆ°è‡ªå®šä¹‰çš„æ‹¦æˆªå™¨å®žçŽ°ç±» ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex); &#125; else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123; // Load providerIndex ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex); &#125; &#125; Â·Â·Â· &#125; ç„¶åŽï¼Œåœ¨ _ARouter çš„ navigation æ–¹æ³•ä¸­ï¼Œå¦‚ä½•åˆ¤æ–­åˆ°æ­¤æ¬¡è·¯ç”±è¯·æ±‚æ²¡æœ‰å¼€å¯ç»¿è‰²é€šé“æ¨¡å¼çš„è¯ï¼Œé‚£ä¹ˆå°±ä¼šå°†æ­¤æ¬¡è¯·æ±‚è½¬äº¤ç»™ interceptorServiceï¼Œè®©å…¶åŽ»éåŽ†æ¯ä¸ªæ‹¦æˆªå™¨ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950final class _ARouter &#123; /** * Use router navigation. * * @param context Activity or null. * @param postcard Route metas * @param requestCode RequestCode * @param callback cb */ protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) &#123; Â·Â·Â· if (!postcard.isGreenChannel()) &#123; // It must be run in async thread, maybe interceptor cost too mush time made ANR. //éåŽ†æ‹¦æˆªå™¨ interceptorService.doInterceptions(postcard, new InterceptorCallback() &#123; /** * Continue process * * @param postcard route meta */ @Override public void onContinue(Postcard postcard) &#123; _navigation(context, postcard, requestCode, callback); &#125; /** * Interrupt process, pipeline will be destory when this method called. * * @param exception Reson of interrupt. */ @Override public void onInterrupt(Throwable exception) &#123; if (null != callback) &#123; callback.onInterrupt(postcard); &#125; logger.info(Consts.TAG, "Navigation failed, termination by interceptor : " + exception.getMessage()); &#125; &#125;); &#125; else &#123; return _navigation(context, postcard, requestCode, callback); &#125; return null; &#125; &#125; interceptorService å˜é‡å±žäºŽ InterceptorService æŽ¥å£ç±»åž‹ï¼Œè¯¥æŽ¥å£çš„å®žçŽ°ç±»æ˜¯ InterceptorServiceImplï¼ŒARouterå†…éƒ¨åœ¨åˆå§‹åŒ–çš„è¿‡ç¨‹ä¸­ä¹Ÿæ˜¯æ ¹æ®æŽ§åˆ¶åè½¬çš„æ–¹å¼æ¥æ‹¿åˆ° interceptorService è¿™ä¸ªå®žä¾‹çš„ InterceptorServiceImpl çš„ä¸»è¦é€»è¾‘æ˜¯ï¼š åœ¨ç¬¬ä¸€æ¬¡èŽ·å– InterceptorServiceImpl å®žä¾‹çš„æ—¶å€™ï¼Œå…¶ init æ–¹æ³•ä¼šé©¬ä¸Šè¢«è°ƒç”¨ï¼Œè¯¥æ–¹æ³•å†…éƒ¨ä¼šäº¤ç”±çº¿ç¨‹æ± æ¥æ‰§è¡Œï¼Œé€šè¿‡åå°„ç”Ÿæˆæ¯ä¸ªæ‹¦æˆªå™¨å¯¹è±¡ï¼Œå¹¶è°ƒç”¨æ¯ä¸ªæ‹¦æˆªå™¨çš„ init æ–¹æ³•æ¥å®Œæˆæ‹¦æˆªå™¨çš„åˆå§‹åŒ–ï¼Œå¹¶å°†æ¯ä¸ªæ‹¦æˆªå™¨å¯¹è±¡éƒ½å­˜åˆ° Warehouse.interceptors ä¸­ã€‚å¦‚æžœåˆå§‹åŒ–å®Œæˆäº†ï¼Œåˆ™å”¤é†’ç­‰å¾…åœ¨ interceptorInitLock ä¸Šçš„çº¿ç¨‹ å½“æ‹¦æˆªå™¨é€»è¾‘è¢«è§¦å‘ï¼Œå³ doInterceptions æ–¹æ³•è¢«è°ƒç”¨æ—¶ï¼Œå¦‚æžœæ­¤æ—¶ç¬¬ä¸€ä¸ªæ­¥éª¤è¿˜æœªæ‰§è¡Œå®Œçš„è¯ï¼Œåˆ™ä¼šé€šè¿‡ checkInterceptorsInitStatus()æ–¹æ³•ç­‰å¾…ç¬¬ä¸€ä¸ªæ­¥éª¤æ‰§è¡Œå®Œæˆã€‚å¦‚æžœåç§’å†…éƒ½æœªå®Œæˆçš„è¯ï¼Œåˆ™èµ°å¤±è´¥æµç¨‹ç›´æŽ¥è¿”å›ž åœ¨çº¿ç¨‹æ± ä¸­éåŽ†æ‹¦æˆªå™¨åˆ—è¡¨ï¼Œå¦‚æžœæœ‰æŸä¸ªæ‹¦æˆªå™¨æ‹¦æˆªäº†è¯·æ±‚çš„è¯åˆ™è°ƒç”¨ callback.onInterruptæ–¹æ³•é€šçŸ¥å¤–éƒ¨ï¼Œå¦åˆ™çš„è¯åˆ™è°ƒç”¨ callback.onContinue() æ–¹æ³•ç»§ç»­è·³è½¬é€»è¾‘ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122@Route(path = "/arouter/service/interceptor")public class InterceptorServiceImpl implements InterceptorService &#123; private static boolean interceptorHasInit; private static final Object interceptorInitLock = new Object(); @Override public void init(final Context context) &#123; LogisticsCenter.executor.execute(new Runnable() &#123; @Override public void run() &#123; if (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123; //éåŽ†æ‹¦æˆªå™¨åˆ—è¡¨ï¼Œé€šè¿‡åå°„æž„å»ºå¯¹è±¡å¹¶åˆå§‹åŒ– for (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123; Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue(); try &#123; IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance(); iInterceptor.init(context); //å­˜èµ·æ¥ Warehouse.interceptors.add(iInterceptor); &#125; catch (Exception ex) &#123; throw new HandlerException(TAG + "ARouter init interceptor error! name = [" + interceptorClass.getName() + "], reason = [" + ex.getMessage() + "]"); &#125; &#125; interceptorHasInit = true; logger.info(TAG, "ARouter interceptors init over."); synchronized (interceptorInitLock) &#123; interceptorInitLock.notifyAll(); &#125; &#125; &#125; &#125;); &#125; @Override public void doInterceptions(final Postcard postcard, final InterceptorCallback callback) &#123; if (null != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; 0) &#123; checkInterceptorsInitStatus(); if (!interceptorHasInit) &#123; //åˆå§‹åŒ–å¤ªä¹…ï¼Œä¸ç­‰äº†ï¼Œç›´æŽ¥èµ°å¤±è´¥æµç¨‹ callback.onInterrupt(new HandlerException("Interceptors initialization takes too much time.")); return; &#125; LogisticsCenter.executor.execute(new Runnable() &#123; @Override public void run() &#123; CancelableCountDownLatch interceptorCounter = new CancelableCountDownLatch(Warehouse.interceptors.size()); try &#123; _excute(0, interceptorCounter, postcard); interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS); if (interceptorCounter.getCount() &gt; 0) &#123; // Cancel the navigation this time, if it hasn't return anythings. //å¤§äºŽ 0 è¯´æ˜Žæ­¤æ¬¡è¯·æ±‚è¢«æŸä¸ªæ‹¦æˆªå™¨æ‹¦æˆªäº†ï¼Œèµ°å¤±è´¥æµç¨‹ callback.onInterrupt(new HandlerException("The interceptor processing timed out.")); &#125; else if (null != postcard.getTag()) &#123; // Maybe some exception in the tag. callback.onInterrupt(new HandlerException(postcard.getTag().toString())); &#125; else &#123; callback.onContinue(postcard); &#125; &#125; catch (Exception e) &#123; callback.onInterrupt(e); &#125; &#125; &#125;); &#125; else &#123; callback.onContinue(postcard); &#125; &#125; /** * Excute interceptor * * @param index current interceptor index * @param counter interceptor counter * @param postcard routeMeta */ private static void _excute(final int index, final CancelableCountDownLatch counter, final Postcard postcard) &#123; if (index &lt; Warehouse.interceptors.size()) &#123; IInterceptor iInterceptor = Warehouse.interceptors.get(index); iInterceptor.process(postcard, new InterceptorCallback() &#123; @Override public void onContinue(Postcard postcard) &#123; // Last interceptor excute over with no exception. counter.countDown(); _excute(index + 1, counter, postcard); // When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know. &#125; @Override public void onInterrupt(Throwable exception) &#123; // Last interceptor excute over with fatal exception. postcard.setTag(null == exception ? new HandlerException("No message.") : exception.getMessage()); // save the exception message for backup. counter.cancel(); // Be attention, maybe the thread in callback has been changed, // then the catch block(L207) will be invalid. // The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!// if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123; // You shouldn't throw the exception if the thread is main thread.// throw new HandlerException(exception.getMessage());// &#125; &#125; &#125;); &#125; &#125; private static void checkInterceptorsInitStatus() &#123; synchronized (interceptorInitLock) &#123; while (!interceptorHasInit) &#123; try &#123; interceptorInitLock.wait(10 * 1000); &#125; catch (InterruptedException e) &#123; throw new HandlerException(TAG + "Interceptor init cost too much time error! reason = [" + e.getMessage() + "]"); &#125; &#125; &#125; &#125; &#125; å…«ã€æ³¨è§£å¤„ç†å™¨é€šç¯‡è¯»ä¸‹æ¥ï¼Œè¯»è€…åº”è¯¥èƒ½å¤Ÿæ„Ÿå—åˆ°æ³¨è§£å¤„ç†å™¨åœ¨ ARouter ä¸­èµ·åˆ°äº†å¾ˆå¤§çš„ä½œç”¨ï¼Œä¾é æ³¨è§£å¤„ç†å™¨ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶ï¼ŒARouter æ‰èƒ½å®Œæˆå‚æ•°è‡ªåŠ¨æ³¨å…¥ç­‰åŠŸèƒ½ã€‚è¿™é‡Œå°±å†æ¥ä»‹ç»ä¸‹ ARouter å…³äºŽæ³¨è§£å¤„ç†å™¨çš„å®žçŽ°åŽŸç† APT(Annotation Processing Tool) å³æ³¨è§£å¤„ç†å™¨ï¼Œæ˜¯ä¸€ç§æ³¨è§£å¤„ç†å·¥å…·ï¼Œç”¨æ¥åœ¨ç¼–è¯‘æœŸæ‰«æå’Œå¤„ç†æ³¨è§£ï¼Œé€šè¿‡æ³¨è§£æ¥ç”Ÿæˆ Java æ–‡ä»¶ã€‚å³ä»¥æ³¨è§£ä½œä¸ºæ¡¥æ¢ï¼Œé€šè¿‡é¢„å…ˆè§„å®šå¥½çš„ä»£ç ç”Ÿæˆè§„åˆ™æ¥è‡ªåŠ¨ç”Ÿæˆ Java æ–‡ä»¶ã€‚æ­¤ç±»æ³¨è§£æ¡†æž¶çš„ä»£è¡¨æœ‰ ButterKnifeã€Dragger2ã€EventBus ç­‰ Java API å·²ç»æä¾›äº†æ‰«ææºç å¹¶è§£æžæ³¨è§£çš„æ¡†æž¶ï¼Œå¼€å‘è€…å¯ä»¥é€šè¿‡ç»§æ‰¿ AbstractProcessor ç±»æ¥å®žçŽ°è‡ªå·±çš„æ³¨è§£è§£æžé€»è¾‘ã€‚APT çš„åŽŸç†å°±æ˜¯åœ¨æ³¨è§£äº†æŸäº›ä»£ç å…ƒç´ ï¼ˆå¦‚å­—æ®µã€å‡½æ•°ã€ç±»ç­‰ï¼‰åŽï¼Œåœ¨ç¼–è¯‘æ—¶ç¼–è¯‘å™¨ä¼šæ£€æŸ¥ AbstractProcessor çš„å­ç±»ï¼Œå¹¶ä¸”è‡ªåŠ¨è°ƒç”¨å…¶ process() æ–¹æ³•ï¼Œç„¶åŽå°†æ·»åŠ äº†æŒ‡å®šæ³¨è§£çš„æ‰€æœ‰ä»£ç å…ƒç´ ä½œä¸ºå‚æ•°ä¼ é€’ç»™è¯¥æ–¹æ³•ï¼Œå¼€å‘è€…å†æ ¹æ®æ³¨è§£å…ƒç´ åœ¨ç¼–è¯‘æœŸè¾“å‡ºå¯¹åº”çš„ Java ä»£ç  å…³äºŽ APT æŠ€æœ¯çš„åŽŸç†å’Œåº”ç”¨å¯ä»¥çœ‹è¿™ç¯‡æ–‡ç« ï¼šAndroid APT å®žä¾‹è®²è§£ ARouter æºç ä¸­å’Œæ³¨è§£å¤„ç†å™¨ç›¸å…³çš„ module æœ‰ä¸¤ä¸ªï¼š arouter-annotationã€‚Java Moduleï¼ŒåŒ…å«äº†åƒ Autowiredã€Interceptor è¿™äº›æ³¨è§£ä»¥åŠ RouteMeta ç­‰ JavaBean arouter-compilerã€‚Android Moduleï¼ŒåŒ…å«äº†å¤šä¸ª AbstractProcessor çš„å®žçŽ°ç±»ç”¨äºŽç”Ÿæˆä»£ç  è¿™é‡Œä¸»è¦æ¥çœ‹ arouter-compilerï¼Œè¿™é‡Œä»¥è‡ªå®šä¹‰çš„æ‹¦æˆªå™¨ NothingInterceptor ä½œä¸ºä¾‹å­ 123456789101112131415161718192021package github.leavesc.user/** * ä½œè€…ï¼šleavesC * æ—¶é—´ï¼š2020/10/5 11:49 * æè¿°ï¼š * GitHubï¼šhttps://github.com/leavesC */@Interceptor(priority = 100, name = "å•¥ä¹Ÿä¸åšçš„æ‹¦æˆªå™¨")class NothingInterceptor : IInterceptor &#123; override fun init(context: Context) &#123; &#125; override fun process(postcard: Postcard, callback: InterceptorCallback) &#123; //ä¸æ‹¦æˆªï¼Œä»»å…¶è·³è½¬ callback.onContinue(postcard) &#125;&#125; ç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶ï¼š 123456789101112131415161718package com.alibaba.android.arouter.routes;import com.alibaba.android.arouter.facade.template.IInterceptor;import com.alibaba.android.arouter.facade.template.IInterceptorGroup;import github.leavesc.user.NothingInterceptor;import java.lang.Class;import java.lang.Integer;import java.lang.Override;import java.util.Map;/** * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */public class ARouter$$Interceptors$$user implements IInterceptorGroup &#123; @Override public void loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptors) &#123; interceptors.put(100, NothingInterceptor.class); &#125;&#125; é‚£ä¹ˆï¼Œç”Ÿæˆçš„è¾…åŠ©æ–‡ä»¶æˆ‘ä»¬å°±è¦åŒ…å«ä»¥ä¸‹å‡ ä¸ªå…ƒç´ ï¼š åŒ…å å¯¼åŒ… æ³¨é‡Š å®žçŽ°ç±»åŠç»§æ‰¿çš„æŽ¥å£ åŒ…å«çš„æ–¹æ³•åŠæ–¹æ³•å‚æ•° æ–¹æ³•ä½“ ä¿®é¥°ç¬¦ å¦‚æžœé€šè¿‡ç¡¬ç¼–ç çš„å½¢å¼ï¼Œå³é€šè¿‡æ‹¼æŽ¥å­—ç¬¦ä¸²çš„æ–¹å¼æ¥ç”Ÿæˆä»¥ä¸Šä»£ç ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œä½†æ˜¯è¿™æ ·ä¼šä½¿å¾—ä»£ç ä¸å¥½ç»´æŠ¤ä¸”å¯è¯»æ€§å¾ˆä½Žï¼Œæ‰€ä»¥ ARouter æ˜¯é€šè¿‡ JavaPoet è¿™ä¸ªå¼€æºåº“æ¥ç”Ÿæˆä»£ç çš„ã€‚JavaPoet æ˜¯ square å…¬å¸å¼€æºçš„ Java ä»£ç ç”Ÿæˆæ¡†æž¶ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿åœ°é€šè¿‡å…¶æä¾›çš„ API æ¥ç”ŸæˆæŒ‡å®šæ ¼å¼ï¼ˆä¿®é¥°ç¬¦ã€è¿”å›žå€¼ã€å‚æ•°ã€å‡½æ•°ä½“ç­‰ï¼‰çš„ä»£ç  æ‹¦æˆªå™¨å¯¹åº”çš„ AbstractProcessor å­ç±»å°±æ˜¯ InterceptorProcessorï¼Œå…¶ä¸»è¦é€»è¾‘æ˜¯ï¼š åœ¨ process æ–¹æ³•ä¸­é€šè¿‡ RoundEnvironment æ‹¿åˆ°æ‰€æœ‰ä½¿ç”¨äº† @Interceptor æ³¨è§£è¿›è¡Œä¿®é¥°çš„ä»£ç å…ƒç´  elementsï¼Œç„¶åŽéåŽ†æ‰€æœ‰ item åˆ¤æ–­æ¯ä¸ª item æ˜¯å¦ç»§æ‰¿äº† IInterceptor æŽ¥å£ï¼Œæ˜¯çš„è¯åˆ™è¯´æ˜Žè¯¥ item å°±æ˜¯æˆ‘ä»¬è¦æ‰¾çš„æ‹¦æˆªå™¨å®žçŽ°ç±» èŽ·å–æ¯ä¸ª item åŒ…å«çš„ @Interceptor æ³¨è§£å¯¹è±¡ï¼Œæ ¹æ®æˆ‘ä»¬ä¸ºä¹‹è®¾å®šçš„ä¼˜å…ˆçº§ priorityï¼Œå°†æ¯ä¸ª item æŒ‰é¡ºåºå­˜åˆ° interceptors ä¸­ å¦‚æžœå­˜åœ¨ä¸¤ä¸ªæ‹¦æˆªå™¨çš„ä¼˜å…ˆçº§ç›¸åŒï¼Œé‚£ä¹ˆå°±æŠ›å‡ºå¼‚å¸¸ å°†æ‰€æœ‰æ‹¦æˆªå™¨æŒ‰é¡ºåºå­˜å…¥ interceptors åŽï¼Œé€šè¿‡ JavaPoet æä¾›çš„ API æ¥ç”ŸæˆåŒ…åã€å¯¼åŒ…ã€æ³¨é‡Šã€å®žçŽ°ç±»ç­‰å¤šä¸ªä»£ç å…ƒç´ ï¼Œå¹¶æœ€ç»ˆç”Ÿæˆä¸€ä¸ªå®Œæ•´çš„ç±»æ–‡ä»¶ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142@AutoService(Processor.class)@SupportedAnnotationTypes(ANNOTATION_TYPE_INTECEPTOR)public class InterceptorProcessor extends BaseProcessor &#123; //ç”¨äºŽä¿å­˜æ‹¦æˆªå™¨ï¼ŒæŒ‰ç…§ä¼˜å…ˆçº§é«˜ä½Žè¿›è¡ŒæŽ’åº private Map&lt;Integer, Element&gt; interceptors = new TreeMap&lt;&gt;(); private TypeMirror iInterceptor = null; @Override public synchronized void init(ProcessingEnvironment processingEnv) &#123; super.init(processingEnv); iInterceptor = elementUtils.getTypeElement(Consts.IINTERCEPTOR).asType(); logger.info("&gt;&gt;&gt; InterceptorProcessor init. &lt;&lt;&lt;"); &#125; /** * &#123;@inheritDoc&#125; * * @param annotations * @param roundEnv */ @Override public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) &#123; if (CollectionUtils.isNotEmpty(annotations)) &#123; //æ‹¿åˆ°æ‰€æœ‰ä½¿ç”¨äº† @Interceptor è¿›è¡Œä¿®é¥°çš„ä»£ç å…ƒç´  Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(Interceptor.class); try &#123; parseInterceptors(elements); &#125; catch (Exception e) &#123; logger.error(e); &#125; return true; &#125; return false; &#125; /** * Parse tollgate. * * @param elements elements of tollgate. */ private void parseInterceptors(Set&lt;? extends Element&gt; elements) throws IOException &#123; if (CollectionUtils.isNotEmpty(elements)) &#123; logger.info("&gt;&gt;&gt; Found interceptors, size is " + elements.size() + " &lt;&lt;&lt;"); // Verify and cache, sort incidentally. for (Element element : elements) &#123; //åˆ¤æ–­ä½¿ç”¨äº† @Interceptor è¿›è¡Œä¿®é¥°çš„ä»£ç å…ƒç´ æ˜¯å¦åŒæ—¶å®žçŽ°äº† com.alibaba.android.arouter.facade.template.IInterceptor è¿™ä¸ªæŽ¥å£ //ä¸¤è€…ç¼ºä¸€ä¸å¯ if (verify(element)) &#123; // Check the interceptor meta logger.info("A interceptor verify over, its " + element.asType()); Interceptor interceptor = element.getAnnotation(Interceptor.class); Element lastInterceptor = interceptors.get(interceptor.priority()); if (null != lastInterceptor) &#123; // Added, throw exceptions //ä¸ä¸º null è¯´æ˜Žå­˜åœ¨ä¸¤ä¸ªæ‹¦æˆªå™¨å…¶ä¼˜å…ˆçº§ç›¸ç­‰ï¼Œè¿™æ˜¯ä¸å…è®¸çš„ï¼Œç›´æŽ¥æŠ›å‡ºå¼‚å¸¸ throw new IllegalArgumentException( String.format(Locale.getDefault(), "More than one interceptors use same priority [%d], They are [%s] and [%s].", interceptor.priority(), lastInterceptor.getSimpleName(), element.getSimpleName()) ); &#125; //å°†æ‹¦æˆªå™¨æŒ‰ç…§ä¼˜å…ˆçº§é«˜ä½Žè¿›è¡ŒæŽ’åºä¿å­˜ interceptors.put(interceptor.priority(), element); &#125; else &#123; logger.error("A interceptor verify failed, its " + element.asType()); &#125; &#125; // Interface of ARouter. //æ‹¿åˆ° com.alibaba.android.arouter.facade.template.IInterceptor è¿™ä¸ªæŽ¥å£çš„ç±»åž‹æŠ½è±¡ TypeElement type_ITollgate = elementUtils.getTypeElement(IINTERCEPTOR); //æ‹¿åˆ° com.alibaba.android.arouter.facade.template.IInterceptorGroup è¿™ä¸ªæŽ¥å£çš„ç±»åž‹æŠ½è±¡ TypeElement type_ITollgateGroup = elementUtils.getTypeElement(IINTERCEPTOR_GROUP); /** * Build input type, format as : * * Map&lt;Integer, Class&lt;? extends ITollgate&gt;&gt; */ //ç”Ÿæˆå¯¹ Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; è¿™æ®µä»£ç çš„æŠ½è±¡å°è£… ParameterizedTypeName inputMapTypeOfTollgate = ParameterizedTypeName.get( ClassName.get(Map.class), ClassName.get(Integer.class), ParameterizedTypeName.get( ClassName.get(Class.class), WildcardTypeName.subtypeOf(ClassName.get(type_ITollgate)) ) ); // Build input param name. //ç”Ÿæˆ loadInto æ–¹æ³•çš„å…¥å‚å‚æ•° interceptors ParameterSpec tollgateParamSpec = ParameterSpec.builder(inputMapTypeOfTollgate, "interceptors").build(); // Build method : 'loadInto' //ç”Ÿæˆ loadInto æ–¹æ³• MethodSpec.Builder loadIntoMethodOfTollgateBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(tollgateParamSpec); // Generate if (null != interceptors &amp;&amp; interceptors.size() &gt; 0) &#123; // Build method body for (Map.Entry&lt;Integer, Element&gt; entry : interceptors.entrySet()) &#123; //éåŽ†æ¯ä¸ªæ‹¦æˆªå™¨ï¼Œç”Ÿæˆ interceptors.put(100, NothingInterceptor.class); è¿™ç±»åž‹çš„ä»£ç  loadIntoMethodOfTollgateBuilder.addStatement("interceptors.put(" + entry.getKey() + ", $T.class)", ClassName.get((TypeElement) entry.getValue())); &#125; &#125; // Write to disk(Write file even interceptors is empty.) //åŒ…åå›ºå®šæ˜¯ PACKAGE_OF_GENERATE_FILEï¼Œå³ com.alibaba.android.arouter.routes JavaFile.builder(PACKAGE_OF_GENERATE_FILE, TypeSpec.classBuilder(NAME_OF_INTERCEPTOR + SEPARATOR + moduleName) //è®¾ç½®ç±»å .addModifiers(PUBLIC) //æ·»åŠ  public ä¿®é¥°ç¬¦ .addJavadoc(WARNING_TIPS) //æ·»åŠ æ³¨é‡Š .addMethod(loadIntoMethodOfTollgateBuilder.build()) //æ·»åŠ  loadInto æ–¹æ³• .addSuperinterface(ClassName.get(type_ITollgateGroup)) //æœ€åŽç”Ÿæˆçš„ç±»åŒæ—¶å®žçŽ°äº† IInterceptorGroup æŽ¥å£ .build() ).build().writeTo(mFiler); logger.info("&gt;&gt;&gt; Interceptor group write over. &lt;&lt;&lt;"); &#125; &#125; /** * Verify inteceptor meta * * @param element Interceptor taw type * @return verify result */ private boolean verify(Element element) &#123; Interceptor interceptor = element.getAnnotation(Interceptor.class); // It must be implement the interface IInterceptor and marked with annotation Interceptor. return null != interceptor &amp;&amp; ((TypeElement) element).getInterfaces().contains(iInterceptor); &#125;&#125; ä¹ã€ç»“å°¾ARouter çš„å®žçŽ°åŽŸç†å’Œæºç è§£æžéƒ½è®²å¾—å·®ä¸å¤šäº†ï¼Œæ–‡æœ¬åº”è¯¥è®²å¾—æŒºå…¨é¢çš„äº†ï¼Œé‚£ä¹ˆä¸‹ä¸€ç¯‡å°±å†æ¥è¿›å…¥å®žæˆ˜ç¯‡å§ï¼Œè‡ªå·±æ¥åŠ¨æ‰‹å®žçŽ°ä¸€ä¸ª ARouter ðŸ˜ðŸ˜ æœ¬æ–‡è½¬è½½è‡ªä¸‰æ–¹åº“æºç ç¬”è®°ï¼ˆ3ï¼‰-ARouter æºç è¯¦è§£]]></content>
      <categories>
        <category>ä¸‰æ–¹åº“æºç åˆ†æž</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jetpackä¹‹Lifecycleæºç è§£æž]]></title>
    <url>%2F2020%2F12%2F28%2FLifecycle%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Lifecycle æ˜¯ Jetpack æ•´ä¸ªå®¶æ—ä½“ç³»å†…æœ€ä¸ºåŸºç¡€çš„å†…å®¹ä¹‹ä¸€ï¼Œæ­£æ˜¯å› ä¸ºæœ‰äº† Lifecycle çš„å­˜åœ¨ï¼Œä½¿å¾—å¦‚ä»Šå¼€å‘è€…æ­å»ºä¾èµ–äºŽç”Ÿå‘½å‘¨æœŸå˜åŒ–çš„ä¸šåŠ¡é€»è¾‘å˜å¾—ç®€å•ä¸”é«˜æ•ˆäº†è®¸å¤šï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥ä»¥ä¸€ç§ç»Ÿä¸€çš„æ–¹å¼æ¥ç›‘å¬ Activityã€Fragmentã€Serviceã€ç”šè‡³ Process çš„ç”Ÿå‘½å‘¨æœŸå˜åŒ–ï¼Œä¸”å¤§å¤§å‡å°‘äº†ä¸šåŠ¡ä»£ç å‘ç”Ÿå†…å­˜æ³„æ¼å’Œ NPE çš„é£Žé™©ã€‚æœ¬æ–‡çš„å†…å®¹å°±æ˜¯å¯¹ Lifecycle è¿›è¡Œäº†ä¸€æ¬¡å…¨é¢çš„æºç è®²è§£ï¼Œå¸Œæœ›å¯¹ä½ æœ‰æ‰€å¸®åŠ© æœ¬æ–‡æ‰€è®²çš„çš„æºä»£ç åŸºäºŽä»¥ä¸‹ä¾èµ–åº“å½“å‰æœ€æ–°çš„ release ç‰ˆæœ¬ï¼š 123456compileSdkVersion 29implementation 'androidx.appcompat:appcompat:1.1.0'implementation "androidx.lifecycle:lifecycle-common:2.2.0"implementation "androidx.lifecycle:lifecycle-common-java8:2.2.0"implementation "androidx.lifecycle:lifecycle-runtime:2.2.0" ä¸€ã€Lifecycle1.1ã€å¦‚ä½•ä½¿ç”¨çŽ°å¦‚ä»Šï¼Œå¦‚æžœæˆ‘ä»¬æƒ³è¦æ ¹æ® Activity çš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€çš„å˜åŒ–æ¥ç®¡ç†æˆ‘ä»¬çš„ä¸šåŠ¡é€»è¾‘çš„è¯ï¼Œé‚£ä¹ˆå¯ä»¥å¾ˆæ–¹ä¾¿çš„ä½¿ç”¨ç±»ä¼¼å¦‚ä¸‹ä»£ç æ¥ç›‘å¬å…¶ç”Ÿå‘½å‘¨æœŸçŠ¶æ€çš„å˜åŒ– 1234567891011121314151617override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) lifecycle.addObserver(object : DefaultLifecycleObserver &#123; override fun onCreate(owner: LifecycleOwner) &#123; &#125; override fun onResume(owner: LifecycleOwner) &#123; &#125; override fun onDestroy(owner: LifecycleOwner) &#123; &#125; &#125;)&#125; ä»¥ä¸Šä»£ç æ˜¯åŸºäºŽæŽ¥å£çš„å½¢å¼ï¼ˆDefaultLifecycleObserverï¼‰æ¥è¿›è¡Œäº‹ä»¶å›žè°ƒçš„ï¼Œæ¯å½“ Activity çš„ç”Ÿå‘½å‘¨æœŸå‡½æ•°è¢«è§¦å‘æ—¶ï¼Œè¯¥æŽ¥å£çš„ç›¸åº”åŒåå‡½æ•°å°±ä¼šåœ¨ä¹‹å‰æˆ–è€…ä¹‹åŽè¢«è°ƒç”¨ï¼Œä»¥æ­¤æ¥èŽ·å¾—ç›¸åº”ç”Ÿå‘½å‘¨æœŸäº‹ä»¶å˜åŒ–çš„é€šçŸ¥ æ­¤å¤–è¿˜æœ‰ä¸€ç§åŸºäºŽ OnLifecycleEvent æ³¨è§£çš„æ–¹å¼æ¥è¿›è¡Œå›žè°ƒçš„æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¸»è¦æ˜¯é¢å‘åŸºäºŽ Java 7 ä½œä¸ºç¼–è¯‘ç‰ˆæœ¬çš„å¹³å°ï¼Œä½†è¯¥æ–¹å¼åœ¨ä»¥åŽä¼šè¢«é€æ­¥åºŸå¼ƒï¼ŒGoogle å®˜æ–¹ä¹Ÿå»ºè®®å¼€å‘è€…å°½é‡ä½¿ç”¨æŽ¥å£å›žè°ƒçš„å½¢å¼ åŸºäºŽæ³¨è§£çš„æ–¹å¼ä¸å¯¹å‡½æ•°ååšç‰¹å®šè¦æ±‚ï¼Œä½†æ˜¯å¯¹äºŽå‡½æ•°çš„å…¥å‚ç±»åž‹ã€å…¥å‚é¡ºåºã€å…¥å‚ä¸ªæ•°æœ‰ç‰¹å®šè¦æ±‚ï¼Œè¿™ä¸ªåœ¨åŽç»­ç« èŠ‚ä¼šæœ‰ä»‹ç» 123456789101112131415161718lifecycle.addObserver(object : LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun onCreateEvent(lifecycleOwner: LifecycleOwner) &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) fun onDestroyEvent(lifecycleOwner: LifecycleOwner) &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_ANY) fun onAnyEvent(lifecycleOwner: LifecycleOwner, event: Lifecycle.Event) &#123; &#125; &#125;) 1.2ã€LifecycleLifecycle æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œå…¶æœ¬èº«çš„é€»è¾‘æ¯”è¾ƒç®€å•ï¼Œåœ¨å¤§å¤šæ•°æ—¶å€™æˆ‘ä»¬ä¼šæŽ¥è§¦åˆ°çš„æ˜¯å…¶å­ç±» LifecycleRegistryã€‚Lifecycle å†…éƒ¨ä»…åŒ…å«ä¸€ä¸ªå…¨å±€å˜é‡ï¼Œä¸‰ä¸ªæŠ½è±¡æ–¹æ³•ã€ä¸¤ä¸ªæžšä¸¾ç±» Lifecycle å†…éƒ¨åŒ…å«çš„æˆå‘˜å˜é‡ï¼Œç”¨äºŽåœ¨å¼•å…¥äº† lifecycle-common-ktx åŒ…çš„æƒ…å†µï¼Œå³åœ¨ä½¿ç”¨ kotlin åç¨‹åº“çš„æ—¶å€™æ‰æœ‰ç”¨ã€‚åœ¨è¿™é‡Œæ— éœ€ç†ä¼š 123@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)@NonNullAtomicReference&lt;Object&gt; mInternalScopeRef = new AtomicReference&lt;&gt;(); åŒ…å«çš„ä¸‰ä¸ªæŠ½è±¡å‡½æ•°ï¼Œåˆ†åˆ«ç”¨äºŽæ·»åŠ  LifecycleObserver ã€ç§»é™¤ LifecycleObserverã€èŽ·å–å½“å‰ Lifecycle æ‰€å¤„çš„çŠ¶æ€å€¼ 123456789@MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); @MainThread @NonNull public abstract State getCurrentState(); Lifecycle å†…éƒ¨åŒ…å«çš„ä¸¤ä¸ªæžšä¸¾ç±»ï¼Œç”¨äºŽæ ‡è®° Activity/Fragment ç­‰å…·æœ‰ç”Ÿå‘½å‘¨æœŸçŠ¶æ€çš„äº‹ç‰©å½“å‰æ‰€å¤„çš„çŠ¶æ€ Event ç±»ç”¨äºŽæŠ½è±¡ Activity/Fragment çš„ç”Ÿå‘½å‘¨æœŸäº‹ä»¶å‘ç”Ÿå˜åŒ–æ—¶æ‰€è§¦å‘çš„äº‹ä»¶ã€‚ä¾‹å¦‚ï¼Œå½“ Activity çš„æ¯ä¸ªç”Ÿå‘½å‘¨æœŸäº‹ä»¶å›žè°ƒå‡½æ•°ï¼ˆonCreateã€onStart ç­‰ï¼‰è¢«è§¦å‘æ—¶éƒ½ä¼šè¢«æŠ½è±¡ä¸ºç›¸åº”çš„ ON_CREATEã€ON_START ä¸¤ä¸ª Event 123456789public enum Event &#123; ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY &#125; State ç±»ç”¨äºŽæ ‡è®° Lifecycle çš„å½“å‰ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ 123456789101112131415public enum State &#123; //å½“å¤„äºŽ DESTROYED çŠ¶æ€æ—¶ï¼ŒLifecycle å°†ä¸ä¼šå‘å¸ƒå…¶å®ƒ Event å€¼ //å½“ Activity å³å°†å›žè°ƒ onDestory æ—¶åˆ™å¤„äºŽæ­¤çŠ¶æ€ DESTROYED, //å·²åˆå§‹åŒ–çš„çŠ¶æ€ã€‚ä¾‹å¦‚ï¼Œå½“ Activity çš„æž„é€ å‡½æ•°å·²å®Œæˆï¼Œä½†è¿˜æœªå›žè°ƒ onCreate æ—¶åˆ™å¤„äºŽæ­¤çŠ¶æ€ INITIALIZED, CREATED, STARTED, RESUMED; //å¦‚æžœå½“å‰çŠ¶æ€å¤§äºŽå…¥å‚å€¼ state æ—¶ï¼Œåˆ™è¿”å›ž true public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125;&#125; äºŒã€Lifecycle ç›¸å…³çš„æŽ¥å£åœ¨ Lifecycle ä½“ç³»ä¸­ï¼Œå¾ˆå¤šäº‹ä»¶å›žè°ƒå’Œç±»åž‹å®šä¹‰éƒ½æ˜¯é€šè¿‡æŽ¥å£çš„å½¢å¼æ¥å®žçŽ°çš„ï¼Œè¿™é‡Œå†æ¥ç½—åˆ—ä¸‹å¼€å‘è€…ç»å¸¸ä¼šä½¿ç”¨åˆ°çš„å‡ ä¸ªæŽ¥å£åŠå…¶ä½œç”¨ 2.1ã€LifecycleOwnerLifecycleOwner æŽ¥å£ç”¨äºŽæ ‡è®°å…¶å®žçŽ°ç±»å…·å¤‡ Lifecycle å¯¹è±¡ã€‚æˆ‘ä»¬æ—¥å¸¸ä½¿ç”¨çš„ androidx.appcompat.app.AppCompatActivity å’Œ androidx.fragment.app.Fragment å‡å®žçŽ°äº†è¯¥æŽ¥å£ 1234public interface LifecycleOwner &#123; @NonNull Lifecycle getLifecycle();&#125; 2.2ã€LifecycleObserverLifecycleObserver æ˜¯ä¸€ä¸ªç©ºæŽ¥å£ï¼Œå¤§éƒ¨åˆ†æƒ…å†µä¸‹çœŸæ­£å…·æœ‰ä½¿ç”¨æ„ä¹‰çš„æ˜¯å®ƒçš„å­æŽ¥å£ ï¼ŒLifecycleObserver å¯ä»¥è¯´ä»…æ˜¯ç”¨äºŽç±»åž‹æ ‡è®° 123public interface LifecycleObserver &#123;&#125; 1ã€LifecycleEventObserverLifecycleEventObserver ç”¨äºŽç›‘å¬ Lifecycle çš„ç”Ÿå‘½å‘¨æœŸå˜åŒ–ï¼Œå¯ä»¥èŽ·å–åˆ°ç”Ÿå‘½å‘¨æœŸäº‹ä»¶å‘ç”Ÿçš„å…·ä½“å˜åŒ– 12345public interface LifecycleEventObserver extends LifecycleObserver &#123; //å½“ LifecycleOwner å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸäº‹ä»¶å‘ç”Ÿå˜åŒ–æ—¶å°†å›žè°ƒæ­¤æ–¹æ³• void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);&#125; 2ã€FullLifecycleObserverFullLifecycleObserver æ ¹æ® Activity/Fragment è¿™ä¸¤ä¸ªç±»çš„ç”Ÿå‘½å‘¨æœŸå›žè°ƒå‡½æ•°æ‰©å±•äº†å‡ ä¸ªåŒåçš„æŠ½è±¡æ–¹æ³•ï¼Œå¯ä»¥çœ‹æˆæ˜¯å¯¹ LifecycleEventObserver è¿›è¡Œæ›´åŠ å…·ä½“çš„äº‹ä»¶æ‹†åˆ† 1234567891011121314interface FullLifecycleObserver extends LifecycleObserver &#123; void onCreate(LifecycleOwner owner); void onStart(LifecycleOwner owner); void onResume(LifecycleOwner owner); void onPause(LifecycleOwner owner); void onStop(LifecycleOwner owner); void onDestroy(LifecycleOwner owner);&#125; 3ã€DefaultLifecycleObserverDefaultLifecycleObserver æŽ¥å£ç»§æ‰¿äºŽ FullLifecycleObserverï¼Œandroidx.lifecycle:lifecycle-common-java8:xxx æ•´ä¸ªä¾èµ–åº“ä»…åŒ…å«äº†è¯¥æŽ¥å£ï¼Œä»Žä¾èµ–åº“çš„å‘½åä¸Šæ¥çœ‹ï¼Œå¯ä»¥çœ‹å‡ºå®ƒæ˜¯ç”¨äºŽ Java 8 å¹³å°çš„ã€‚DefaultLifecycleObserver å°† FullLifecycleObserver çš„æ‰€æœ‰æ–¹æ³•éƒ½è¿›è¡Œäº†é»˜è®¤å®žçŽ°ï¼Œè®©å¼€å‘è€…å¯ä»¥åªå¤„ç†è‡ªå·±å…³å¿ƒçš„ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ã€‚å› ä¸ºå¤§å¤šæ•°æ—¶å€™æˆ‘ä»¬ä»…éœ€è¦ä½¿ç”¨ä¸€éƒ¨åˆ†ç”Ÿå‘½å‘¨æœŸçŠ¶æ€å‡½æ•°ï¼Œå¦‚æžœä½¿ç”¨ FullLifecycleObserver çš„è¯æˆ‘ä»¬å°±å¿…é¡»å®žçŽ°æ‰€æœ‰æŠ½è±¡æ–¹æ³•ï¼Œè€Œå¤§éƒ¨åˆ†æ–¹æ³•å¯èƒ½éƒ½æ˜¯ç©ºå®žçŽ° æ‰€ä»¥ï¼Œä¸ºäº†ç®€åŒ–ä»£ç ï¼ŒJetpack ä¹Ÿæä¾›äº† DefaultLifecycleObserver æŽ¥å£ï¼Œè€ŒæŽ¥å£å¯ä»¥å£°æ˜Žé»˜è®¤æ–¹æ³•è¿™ä¸€ç‰¹æ€§ä¹Ÿæ˜¯ Java 8 å¼€å§‹æ‰æœ‰çš„ï¼Œæ‰€ä»¥åªæœ‰å½“ä½ çš„é¡¹ç›®æ˜¯ä»¥ Java 8 ä½œä¸ºç›®æ ‡ç¼–è¯‘ç‰ˆæœ¬æ—¶ï¼Œæ‰å¯ä»¥ä½¿ç”¨ DefaultLifecycleObserverã€‚è€Œ Google å®˜æ–¹ä¹Ÿå»ºè®®å¼€å‘è€…å°½é‡ä½¿ç”¨ DefaultLifecycleObserver ï¼Œå› ä¸º Java 8 æœ€ç»ˆæ˜¯ä¼šæˆä¸º Android å¼€å‘çš„ä¸»æµï¼Œè€Œ Java 7 å¹³å°ä¸‹é€šè¿‡æ³¨è§£ OnLifecycleEvent æ¥å®žçŽ°ç”Ÿå‘½å‘¨æœŸå›žè°ƒçš„æ–¹å¼æœ€ç»ˆä¼šè¢«åºŸå¼ƒ 1234567891011121314151617181920public interface DefaultLifecycleObserver extends FullLifecycleObserver &#123; @Override default void onCreate(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onStart(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onResume(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onPause(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onStop(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onDestroy(@NonNull LifecycleOwner owner) &#123; &#125;&#125; 4ã€FullLifecycleObserverAdapterFullLifecycleObserverAdapter å®žçŽ°äº† LifecycleEventObserver æŽ¥å£ï¼Œç”¨äºŽåœ¨æ”¶åˆ° Lifecycle ç”Ÿå‘½å‘¨æœŸäº‹ä»¶çŠ¶æ€å˜åŒ–æ—¶ï¼Œå¯¹å…¶ä¸¤ä¸ªæž„é€ å‡½æ•°å‚æ•°ï¼ˆ FullLifecycleObserverã€LifecycleEventObserverï¼‰è¿›è¡Œäº‹ä»¶è½¬å‘ 12345678910111213141516171819202122232425262728293031323334353637383940class FullLifecycleObserverAdapter implements LifecycleEventObserver &#123; private final FullLifecycleObserver mFullLifecycleObserver; private final LifecycleEventObserver mLifecycleEventObserver; FullLifecycleObserverAdapter(FullLifecycleObserver fullLifecycleObserver, LifecycleEventObserver lifecycleEventObserver) &#123; mFullLifecycleObserver = fullLifecycleObserver; mLifecycleEventObserver = lifecycleEventObserver; &#125; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; switch (event) &#123; case ON_CREATE: mFullLifecycleObserver.onCreate(source); break; case ON_START: mFullLifecycleObserver.onStart(source); break; case ON_RESUME: mFullLifecycleObserver.onResume(source); break; case ON_PAUSE: mFullLifecycleObserver.onPause(source); break; case ON_STOP: mFullLifecycleObserver.onStop(source); break; case ON_DESTROY: mFullLifecycleObserver.onDestroy(source); break; case ON_ANY: throw new IllegalArgumentException("ON_ANY must not been send by anybody"); &#125; if (mLifecycleEventObserver != null) &#123; mLifecycleEventObserver.onStateChanged(source, event); &#125; &#125;&#125; 2.3ã€OnLifecycleEventOnLifecycleEvent æ˜¯ä¸€ä¸ªè‡ªå®šä¹‰æ³¨è§£ï¼Œå½“å¼€å‘è€…æƒ³è¦é€šè¿‡æ³¨è§£çš„å½¢å¼æ¥å¯¹åº”ä¸åŒçš„ç”Ÿå‘½å‘¨æœŸå›žè°ƒæ—¶å°±éœ€è¦ä½¿ç”¨åˆ°ï¼Œè¿™ä¸€èˆ¬åªç”¨äºŽç¼–è¯‘ç‰ˆæœ¬æ˜¯ Java 7 çš„æƒ…å†µ 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface OnLifecycleEvent &#123; Lifecycle.Event value();&#125; ä¸‰ã€ReportFragmentçŽ°å¦‚ä»Šï¼Œå¦‚æžœæˆ‘ä»¬æƒ³è¦æ ¹æ® Activity çš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€çš„å˜åŒ–æ¥ç®¡ç†æˆ‘ä»¬çš„ä¸šåŠ¡é€»è¾‘çš„è¯ï¼Œé‚£ä¹ˆå¯ä»¥å¾ˆæ–¹ä¾¿çš„ä½¿ç”¨ç±»ä¼¼å¦‚ä¸‹ä»£ç æ¥ç›‘å¬å…¶ç”Ÿå‘½å‘¨æœŸçŠ¶æ€çš„å˜åŒ– 1234567891011121314151617override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) lifecycle.addObserver(object : LifecycleEventObserver &#123; override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) &#123;when (event) &#123; Lifecycle.Event.ON_CREATE -&gt; TODO() Lifecycle.Event.ON_START -&gt; TODO() Lifecycle.Event.ON_RESUME -&gt; TODO() Lifecycle.Event.ON_PAUSE -&gt; TODO() Lifecycle.Event.ON_STOP -&gt; TODO() Lifecycle.Event.ON_DESTROY -&gt; TODO() Lifecycle.Event.ON_ANY -&gt; TODO() &#125; &#125; &#125;)&#125; ç”¨æ˜¯è¿™æ ·å°±èƒ½ç”¨äº†ï¼Œä½†æ·±ç©¶èµ·æ¥ï¼Œæ­¤æ—¶ä¸€ä¸ªå¾ˆæ˜¾è€Œæ˜“è§çš„é—®é¢˜å°±æ˜¯ï¼ŒLifecycleEventObserver æ˜¯å¦‚ä½•å–å¾—å„ä¸ªç”Ÿå‘½å‘¨æœŸçŠ¶æ€å˜åŒ–çš„äº‹ä»¶ï¼ˆLifecycle.Eventï¼‰å‘¢ï¼Ÿæˆ–è€…è¯´ï¼Œæ˜¯è°å›žè°ƒäº† LifecycleEventObserver çš„ onStateChanged æ–¹æ³•å‘¢ï¼Ÿ çŽ°åœ¨æˆ‘ä»¬åœ¨æ—¥å¸¸å¼€å‘ä¸­ï¼Œå¤šæ•°æƒ…å†µä¸‹æˆ‘ä»¬ä½¿ç”¨çš„ Activity éƒ½æ˜¯ç»§æ‰¿äºŽ androidx.appcompat.appcompat:xxxè¿™ä¸ªåŒ…å†…çš„ AppCompatActivityï¼Œè€Œ AppCompatActivity æœ€ç»ˆæ˜¯ä¼šç»§æ‰¿äºŽ androidx.core.app.ComponentActivityï¼Œ ComponentActivity çš„ onCreate å‡½æ•°æ˜¯è¿™æ ·çš„ï¼š 123456@SuppressLint("RestrictedApi")@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this);&#125; è€Œæ­£æ˜¯é€šè¿‡ ReportFragment ä½¿å¾— LifecycleEventObserver å¯ä»¥æŽ¥æ”¶åˆ° Activity æ‰€æœ‰çš„çš„ Lifecycle.Event è¿™é‡Œå°±æ¥è¯¦ç»†çœ‹çœ‹ ReportFragment çš„å†…éƒ¨æºç ï¼Œä¸€æ­¥æ­¥äº†è§£å…¶å®žçŽ°é€»è¾‘ injectIfNeededIn() å‡½æ•°æ˜¯ä¸€ä¸ªé™æ€å‡½æ•°ï¼Œä»¥ android.app.Activity å¯¹è±¡ä½œä¸ºå…¥å‚å‚æ•° 12345678910111213141516171819 public static void injectIfNeededIn(Activity activity) &#123; if (Build.VERSION.SDK_INT &gt;= 29) &#123; // On API 29+, we can register for the correct Lifecycle callbacks directly //å½“ API ç­‰çº§ä¸º 29+ æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æŽ¥å‘ android.app.Activity æ³¨å†Œç”Ÿå‘½å‘¨æœŸå›žè°ƒ activity.registerActivityLifecycleCallbacks( new LifecycleCallbacks()); &#125; // Prior to API 29 and to maintain compatibility with older versions of // ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and // need to support activities that don't extend from FragmentActivity from support lib), // use a framework fragment to get the correct timing of Lifecycle events //åœ¨ API 29 ä¹‹å‰ï¼Œå‘ activity æ·»åŠ ä¸€ä¸ªä¸å¯è§çš„ framework ä¸­çš„ fragmentï¼Œä»¥æ­¤æ¥å–å¾— Activity ç”Ÿå‘½å‘¨æœŸäº‹ä»¶çš„æ­£ç¡®å›žè°ƒ android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125;&#125; ReportFragment çš„ injectIfNeededIn() å‡½æ•°ä¼šæ ¹æ®ä¸¤ç§æƒ…å†µæ¥è¿›è¡Œäº‹ä»¶åˆ†å‘ è¿è¡Œè®¾å¤‡çš„ç³»ç»Ÿç‰ˆæœ¬å·å°äºŽ 29ã€‚æ­¤æƒ…å†µä¼šé€šè¿‡å‘ Activity æ·»åŠ ä¸€ä¸ªæ—  UI ç•Œé¢çš„ Fragmentï¼ˆå³ ReportFragmentï¼‰ï¼Œé—´æŽ¥èŽ·å¾— Activity çš„å„ä¸ªç”Ÿå‘½å‘¨æœŸäº‹ä»¶çš„å›žè°ƒé€šçŸ¥ è¿è¡Œè®¾å¤‡çš„ç³»ç»Ÿç‰ˆæœ¬å·å¤§äºŽæˆ–ç­‰äºŽ29ã€‚æ­¤æƒ…å†µä¼šå‘ Activity æ³¨å†Œä¸€ä¸ª LifecycleCallbacks ï¼Œä»¥æ­¤æ¥ç›´æŽ¥èŽ·å¾—å„ä¸ªç”Ÿå‘½å‘¨æœŸäº‹ä»¶çš„å›žè°ƒé€šçŸ¥ã€‚æ­¤æ—¶ä¹Ÿä¼šåŒæ—¶æ‰§è¡Œç¬¬ä¸€ç§æƒ…å†µçš„æ“ä½œ ä¹‹æ‰€ä»¥ä¼šè¿›è¡Œè¿™ä¸¤ç§æƒ…å†µåŒºåˆ†ï¼Œæ˜¯å› ä¸º registerActivityLifecycleCallbacks æ˜¯ SDK 29 æ—¶ android.app.Activity æ–°æ·»åŠ çš„æ–¹æ³•ï¼Œä»Žè¿™ä¸ªç‰ˆæœ¬å¼€å§‹æ”¯æŒç›´æŽ¥åœ¨ LifecycleCallbacks ä¸­å–å¾—äº‹ä»¶é€šçŸ¥ã€‚å½“ç”¨æˆ·çš„è®¾å¤‡ SDK ç‰ˆæœ¬å°äºŽ 29 æ—¶ï¼Œå°±è¿˜æ˜¯éœ€è¦é€šè¿‡ ReportFragment æ¥é—´æŽ¥å–å¾—äº‹ä»¶é€šçŸ¥ 3.1ã€SDK &gt;= 29å…ˆæ¥çœ‹ä¸‹ LifecycleCallbacks ç±»ã€‚å…¶é€»è¾‘å°±æ˜¯ä¼šåœ¨ Activity çš„ onCreateã€onStartã€onResume ç­‰æ–¹æ³•è¢«è°ƒç”¨åŽé€šè¿‡ dispatch(activity, Lifecycle.Event.ON_XXX) æ–¹æ³•å‘é€ç›¸åº”çš„ Event å€¼ï¼Œå¹¶åœ¨ onPauseã€onStopã€onDestroy ç­‰æ–¹æ³•è¢«è°ƒç”¨å‰å‘é€ç›¸åº”çš„ Event å€¼ 123456789101112131415161718192021222324static class LifecycleCallbacks implements Application.ActivityLifecycleCallbacks &#123; @Override public void onActivityCreated(@NonNull Activity activity, @Nullable Bundle bundle) &#123; &#125; @Override public void onActivityPostCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState) &#123; dispatch(activity, Lifecycle.Event.ON_CREATE); &#125; //çœç•¥éƒ¨åˆ†ç›¸ä¼¼ä»£ç  Â·Â·Â· @Override public void onActivityPreDestroyed(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_DESTROY); &#125; @Override public void onActivityDestroyed(@NonNull Activity activity) &#123; &#125;&#125; dispatch() æ–¹æ³•æ‹¿åˆ° Event å€¼åŽï¼Œå°±ä¼šå…ˆé€šè¿‡ activity æ‹¿åˆ° Lifecycle å¯¹è±¡ï¼Œå†é€šè¿‡ç±»åž‹åˆ¤æ–­æ‹¿åˆ° LifecycleRegistry å¯¹è±¡ï¼Œæœ€ç»ˆé€šè¿‡è°ƒç”¨ handleLifecycleEvent() æ–¹æ³•å°† Event å€¼ä¼ é€’å‡ºåŽ»ï¼Œä»Žè€Œä½¿å¾—å¤–éƒ¨å¾—åˆ°å„ä¸ªç”Ÿå‘½å‘¨æœŸäº‹ä»¶çš„é€šçŸ¥ ä»Žè¿™ä¹Ÿå¯ä»¥çœ‹å‡ºæ¥ï¼Œandroidx.appcompat.app.AppCompatActivity å®žçŽ°äº† LifecycleOwner æŽ¥å£åŽè¿”å›žçš„ Lifecycle å¯¹è±¡å°±æ˜¯ LifecycleRegistryï¼Œå®žé™…ä¸Š androidx.fragment.app.Fragment ä¹Ÿä¸€æ · 123456789101112131415@SuppressWarnings("deprecation")static void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) &#123; //LifecycleRegistryOwner å·²è¢«åºŸå¼ƒï¼Œä¸»è¦çœ‹ LifecycleOwner if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125;&#125; 3.2ã€SDK &lt; 29å†æ¥çœ‹ä¸‹å‘ Activity æ·»åŠ çš„ ReportFragment æ˜¯å¦‚ä½•ç”Ÿæ•ˆçš„ã€‚ç”±äºŽ ReportFragment æ˜¯æŒ‚è½½åœ¨ Activity èº«ä¸Šçš„ï¼ŒReportFragment æœ¬èº«çš„ç”Ÿå‘½å‘¨æœŸå‡½æ•°å’Œæ‰€åœ¨çš„ Activity æ˜¯ç›¸å…³è”çš„ï¼Œé€šè¿‡åœ¨ ReportFragment ç›¸åº”çš„ç”Ÿå‘½å‘¨æœŸå‡½æ•°é‡Œè°ƒç”¨ dispatch(Lifecycle.Event.ON_XXXX) å‡½æ•°å‘é€ç›¸åº”çš„ Event å€¼ï¼Œä»¥æ­¤æ¥é—´æŽ¥èŽ·å¾— Activity çš„å„ä¸ªç”Ÿå‘½å‘¨æœŸäº‹ä»¶çš„å›žè°ƒé€šçŸ¥ 1234567891011121314151617181920@Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); //çœç•¥æ— å…³ä»£ç  dispatch(Lifecycle.Event.ON_CREATE); &#125; @Override public void onStart() &#123; super.onStart(); //çœç•¥æ— å…³ä»£ç  dispatch(Lifecycle.Event.ON_START); &#125; @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); //çœç•¥æ— å…³ä»£ç  &#125; dispatch() å‡½æ•°å†…éƒ¨ä¼šåˆ¤æ–­ç›®æ ‡è®¾å¤‡çš„ç‰ˆæœ¬å·æ¥å†³å®šæ˜¯å¦çœŸçš„åˆ†å‘ Event å€¼ï¼Œé¿å…å½“ SDK ç‰ˆæœ¬å·å¤§äºŽ 29 æ—¶å’Œ LifecycleCallbacks é‡å¤å‘é€ 12345678private void dispatch(@NonNull Lifecycle.Event event) &#123; if (Build.VERSION.SDK_INT &lt; 29) &#123; // Only dispatch events from ReportFragment on API levels prior // to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks // added in ReportFragment.injectIfNeededIn dispatch(getActivity(), event); &#125;&#125; è¿™æ ·ï¼ŒReportFragment å°±é€šè¿‡ä¸Šè¿°é€»è¾‘å‘å¤–éƒ¨è½¬å‘äº† Activity å‘ç”Ÿçš„ Event å€¼ å››ã€LifecycleRegistryReportFragment æœ€ç»ˆåœ¨å‘å¤–ä¼ å‡º Lifecycle.Event å€¼æ—¶ï¼Œè°ƒç”¨çš„éƒ½æ˜¯ LifecycleRegistry å¯¹è±¡çš„ handleLifecycleEvent(Lifecycle.Event) æ–¹æ³•ï¼Œæ—¢ç„¶éœ€è¦çš„ Event å€¼å·²ç»æ‹¿åˆ°äº†ï¼Œé‚£å†æ¥çœ‹ä¸‹ LifecycleRegistry æ˜¯å¦‚ä½•å°† Event å€¼è½¬å‘ç»™ LifecycleObserver çš„ LifecycleRegistry æ˜¯æ•´ä¸ª Lifecycle å®¶æ—å†…ä¸€ä¸ªå¾ˆé‡è¦çš„ç±»ï¼Œå…¶å±è”½äº†ç”Ÿå‘½å‘¨æœŸæŒæœ‰ç±»ï¼ˆActivity / Fragment ç­‰ï¼‰çš„å…·ä½“ç±»åž‹ï¼Œä½¿å¾—å¤–éƒ¨ï¼ˆActivity / Fragment ç­‰ï¼‰å¯ä»¥åªè´Ÿè´£è½¬å‘ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ï¼Œç”± LifecycleRegistry æ¥å®žçŽ°å…·ä½“çš„äº‹ä»¶å›žè°ƒå’ŒçŠ¶æ€ç®¡ç†ã€‚androidx.activity.ComponentActivity å’Œ androidx.fragment.app.Fragment éƒ½ä½¿ç”¨åˆ°äº† LifecycleRegistry 12345678910111213141516 public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, OnBackPressedDispatcherOwner &#123; private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); @NonNull @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; &#125; 123456789101112public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner &#123; LifecycleRegistry mLifecycleRegistry; @Override @NonNull public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; &#125; åœ¨å…·ä½“çœ‹ LifecycleRegistry çš„å®žçŽ°é€»è¾‘ä¹‹å‰ï¼Œéœ€è¦å…ˆå¯¹ LifecycleRegistry çš„å®šä½ã€ä½œç”¨å’Œå¿…é¡»å…·å¤‡çš„åŠŸèƒ½æœ‰ä¸€ä¸ªå¤§è‡´çš„äº†è§£ï¼Œå¯ä»¥ä»Žæˆ‘ä»¬æƒ³è¦çš„æ•ˆæžœæ¥é€†æŽ¨å®žçŽ°è¿™ä¸ªæ•ˆæžœæ‰€éœ€è¦çš„æ­¥éª¤ï¼š ä¸å•å•æ˜¯ Activity å’Œ Fragment å¯ä»¥å®žçŽ° LifecycleOwner æŽ¥å£ï¼Œåƒ Serviceã€Dialog ç­‰å…·æœ‰ç”Ÿå‘½å‘¨æœŸçš„ç±»ä¸€æ ·å¯ä»¥å®žçŽ° LifecycleOwner æŽ¥å£ï¼Œè€Œä¸ç®¡ LifecycleOwner çš„å®žçŽ°ç±»æ˜¯ä»€ä¹ˆï¼Œå…¶æœ¬èº«æ‰€éœ€è¦å®žçŽ°çš„åŠŸèƒ½/é€»è¾‘éƒ½æ˜¯ä¸€æ ·çš„ï¼šaddObserverã€removeObserverã€getCurrentStateã€éåŽ†å¾ªçŽ¯ observers è¿›è¡Œ Event é€šçŸ¥ç­‰ã€‚æ‰€ä»¥ Google å®˜æ–¹åŠ¿å¿…éœ€è¦æä¾›ä¸€ä¸ªé€šç”¨çš„ Lifecycle å®žçŽ°ç±»ï¼Œä»¥æ­¤æ¥ç®€åŒ–å¼€å‘è€…å®žçŽ° LifecycleOwner æŽ¥å£çš„æˆæœ¬ï¼Œæœ€ç»ˆçš„å®žçŽ°ç±»å³ LifecycleRegistryï¼ˆä¹‹åŽå‡è®¾æˆ‘ä»¬éœ€è¦å®žçŽ° LifecycleOwner æŽ¥å£çš„ä»…æœ‰ Activity ä¸€ç§ï¼Œæ–¹ä¾¿è¯»è€…ç†è§£ï¼‰ LifecycleRegistry éœ€è¦æŒæœ‰ LifecycleOwner å¯¹è±¡æ¥åˆ¤æ–­æ˜¯å¦å¯ä»¥å‘å…¶å›žè°ƒäº‹ä»¶é€šçŸ¥ï¼Œä½†ä¸ºäº†é¿å…å†…å­˜æ³„æ¼ä¹Ÿä¸èƒ½ç›´æŽ¥å¼ºå¼•ç”¨ LifecycleOwner å‡è®¾å½“ Activity å¤„äºŽ State.STARTED çŠ¶æ€æ—¶å‘å…¶æ·»åŠ äº†ä¸€ä¸ª LifecycleEventObserver ï¼Œæ­¤æ—¶å°±å¿…é¡»å‘ LifecycleEventObserver åŒæ­¥å½“å‰çš„æœ€æ–°çŠ¶æ€å€¼ï¼Œæ‰€ä»¥ LifecycleEventObserver å°±ä¼šå…ˆåŽæ”¶åˆ° Lifecycle.Event.ON_CREATEã€Lifecycle.Event.ON_START ä¸¤ä¸ª Event LifecycleRegistry å‘ Observer å‘å¸ƒ Event å€¼çš„è§¦å‘æ¡ä»¶æœ‰ä¸¤ç§ï¼š æ–°æ·»åŠ äº†ä¸€ä¸ª Observerï¼Œéœ€è¦å‘å…¶åŒæ­¥ Activity å½“å‰çš„ State å€¼ã€‚åœ¨åŒæ­¥çš„è¿‡ç¨‹ä¸­æ–°çš„ Event å€¼å¯èƒ½åˆšå¥½åˆæ¥äº†ï¼Œæ­¤æ—¶éœ€è¦è€ƒè™‘å¦‚ä½•å‘æ‰€æœ‰ Observer åŒæ­¥æœ€æ–°çš„ Event å€¼ Activity çš„ç”Ÿå‘½å‘¨æœŸçŠ¶æ€å‘ç”Ÿäº†å˜åŒ–ï¼Œéœ€è¦å‘ Observer åŒæ­¥æœ€æ–°çš„ State å€¼ã€‚åœ¨åŒæ­¥çš„è¿‡ç¨‹ä¸­å¯èƒ½åˆæ·»åŠ äº†æ–°çš„ Observer æˆ–è€…ç§»é™¤äº† Observer ï¼Œæ­¤æ—¶ä¸€æ ·éœ€è¦è€ƒè™‘å¦‚ä½•å‘æ‰€æœ‰ Observer åŒæ­¥æœ€æ–°çš„ Event å€¼ æœ‰äº†ä»¥ä¸Šçš„å‡ ç‚¹è®¤çŸ¥åŽï¼Œå†æ¥çœ‹ä¸‹ LifecycleRegistry çš„å¤§è‡´é€»è¾‘ LifecycleRegistry è‡ªç„¶æ˜¯ Lifecycle çš„å­ç±»ï¼Œå…¶æž„é€ å‡½æ•°éœ€è¦ä¼ å…¥ LifecycleOwner å¯¹è±¡ 123456789101112131415public class LifecycleRegistry extends Lifecycle &#123; //ä¸€èˆ¬ä¸€ä¸ª LifecycleRegistry å¯¹åº”ä¸€ä¸ª LifecycleOwner å¯¹è±¡ï¼ˆActivity/Fragmentç­‰ï¼‰ //mState å°±ç”¨æ¥æ ‡è®° LifecycleOwner å¯¹è±¡æ‰€å¤„çš„å½“å‰ç”Ÿå‘½å‘¨æœŸçŠ¶æ€ private State mState; //æŒæœ‰å¯¹ LifecycleOwner çš„å¼±å¼•ç”¨ï¼Œé¿å…å†…å­˜æ³„éœ² private final WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner; public LifecycleRegistry(@NonNull LifecycleOwner provider) &#123; mLifecycleOwner = new WeakReference&lt;&gt;(provider); mState = INITIALIZED; &#125; &#125; addObserver() å‡½æ•°çš„ä¸»è¦é€»è¾‘æ˜¯ï¼šå°†ä¼ å…¥çš„ observer å¯¹è±¡åŒ…è£…ä¸º ObserverWithState ç±»åž‹ï¼Œæ–¹ä¾¿å°†æ³¨è§£å½¢å¼çš„LifecycleObserverï¼ˆJava 7ï¼‰å’ŒæŽ¥å£å®žçŽ°çš„ LifecycleObserverï¼ˆJava 8ï¼‰è¿›è¡ŒçŠ¶æ€å›žè°ƒæ—¶çš„å…¥å£ç»Ÿä¸€ä¸º dispatchEvent() æ–¹æ³•ã€‚æ­¤å¤–ï¼Œç”±äºŽå½“æ·»åŠ  LifecycleObserver æ—¶ Lifecycle å¯èƒ½å·²ç»å¤„äºŽéž INITIALIZED çŠ¶æ€äº†ï¼Œæ‰€ä»¥éœ€è¦é€šè¿‡å¾ªçŽ¯æ£€æŸ¥çš„æ–¹å¼æ¥å‘ ObserverWithState é€æ­¥ä¸‹å‘ Event å€¼ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Lifecycle ç±»ä¸­å¯¹ addObserver æ–¹æ³•æ·»åŠ äº† @MainThread æ³¨è§£ï¼Œæ„æ€æ˜¯è¯¥æ–¹æ³•åªèƒ½ç”¨äºŽä¸»çº¿ç¨‹è°ƒç”¨ //æ‰€ä»¥æ­¤å¤„ä¸éœ€è¦è€ƒè™‘å¤šçº¿ç¨‹çš„æƒ…å†µ@Override public void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; //å¦‚æžœ observer ä¹‹å‰å·²ç»ä¼ è¿›æ¥è¿‡äº†ï¼Œåˆ™ä¸é‡å¤æ·»åŠ ï¼Œç›´æŽ¥è¿”å›ž return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly //å¦‚æžœ LifecycleOwner å¯¹è±¡å·²ç»è¢«å›žæ”¶äº†ï¼Œåˆ™ç›´æŽ¥è¿”å›ž return; &#125; //å¦‚æžœ isReentrance ä¸º trueï¼Œåˆ™è¯´æ˜Žæ­¤æ—¶ä»¥ä¸‹ä¸¤ç§æƒ…å†µè‡³å°‘æœ‰ä¸€ä¸ªæˆç«‹ï¼š //1. mAddingObserverCounter != 0ã€‚ä¼šå‡ºçŽ°è¿™ç§æƒ…å†µï¼Œæ˜¯ç”±äºŽå¼€å‘è€…å…ˆæ·»åŠ äº†ä¸€ä¸ª LifecycleObserver ï¼Œå½“è¿˜åœ¨å‘å…¶å›žè°ƒäº‹ä»¶çš„è¿‡ç¨‹ä¸­ï¼Œåœ¨å›žè°ƒå‡½æ•°é‡Œåˆå†æ¬¡è°ƒç”¨äº† addObserver æ–¹æ³•æ·»åŠ äº†ä¸€ä¸ªæ–°çš„ LifecycleObserver //2.mHandlingEvent ä¸º trueã€‚å³æ­¤æ—¶æ­£å¤„äºŽå‘å¤–å›žè°ƒ Lifecycle.Event çš„çŠ¶æ€ boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); //é€’å¢žåŠ ä¸€ï¼Œæ ‡è®°å½“å‰æ­£å¤„äºŽå‘æ–°æ·»åŠ çš„ LifecycleObserver å›žè°ƒ Event å€¼çš„è¿‡ç¨‹ mAddingObserverCounter++; //statefulObserver.mState.compareTo(targetState) &lt; 0 æˆç«‹çš„è¯è¯´æ˜Ž State å€¼è¿˜æ²¡éåŽ†åˆ°ç›®æ ‡çŠ¶æ€ //mObserverMap.contains(observer) æˆç«‹çš„è¯è¯´æ˜Ž observer è¿˜æ²¡æœ‰å¹¶ç§»é™¤ //å› ä¸ºæœ‰å¯èƒ½åœ¨éåŽ†è¿‡ç¨‹ä¸­å¼€å‘è€…ä¸»åŠ¨åœ¨å›žè°ƒå‡½æ•°é‡Œå°† observer ç»™ç§»é™¤æŽ‰äº†ï¼Œæ‰€ä»¥è¿™é‡Œæ¯æ¬¡å¾ªçŽ¯éƒ½æ£€æŸ¥ä¸‹ while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; //å°† observer å·²ç»éåŽ†åˆ°çš„å½“å‰çš„çŠ¶æ€å€¼ mState ä¿å­˜ä¸‹æ¥ pushParentState(statefulObserver.mState); //å‘ observer å›žè°ƒè¿›å…¥â€œstatefulObserver.mStateâ€å‰éœ€è¦æ”¶åˆ°çš„ Event å€¼ statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); //ç§»é™¤ mState popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--; &#125; å‘ LifecycleObserver å›žè°ƒäº‹ä»¶çš„è¿‡ç¨‹å¯ä»¥ç”¨ä»¥ä¸‹è¿™å¼ å®˜æ–¹æä¾›çš„å›¾æ¥å±•ç¤º å‡è®¾å½“å‰ LifecycleRegistry çš„ mState å¤„äºŽ RESUMED çŠ¶æ€ï¼Œæ­¤æ—¶é€šè¿‡ addObserver æ–¹æ³•æ–°æ·»åŠ çš„ LifecycleObserver ä¼šè¢«åŒ…è£…ä¸º ObserverWithStateï¼Œä¸”åˆå§‹åŒ–çŠ¶æ€ä¸º INITIALIZEDã€‚ç”±äºŽ RESUMED å¤§äºŽINITIALIZEDï¼ŒObserverWithState å°±ä¼šæŒ‰ç…§ INITIALIZED -&gt; CREATED -&gt; STARTED -&gt; RESUMED è¿™æ ·çš„é¡ºåºå…ˆåŽæ”¶åˆ°äº‹ä»¶é€šçŸ¥ å‡è®¾å½“å‰ LifecycleRegistry çš„ mState å¤„äºŽ STARTED çŠ¶æ€ã€‚å¦‚æžœ LifecycleRegistry æ”¶åˆ° ON_RESUME äº‹ä»¶ï¼ŒmState å°±éœ€è¦å˜æ›´ä¸º RESUMEDï¼›å¦‚æžœ LifecycleRegistry æ”¶åˆ° ON_STOP äº‹ä»¶ï¼ŒmState å°±éœ€è¦å˜æ›´ä¸º CREATEDï¼›æ‰€ä»¥è¯´ï¼ŒLifecycleRegistry çš„ mState ä¼šå…ˆåŽå‘ä¸åŒæ–¹å‘è¿ç§» ObserverWithState å°†å¤–ç•Œä¼ å…¥çš„ LifecycleObserver å¯¹è±¡ä¼ ç»™ Lifecycling è¿›è¡Œç±»åž‹åŒ…è£…ï¼Œå°†åå°„é€»è¾‘å’ŒæŽ¥å£å›žè°ƒé€»è¾‘éƒ½ç»™æ±‡æ€»ç»¼åˆæˆä¸€ä¸ªæ–°çš„ LifecycleEventObserver å¯¹è±¡ï¼Œä»Žè€Œä½¿å¾— Event åˆ†å‘è¿‡ç¨‹éƒ½ç»Ÿä¸€ä¸ºä¸€ä¸ªå…¥å£ 12345678910111213141516static class ObserverWithState &#123; State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125;&#125; è€Œåœ¨ä¸Šæ–‡æåˆ°çš„ï¼ŒReportFragment æœ€ç»ˆåœ¨å‘å¤–ä¼ å‡º Lifecycle.Event å€¼æ—¶ï¼Œè°ƒç”¨çš„éƒ½æ˜¯ LifecycleRegistry å¯¹è±¡çš„ handleLifecycleEvent(Lifecycle.Event) æ–¹æ³•ï¼Œè¯¥æ–¹æ³•ä¼šæ ¹æ®æŽ¥æ”¶åˆ°çš„ Event å€¼æ¢ç®—å‡ºå¯¹åº”çš„ State å€¼ï¼Œç„¶åŽæ›´æ–°æœ¬åœ°çš„ mStateï¼Œå†å‘æ‰€æœ‰ Observer è¿›è¡Œäº‹ä»¶é€šçŸ¥ï¼Œæœ€ç»ˆè¿˜æ˜¯ä¼šè°ƒç”¨åˆ° ObserverWithState çš„ dispatchEvent æ–¹æ³•ï¼Œæ‰€ä»¥åŽè¾¹æˆ‘ä»¬å†æ¥é‡ç‚¹å…³æ³¨ dispatchEvent æ–¹æ³•å³å¯ 12345678910111213141516171819public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125;private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false;&#125; éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ï¼Œå¯¹ androidx.fragment.app.Fragment ç”Ÿå‘½å‘¨æœŸäº‹ä»¶çš„ç›‘å¬ä¸€æ ·éœ€è¦ä½¿ç”¨åˆ° LifecycleRegistryï¼ŒFragment å†…éƒ¨æœ€ç»ˆä¹Ÿæ˜¯é€šè¿‡è°ƒç”¨å…¶ handleLifecycleEvent(Lifecycle.Event) æ–¹æ³•æ¥å®Œæˆå…¶æœ¬èº«çš„ç”Ÿå‘½å‘¨æœŸäº‹ä»¶é€šçŸ¥ï¼Œä»£ç è¾ƒä¸ºç®€å•ï¼Œè¿™é‡Œä¸å†èµ˜è¿° äº”ã€Lifecyclingä¸Šé¢è¯´åˆ°äº†ï¼ŒLifecycleRegistry ä¼šå°†å¤–éƒ¨ä¼ å…¥çš„æ‰€æœ‰ LifecycleObserver æ ¹æ® Lifecycling åŒ…è£…æˆ LifecycleEventObserver å¯¹è±¡ï¼Œè¿™é‡Œå…ˆæ¥è§£é‡Šä¸‹ä¸ºä»€ä¹ˆéœ€è¦è¿›è¡Œè¿™å±‚åŒ…è£… LifecycleEventObserver å’Œ FullLifecycleObserver éƒ½æ˜¯ç»§æ‰¿äºŽ LifecycleObserver çš„æŽ¥å£ï¼Œå¦‚æžœå¼€å‘è€…è‡ªå·±å®žçŽ°çš„è‡ªå®šä¹‰ Observer åŒæ—¶å®žçŽ°äº†è¿™ä¸¤ä¸ªæŽ¥å£ï¼Œé‚£æŒ‰é“ç†æ¥è¯´ LifecycleRegistry å°±å¿…é¡»åœ¨æœ‰äº‹ä»¶è§¦å‘çš„æƒ…å†µä¸‹åŒæ—¶å›žè°ƒè¿™ä¸¤ä¸ªæŽ¥å£çš„æ‰€æœ‰æ–¹æ³• å¦‚æžœå¼€å‘è€…è‡ªå·±å®žçŽ°çš„è‡ªå®šä¹‰ Observer ä»…å®žçŽ°äº† LifecycleEventObserver å’Œ FullLifecycleObserver è¿™ä¸¤ä¸ªæŽ¥å£å½“ä¸­çš„ä¸€ä¸ªï¼Œé‚£ä¹ˆä¹Ÿéœ€è¦åœ¨æœ‰äº‹ä»¶è§¦å‘çš„æƒ…å†µä¸‹è°ƒç”¨ç›¸åº”æŽ¥å£çš„å¯¹åº”æ–¹æ³• å®žçŽ°äº†é€šè¿‡ä»¥ä¸Šä¸¤ä¸ªæŽ¥å£æ¥å®žçŽ°å›žè°ƒå¤–ï¼ŒGoogle ä¹Ÿæä¾›äº†é€šè¿‡æ³¨è§£çš„æ–¹æ³•æ¥å£°æ˜Žç”Ÿå‘½å‘¨æœŸå›žè°ƒå‡½æ•°ï¼Œæ­¤æ—¶å°±åªèƒ½é€šè¿‡åå°„æ¥è¿›è¡Œå›žè°ƒ åŸºäºŽä»¥ä¸Šä¸‰ç‚¹çŽ°çŠ¶ï¼Œå¦‚æžœåœ¨ LifecycleRegistry ä¸­ç›´æŽ¥å¯¹å¤–éƒ¨ä¼ å…¥çš„ Observer æ¥è¿›è¡Œç±»åž‹åˆ¤æ–­ã€æŽ¥å£å›žè°ƒã€åå°„è°ƒç”¨ç­‰ä¸€ç³»åˆ—æ“ä½œçš„è¯ï¼Œé‚£åŠ¿å¿…ä¼šä½¿å¾— LifecycleRegistry æ•´ä¸ªç±»éžå¸¸çš„è‡ƒè‚¿ï¼Œæ‰€ä»¥ Lifecycling çš„ä½œç”¨å°±æ˜¯æ¥å°†è¿™ä¸€ç³»åˆ—çš„é€»è¾‘ç»™å°è£…èµ·æ¥ï¼Œä»…ä»…å¼€æ”¾ä¸€ä¸ª onStateChanged æ–¹æ³•å³å¯è®© LifecycleRegistry å®Œæˆæ•´ä¸ªäº‹ä»¶åˆ†å‘ï¼Œä»Žè€Œä½¿å¾—æ•´ä¸ªæµç¨‹ä¼šæ›´åŠ æ¸…æ™°æ˜Žäº†ä¸”èŒè´£åˆ†æ˜Ž é‚£çŽ°åœ¨å°±æ¥çœ‹ä¸‹ lifecycleEventObserver æ–¹æ³•çš„é€»è¾‘ 123456789101112131415161718192021222324252627282930313233343536373839404142@NonNull static LifecycleEventObserver lifecycleEventObserver(Object object) &#123; //ä»¥ä¸‹å¯¹åº”äºŽä¸Šè¿°çš„ç¬¬ä¸€ç‚¹å’Œç¬¬äºŒç‚¹ boolean isLifecycleEventObserver = object instanceof LifecycleEventObserver; boolean isFullLifecycleObserver = object instanceof FullLifecycleObserver; if (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123; //å¦‚æžœ object å¯¹è±¡åŒæ—¶ç»§æ‰¿äº† LifecycleEventObserver å’Œ FullLifecycleObserver æŽ¥å£ //åˆ™å°†å…¶åŒ…è£…ä¸º FullLifecycleObserverAdapter å¯¹è±¡æ¥è¿›è¡Œäº‹ä»¶è½¬å‘ return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, (LifecycleEventObserver) object); &#125; if (isFullLifecycleObserver) &#123; //åŒä¸Š return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, null); &#125; if (isLifecycleEventObserver) &#123; //object å·²ç»æ˜¯éœ€è¦çš„ç›®æ ‡ç±»åž‹äº†ï¼ˆLifecycleEventObserverï¼‰ï¼Œç›´æŽ¥åŽŸæ ·è¿”å›žå³å¯ return (LifecycleEventObserver) object; &#125; //ä»¥ä¸‹å¯¹åº”äºŽä¸Šè¿°æ‰€è¯´çš„ç¬¬ä¸‰ç‚¹ï¼Œå³åå°„æ“ä½œ final Class&lt;?&gt; klass = object.getClass(); int type = getObserverConstructorType(klass); if (type == GENERATED_CALLBACK) &#123; List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors = sClassToAdapters.get(klass); if (constructors.size() == 1) &#123; GeneratedAdapter generatedAdapter = createGeneratedAdapter( constructors.get(0), object); return new SingleGeneratedAdapterObserver(generatedAdapter); &#125; GeneratedAdapter[] adapters = new GeneratedAdapter[constructors.size()]; for (int i = 0; i &lt; constructors.size(); i++) &#123; adapters[i] = createGeneratedAdapter(constructors.get(i), object); &#125; return new CompositeGeneratedAdaptersObserver(adapters); &#125; return new ReflectiveGenericLifecycleObserver(object); &#125; 5.1ã€å‰ä¸¤ç§æƒ…å†µFullLifecycleObserver æ ¹æ® Activity/Fragment è¿™ä¸¤ä¸ªç±»çš„ç”Ÿå‘½å‘¨æœŸå›žè°ƒå‡½æ•°æ‰©å±•äº†å‡ ä¸ªåŒåçš„æŠ½è±¡æ–¹æ³•ï¼Œå¯ä»¥çœ‹æˆæ˜¯å¯¹ LifecycleEventObserver è¿›è¡Œæ›´åŠ å…·ä½“çš„äº‹ä»¶æ‹†åˆ†ï¼Œè®©ä½¿ç”¨è€…å¯ä»¥åªå¤„ç†è‡ªå·±å…³å¿ƒçš„ç”Ÿå‘½å‘¨æœŸäº‹ä»¶ï¼Œè¿™ä¸€èˆ¬æ˜¯ç”¨äºŽ Java 8 ä»¥ä¸Šçš„ç¼–è¯‘å¹³å° 1234567891011121314interface FullLifecycleObserver extends LifecycleObserver &#123; void onCreate(LifecycleOwner owner); void onStart(LifecycleOwner owner); void onResume(LifecycleOwner owner); void onPause(LifecycleOwner owner); void onStop(LifecycleOwner owner); void onDestroy(LifecycleOwner owner);&#125; FullLifecycleObserverAdapter å®žçŽ°äº† LifecycleEventObserver æŽ¥å£ï¼Œç”¨äºŽåœ¨æ”¶åˆ° Lifecycle ç”Ÿå‘½å‘¨æœŸäº‹ä»¶çŠ¶æ€å˜åŒ–æ—¶ï¼Œå¯¹å…¶ä¸¤ä¸ªæž„é€ å‡½æ•°å‚æ•°ï¼ˆ FullLifecycleObserverã€LifecycleEventObserverï¼‰è¿›è¡Œäº‹ä»¶è½¬å‘ 12345678910111213141516171819202122232425262728293031323334353637383940class FullLifecycleObserverAdapter implements LifecycleEventObserver &#123; private final FullLifecycleObserver mFullLifecycleObserver; private final LifecycleEventObserver mLifecycleEventObserver; FullLifecycleObserverAdapter(FullLifecycleObserver fullLifecycleObserver, LifecycleEventObserver lifecycleEventObserver) &#123; mFullLifecycleObserver = fullLifecycleObserver; mLifecycleEventObserver = lifecycleEventObserver; &#125; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; switch (event) &#123; case ON_CREATE: mFullLifecycleObserver.onCreate(source); break; case ON_START: mFullLifecycleObserver.onStart(source); break; case ON_RESUME: mFullLifecycleObserver.onResume(source); break; case ON_PAUSE: mFullLifecycleObserver.onPause(source); break; case ON_STOP: mFullLifecycleObserver.onStop(source); break; case ON_DESTROY: mFullLifecycleObserver.onDestroy(source); break; case ON_ANY: throw new IllegalArgumentException("ON_ANY must not been send by anybody"); &#125; if (mLifecycleEventObserver != null) &#123; mLifecycleEventObserver.onStateChanged(source, event); &#125; &#125;&#125; 5.2ã€ç¬¬ä¸‰ç§æƒ…å†µå¯¹äºŽç¬¬ä¸‰ç§æƒ…å†µçš„åå°„æ“ä½œï¼Œå…¶é€»è¾‘ç›¸å¯¹æ¥è¯´ä¼šæ¯”è¾ƒå¤æ‚ï¼Œéœ€è¦è¿›è¡Œä¸€ç³»åˆ—çš„ç±»åž‹åˆ¤æ–­ã€ç±»åž‹ç¼“å­˜ã€åå°„è°ƒç”¨ç­‰æ“ä½œï¼Œè¿™é‡Œä¸»è¦æ¥çœ‹ä¸‹ ClassesInfoCache å¯¹äºŽä½¿ç”¨ OnLifecycleEventè¿›è¡Œæ³¨è§£çš„å‡½æ•°æ˜¯å¦‚ä½•è¿›è¡Œé™åˆ¶çš„ å¼€å‘è€…åº”è¯¥éƒ½çŸ¥é“ï¼ŒJava å¹³å°çš„åå°„æ“ä½œæ˜¯ä¸€ä¸ªæ¯”è¾ƒä½Žæ•ˆå’Œè€—è´¹æ€§èƒ½çš„è¡Œä¸ºï¼Œä¸ºäº†é¿å…æ¯æ¬¡æœ‰éœ€è¦è¿›è¡Œäº‹ä»¶å›žè°ƒæ—¶éƒ½å†æ¥å¯¹åŒ…å« OnLifecycleEvent æ³¨è§£çš„ class å¯¹è±¡è¿›è¡Œåå°„è§£æžï¼Œæ‰€ä»¥ Lifecycling å†…éƒ¨å¯¹ Classã€Method ç­‰è¿›è¡Œäº†ç¼“å­˜ï¼Œä»¥ä¾¿åŽç»­å¤ç”¨ã€‚è€Œ Lifecycling å°±å°†è¿™äº›ç¼“å­˜ä¿¡æ¯éƒ½å°è£…å­˜æ”¾åœ¨äº† ClassesInfoCache å†…éƒ¨ æ­¤å¤–ï¼Œè¢«æ³¨è§£çš„å‡½æ•°çš„å…¥å‚ç±»åž‹ã€å…¥å‚é¡ºåºã€å…¥å‚ä¸ªæ•°éƒ½æœ‰ç€ä¸¥æ ¼çš„é™åˆ¶ï¼Œæ¯•ç«Ÿå¦‚æžœå¼€å‘è€…ä¸ºå›žè°ƒå‡½æ•°å£°æ˜Žäº†ä¸€ä¸ª String ç±»åž‹çš„å…¥å‚å‚æ•°çš„è¯ï¼ŒLifecycle ä¹Ÿä¸çŸ¥é“è¯¥å‘å…¶ä¼ é€’ä»€ä¹ˆå±žæ€§å€¼ ClassesInfoCache å†…éƒ¨ä¼šåˆ¤æ–­æŒ‡å®šçš„ class å¯¹è±¡æ˜¯å¦åŒ…å«ä½¿ç”¨äº† OnLifecycleEvent è¿›è¡Œæ³¨è§£çš„å‡½æ•°ï¼Œå¹¶å°†åˆ¤æ–­ç»“æžœç¼“å­˜åœ¨ mHasLifecycleMethods å†…ï¼Œç¼“å­˜ä¿¡æ¯ä¼šæ ¹æ® createInfo(klass, methods) æ¥è¿›è¡ŒèŽ·å– 123456789101112131415161718192021222324252627//åˆ¤æ–­æŒ‡å®šçš„ class å¯¹è±¡æ˜¯å¦åŒ…å«ä½¿ç”¨äº† OnLifecycleEvent è¿›è¡Œæ³¨è§£çš„å‡½æ•° boolean hasLifecycleMethods(Class&lt;?&gt; klass) &#123; Boolean hasLifecycleMethods = mHasLifecycleMethods.get(klass); if (hasLifecycleMethods != null) &#123; //å¦‚æžœæœ¬åœ°æœ‰ç¼“å­˜çš„è¯åˆ™ç›´æŽ¥è¿”å›žç¼“å­˜å€¼ return hasLifecycleMethods; &#125; //æœ¬åœ°è¿˜æ²¡æœ‰ç¼“å­˜å€¼ï¼Œä»¥ä¸‹é€»è¾‘å°±æ˜¯æ¥é€šè¿‡åå°„åˆ¤æ–­ klass æ˜¯å¦åŒ…å«ä½¿ç”¨ OnLifecycleEvent è¿›è¡Œæ³¨è§£çš„å‡½æ•° //èŽ·å– klass åŒ…å«çš„æ‰€æœ‰å‡½æ•° Method[] methods = getDeclaredMethods(klass); for (Method method : methods) &#123; OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class); if (annotation != null) &#123; // Optimization for reflection, we know that this method is called // when there is no generated adapter. But there are methods with @OnLifecycleEvent // so we know that will use ReflectiveGenericLifecycleObserver, // so we createInfo in advance. // CreateInfo always initialize mHasLifecycleMethods for a class, so we don't do it // here. createInfo(klass, methods); return true; &#125; &#125; mHasLifecycleMethods.put(klass, false); return false; &#125; è€Œæ­£æ˜¯åœ¨ createInfoå‡½æ•°å†…éƒ¨å¯¹è¢«æ³¨è§£å‡½æ•°çš„å…¥å‚ç±»åž‹ã€å…¥å‚é¡ºåºã€å…¥å‚ä¸ªæ•°ç­‰è¿›è¡Œäº†é™åˆ¶ï¼Œå½“ä¸ç¬¦åˆè§„å®šæ—¶åˆ™ä¼šåœ¨è¿è¡Œæ—¶ç›´æŽ¥æŠ›å‡ºå¼‚å¸¸ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 //ä»¥ä¸‹ä¸‰ä¸ªæ•´æ•°å€¼ç”¨äºŽæ ‡è®°è¢«æ³¨è§£çš„å‡½æ•°çš„å…¥å‚å‚æ•°çš„ä¸ªæ•°//ä¸åŒ…å«å…¥å‚å‚æ•°private static final int CALL_TYPE_NO_ARG = 0;//åŒ…å«ä¸€ä¸ªå…¥å‚å‚æ•° private static final int CALL_TYPE_PROVIDER = 1;//åŒ…å«ä¸¤ä¸ªå…¥å‚å‚æ•° private static final int CALL_TYPE_PROVIDER_WITH_EVENT = 2;private CallbackInfo createInfo(Class&lt;?&gt; klass, @Nullable Method[] declaredMethods) &#123; Class&lt;?&gt; superclass = klass.getSuperclass(); Map&lt;MethodReference, Lifecycle.Event&gt; handlerToEvent = new HashMap&lt;&gt;(); if (superclass != null) &#123; CallbackInfo superInfo = getInfo(superclass); if (superInfo != null) &#123; handlerToEvent.putAll(superInfo.mHandlerToEvent); &#125; &#125; Class&lt;?&gt;[] interfaces = klass.getInterfaces(); for (Class&lt;?&gt; intrfc : interfaces) &#123; for (Map.Entry&lt;MethodReference, Lifecycle.Event&gt; entry : getInfo( intrfc).mHandlerToEvent.entrySet()) &#123; verifyAndPutHandler(handlerToEvent, entry.getKey(), entry.getValue(), klass); &#125; &#125; Method[] methods = declaredMethods != null ? declaredMethods : getDeclaredMethods(klass); boolean hasLifecycleMethods = false; for (Method method : methods) &#123; //æ‰¾åˆ°åŒ…å« OnLifecycleEvent æ³¨è§£çš„å‡½æ•° OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class); if (annotation == null) &#123; continue; &#125; hasLifecycleMethods = true; //ä»¥ä¸‹çš„æ‰€æœ‰é€»è¾‘æ˜¯è¿™æ ·çš„ï¼š //1. èŽ·å– method æ‰€å¯¹åº”çš„å‡½æ•°çš„å‚æ•°ä¸ªæ•°å’Œå‚æ•°ç±»åž‹ï¼Œå³ params //2. å¦‚æžœå‚æ•°ä¸ªæ•°ä¸º 0ï¼Œåˆ™ callType = CALL_TYPE_NO_ARGï¼Œmethod ä¸åŒ…å«å…¥å‚å‚æ•° //3. å¦‚æžœå‚æ•°ä¸ªæ•°å¤§äºŽ 0ï¼Œåˆ™ç¬¬ä¸€ä¸ªå‚æ•°å¿…é¡»æ˜¯ LifecycleOwner ç±»åž‹çš„å¯¹è±¡ï¼Œå¦åˆ™æŠ›å‡ºå¼‚å¸¸ //3.1ã€å¦‚æžœå‚æ•°ä¸ªæ•°ä¸º 1ï¼Œåˆ™ callType = CALL_TYPE_PROVIDER //3.2ã€å¦‚æžœå‚æ•°ä¸ªæ•°ä¸º 2ï¼Œåˆ™æ³¨è§£å€¼ annotation å¿…é¡»æ˜¯ Lifecycle.Event.ON_ANY // ä¸”ç¬¬äºŒä¸ªå‚æ•°å¿…é¡»æ˜¯ Lifecycle.Event ç±»åž‹çš„å¯¹è±¡ï¼Œå¦åˆ™æŠ›å‡ºå¼‚å¸¸ // å¦‚æžœä¸€åˆ‡éƒ½ç¬¦åˆæ¡ä»¶ï¼Œåˆ™ callType = CALL_TYPE_PROVIDER_WITH_EVENT //3.3ã€å¦‚æžœå‚æ•°ä¸ªæ•°å¤§äºŽ 2ï¼Œåˆ™æŠ›å‡ºå¼‚å¸¸ï¼Œå³è¦æ±‚ method æœ€å¤šåŒ…å«ä¸¤ä¸ªå‚æ•°ï¼Œä¸”å¯¹å‚æ•°ç±»åž‹å’Œå‚æ•°é¡ºåºè¿›è¡Œäº†é™åˆ¶ Class&lt;?&gt;[] params = method.getParameterTypes(); int callType = CALL_TYPE_NO_ARG; if (params.length &gt; 0) &#123; callType = CALL_TYPE_PROVIDER; if (!params[0].isAssignableFrom(LifecycleOwner.class)) &#123; throw new IllegalArgumentException( "invalid parameter type. Must be one and instanceof LifecycleOwner"); &#125; &#125; Lifecycle.Event event = annotation.value(); if (params.length &gt; 1) &#123; callType = CALL_TYPE_PROVIDER_WITH_EVENT; if (!params[1].isAssignableFrom(Lifecycle.Event.class)) &#123; throw new IllegalArgumentException( "invalid parameter type. second arg must be an event"); &#125; if (event != Lifecycle.Event.ON_ANY) &#123; throw new IllegalArgumentException( "Second arg is supported only for ON_ANY value"); &#125; &#125; if (params.length &gt; 2) &#123; throw new IllegalArgumentException("cannot have more than 2 params"); &#125; MethodReference methodReference = new MethodReference(callType, method); verifyAndPutHandler(handlerToEvent, methodReference, event, klass); &#125; CallbackInfo info = new CallbackInfo(handlerToEvent); mCallbackMap.put(klass, info); mHasLifecycleMethods.put(klass, hasLifecycleMethods); return info; &#125; ç„¶åŽæœ€ç»ˆåœ¨ MethodReference ç±»å†…éƒ¨çš„ invokeCallback() å‡½æ•°å®Œæˆæœ€ç»ˆçš„åå°„è°ƒç”¨ MethodReference ç”¨äºŽç¼“å­˜å…·æœ‰ OnLifecycleEvent æ³¨è§£çš„å‡½æ•°ï¼ˆMethodï¼‰ä»¥åŠè¯¥å‡½æ•°æ‰€å…·æœ‰çš„å…¥å‚ä¸ªæ•°ï¼ˆçŸ¥é“äº†å…¥å‚ä¸ªæ•°å°±çŸ¥é“äº†è¯¥å¦‚ä½•è¿›è¡Œåå°„è°ƒç”¨ï¼‰ï¼Œé€šè¿‡ invokeCallback() å‡½æ•°æ¥è¿›è¡Œ Lifecycle.Event äº‹ä»¶é€šçŸ¥ 12345678910111213141516171819202122232425262728293031323334353637static class MethodReference &#123; final int mCallType; final Method mMethod; MethodReference(int callType, Method method) &#123; mCallType = callType; mMethod = method; mMethod.setAccessible(true); &#125; void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) &#123; //noinspection TryWithIdenticalCatches //æ ¹æ®å…¥å‚ä¸ªæ•°æ¥ä¼ é€’ç‰¹å®šçš„å‚æ•°å¹¶è¿›è¡Œåå°„å›žè°ƒ //å› æ­¤ç”¨ OnLifecycleEvent è¿›è¡Œæ³¨è§£çš„å‡½æ•°ï¼Œå…¶å…¥å‚ä¸ªæ•°ã€å…¥å‚ç±»åž‹ã€å…¥å‚å£°æ˜Žé¡ºåºéƒ½æœ‰å›ºå®šçš„è¦æ±‚ //å½“ä¸ç¬¦åˆè¦æ±‚æ—¶ä¼šå¯¼è‡´åå°„å¤±è´¥ä»Žè€ŒæŠ›å‡ºå¼‚å¸¸ try &#123; switch (mCallType) &#123; case CALL_TYPE_NO_ARG: mMethod.invoke(target); break; case CALL_TYPE_PROVIDER: mMethod.invoke(target, source); break; case CALL_TYPE_PROVIDER_WITH_EVENT: mMethod.invoke(target, source, event); break; &#125; &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException("Failed to call observer method", e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; //çœç•¥æ— å…³å‡½æ•° Â·Â·Â·Â· &#125; å…­ã€æ€»ç»“Lifecycle çš„æ•´ä¸ªäº‹ä»¶æµç¨‹éƒ½åœ¨ä¸Šæ–‡å¤§è‡´è®²è¿°å®Œæ¯•äº†ï¼Œè¿™é‡Œå†æ¥åšä¸‹æ€»ç»“ æˆ‘ä»¬æ—¥å¸¸ä½¿ç”¨çš„ androidx.appcompat.app.AppCompatActivity å’Œ androidx.fragment.app.Fragment éƒ½å®žçŽ°äº† LifecycleOwner æŽ¥å£ï¼Œå…¶ getLifecycle() æ–¹æ³•è¿”å›žçš„ Lifecycle å¯¹è±¡å‡ä¸º LifecycleRegistry AppCompatActivity é»˜è®¤æŒ‚è½½äº†ä¸€ä¸ªæ—  UI ç•Œé¢çš„ ReportFragmentï¼ŒReportFragment ä¼šæ ¹æ®ç”¨æˆ·æ‰‹æœºçš„ç³»ç»Ÿç‰ˆæœ¬å·é«˜ä½Žï¼Œç”¨ä¸åŒçš„æ–¹å¼èŽ·å–åˆ° AppCompatActivity çš„äº‹ä»¶å˜åŒ–é€šçŸ¥ï¼Œæœ€ç»ˆè°ƒç”¨ LifecycleRegistry çš„ handleLifecycleEvent(Lifecycle.Event) æ–¹æ³•å°† Lifecycle.Event ä¼ é€’å‡ºåŽ»ã€‚æ­¤æ—¶ï¼ŒLifecycleRegistry å°±æ‹¿åˆ°äº† Lifecycle.Event androidx.fragment.app.Fragment ä¼šåœ¨å†…éƒ¨ç›´æŽ¥è°ƒç”¨ LifecycleRegistry çš„ handleLifecycleEvent(Lifecycle.Event) æ–¹æ³•å®Œæˆäº‹ä»¶é€šçŸ¥ï¼Œæ­¤æ—¶ï¼ŒLifecycleRegistry ä¹Ÿæ‹¿åˆ°äº† Lifecycle.Event LifecycleRegistry ä¼šå°†å¤–éƒ¨ addObserver ä¼ è¿›æ¥çš„ LifecycleObserver å¯¹è±¡éƒ½ç»™åŒ…è£…æˆ ObserverWithState ç±»å†…éƒ¨çš„ LifecycleEventObserver å¯¹è±¡ï¼Œå±è”½äº†å¤–éƒ¨ä¼ è¿›æ¥çš„ LifecycleObserver çš„å·®å¼‚æ€§ï¼ˆå¯èƒ½æ˜¯æŽ¥å£ï¼Œä¹Ÿå¯èƒ½æ˜¯æ³¨è§£ï¼‰ LifecycleRegistry é€šè¿‡ç›´æŽ¥è°ƒç”¨ ObserverWithState ç±»å†…éƒ¨çš„ LifecycleEventObserver å¯¹è±¡çš„ onStateChanged æ–¹æ³•æ¥å®Œæˆæœ€ç»ˆçš„äº‹ä»¶å›žè°ƒã€‚è‡³æ­¤æ•´ä¸ªæµç¨‹å°±å®Œæˆäº†]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è®¾è®¡æ¨¡å¼å…­å¤§åŽŸåˆ™]]></title>
    <url>%2F2019%2F06%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[1ã€å•ä¸€èŒè´£åŽŸåˆ™ï¼ˆSingle Responsibility Principleï¼Œç®€ç§°SRP ï¼‰ æ ¸å¿ƒæ€æƒ³ï¼šåº”è¯¥æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªåŽŸå› å¼•èµ·ç±»çš„å˜æ›´ é—®é¢˜æè¿°ï¼šå‡å¦‚æœ‰ç±»Class1å®ŒæˆèŒè´£T1ï¼ŒT2ï¼Œå½“èŒè´£T1æˆ–T2æœ‰å˜æ›´éœ€è¦ä¿®æ”¹æ—¶ï¼Œæœ‰å¯èƒ½å½±å“åˆ°è¯¥ç±»çš„å¦å¤–ä¸€ä¸ªèŒè´£æ­£å¸¸å·¥ä½œã€‚ å¥½å¤„ï¼šç±»çš„å¤æ‚åº¦é™ä½Žã€å¯è¯»æ€§æé«˜ã€å¯ç»´æŠ¤æ€§æé«˜ã€æ‰©å±•æ€§æé«˜ã€é™ä½Žäº†å˜æ›´å¼•èµ·çš„é£Žé™©ã€‚ éœ€æ³¨æ„ï¼šå•ä¸€èŒè´£åŽŸåˆ™æå‡ºäº†ä¸€ä¸ªç¼–å†™ç¨‹åºçš„æ ‡å‡†ï¼Œç”¨â€œèŒè´£â€æˆ–â€œå˜åŒ–åŽŸå› â€æ¥è¡¡é‡æŽ¥å£æˆ–ç±»è®¾è®¡å¾—æ˜¯å¦ä¼˜è‰¯ï¼Œä½†æ˜¯â€œèŒè´£â€å’Œâ€œå˜åŒ–åŽŸå› â€éƒ½æ˜¯ä¸å¯ä»¥åº¦é‡çš„ï¼Œå› é¡¹ç›®å’ŒçŽ¯å¢ƒè€Œå¼‚ã€‚ 2ã€é‡Œæ°æ›¿æ¢åŽŸåˆ™ï¼ˆLiskov Substitution Principle,ç®€ç§°LSPï¼‰ æ ¸å¿ƒæ€æƒ³ï¼šåœ¨ä½¿ç”¨åŸºç±»çš„çš„åœ°æ–¹å¯ä»¥ä»»æ„ä½¿ç”¨å…¶å­ç±»ï¼Œèƒ½ä¿è¯å­ç±»å®Œç¾Žæ›¿æ¢åŸºç±»ã€‚ é€šä¿—æ¥è®²ï¼šåªè¦çˆ¶ç±»èƒ½å‡ºçŽ°çš„åœ°æ–¹å­ç±»å°±èƒ½å‡ºçŽ°ã€‚åä¹‹ï¼Œçˆ¶ç±»åˆ™æœªå¿…èƒ½èƒœä»»ã€‚ å¥½å¤„ï¼šå¢žå¼ºç¨‹åºçš„å¥å£®æ€§ï¼Œå³ä½¿å¢žåŠ äº†å­ç±»ï¼ŒåŽŸæœ‰çš„å­ç±»è¿˜å¯ä»¥ç»§ç»­è¿è¡Œã€‚ éœ€æ³¨æ„ï¼šå¦‚æžœå­ç±»ä¸èƒ½å®Œæ•´åœ°å®žçŽ°çˆ¶ç±»çš„æ–¹æ³•ï¼Œæˆ–è€…çˆ¶ç±»çš„æŸäº›æ–¹æ³•åœ¨å­ç±»ä¸­å·²ç»å‘ç”Ÿâ€œç•¸å˜â€ï¼Œåˆ™å»ºè®®æ–­å¼€çˆ¶å­ç»§æ‰¿å…³ç³» é‡‡ç”¨ä¾èµ–ã€èšåˆã€ç»„åˆç­‰å…³ç³»ä»£æ›¿ç»§æ‰¿ã€‚ 3ã€ä¾èµ–å€’ç½®åŽŸåˆ™ï¼ˆDependence Inversion Principle,ç®€ç§°DIPï¼‰ æ ¸å¿ƒæ€æƒ³ï¼šé«˜å±‚æ¨¡å—ä¸åº”è¯¥ä¾èµ–åº•å±‚æ¨¡å—ï¼ŒäºŒè€…éƒ½è¯¥ä¾èµ–å…¶æŠ½è±¡ï¼›æŠ½è±¡ä¸åº”è¯¥ä¾èµ–ç»†èŠ‚ï¼›ç»†èŠ‚åº”è¯¥ä¾èµ–æŠ½è±¡ï¼› è¯´æ˜Žï¼šé«˜å±‚æ¨¡å—å°±æ˜¯è°ƒç”¨ç«¯ï¼Œä½Žå±‚æ¨¡å—å°±æ˜¯å…·ä½“å®žçŽ°ç±»ã€‚æŠ½è±¡å°±æ˜¯æŒ‡æŽ¥å£æˆ–æŠ½è±¡ç±»ã€‚ç»†èŠ‚å°±æ˜¯å®žçŽ°ç±»ã€‚ é€šä¿—æ¥è®²ï¼šä¾èµ–å€’ç½®åŽŸåˆ™çš„æœ¬è´¨å°±æ˜¯é€šè¿‡æŠ½è±¡ï¼ˆæŽ¥å£æˆ–æŠ½è±¡ç±»ï¼‰ä½¿ä¸ªå„ç±»æˆ–æ¨¡å—çš„å®žçŽ°å½¼æ­¤ç‹¬ç«‹ï¼Œäº’ä¸å½±å“ï¼Œå®žçŽ°æ¨¡å—é—´çš„æ¾è€¦åˆã€‚ é—®é¢˜æè¿°ï¼šç±»Aç›´æŽ¥ä¾èµ–ç±»Bï¼Œå‡å¦‚è¦å°†ç±»Aæ”¹ä¸ºä¾èµ–ç±»Cï¼Œåˆ™å¿…é¡»é€šè¿‡ä¿®æ”¹ç±»Açš„ä»£ç æ¥è¾¾æˆã€‚è¿™ç§åœºæ™¯ä¸‹ï¼Œç±»Aä¸€èˆ¬æ˜¯é«˜å±‚æ¨¡å—ï¼Œè´Ÿè´£å¤æ‚çš„ä¸šåŠ¡é€»è¾‘ï¼›ç±»Bå’Œç±»Cæ˜¯ä½Žå±‚æ¨¡å—ï¼Œè´Ÿè´£åŸºæœ¬çš„åŽŸå­æ“ä½œï¼›å‡å¦‚ä¿®æ”¹ç±»Aï¼Œä¼šç»™ç¨‹åºå¸¦æ¥ä¸å¿…è¦çš„é£Žé™©ã€‚ è§£å†³æ–¹æ¡ˆï¼šå°†ç±»Aä¿®æ”¹ä¸ºä¾èµ–æŽ¥å£interfaceï¼Œç±»Bå’Œç±»Cå„è‡ªå®žçŽ°æŽ¥å£interfaceï¼Œç±»Aé€šè¿‡æŽ¥å£interfaceé—´æŽ¥ä¸Žç±»Bæˆ–è€…ç±»Cå‘ç”Ÿè”ç³»ï¼Œåˆ™ä¼šå¤§å¤§é™ä½Žä¿®æ”¹ç±»Açš„å‡ çŽ‡ã€‚ å¥½å¤„ï¼šä¾èµ–å€’ç½®çš„å¥½å¤„åœ¨å°åž‹é¡¹ç›®ä¸­å¾ˆéš¾ä½“çŽ°å‡ºæ¥ã€‚ä½†åœ¨å¤§ä¸­åž‹é¡¹ç›®ä¸­å¯ä»¥å‡å°‘éœ€æ±‚å˜åŒ–å¼•èµ·çš„å·¥ä½œé‡ã€‚ä½¿å¹¶è¡Œå¼€å‘æ›´å‹å¥½ã€‚ 4ã€æŽ¥å£éš”ç¦»åŽŸåˆ™ï¼ˆInterface Segregation Principle,ç®€ç§°ISPï¼‰ æ ¸å¿ƒæ€æƒ³ï¼šç±»é—´çš„ä¾èµ–å…³ç³»åº”è¯¥å»ºç«‹åœ¨æœ€å°çš„æŽ¥å£ä¸Š é€šä¿—æ¥è®²ï¼šå»ºç«‹å•ä¸€æŽ¥å£ï¼Œä¸è¦å»ºç«‹åºžå¤§è‡ƒè‚¿çš„æŽ¥å£ï¼Œå°½é‡ç»†åŒ–æŽ¥å£ï¼ŒæŽ¥å£ä¸­çš„æ–¹æ³•å°½é‡å°‘ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬è¦ä¸ºå„ä¸ªç±»å»ºç«‹ä¸“ç”¨çš„æŽ¥å£ï¼Œè€Œä¸è¦è¯•å›¾åŽ»å»ºç«‹ä¸€ä¸ªå¾ˆåºžå¤§çš„æŽ¥å£ä¾›æ‰€æœ‰ä¾èµ–å®ƒçš„ç±»åŽ»è°ƒç”¨ã€‚ é—®é¢˜æè¿°ï¼šç±»Aé€šè¿‡æŽ¥å£interfaceä¾èµ–ç±»Bï¼Œç±»Cé€šè¿‡æŽ¥å£interfaceä¾èµ–ç±»Dï¼Œå¦‚æžœæŽ¥å£interfaceå¯¹äºŽç±»Aå’Œç±»Bæ¥è¯´ä¸æ˜¯æœ€å°æŽ¥å£ï¼Œåˆ™ç±»Bå’Œç±»Då¿…é¡»åŽ»å®žçŽ°ä»–ä»¬ä¸éœ€è¦çš„æ–¹æ³•ã€‚ éœ€æ³¨æ„ï¼š æŽ¥å£å°½é‡å°ï¼Œä½†æ˜¯è¦æœ‰é™åº¦ã€‚å¯¹æŽ¥å£è¿›è¡Œç»†åŒ–å¯ä»¥æé«˜ç¨‹åºè®¾è®¡çµæ´»æ€§ï¼Œä½†æ˜¯å¦‚æžœè¿‡å°ï¼Œåˆ™ä¼šé€ æˆæŽ¥å£æ•°é‡è¿‡å¤šï¼Œä½¿è®¾è®¡å¤æ‚åŒ–ã€‚æ‰€ä»¥ä¸€å®šè¦é€‚åº¦ æé«˜å†…èšï¼Œå‡å°‘å¯¹å¤–äº¤äº’ã€‚ä½¿æŽ¥å£ç”¨æœ€å°‘çš„æ–¹æ³•åŽ»å®Œæˆæœ€å¤šçš„äº‹æƒ… ä¸ºä¾èµ–æŽ¥å£çš„ç±»å®šåˆ¶æœåŠ¡ã€‚åªæš´éœ²ç»™è°ƒç”¨çš„ç±»å®ƒéœ€è¦çš„æ–¹æ³•ï¼Œå®ƒä¸éœ€è¦çš„æ–¹æ³•åˆ™éšè—èµ·æ¥ã€‚åªæœ‰ä¸“æ³¨åœ°ä¸ºä¸€ä¸ªæ¨¡å—æä¾›å®šåˆ¶æœåŠ¡ï¼Œæ‰èƒ½å»ºç«‹æœ€å°çš„ä¾èµ–å…³ç³»ã€‚ 5ã€è¿ªç±³ç‰¹æ³•åˆ™ï¼ˆLaw of Demeter,ç®€ç§°LoDï¼‰ æ ¸å¿ƒæ€æƒ³ï¼šç±»é—´è§£è€¦ã€‚ é€šä¿—æ¥è®²ï¼š ä¸€ä¸ªç±»å¯¹è‡ªå·±ä¾èµ–çš„ç±»çŸ¥é“çš„è¶Šå°‘è¶Šå¥½ã€‚è‡ªä»Žæˆ‘ä»¬æŽ¥è§¦ç¼–ç¨‹å¼€å§‹ï¼Œå°±çŸ¥é“äº†è½¯ä»¶ç¼–ç¨‹çš„æ€»çš„åŽŸåˆ™ï¼šä½Žè€¦åˆï¼Œé«˜å†…èšã€‚æ— è®ºæ˜¯é¢å‘è¿‡ç¨‹ç¼–ç¨‹è¿˜æ˜¯é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼Œåªæœ‰ä½¿å„ä¸ªæ¨¡å—ä¹‹é—´çš„è€¦åˆå°½é‡çš„ä½Žï¼Œæ‰èƒ½æé«˜ä»£ç çš„å¤ç”¨çŽ‡ã€‚ä½Žè€¦åˆçš„ä¼˜ç‚¹ä¸è¨€è€Œå–»ï¼Œä½†æ˜¯æ€Žä¹ˆæ ·ç¼–ç¨‹æ‰èƒ½åšåˆ°ä½Žè€¦åˆå‘¢ï¼Ÿé‚£æ­£æ˜¯è¿ªç±³ç‰¹æ³•åˆ™è¦åŽ»å®Œæˆçš„ã€‚ 6ã€å¼€æ”¾å°é—­åŽŸåˆ™ï¼ˆOpen Close Principle,ç®€ç§°OCPï¼‰ æ ¸å¿ƒæ€æƒ³ï¼šå°½é‡é€šè¿‡æ‰©å±•è½¯ä»¶å®žä½“æ¥è§£å†³éœ€æ±‚å˜åŒ–ï¼Œè€Œä¸æ˜¯é€šè¿‡ä¿®æ”¹å·²æœ‰çš„ä»£ç æ¥å®Œæˆå˜åŒ– é€šä¿—æ¥è®²ï¼š ä¸€ä¸ªè½¯ä»¶äº§å“åœ¨ç”Ÿå‘½å‘¨æœŸå†…ï¼Œéƒ½ä¼šå‘ç”Ÿå˜åŒ–ï¼Œæ—¢ç„¶å˜åŒ–æ˜¯ä¸€ä¸ªæ—¢å®šçš„äº‹å®žï¼Œæˆ‘ä»¬å°±åº”è¯¥åœ¨è®¾è®¡çš„æ—¶å€™å°½é‡é€‚åº”è¿™äº›å˜åŒ–ï¼Œä»¥æé«˜é¡¹ç›®çš„ç¨³å®šæ€§å’Œçµæ´»æ€§ã€‚ ä¸€å¥è¯æ¦‚æ‹¬:å•ä¸€èŒè´£åŽŸåˆ™å‘Šè¯‰æˆ‘ä»¬å®žçŽ°ç±»è¦èŒè´£å•ä¸€ï¼›é‡Œæ°æ›¿æ¢åŽŸåˆ™å‘Šè¯‰æˆ‘ä»¬ä¸è¦ç ´åç»§æ‰¿ä½“ç³»ï¼›ä¾èµ–å€’ç½®åŽŸåˆ™å‘Šè¯‰æˆ‘ä»¬è¦é¢å‘æŽ¥å£ç¼–ç¨‹ï¼›æŽ¥å£éš”ç¦»åŽŸåˆ™å‘Šè¯‰æˆ‘ä»¬åœ¨è®¾è®¡æŽ¥å£çš„æ—¶å€™è¦ç²¾ç®€å•ä¸€ï¼›è¿ªç±³ç‰¹æ³•åˆ™å‘Šè¯‰æˆ‘ä»¬è¦é™ä½Žè€¦åˆã€‚è€Œå¼€é—­åŽŸåˆ™æ˜¯æ€»çº²ï¼Œä»–å‘Šè¯‰æˆ‘ä»¬è¦å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ã€‚ æ€»ç»“ï¼šæœ€åŽæ€»ç»“ä¸€ä¸‹å¦‚ä½•åŽ»éµå®ˆè¿™å…­ä¸ªåŽŸåˆ™ã€‚å¯¹è¿™å…­ä¸ªåŽŸåˆ™çš„éµå®ˆå¹¶ä¸æ˜¯æ˜¯å’Œå¦çš„é—®é¢˜ï¼Œè€Œæ˜¯å¤šå’Œå°‘çš„é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¸ä¼šè¯´æœ‰æ²¡æœ‰éµå®ˆï¼Œè€Œæ˜¯è¯´éµå®ˆç¨‹åº¦çš„å¤šå°‘ã€‚ä»»ä½•äº‹éƒ½æ˜¯è¿‡çŠ¹ä¸åŠï¼Œè®¾è®¡æ¨¡å¼çš„å…­ä¸ªè®¾è®¡åŽŸåˆ™ä¹Ÿæ˜¯ä¸€æ ·ï¼Œåˆ¶å®šè¿™å…­ä¸ªåŽŸåˆ™çš„ç›®çš„å¹¶ä¸æ˜¯è¦æˆ‘ä»¬åˆ»æ¿çš„éµå®ˆä»–ä»¬ï¼Œè€Œéœ€è¦æ ¹æ®å®žé™…æƒ…å†µçµæ´»è¿ç”¨ã€‚å¯¹ä»–ä»¬çš„éµå®ˆç¨‹åº¦åªè¦åœ¨ä¸€ä¸ªåˆç†çš„èŒƒå›´å†…ï¼Œå°±ç®—æ˜¯è‰¯å¥½çš„è®¾è®¡ã€‚æˆ‘ä»¬ç”¨ä¸€å¹…å›¾æ¥è¯´æ˜Žä¸€ä¸‹ã€‚ å›¾ä¸­çš„æ¯ä¸€æ¡ç»´åº¦å„ä»£è¡¨ä¸€é¡¹åŽŸåˆ™ï¼Œæˆ‘ä»¬ä¾æ®å¯¹è¿™é¡¹åŽŸåˆ™çš„éµå®ˆç¨‹åº¦åœ¨ç»´åº¦ä¸Šç”»ä¸€ä¸ªç‚¹ï¼Œåˆ™å¦‚æžœå¯¹è¿™é¡¹åŽŸåˆ™éµå®ˆçš„åˆç†çš„è¯ï¼Œè¿™ä¸ªç‚¹åº”è¯¥è½åœ¨çº¢è‰²çš„åŒå¿ƒåœ†å†…éƒ¨ï¼›å¦‚æžœéµå®ˆçš„å·®ï¼Œç‚¹å°†ä¼šåœ¨å°åœ†å†…éƒ¨ï¼›å¦‚æžœè¿‡åº¦éµå®ˆï¼Œç‚¹å°†ä¼šè½åœ¨å¤§åœ†å¤–éƒ¨ã€‚ä¸€ä¸ªè‰¯å¥½çš„è®¾è®¡ä½“çŽ°åœ¨å›¾ä¸­ï¼Œåº”è¯¥æ˜¯å…­ä¸ªé¡¶ç‚¹éƒ½åœ¨åŒå¿ƒåœ†ä¸­çš„å…­è¾¹å½¢ 2.png åœ¨ä¸Šå›¾ä¸­ï¼Œè®¾è®¡1ã€è®¾è®¡2å±žäºŽè‰¯å¥½çš„è®¾è®¡ï¼Œä»–ä»¬å¯¹å…­é¡¹åŽŸåˆ™çš„éµå®ˆç¨‹åº¦éƒ½åœ¨åˆç†çš„èŒƒå›´å†…ï¼›è®¾è®¡3ã€è®¾è®¡4è®¾è®¡è™½ç„¶æœ‰äº›ä¸è¶³ï¼Œä½†ä¹ŸåŸºæœ¬å¯ä»¥æŽ¥å—ï¼›è®¾è®¡5åˆ™ä¸¥é‡ä¸è¶³ï¼Œå¯¹å„é¡¹åŽŸåˆ™éƒ½æ²¡æœ‰å¾ˆå¥½çš„éµå®ˆï¼›è€Œè®¾è®¡6åˆ™éµå®ˆè¿‡æ¸¡äº†ï¼Œè®¾è®¡5å’Œè®¾è®¡6éƒ½æ˜¯è¿«åˆ‡éœ€è¦é‡æž„çš„è®¾è®¡ã€‚]]></content>
      <categories>
        <category>è®¾è®¡æ¨¡å¼</category>
      </categories>
      <tags>
        <tag>å…­å¤§åŽŸåˆ™</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gité…ç½®å¤šä¸ªSSH Key]]></title>
    <url>%2F2019%2F06%2F15%2Fgit%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key%2F</url>
    <content type="text"><![CDATA[gité…ç½®å¤šä¸ªSSH Keyå½“æœ‰å¤šä¸ªgitè´¦å·æ—¶ï¼Œæ¯”å¦‚ï¼š ä¸€ä¸ªgithubï¼Œå›½é™…è®¤å¯çš„ä»“åº“ ä¸€ä¸ªgiteeç äº‘ï¼Œå›½å†…ä»“åº“ï¼Œé€Ÿåº¦å¿« è¿™ä¸¤è€…å¦‚æžœé‚®ç®±ä¸åŒçš„è¯ï¼Œåœ¨ç”Ÿæˆç¬¬äºŒä¸ªkeyçš„æ—¶å€™ä¼šè¦†ç›–ç¬¬ä¸€ä¸ªçš„keyï¼Œå¯¼è‡´ä¸€ä¸ªç”¨ä¸äº†ã€‚ è§£å†³åŠžæ³•å°±æ˜¯ï¼š ç”Ÿæˆä¸¤ä¸ªï¼ˆæˆ–å¤šä¸ªï¼‰ä¸åŒçš„å…¬ç§å¯†é’¥å¯¹ï¼Œç”¨configæ–‡ä»¶ç®¡ç†å®ƒä»¬ã€‚ 1 æ­¥éª¤æˆ‘ä»¬å‡è®¾åŽŸæ¥åœ¨~/.sshç›®å½•ä¸‹å·²ç»ç”Ÿæˆäº†ä¸€ä¸ªå¯†é’¥å¯¹ï¼š 12id_rsaid_rsa.pub 1.1 ç”Ÿæˆç¬¬äºŒä¸ªkeyæŽ¥ä¸‹æ¥æˆ‘ä»¬ç”Ÿæˆç¬¬äºŒä¸ªssh keyï¼š 1ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot; è¿™é‡Œä¸è¦ä¸€è·¯å›žè½¦ï¼Œæˆ‘ä»¬è‡ªå·±æ‰‹åŠ¨å¡«å†™ä¿å­˜è·¯å¾„ï¼š Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Gary/.ssh/id_rsa): /c/Users/Gary/.ssh/id_rsa_github&lt;å‰©ä¸‹ä¸¤ä¸ªç›´æŽ¥å›žè½¦&gt; è¿™é‡Œæˆ‘ä»¬ç”¨id_rsa_githubæ¥åŒºåˆ«åŽŸæœ‰å¯†é’¥å¯¹ï¼Œé¿å…è¢«è¦†ç›–ã€‚ å®Œæˆä¹‹åŽï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°~/.sshç›®å½•ä¸‹å¤šäº†ä¸¤ä¸ªæ–‡ä»¶ï¼Œå˜æˆï¼š id_rsa id_ras.pub id_rsa_github id_rsa_github.pub known_hosts 1.2 æ‰“å¼€ssh-agentè¿™é‡Œå¦‚æžœä½ ç”¨çš„githubå®˜æ–¹çš„bashï¼Œç”¨ï¼š 1ssh-agent -s å¦‚æžœæ˜¯å…¶ä»–çš„ï¼Œæ¯”å¦‚msysgitï¼Œç”¨ï¼š 1eval $(ssh-agent -s) ç•¥è¿‡è¿™ä¸€æ­¥çš„è¯ï¼Œä¸‹ä¸€æ­¥ä¼šæç¤ºè¿™æ ·çš„é”™è¯¯ï¼šCould not open a connection to your authentication agent. 1.3 æ·»åŠ ç§é’¥12ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_github å¦‚æžœæç¤ºæ–‡ä»¶æˆ–ç›®å½•ä¸å­˜åœ¨ï¼Œå°±ä½¿ç”¨ç»å¯¹åœ°å€ã€‚ 1.4 åˆ›å»ºconfigæ–‡ä»¶åœ¨~/.sshç›®å½•ä¸‹åˆ›å»ºåä¸ºconfigçš„æ–‡ä»¶ã€‚ æ·»åŠ ä¸€ä¸‹å†…å®¹ï¼š 1234567891011# gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee# github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github å…¶ä¸­ï¼ŒHostå’ŒHostNameå¡«å†™gitæœåŠ¡å™¨çš„åŸŸåã€‚ IdentityFileæŒ‡å®šç§é’¥çš„è·¯å¾„ã€‚ å¦‚æžœåœ¨Linuxç³»ç»Ÿä¸‹æç¤ºé”™è¯¯ï¼šBad owner or permissions on /home/gary/.ssh/config è¯´æ˜Žconfigæƒé™è¿‡å¤§ï¼Œchmodå‘½ä»¤è°ƒæ•´ï¼š 1$ chmod 644 ~/.ssh/config ç„¶åŽåœ¨githubå’Œgiteeç äº‘ä¸Šæ·»åŠ å…¬é’¥å³å¯ï¼Œè¿™é‡Œä¸å†å¤šè¯´ã€‚ 1.5 æµ‹è¯•ç„¶åŽç”¨sshå‘½ä»¤åˆ†åˆ«æµ‹è¯•ï¼š 1ssh -T git@github.com 2 è°ƒè¯•å¦‚æžœåˆ°è¿™é‡Œä½ æ²¡æœ‰æˆåŠŸçš„è¯ï¼Œåˆ«æ€¥ï¼Œæ•™ä½ è§£å†³é—®é¢˜çš„ç»ˆæžåŠžæ³•--debug æ¯”å¦‚æµ‹è¯•githubï¼š 1ssh -vT git@github.com -v æ˜¯è¾“å‡ºç¼–è¯‘ä¿¡æ¯ï¼Œç„¶åŽæ ¹æ®ç¼–è¯‘ä¿¡æ¯è‡ªå·±åŽ»è§£å†³é—®é¢˜å§ã€‚ å°±æˆ‘è‡ªå·±æ¥è¯´ä¸€èˆ¬æ˜¯configé‡Œçš„hosté‚£å—å†™é”™äº†ã€‚ 3 å…³äºŽç”¨æˆ·åå¦‚æžœä¹‹å‰æœ‰è®¾ç½®å…¨å±€ç”¨æˆ·åå’Œé‚®ç®±çš„è¯ï¼Œéœ€è¦unsetä¸€ä¸‹ 12git config --global --unset user.namegit config --global --unset user.email ç„¶åŽåœ¨ä¸åŒçš„ä»“åº“ä¸‹è®¾ç½®å±€éƒ¨çš„ç”¨æˆ·åå’Œé‚®ç®±æ¯”å¦‚åœ¨å…¬å¸çš„repositoryä¸‹ 12git config user.name "yourname" git config user.email "youremail" åœ¨è‡ªå·±çš„githubçš„ä»“åº“åœ¨æ‰§è¡Œåˆšåˆšçš„å‘½ä»¤ä¸€éå³å¯ã€‚ è¿™æ ·å°±å¯ä»¥åœ¨ä¸åŒçš„ä»“åº“ï¼Œå·²ä¸åŒçš„è´¦å·ç™»å½•ã€‚]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[èŠèŠæ€§èƒ½ä¼˜åŒ–]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[å¸ƒå±€ä¼˜åŒ– å°½é‡å‡å°‘åµŒå¥— includeã€mergeã€ViewStub å‡å°‘è¿‡åº¦ç»˜åˆ¶ backgroudå±žæ€§ä¸è¦é‡å¤è®¾ç½® ç®€å•é¡µé¢ä¼˜å…ˆä½¿ç”¨LinearLayout ã€FrameLayoutã€å¤æ‚é¡µé¢ä½¿ç”¨ConstraintLayout onDrawä¸è¦åšè€—æ—¶ä»»åŠ¡ï¼Œä¸è¦å¾ªçŽ¯åˆ›å»ºå¤§é‡å¯¹è±¡ â€‹ æ¸²æŸ“é—®é¢˜ è¿‡åº¦ç»˜åˆ¶ï¼ˆè®¾ç½® â€” å¼€å‘è€…é€‰é¡¹ â€” è°ƒè¯•GPUè¿‡åº¦ç»˜åˆ¶â€”x4æ¬¡çº¢è‰²æ˜¾ç¤ºï¼‰ â€‹ 1ã€ç§»é™¤æˆ–ä¿®æ”¹Themeã€Windowé»˜è®¤çš„Background 2ã€ç§»é™¤XMLå¸ƒå±€æ–‡ä»¶ä¸­éžå¿…éœ€çš„Background 3ã€æŒ‰éœ€æ˜¾ç¤ºå ä½èƒŒæ™¯å›¾ç‰‡ 4ã€æŽ§åˆ¶ç»˜åˆ¶åŒºåŸŸ å¸ƒå±€ä¼˜åŒ– å‡å°‘å¸ƒå±€åµŒå¥—å’Œå±‚çº§ mergeã€includeã€ViewStub æŸ¥çœ‹æ¸²æŸ“æ€§èƒ½å·¥å…· GPUå‘ˆçŽ°æ¨¡å¼åˆ†æž GPU monitor å¯ç”¨ä¸¥æ ¼æ¨¡å¼ï¼šä¸»çº¿ç¨‹ä¸Šæ‰§è¡Œé•¿æ—¶é—´æ“ä½œä¼šé—ªçƒå±å¹• æ€§èƒ½ä¼˜åŒ–å¿…å¤‡ç¥žå™¨Lintæ£€æŸ¥å·¥å…·ï¼ŒPerformance å†…å­˜ä¼˜åŒ–å†…å­˜æ³„æ¼ é›†åˆç±»æ³„æ¼ å•ä¾‹/é™æ€å˜é‡é€ æˆçš„å†…å­˜æ³„æ¼ åŒ¿åå†…éƒ¨ç±»/éžé™æ€å†…éƒ¨ç±» èµ„æºæœªå…³é—­é€ æˆçš„å†…å­˜æ³„æ¼ åˆ†æžå·¥å…·ï¼šMemory Profilerã€ Leakcanaryã€MATã€TraceViewã€GTï¼ˆè…¾è®¯ç§»åŠ¨è°ƒè¯•å¹³å°ï¼‰ å†…å­˜æµªè´¹ ä½¿ç”¨ArrayMapã€SparseArrayï¼ˆé¿å…äº†è‡ªåŠ¨è£…ç®±ï¼‰ä»£æ›¿HashMap é¿å…ä½¿ç”¨Enumï¼Œå†…å­˜è€—è´¹æ˜¯final static int çš„10å‡ å€ å†…å­˜æŠ–åŠ¨ï¼šé¿å…å¾ªçŽ¯ä½“å†…å¤§é‡åˆ›å»ºå¤§åž‹å¯¹è±¡ â€‹ å¯åŠ¨é€Ÿåº¦ä¼˜åŒ–æ€è·¯ï¼šApplicationã€Activityåˆ›å»ºä»¥åŠå›žè°ƒç­‰è¿‡ç¨‹ å¯åŠ¨é¡µè®¾ç½®windowBackgroundå±žæ€§ï¼Œå¿«é€Ÿå±•ç¤ºå‡ºæ¥ä¸€ä¸ªç•Œé¢ï¼› é¿å…åœ¨å¯åŠ¨æ—¶åšå¯†é›†æ²‰é‡çš„åˆå§‹åŒ–ï¼ˆHeavy app initializationï¼‰ï¼› 1ã€æ¯”å¦‚åƒå‹ç›Ÿï¼Œbuglyè¿™æ ·çš„ä¸šåŠ¡éžå¿…è¦çš„å¯ä»¥çš„å¼‚æ­¥åŠ è½½ã€‚ 2ã€æ¯”å¦‚åœ°å›¾ï¼ŒæŽ¨é€ç­‰ï¼Œéžç¬¬ä¸€æ—¶é—´éœ€è¦çš„å¯ä»¥åœ¨ä¸»çº¿ç¨‹åšå»¶æ—¶å¯åŠ¨ã€‚å½“ç¨‹åºå·²ç»å¯åŠ¨èµ·æ¥ä¹‹åŽï¼Œåœ¨è¿›è¡Œåˆå§‹åŒ–ã€‚ 3ã€å¯¹äºŽå›¾ç‰‡ï¼Œç½‘ç»œè¯·æ±‚æ¡†æž¶å¿…é¡»åœ¨ä¸»çº¿ç¨‹é‡Œåˆå§‹åŒ–äº†ã€‚ åŒæ—¶å› ä¸ºæˆ‘ä»¬ä¸€èˆ¬ä¼šæœ‰é—ªå±é¡µé¢ï¼Œä¹Ÿå¯ä»¥æŠŠå»¶æ—¶å¯åŠ¨çš„åœ°å›¾ï¼ŒæŽ¨åŠ¨çš„å¯åŠ¨åœ¨è¿™ä¸ªæ—¶é—´æ®µé‡Œï¼Œè¿™æ ·åˆç†å®‰æŽ’æ—¶é—´ç‰‡çš„ä½¿ç”¨ã€‚æžå¤§çš„æé«˜äº†å¯åŠ¨é€Ÿåº¦ã€‚ â€‹ é¿å…I/Oæ“ä½œã€ååºåˆ—åŒ–ã€ç½‘ç»œæ“ä½œã€å¸ƒå±€åµŒå¥—ç­‰ã€‚ Apkå¤§å°ä¼˜åŒ– lintå·¥å…·åŽ»é™¤æ— ç”¨èµ„æº å¼€å¯æ··æ·†å’Œèµ„æºåŽ‹ç¼© shrinkResources true minifyEnabled true åˆ©ç”¨shapeå’ŒcolorTintå‡å°‘éƒ¨åˆ†å›¾ç‰‡ å›¾ç‰‡åŽ‹ç¼© webpã€pngcrush çŸ¢é‡å›¾å½¢VectorDrawable æ’ä»¶åŒ–éƒ¨ç½² è€—ç”µä¼˜åŒ– æ›´ç»†çš„è€—ç”µåˆ†æžå¯ä»¥ä½¿ç”¨è¿™ä¸ªBattery Historian ä½¿ç”¨JobScheduler JobScheduleræ¥è°ƒæ•´ä»»åŠ¡ä¼˜å…ˆçº§ç­‰ç­–ç•¥æ¥è¾¾åˆ°é™ä½ŽæŸè€—çš„ç›®çš„, é¿å…é¢‘ç¹çš„å”¤é†’ç¡¬ä»¶æ¨¡å—ï¼Œé€ æˆä¸å¿…è¦çš„ç”µé‡æ¶ˆè€—ã€‚é¿å…åœ¨ä¸åˆé€‚çš„æ—¶é—´(ä¾‹å¦‚ä½Žç”µé‡æƒ…å†µä¸‹ã€å¼±ç½‘ç»œæˆ–è€…ç§»åŠ¨ç½‘ç»œæƒ…å†µä¸‹çš„)æ‰§è¡Œè¿‡å¤šçš„ä»»åŠ¡æ¶ˆè€—ç”µé‡ã€‚ æ‡’æƒ°ç¬¬ä¸€çš„æ³•åˆ™: å‡å°‘é‡å¤æ“ä½œã€æŽ¨è¿Ÿæ‰§è¡Œã€åˆå¹¶å¤„ç† ç‰¹åˆ«å…³æ³¨WakeLockã€GPSã€è“ç‰™ç­‰è€—ç”µä¸šåŠ¡ BitMapä¼˜åŒ– å¯¹å›¾ç‰‡è´¨é‡è¿›è¡ŒåŽ‹ç¼© å¯¹å›¾ç‰‡å°ºå¯¸è¿›è¡ŒåŽ‹ç¼© ä½¿ç”¨libjpeg.soåº“è¿›è¡ŒåŽ‹ç¼© RecyclerView åˆ†é¡µåŠ è½½ï¼ŒListViewä½¿ç”¨ViewHolder ç½‘ç»œä¼˜åŒ– å·¥å…·ï¼šWireSharkã€Fiddlerã€Charlesã€NetWork Profiler å‡å°‘ç½‘ç»œè¯·æ±‚é¢‘æ¬¡ã€ApiæŽ¥å£åˆå¹¶è¯·æ±‚ GzipåŽ‹ç¼©ï¼Œç”¨Protocol Bufferä»£æ›¿Json åˆ—è¡¨åŠ è½½è¯·æ±‚ç¼©ç•¥å›¾ã€webpã€å›¾ç‰‡ç¼“å­˜ IPç›´è¿žï¼ŒçœåŽ»DNSè§£æžè¿‡ç¨‹ å…¶ä»–ä¼˜åŒ– ä¸»çº¿ç¨‹é¿å…è€—æ—¶æ“ä½œã€å¼‚æ­¥å¤„ç† é‡‡ç”¨çº¿ç¨‹æ± ã€é¿å…çº¿ç¨‹åˆ‡æ¢å¼€é”€ Googleå®˜æ–¹å»ºè®®: Performance Android Performance Patterns è§†å± ç›¸å…³å­¦ä¹ æ•´ç†å¯ä»¥å‰å¾€èƒ¡å‡¯å¤§ä½¬çš„åšå®¢é˜…è¯»ï¼Œæ„Ÿè°¢ä»–çš„æ— ç§åˆ†äº«ï¼š Android æ€§èƒ½ä¼˜åŒ–å…¸èŒƒ - ç¬¬ 1 å­£ Android æ€§èƒ½ä¼˜åŒ–å…¸èŒƒ - ç¬¬ 2 å­£ Android æ€§èƒ½ä¼˜åŒ–å…¸èŒƒ - ç¬¬ 3 å­£ Android æ€§èƒ½ä¼˜åŒ–å…¸èŒƒ - ç¬¬ 4 å­£ Android æ€§èƒ½ä¼˜åŒ–å…¸èŒƒ - ç¬¬ 5 å­£ Android æ€§èƒ½ä¼˜åŒ–å…¸èŒƒ - ç¬¬ 6 å­£]]></content>
      <categories>
        <category>æ€§èƒ½ä¼˜åŒ–</category>
      </categories>
      <tags>
        <tag>æ€§èƒ½ä¼˜åŒ–</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofitæºç è§£æž]]></title>
    <url>%2F2018%2F04%2F10%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Retrofit æ˜¯Androidå¼€å‘ä¸­éžå¸¸æµè¡Œçš„ç½‘ç»œè¯·æ±‚åº“ï¼Œå®ƒèƒ½å¤Ÿè®©å¼€å‘è€…ä½¿ç”¨æŽ¥å£å®šä¹‰åŠ æ³¨è§£çš„æ–¹å¼ï¼Œéžå¸¸ä¼˜é›…çš„å‘é€ç½‘ç»œè¯·æ±‚ï¼Œå…¶å®žRetrofitåªæ˜¯ç”¨ç»Ÿä¸€æŽ¥å£çš„æ–¹å¼å°è£…äº†ç½‘ç»œè¯·æ±‚ï¼Œåº•å±‚ç½‘ç»œè¯·æ±‚è¿˜æ˜¯é€šè¿‡ OkHttpæ¥å®žçŽ°çš„ ã€‚å…¶å°è£…è¿‡ç¨‹ååˆ†çš„ä¼˜é›…ï¼Œç”¨ä¸¤ä¸ªå­—æ¥æ¦‚æ‹¬å°±æ˜¯â€”-è§£è€¦ã€‚ Retrofit GitHub åœ°å€ï¼šhttps://github.com/square/retrofit ä¸‹é¢å…ˆçœ‹ä¸€ä¸‹ Retrofit çš„ç®€å•å®žç”¨æ–¹å¼ã€‚ Retrofit ä½¿ç”¨æ–¹æ³•ç›´æŽ¥æŠ„å®˜ç½‘çš„ï¼š ç¬¬ä¸€æ­¥ï¼Œå£°æ˜Ž API æŽ¥å£ï¼š 1234public interface GitHubService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125; ç¬¬äºŒæ­¥ï¼Œæž„é€ å‡º Retrofit å¯¹è±¡ï¼š 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); ç¬¬ä¸‰æ­¥ï¼Œå¾—åˆ° API æŽ¥å£ï¼Œç›´æŽ¥è°ƒç”¨ï¼š 12GitHubService service = retrofit.create(GitHubService.class);//å¾—åˆ°ä»£ç†å¯¹è±¡Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos("octocat"); æœ€åŽï¼Œå°±æ˜¯è°ƒç”¨ repos æ‰§è¡Œ Call ï¼š 1234// syncrepos.execute();// asyncrepos.enqueue(CallBack callback); è¯·æ±‚æºç è§£æžRetrofitè¯·æ±‚æµç¨‹å¯¹æ¯”ä¸€èˆ¬çš„OkHttpè¯·æ±‚æµç¨‹ï¼š æˆ‘ä»¬å…ˆæ¥çœ‹çœ‹å‘å‡ºç½‘ç»œè¯·æ±‚éƒ¨åˆ†çš„æºç ã€‚ Retrofit.Builderé¦–å…ˆåˆ‡å…¥ç‚¹å°±æ˜¯ Retrofit.Builder ã€‚ 123456789101112131415161718192021222324//Retrofit.java#Builderpublic static final class Builder &#123; private final Platform platform; private okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private Executor callbackExecutor; private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform;// ç¡®å®šå¹³å°ï¼Œæœ‰ Androidã€ Java8 é»˜è®¤Platform ä¸‰ç§ // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); &#125; public Builder() &#123; this(Platform.get()); &#125; ... &#125; åœ¨ Retrofit.Builder ä¸­æœ‰ä»¥ä¸‹çš„æ–¹æ³•ï¼š platform : ç¡®å®šè¿è¡Œå¹³å°ï¼ŒAndroidçŽ¯å¢ƒå¯¹åº”äºŽAndroid callFactory ï¼š è®¾ç½®ç½‘ç»œè¯·æ±‚ call çš„å·¥åŽ‚ï¼Œé»˜è®¤å°±æ˜¯ä¸Šé¢çš„OkHttpClient baseUrl ï¼š api çš„ base url addConverterFactory ï¼š æ·»åŠ æ•°æ®è½¬æ¢å™¨å·¥åŽ‚ addCallAdapterFactory ï¼š æ·»åŠ ç½‘ç»œè¯·æ±‚é€‚é…å™¨å·¥åŽ‚ callbackExecutor ï¼š å›žè°ƒæ–¹æ³•æ‰§è¡Œå™¨ï¼Œç”¨äºŽåˆ‡æ¢çº¿ç¨‹ validateEagerly ï¼š æ˜¯å¦æå‰è§£æžæŽ¥å£æ–¹æ³• è¿™äº›éƒ½æ˜¯ç”¨æ¥é…ç½® Builder çš„ï¼Œè¿™è¾¹ç”¨åˆ°äº†å»ºé€ è€…æ¨¡å¼ã€‚ å»ºé€ è€…æ¨¡å¼: å°†ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æž„å»ºä¸Žå®ƒçš„è¡¨ç¤ºåˆ†ç¦»ï¼Œä½¿å¾—åŒæ ·çš„æž„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤ºã€‚ é‚£ä¹ˆæˆ‘ä»¬æ¥çœ‹ä¸‹ Builder çš„æž„é€ æ–¹æ³•ï¼šæ¥ä¸ªå°æ’æ›²ï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹ Retrofit æ˜¯å¦‚ä½•ç¡®å®šå¹³å°çš„ï¼š Platform1234567891011121314151617181920212223242526//Platform.javaclass Platform &#123; private static final Platform PLATFORM = findPlatform(); static Platform get() &#123; return PLATFORM; &#125; private static Platform findPlatform() &#123; try &#123; Class.forName("android.os.Build"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android();//è¿™é‡Œæž„å»ºäº†ä¸€ä¸ªAndroidå¯¹è±¡ &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName("java.util.Optional"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform(); &#125; ...&#125; ä»Žä¸Šé¢çš„ä»£ç ä¸­å¯ä»¥çœ‹åˆ°ï¼Œæ˜¯é€šè¿‡åå°„æ¥åˆ¤æ–­å…·ä½“æ˜¯å“ªä¸ªPlatfromï¼Œè¿™ä¸ªç”¨åˆ°çš„ç®€å•çš„ç­–ç•¥æ¨¡å¼ã€‚ ç­–ç•¥æ¨¡å¼ï¼šå®šä¹‰ä¸€ç³»åˆ—çš„ç®—æ³•ï¼ŒæŠŠå®ƒä»¬ä¸€ä¸ªä¸ªå°è£…èµ·æ¥, å¹¶ä¸”ä½¿å®ƒä»¬å¯ç›¸äº’æ›¿æ¢ã€‚ æŽ¥ç€ï¼Œåœ¨åˆ›å»º Builder å¯¹è±¡å¹¶è¿›è¡Œè‡ªå®šä¹‰é…ç½®åŽï¼Œæˆ‘ä»¬å°±è¦è°ƒç”¨ build() æ–¹æ³•æ¥æž„å»ºå‡º Retrofit å¯¹è±¡äº†ã€‚é‚£ä¹ˆï¼Œæˆ‘ä»¬æ¥çœ‹ä¸‹ build() æ–¹æ³•é‡Œå¹²äº†ä»€ä¹ˆï¼š 123456789101112131415161718192021222324252627//Retrofit.javapublic Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; // ç½‘ç»œè¯·æ±‚æ‰§è¡Œå™¨ é»˜è®¤ä¸º OkHttpClient okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // Android å¹³å°ä¸‹é»˜è®¤ä¸º MainThreadExecutor å¯åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹ Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); // Android å¹³å°ä¸‹æ·»åŠ é»˜è®¤çš„ ExecutorCallAdapterFactoryï¼Œæ–‡ç« åŽé¢ä¼šåˆ†æž adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. é»˜è®¤æœ‰ BuiltInConverters List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly);&#125; åœ¨ build() ä¸­ï¼Œé…ç½®äº†ç½‘ç»œæ‰§è¡Œå™¨OkHttpClient, å¼‚æ­¥å›žè°ƒçº¿ç¨‹åˆ‡æ¢å™¨MainThreadExecutor, ç½‘ç»œé€‚é…å™¨å·¥åŽ‚åˆ—è¡¨ï¼ˆé»˜è®¤æ·»åŠ ExecutorCallAdapterFactoryï¼‰ï¼Œæ•°æ®è½¬æ¢å™¨å·¥åŽ‚åˆ—è¡¨(é»˜è®¤æ·»åŠ BuiltInConverters),å¹¶ä»¥æ­¤æž„å»ºå‡ºäº†Retrofitç±»ã€‚ RetrofitRetrofit ç±»çš„æž„é€ æ–¹æ³•æ²¡ä»€ä¹ˆå¥½çœ‹çš„ï¼Œåªæ˜¯ç®€å•çš„å°†Buildçš„å±žæ€§ä¾æ¬¡èµ‹ç»™Retrofitã€‚ å¾—åˆ° Retrofit å¯¹è±¡åŽå°±æ˜¯è°ƒç”¨ create(final Class&lt;T&gt; service) æ–¹æ³•æ¥åˆ›å»ºæˆ‘ä»¬ API æŽ¥å£çš„å®žä¾‹ã€‚ æ‰€ä»¥æˆ‘ä»¬éœ€è¦è·Ÿè¿› create(final Class&lt;T&gt; service) ä¸­æ¥çœ‹ä¸‹ï¼š 12345678910111213141516171819202122232425262728//Retrofit.javapublic &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; //ç”ŸæˆåŠ¨æ€ä»£ç†ï¼ŒåŽé¢è°ƒç”¨ä»£ç†çš„æ–¹æ³•éƒ½å°†èµ°åˆ°InvocationHandlerçš„invokeæ–¹æ³• return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; //æ•²é»‘æ¿----&gt;æœ€æœ€æœ€é‡è¦çš„3å¥è¯ ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå¾ˆå·§å¦™çš„ä½¿ç”¨äº†åŠ¨æ€ä»£ç†æ¨¡å¼ï¼šåœ¨è°ƒç”¨ä»£ç†ç±»çš„ä»»ä½•æ–¹æ³•æ—¶ï¼Œéƒ½å°†ç»Ÿä¸€æ‰§è¡ŒInvocationHandlerçš„invokeæ–¹æ³•ï¼Œå¹¶åœ¨è¿™é‡Œæ·»åŠ é¢å¤–çš„å¤„ç†ã€‚ åŠ¨æ€ä»£ç†ï¼šä»£ç†ç±»åœ¨ç¨‹åºè¿è¡Œå‰ä¸å­˜åœ¨ã€è¿è¡Œæ—¶ç”±ç¨‹åºåŠ¨æ€ç”Ÿæˆçš„ä»£ç†æ–¹å¼ã€‚ è¿™ç§ä»£ç†æ–¹å¼çš„ä¸€å¤§å¥½å¤„æ˜¯å¯ä»¥æ–¹ä¾¿å¯¹ä»£ç†ç±»çš„å‡½æ•°åšç»Ÿä¸€æˆ–ç‰¹æ®Šå¤„ç†ï¼Œå¦‚è®°å½•æ‰€æœ‰å‡½æ•°æ‰§è¡Œæ—¶é—´ã€æ‰€æœ‰å‡½æ•°æ‰§è¡Œå‰æ·»åŠ éªŒè¯åˆ¤æ–­ã€å¯¹æŸä¸ªç‰¹æ®Šå‡½æ•°è¿›è¡Œç‰¹æ®Šæ“ä½œï¼Œè€Œä¸ç”¨åƒé™æ€ä»£ç†æ–¹å¼é‚£æ ·éœ€è¦ä¿®æ”¹æ¯ä¸ªå‡½æ•°ã€‚ invokeä¸­çš„æ ¸å¿ƒå°±æ˜¯ä»¥ä¸‹3å¥è¯ï¼š 123456// å°†æŽ¥å£ä¸­æ¯ä¸ªæ–¹æ³•é…ç½®ä¸ºä¸€ä¸ª ServiceMethodServiceMethod serviceMethod = loadServiceMethod(method);//ç”¨ServiceMethodå’Œargsæž„é€ å‡ºä¸€ä¸ª OkhttpCallOkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);//æ‰§è¡Œç½‘ç»œé€‚é…å™¨çš„adapteræ–¹æ³•return serviceMethod.callAdapter.adapt(okHttpCall); è¿™ä¸‰å¥ä»£ç ï¼Œä¸‹é¢æˆ‘ä»¬é‡ç‚¹åˆ†æžã€‚ åœ¨ä»£ç†ä¸­ï¼Œä¼šæ ¹æ®å‚æ•°ä¸­ä¼ å…¥çš„å…·ä½“æŽ¥å£æ–¹æ³•æ¥æž„é€ å‡ºå¯¹åº”çš„ ServiceMethod ã€‚ServiceMethod ç±»çš„ä½œç”¨å°±æ˜¯æŠŠæŽ¥å£çš„æ–¹æ³•é€‚é…ä¸ºå¯¹åº”çš„ HTTP call ã€‚ 1234567891011121314//Retrofit.javaServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; // å…ˆä»Žç¼“å­˜ä¸­å–ï¼Œè‹¥æ²¡æœ‰å°±åŽ»åˆ›å»ºå¯¹åº”çš„ ServiceMethod result = serviceMethodCache.get(method); if (result == null) &#123; // æ²¡æœ‰ç¼“å­˜å°±åˆ›å»ºï¼Œä¹‹åŽå†æ”¾å…¥ç¼“å­˜ä¸­ result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; å¯ä»¥çœ‹åˆ°åœ¨å†…éƒ¨è¿˜ç»´æŠ¤äº†ä¸€ä¸ª Map serviceMethodCache æ¥ç¼“å­˜ ServiceMethodï¼Œæé«˜åˆ©ç”¨æ•ˆçŽ‡ã€‚ServiceMethodçš„åˆ›å»ºè¿˜æ˜¯ç”¨åˆ°äº†å»ºé€ è€…æ¨¡å¼ï¼Œæ¥å¤ä¹ ä¸€ä¸‹ ã€‚ å»ºé€ è€…æ¨¡å¼: å°†ä¸€ä¸ªå¤æ‚å¯¹è±¡çš„æž„å»ºä¸Žå®ƒçš„è¡¨ç¤ºåˆ†ç¦»ï¼Œä½¿å¾—åŒæ ·çš„æž„å»ºè¿‡ç¨‹å¯ä»¥åˆ›å»ºä¸åŒçš„è¡¨ç¤º. ServiceMethodå‘çŽ° ServiceMethod ä¹Ÿæ˜¯é€šè¿‡å»ºé€ è€…æ¨¡å¼æ¥åˆ›å»ºå¯¹è±¡çš„ã€‚å…ˆçœ‹ä¸‹å®ƒçš„Builderï¼š 12345678910111213141516171819202122232425262728293031323334353637383940//ServiceMethod.java#Builder static final class Builder&lt;T, R&gt; &#123; final Retrofit retrofit; final Method method; final Annotation[] methodAnnotations; final Annotation[][] parameterAnnotationsArray; final Type[] parameterTypes; Type responseType; boolean gotField; boolean gotPart; boolean gotBody; boolean gotPath; boolean gotQuery; boolean gotUrl; String httpMethod;//GET\POST\PUT boolean hasBody; boolean isFormEncoded; boolean isMultipart; String relativeUrl;//path Headers headers;//Headers MediaType contentType; Set&lt;String&gt; relativeUrlParamNames; ParameterHandler&lt;?&gt;[] parameterHandlers;//ç”¨äºŽè§£æžæŽ¥å£çš„å‚æ•°æ³¨è§£ Converter&lt;ResponseBody, T&gt; responseConverter;//æ¯ä¸ªSeviceMethodå¯¹åº”ä¸€ä¸ªè¿”å›žæ•°æ®è½¬æ¢å™¨ CallAdapter&lt;T, R&gt; callAdapter;//æ¯ä¸ªSeviceMethodå¯¹åº”ä¸€ä¸ªç½‘ç»œé€‚é…å™¨ Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; //èŽ·å–methodæ–¹æ³• this.method = method; //èŽ·å–æŽ¥å£æ–¹æ³•çš„æ³¨è§£ this.methodAnnotations = method.getAnnotations(); //èŽ·å–æŽ¥å£æ–¹æ³•å‚æ•°çš„ç±»åž‹ this.parameterTypes = method.getGenericParameterTypes(); //èŽ·å–æŽ¥å£æ–¹æ³•å‚æ•°æ³¨è§£çš„ç±»åž‹ this.parameterAnnotationsArray = method.getParameterAnnotations(); &#125; ...&#125; åœ¨æž„é€ æ–¹æ³•ä¸­èŽ·å–äº†methodçš„æ³¨è§£ï¼Œå‚æ•°ç±»åž‹æ•°ç»„ã€å‚æ•°æ³¨è§£çš„äºŒç»´æ•°ç»„ï¼Œç„¶åŽçœ‹ build() æ–¹æ³•ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//ServiceMethod.java#Builder public ServiceMethod build() &#123; // æ ¹æ®æŽ¥å£æ–¹æ³•çš„æ³¨è§£å’Œè¿”å›žç±»åž‹åˆ›å»º callAdapter // æ ¹æ®methodçš„æ³¨è§£å’Œè¿”å›žå€¼ï¼ŒèŽ·å–retrofitä¸­å¯¹åº”çš„CallAdapter // å¦‚æžœæ²¡æœ‰æ·»åŠ  CallAdapter é‚£ä¹ˆé»˜è®¤ä¼šç”¨ ExecutorCallAdapterFactoryæä¾›çš„callAdapter callAdapter = createCallAdapter(); // calladapter çš„å“åº”ç±»åž‹ä¸­çš„æ³›åž‹ï¼Œæ¯”å¦‚ Call&lt;User&gt; ä¸­çš„ User responseType = callAdapter.responseType();//è¿”å›žå€¼ç±»åž‹ if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError("'" + Utils.getRawType(responseType).getName() + "' is not a valid response body type. Did you mean ResponseBody?"); &#125; // æ ¹æ®methodçš„è¿”å›žå€¼å’Œæ³¨è§£èŽ·å–retrofitä¸­çš„ è¿”å›žæ•°æ®è½¬æ¢å™¨ ResponseConverter responseConverter = createResponseConverter(); // æ ¹æ®æŽ¥å£æ–¹æ³•çš„æ³¨è§£æž„é€ è¯·æ±‚æ–¹æ³•ï¼Œæ¯”å¦‚ @GET @POST @DELETE @PUT @Headers ç­‰ for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; if (httpMethod == null) &#123; throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.)."); &#125; // è‹¥æ—  body åˆ™ä¸èƒ½æœ‰ isMultipart å’Œ isFormEncoded if (!hasBody) &#123; if (isMultipart) &#123; throw methodError( "Multipart can only be specified on HTTP methods with request body (e.g., @POST)."); &#125; if (isFormEncoded) &#123; throw methodError("FormUrlEncoded can only be specified on HTTP methods with " + "request body (e.g., @POST)."); &#125; &#125; // ä¸‹é¢çš„ä»£ç ä¸»è¦ç”¨æ¥è§£æžæŽ¥å£æ–¹æ³•å‚æ•°ä¸­çš„æ³¨è§£ï¼Œæ¯”å¦‚ @Path @Query @QueryMap @Field @Bodyç­‰ç­‰ // ç›¸åº”çš„ï¼Œæ¯ä¸ªæ–¹æ³•çš„å‚æ•°éƒ½åˆ›å»ºäº†ä¸€ä¸ª ParameterHandler&lt;?&gt; å¯¹è±¡ int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s", parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, "No Retrofit annotation found."); &#125; //çœŸçš„çš„è§£æžå‚æ•°æ³¨è§£çš„åœ°æ–¹ parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; // æ£€æŸ¥æž„é€ å‡ºçš„è¯·æ±‚æœ‰æ²¡æœ‰ä¸å¯¹çš„åœ°æ–¹ï¼Ÿ if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError("Missing either @%s URL or @Url parameter.", httpMethod); &#125; if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError("Non-body HTTP method cannot contain @Body."); &#125; if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError("Form-encoded method must contain at least one @Field."); &#125; if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError("Multipart method must contain at least one @Part."); &#125; return new ServiceMethod&lt;&gt;(this);&#125; åœ¨ build() ä¸­ä»£ç æŒºé•¿çš„ï¼Œæ€»ç»“èµ·æ¥å°±ä¸€å¥è¯ï¼š è§£æžAPI æŽ¥å£ä¸­çš„æ–¹æ³•ï¼Œæ ¹æ®å…¶è¿”å›žå€¼ã€æ–¹æ³•æ³¨è§£ã€å‚æ•°æ³¨è§£ç­‰é…ç½®ç»„åˆæˆä¸€ä¸ªServiceMethodå¯¹è±¡ã€‚ ç»†åŒ–ä¸‹å°±æ˜¯ï¼š æ ¹æ®methodçš„returnTypeå’ŒAnnotationsåˆ›å»ºç½‘ç»œé€‚é…å™¨ CallAdapter å’Œ è¿”å›žæ•°æ®è½¬æ¢å™¨Converterï¼› æ ¹æ®methodçš„æ³¨è§£æž„é€ ç½‘ç»œè¯·æ±‚æ–¹æ³•ï¼Œæ¯”å¦‚@GETã€@POSTï¼Œå¤´éƒ¨å­—æ®µï¼Œç›¸å¯¹è·¯å¾„ç­‰ï¼› æ ¹æ® methodå„ä¸ªå‚æ•°çš„æ³¨è§£å¡«å……åˆ°parameterHandlers[]ï¼Œæ¯”å¦‚æž„é€ å…·ä½“çš„ç½‘ç»œè¯·æ±‚çš„å‚æ•°@Bodyã€ @Fieldã€ @Queryã€ @Partç­‰ï¼› ä»£ç ä¸­éƒ½æ˜¯æ³¨é‡Šï¼Œåœ¨è¿™é‡Œå°±ä¸è¯¦ç»†å¤šè®²äº†ï¼Œåˆ°è¿™é‡Œç¬¬ä¸€æ­¥å¦‚ä½•æž„å»ºServiceMethodå°±åˆ†æžå®Œäº†ã€‚ 1ServiceMethod serviceMethod = loadServiceMethod(method); ä¸‹é¢çœ‹ç¬¬äºŒå¥è¯ï¼š 1OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); OkHttpCallçœ‹ä¸€ä¸‹ OkHttpCallçš„æž„é€ æ–¹æ³•ï¼Œåªæ˜¯ç®€å•çš„å°†ServiceMethodå’Œargsä¼ è¿›æ¥è€Œå·²ï¼š 1234567891011121314151617181920212223242526272829final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod; private final Object[] args; private volatile boolean canceled; // All guarded by this. private okhttp3.Call rawCall; //åŽŸå§‹çš„Okhttp.Call private Throwable creationFailure; // Either a RuntimeException or IOException. private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; ... private okhttp3.Call createRawCall() throws IOException &#123; //é€šè¿‡ServiceMethodæž„å»ºä¸€ä¸ªOkHttpçš„Request Request request = serviceMethod.toRequest(args); //è¿™é‡Œçš„serviceMethod.callFactoryå°±æ˜¯OkHttpClientå¯¹è±¡ okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException("Call.Factory returned null."); &#125; return call; &#125;&#125; è¿™é‡Œçš„OkHttpCallå®žçŽ°äº†retrofit2.CallæŽ¥å£ï¼Œä½†ç½‘ç»œè¯·æ±‚æœ€ç»ˆè¿˜æ˜¯å§”æ‰˜ç»™äº†okhttp3.Call rawCallæ¥æ‰§è¡Œï¼Œè¿™é‡Œä¹Ÿæœ‰ç‚¹é€‚é…å™¨æ¨¡å¼çš„æ„æ€ã€‚å…ˆäº†è§£ä¸‹Retrofitçš„CallæŽ¥å£ï¼š 12345678910package retrofit2;public interface Call&lt;T&gt; extends Cloneable &#123; //åŒæ­¥è¯·æ±‚ Response&lt;T&gt; execute() throws IOException; //å¼‚æ­¥è¯·æ±‚ void enqueue(Callback&lt;T&gt; callback); ... /** The original HTTP request. */ Request request();&#125; å†çœ‹ä¸€ä¸‹createRawCall()å¦‚ä½•åˆ›å»ºä¸€ä¸ªrawCallï¼Œè¿™é‡Œæˆ‘ä»¬åˆå›žåˆ°äº†ServiceMethodé‡Œé¢ï¼Œè¿™é‡Œåˆ›å»ºæ¥ä¸€ä¸ªRequestBuilderè¯·æ±‚å¯¹è±¡å»ºé€ è€…ï¼Œé…åˆå‚æ•°æ³¨è§£ParameterHandlerå°†argsé…ç½®åˆ°RequestBuilderä¸­ï¼Œæœ€åŽæž„å»ºå‡ºä¸€ä¸ªå®Œæ•´çš„çš„okhttp3.Requestå¯¹è±¡ï¼Œå…·ä½“å¦‚ä¸‹ï¼š 123456789101112131415161718192021//ServiceMethod.java /** Builds an HTTP request from method arguments. */ Request toRequest(Object... args) throws IOException &#123; //http method, url, relativeUrl, headers, body, formåˆ›å»ºä¸€ä¸ªå®Œæ•´çš„Httpæ¨¡ç‰ˆå¯¹è±¡ RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers; int argumentCount = args != null ? args.length : 0; if (argumentCount != handlers.length) &#123; throw new IllegalArgumentException("Argument count (" + argumentCount + ") doesn't match expected count (" + handlers.length + ")"); &#125; for (int p = 0; p &lt; argumentCount; p++) &#123; handlers[p].apply(requestBuilder, args[p]);//å°†ç”¨æˆ·å‚æ•°å¡«å……åˆ°requestBuilder &#125; return requestBuilder.build(); &#125; RequestBuilderå¯¹è±¡ï¼Œä»–çš„æˆå‘˜åŒ…æ‹¬äº†httpçš„å®Œæ•´å†…å®¹method, url, relativePath, headers, body, formç­‰å‚æ•°ï¼š 1234567891011121314151617final class RequestBuilder &#123; private final String method;//get or post private final HttpUrl baseUrl;//url private String relativeUrl; private HttpUrl.Builder urlBuilder; private final Request.Builder requestBuilder; private MediaType contentType; //type private final boolean hasBody; private MultipartBody.Builder multipartBuilder; private FormBody.Builder formBuilder;//è¡¨å• private RequestBody body;//body ...&#125; æœ€åŽè°ƒç”¨requestBuilder.build()æž„å»ºäº†ä¸€ä¸ªçœŸæ­£çš„è¯·æ±‚okhttp3.Request. æŽ¥ç€é€šè¿‡serviceMethod.callFactory.newCall(request)å°±æž„å»ºå‡ºOkHttpçš„rawCallï¼Œè¿™ä¸ªçš„ serviceMethod.callFactoryç½‘ç»œæ‰§è¡Œå™¨å°±æ˜¯Retrotifé»˜è®¤çš„OkHttpClientå¯¹è±¡ã€‚ æ¦‚æ‹¬ä¸€ä¸‹ï¼šOkHttpCallä¸­ä¾èµ–äº†ServiceMethodå’ŒrawCall,é€šè¿‡ServiceMethodæž„å»ºäº†ä¸€ä¸ªåŽŸå§‹çš„OkHttp Requestè¯·æ±‚ï¼Œå¹¶é€šè¿‡OkHttpClientçš„newCall(request)åˆ›å»ºrawCallæ¥æ‰§è¡ŒçœŸæ­£çš„ç½‘ç»œè¯·æ±‚ã€‚ ExecutorCallAdapterFactoryåœ¨å‰é¢Retrofitçš„buildè¿‡ç¨‹ä¸­æˆ‘ä»¬çŸ¥é“Platformæ˜¯Androidæ—¶ï¼Œé»˜è®¤çš„ ç½‘ç»œé€‚é…å™¨å·¥åŽ‚CallAdapter.Factoryæ˜¯ExecutorCallAdapterFactoryï¼Œä¸‹é¢çœ‹ä¸€ä¸‹è¿™ä¸ªå·¥åŽ‚çš„åˆ›å»ºè¿‡ç¨‹ï¼š 12345678910111213141516171819//Platform.javastatic class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; //ç”¨äºŽåˆ‡æ¢åˆ°ä¸»çº¿ç¨‹ static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; å…¶ä¸­åŒ…å«äº†ä¸€ä¸ªçº¿ç¨‹åˆ‡æ¢çš„æ‰§è¡Œå™¨MainThreadExecutorç”¨äºŽå¼‚æ­¥å›žè°ƒåˆ‡æ¢å›žä¸»çº¿ç¨‹æ‰§è¡Œã€‚ é»˜è®¤çš„ç½‘ç»œé€‚é…å™¨å·¥åŽ‚ExecutorCallAdapterFactoryï¼Œç»§æ‰¿äº†CallAdapter.Factoryï¼Œå…¶æºç è§ä¸‹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//ExecutorCallAdapterFactory.javafinal class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; //æ ¹æ®è¿”å›žå€¼å’Œæ³¨è§£è¿”å›žå¯¹åº”çš„CallAdapter @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; //Call&lt;Repo&gt;æ˜¯returnTypeç±»åž‹ï¼Œä»–çš„responseTypeç±»åž‹æ˜¯Repo. final Type responseType = Utils.getCallResponseType(returnType); //Retrofité»˜è®¤çš„ç½‘ç»œé€‚é…å™¨CallAdatperåœ¨è¿™é‡Œè¿”å›žï¼Œå…¶å®žæ˜¯ä¸ªåŒ¿åç±»å¯¹è±¡ return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; //è¿™é‡Œçš„adaptæ–¹æ³•ä¼šåœ¨Retrofit#create()ä¸­çš„ç¬¬ä¸‰å¥æœ€æ ¸å¿ƒä»£ç è¢«è°ƒç”¨åˆ°äº†ï¼Œ //è¿™é‡Œçš„callå°±æ˜¯OkHttpCallå¯¹è±¡ @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; //ExecutorCallbackCallå®žçŽ°äº†çº¿ç¨‹åˆ‡æ¢ static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate;//è¿™é‡Œçš„delegateå°±æ˜¯OkHttpCallå¯¹è±¡ ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException("callback == null"); //å¼‚æ­¥æ‰§è¡Œï¼Œå…¥é˜Ÿ delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; //è¿”å›žreponseåŽï¼Œåˆ‡æ¢åˆ°ä¸»çº¿ç¨‹æ‰§è¡Œï¼Œæœ¬è´¨æ˜¯é€šè¿‡handleræ¥å®žçŽ°çš„ callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; ... //åŒæ­¥æ‰§è¡Œ @Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute(); &#125; @Override public Request request() &#123; return delegate.request(); &#125; &#125;&#125; è¯´æ˜Žå…¨åœ¨æ³¨é‡Šé‡Œé¢äº†ï¼ŒExecutorCallAdapterFactoryä¸»è¦æ˜¯è¿”å›žäº†ä¸€ä¸ªåŒ¿åçš„CallAdapter,è¯¥é€‚é…å™¨èƒ½å¤Ÿå°†æ™®é€šçš„Call&lt;T&gt;é€šè¿‡adapteré€‚é…ä¸ºExecutorCallbackCall&lt;T&gt;ï¼Œæˆ‘ä»¬å›žè¿‡åŽ»çœ‹Retrofit#create()ä¸­çš„ç¬¬ä¸‰å¥æ ¸å¿ƒä»£ç ï¼š 1return serviceMethod.callAdapter.adapt(okHttpCall); æ²¡é”™è¿™é‡Œä¼ å…¥çš„å°±æ˜¯OkHttpCallï¼Œé€šè¿‡ç½‘ç»œé€‚é…å™¨è¿”å›žçš„æ˜¯ä¸€ä¸ªExecutorCallbackCallå¯¹è±¡. ExecutorCallbackCall1return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); é‡‡ç”¨äº†è£…é¥°æ¨¡å¼ï¼šExecutorCallbackCall ä¸ºè£…é¥°è€…ï¼Œè€Œé‡Œé¢çœŸæ­£åŽ»æ‰§è¡Œç½‘ç»œè¯·æ±‚çš„è¿˜æ˜¯OkHttpCallã€‚é€šè¿‡ ExecutorCallbackCall ï¼Œæˆ‘ä»¬å¯ä»¥è°ƒç”¨åŒæ­¥æ–¹æ³• execute() æˆ–å¼‚æ­¥æ–¹æ³• enqueue(Callback&lt;T&gt; callback) æ¥æ‰§è¡Œè¯¥ callï¼Œå¼‚æ­¥è°ƒç”¨åŽçš„callbackä¼šé€šè¿‡callbackExecutoråˆ‡æ¢å›žä¸»çº¿ç¨‹æ‰§è¡Œ. äºŽæ˜¯å§”æ‰˜å…³ç³»æ˜¯ï¼šExecutorCallbackCallâ€”&gt;retrofit.OkHttpCallâ€”&gt;okhttp3.rawCallã€‚ çœ‹ä¸€ä¸‹åŒæ­¥çš„execute()æ–¹æ³•ï¼Œåªæ˜¯è°ƒç”¨äº†delegate.execute()æ–¹æ³•ï¼Œdelegateå°±æ˜¯OkHttpCallã€‚ å†çœ‹OkHttpCall#execute()æ–¹æ³•çœ‹ä¸€ä¸‹å®ƒçš„execute()æ–¹æ³•: 123456789101112131415161718192021222324252627282930313233343536 @Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; if (creationFailure != null) &#123; if (creationFailure instanceof IOException) &#123; throw (IOException) creationFailure; &#125; else &#123; throw (RuntimeException) creationFailure; &#125; &#125; call = rawCall; if (call == null) &#123; try &#123; // æ ¹æ® serviceMethod ä¸­çš„é…ç½®å‚æ•°åˆ›å»ºå‡º Okhttp ä¸­çš„ Request å¯¹è±¡ // æ³¨æ„çš„ä¸€ç‚¹ï¼Œä¼šè°ƒç”¨ä¸Šé¢çš„ ParameterHandler.apply æ–¹æ³•æ¥å¡«å……ç½‘ç»œè¯·æ±‚å‚æ•° // ç„¶åŽå†æ ¹æ® OkhttpClient çš„newCall(request) åˆ›å»ºå‡º Okhttpç±»åž‹çš„rawCall // è¿™ä¸€æ­¥ä¹Ÿè¯´æ˜Žäº†åœ¨ Retrofit ä¸­çš„ OkHttpCall å†…éƒ¨è¯·æ±‚æœ€åŽä¼šè½¬æ¢ä¸º OkHttp çš„ Call call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException e) &#123; creationFailure = e; throw e; &#125; &#125; &#125; // æ£€æŸ¥ call æ˜¯å¦å–æ¶ˆ if (canceled) &#123; call.cancel(); &#125;// æ‰§è¡Œ call å¹¶è½¬æ¢å“åº”çš„ response return parseResponse(call.execute()); &#125; åœ¨ execute() åšçš„å°±æ˜¯å°† Retrofit ä¸­çš„ call è½¬åŒ–ä¸º OkHttp ä¸­çš„ rawCall ã€‚ æœ€åŽè®© OkHttp çš„ call åŽ»æ‰§è¡Œ, è¿”å›žå“åº”okhttp3.Responseã€‚ Responseè§£æžæˆ‘ä»¬å¯ä»¥çœ‹åˆ° OkHttpCall.execute() ä¸­çš„æœ€åŽä¸€å¥ï¼šparseResponse(call.execute())ï¼Œå¯¹å“åº”çš„å¤„ç†å°±æ˜¯è¿™ä¸ªæ–¹æ³•äº†ã€‚ å†çœ‹OkHttpCall#parseResponse()OkHttpCallçš„execute()å§”æ‰˜ç»™äº†okhttp3.Call rawCallæ¥æ‰§è¡Œï¼Œå› æ­¤è¿”å›žçš„Reponseæ•°æ®ä¹Ÿæ˜¯åœ¨è¿™é‡Œè¿›ä¸€æ­¥å¤„ç†ï¼š 123456789101112131415161718192021222324252627282930313233343536//OkHttpCall.javaResponse&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); // å¦‚æžœè¿”å›žçš„å“åº”ç ä¸æ˜¯æˆåŠŸçš„è¯ï¼Œè¿”å›žé”™è¯¯ Response int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; // å¦‚æžœè¿”å›žçš„å“åº”ç æ˜¯204æˆ–è€…205ï¼Œè¿”å›žæ²¡æœ‰ body çš„æˆåŠŸ Response if (code == 204 || code == 205) &#123; return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; // å°† body è½¬æ¢ä¸ºå¯¹åº”çš„æ³›åž‹ï¼Œç„¶åŽè¿”å›žæˆåŠŸ Response T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125;&#125; å…³é”®æ˜¯è¿™å¥ä»£ç ï¼šT body = serviceMethod.toResponse(catchingBody); å°† ResponseBody ç›´æŽ¥è½¬åŒ–ä¸ºäº†æ³›åž‹ï¼Œå¯ä»¥çŒœåˆ°è¿™ä¹Ÿæ˜¯ è¿”å›žæ•°æ®è½¬æ¢å™¨Converter çš„åŠŸåŠ³ã€‚ 12345//ServiceMethod.java/** Builds a method return value from an HTTP response body. */T toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body);&#125; æžœç„¶æ²¡é”™ï¼Œå†…éƒ¨æ˜¯è°ƒç”¨äº† responseConverter çš„ï¼Œé‚£ä¹ˆresponseConverterå…·ä½“æ˜¯ä»€ä¹ˆï¼Ÿ BuiltInConvertersåœ¨å‰é¢Retrofitçš„build()éƒ¨åˆ†æˆ‘ä»¬åˆ†æžäº†BuiltInConvertersæ˜¯Retrofité»˜è®¤çš„æ•°æ®è½¬æ¢å™¨å·¥åŽ‚ï¼Œ å®ƒå†…ç½®äº† responseBodyConverterã€requestBodyConverterã€ToStringConverterä¸‰å¤§ç±»ï¼Œçœ‹ä¸‹Converterçš„æŽ¥å£å®šä¹‰ï¼š 1234567891011121314151617181920212223242526//Convertå¯¹è±¡è¢«Factoryå·¥åŽ‚åˆ›å»ºï¼ŒFactoryåœ¨Retrofit.Builder#addConverterFactory(factory)æ·»åŠ public interface Converter&lt;F, T&gt; &#123; T convert(F value) throws IOException; abstract class Factory &#123; //ç”¨äºŽå°†OkHttpçš„ResponseBodyè½¬ä¸ºä»»æ„ç±»åž‹Tï¼Œæ¯”å¦‚Call&lt;SimpleResponse&gt; public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; //ç”¨äºŽå°†ä»»æ„ç±»åž‹Tè½¬ä¸ºOkHttpçš„RequestBodyï¼Œæ¯”å¦‚è¯´ç±»åž‹@Body @Part public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; return null; &#125; //Object to String Converter public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; &#125;&#125; Converter.Factoryå·¥åŽ‚æ‹¥æœ‰3ç§Converter ç±»åž‹ï¼š Converter ï¼šç”¨äºŽå°†OkHttpçš„ResponseBodyè½¬ä¸ºä»»æ„ç±»åž‹Tã€‚ Converter&lt;?, RequestBody&gt; ï¼šç”¨äºŽå°†ä»»æ„ç±»åž‹Tè½¬ä¸ºOkHttpçš„RequestBodyã€‚ Converter&lt;?, String&gt;ï¼šè½¬æ¢æˆStringç±»åž‹çš„Converterã€‚ å†çœ‹BuiltInConvertersä¸­çš„responseBodyConverterï¼š 123456789101112131415161718192021222324252627282930313233//BuiltInConverters.javafinal class BuiltInConverters extends Converter.Factory &#123; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; if (type == ResponseBody.class) &#123; return Utils.isAnnotationPresent(annotations, Streaming.class) ? StreamingResponseBodyConverter.INSTANCE : BufferingResponseBodyConverter.INSTANCE;//é»˜è®¤æ˜¯è¿™ä¸ªå–½ &#125; if (type == Void.class) &#123; return VoidResponseBodyConverter.INSTANCE; &#125; return null; &#125; ... static final class BufferingResponseBodyConverter implements Converter&lt;ResponseBody, ResponseBody&gt; &#123; static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter(); @Override public ResponseBody convert(ResponseBody value) throws IOException &#123; try &#123; // Buffer the entire body to avoid future I/O. return Utils.buffer(value); &#125; finally &#123; value.close(); &#125; &#125; &#125;&#125; é»˜è®¤æ˜¯ç”¨äº† BufferingResponseBodyConverteråªæ˜¯å°†ResponseBody ç¼“å­˜äº†ï¼Œè¿”å›žçš„è¿˜æ˜¯ResponseBodyç±»åž‹ã€‚æ‰€ä»¥OkHttpCallçš„execute()é»˜è®¤è¿”å›žçš„è¿˜æ˜¯Responseç±»åž‹ã€‚ GsonConverterFactoryå¦‚æžœæ˜¯ GsonConverterFactory å‘¢ï¼Ÿè¯¥å·¥åŽ‚è‡ªç„¶æ˜¯æž„å»ºäº†ä¸€ä¸ª GsonResponseBodyConverterGsonæ•°æ®è½¬æ¢å™¨ï¼Œç›®çš„æ˜¯æŠŠResponseBody å€Ÿç”¨gson è½¬åŒ–ä¸ºç”¨æˆ·å®šä¹‰çš„JavaBean-Typeï¼Œå…¶æºç å¦‚ä¸‹ï¼š 12345678//GsonConverterFactory.java@Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; //è¿™é‡Œçš„Typeå°±æ˜¯responseTypeï¼Œæ¯”å¦‚Call&lt;SimpleResponse&gt;ä¸­çš„SimpleResponseç±»åž‹ TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter); &#125; å…¶ä¸­GsonResponseBodyConverterså®šä¹‰ä¸º: 123456789101112131415161718final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123; this.gson = gson; this.adapter = adapter; &#125; @Override public T convert(ResponseBody value) throws IOException &#123; JsonReader jsonReader = gson.newJsonReader(value.charStream()); try &#123; return adapter.read(jsonReader); &#125; finally &#123; value.close(); &#125; &#125;&#125; æ˜¾ç„¶ä¹Ÿæ˜¯åœ¨convertä¸­å°†ResponseBodyåˆ©ç”¨Gsonè½¬æ¢ä¸ºç”¨æˆ·å®šä¹‰çš„ç±»åž‹Tï¼Œæ¯”å¦‚Callä¸­çš„Tå°±æ˜¯UserInfoã€‚ å‘¼å‘¼ï¼Œç»ˆäºŽå†™å®Œäº†ï¼Œå¿«æ™•äº†ðŸ˜·â€¦ æœ€åŽRetrofitåªæ˜¯æŠŠè¯·æ±‚å‘é€å’Œå“åº”å°è£…äº†ä¸€ä¸‹ï¼Œå†…éƒ¨è®¿é—®ç½‘ç»œä»ç„¶æ˜¯é€šè¿‡ OkHttp ï¼Œå…¶ç‰¹åˆ«ä¹‹å¤„æ˜¯èƒ½é€šè¿‡æ³¨è§£çš„æ–¹å¼æž„å»ºç½‘ç»œè¯·æ±‚ï¼Œå¤§å¤§å¢žåŠ äº†å¯è¯»æ€§ã€‚ Retrofitæºç è®¾è®¡ä¸­è¿ç”¨äº†å¾ˆå¤šè®¾è®¡æ¨¡å¼ï¼Œå€¼å¾—æˆ‘ä»¬æ·±å…¥æ€è€ƒï¼Œæ¯”å¦‚å¤–è§‚æ¨¡å¼ï¼ˆå®šä¹‰ApiServiceæŽ¥å£ï¼‰ã€ä»£ç†æ¨¡å¼ï¼ˆRetrofit#createä¸­çš„Proxyï¼‰ã€å»ºé€ è€…æ¨¡å¼ï¼ˆRetrofit#Builderï¼ŒServiceMethod#Builderï¼‰ã€ç­–ç•¥æ¨¡å¼(å„ç§Platform)ã€é€‚é…å™¨æ¨¡å¼ï¼ˆCallAdapter.adaptï¼‰ã€è£…é¥°è€…æ¨¡å¼ï¼ˆExecutorCallbackCallï¼ˆOkHttpCallï¼‰ï¼‰ã€å·¥åŽ‚æ¨¡å¼ï¼ˆCallAdapter.Factoryï¼Œ Converter.Factoryï¼‰ç­‰ï¼Œè¿™ä½¿å¾—Retrofitèƒ½å¤Ÿå¾ˆå¥½çš„è§£è€¦ï¼Œé…åˆOkHttpå’ŒRxjavaå‘æŒ¥å‡ºæœ€å¤§çš„ä¼˜åŠ¿ã€‚]]></content>
      <categories>
        <category>æ‹†è½®å­</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttpæºç è§£æž]]></title>
    <url>%2F2018%2F04%2F04%2FOkHttp%203.7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ä»¥ä¸‹å†…å®¹ä¸ºè½¬è½½è‡ªï¼š OkHttpæºç åˆ†æžâ€”â€”æ•´ä½“æž¶æž„ OkHttpæ˜¯ä¸€ä¸ªå¤„ç†ç½‘ç»œè¯·æ±‚çš„å¼€æºé¡¹ç›®,æ˜¯Androidç«¯æœ€ç«çƒ­çš„è½»é‡çº§æ¡†æž¶,ç”±ç§»åŠ¨æ”¯ä»˜Squareå…¬å¸è´¡çŒ®ç”¨äºŽæ›¿ä»£HttpUrlConnectionå’ŒApache HttpClientã€‚éšç€OkHttpçš„ä¸æ–­æˆç†Ÿï¼Œè¶Šæ¥è¶Šå¤šçš„Androidå¼€å‘è€…ä½¿ç”¨OkHttpä½œä¸ºç½‘ç»œæ¡†æž¶ã€‚ ä¹‹æ‰€ä»¥å¯ä»¥èµ¢å¾—å¦‚æ­¤å¤šå¼€å‘è€…çš„å–œçˆ±ï¼Œä¸»è¦å¾—ç›ŠäºŽå¦‚ä¸‹ç‰¹ç‚¹ï¼š æ”¯æŒHTTPS/HTTP2/WebSocketï¼ˆåœ¨OkHttp3.7ä¸­å·²ç»å‰¥ç¦»å¯¹Spdyçš„æ”¯æŒï¼Œè½¬è€Œå¤§åŠ›æ”¯æŒHTTP2ï¼‰ å†…éƒ¨ç»´æŠ¤ä»»åŠ¡é˜Ÿåˆ—çº¿ç¨‹æ± ï¼Œå‹å¥½æ”¯æŒå¹¶å‘è®¿é—® å†…éƒ¨ç»´æŠ¤è¿žæŽ¥æ± ï¼Œæ”¯æŒå¤šè·¯å¤ç”¨ï¼Œå‡å°‘è¿žæŽ¥åˆ›å»ºå¼€é”€ socketåˆ›å»ºæ”¯æŒæœ€ä½³è·¯ç”± æä¾›æ‹¦æˆªå™¨é“¾ï¼ˆInterceptorChainï¼‰ï¼Œå®žçŽ°requestä¸Žresponseçš„åˆ†å±‚å¤„ç†(å¦‚é€æ˜ŽGZIPåŽ‹ç¼©ï¼Œloggingç­‰) ä¸ºäº†ä¸€æŽ¢OkHttpæ˜¯å¦‚ä½•å…·å¤‡ä»¥ä¸‹ç‰¹ç‚¹çš„ï¼Œç¬”è€…åå¤ç ”ç©¶OkHttpæ¡†æž¶æºç ï¼ŒåŠ›æ±‚é€šè¿‡æºç åˆ†æžå‘å„ä½è§£é‡Šä¸€äºŒã€‚æ‰€ä»¥ç‰¹æ„å‡†å¤‡äº†å‡ ç¯‡åšå®¢è·Ÿå¤§å®¶ä¸€èµ·æŽ¢è®¨ä¸‹OkHttpçš„æ–¹æ–¹é¢é¢ï¼Œä»Šå¤©é¦–å…ˆä»Žæ•´ä½“æž¶æž„ä¸Šåˆ†æžä¸‹OkHttpã€‚ ç®€å•ä½¿ç”¨é¦–å…ˆæ¥çœ‹ä¸‹OkHttpçš„ç®€å•ä½¿ç”¨ï¼ŒOkHttpæä¾›äº†ä¸¤ç§è°ƒç”¨æ–¹å¼ï¼š åŒæ­¥è°ƒç”¨ å¼‚æ­¥è°ƒç”¨ åŒæ­¥è°ƒç”¨1234567891011121314@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(false); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; é¦–å…ˆåŠ é”ç½®æ ‡å¿—ä½ï¼ŒæŽ¥ç€ä½¿ç”¨åˆ†é…å™¨çš„executedæ–¹æ³•å°†callåŠ å…¥åˆ°åŒæ­¥é˜Ÿåˆ—ä¸­ï¼Œç„¶åŽè°ƒç”¨getResponseWithInterceptorChainæ–¹æ³•ï¼ˆç¨åŽåˆ†æžï¼‰æ‰§è¡Œhttpè¯·æ±‚ï¼Œæœ€åŽè°ƒç”¨finishiedæ–¹æ³•å°†callä»ŽåŒæ­¥é˜Ÿåˆ—ä¸­åˆ é™¤ å¼‚æ­¥è¯·æ±‚1234567void enqueue(Callback responseCallback, boolean forWebSocket) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));&#125; åŒæ ·å…ˆç½®æ ‡å¿—ä½ï¼Œç„¶åŽå°†å°è£…çš„ä¸€ä¸ªæ‰§è¡Œä½“æ”¾åˆ°å¼‚æ­¥æ‰§è¡Œé˜Ÿåˆ—ä¸­ã€‚è¿™é‡Œé¢å¼•å…¥äº†ä¸€ä¸ªæ–°çš„ç±»AsyncCallï¼Œè¿™ä¸ªç±»ç»§æ‰¿äºŽNamedRunnableï¼Œå®žçŽ°äº†RunnableæŽ¥å£ã€‚NamedRunnableå¯ä»¥ç»™å½“å‰çš„çº¿ç¨‹è®¾ç½®åå­—ï¼Œå¹¶ä¸”ç”¨æ¨¡æ¿æ–¹æ³•å°†çº¿ç¨‹çš„æ‰§è¡Œä½“æ”¾åˆ°äº†executeæ–¹æ³•ä¸­ æ‹¦æˆªå™¨é™¤äº†åŒæ­¥è°ƒç”¨å’Œå¼‚æ­¥è°ƒç”¨ï¼ŒOkHttpè¿˜æä¾›äº†ä¸€ä¸ªæ‹¦æˆªå™¨çš„æ¦‚å¿µã€‚æ‹¦æˆªå™¨æä¾›äº†æ‹¦æˆªè¯·æ±‚å’Œæ‹¦æˆªæœåŠ¡å™¨åº”ç­”çš„æŽ¥å£ã€‚OkHttpæä¾›äº†ä¸€ä¸ªæ‹¦æˆªå™¨é“¾çš„æ¦‚å¿µï¼Œé€šè¿‡å°†ä¸€ä¸ªä¸ªæ‹¦æˆªå™¨ç»„åˆæˆä¸€ä¸ªæ‹¦æˆªå™¨é“¾ï¼Œå¯ä»¥è¾¾åˆ°åœ¨ä¸åŒå±‚é¢åšä¸åŒæ‹¦æˆªæ“ä½œçš„æ•ˆæžœï¼Œæœ‰ç‚¹AOPçš„æ„æ€ã€‚å…·ä½“æ‹¦æˆªå™¨çš„ä½¿ç”¨å¯ä»¥å‚è€ƒï¼šOkhttp-wiki ä¹‹ Interceptors æ‹¦æˆªå™¨ æ€»ä½“æž¶æž„ ä¸Šå›¾æ˜¯OkHttpçš„æ€»ä½“æž¶æž„ï¼Œå¤§è‡´å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ å±‚ï¼š Interfaceâ€”â€”æŽ¥å£å±‚ï¼šæŽ¥å—ç½‘ç»œè®¿é—®è¯·æ±‚ Protocolâ€”â€”åè®®å±‚ï¼šå¤„ç†åè®®é€»è¾‘ Connectionâ€”â€”è¿žæŽ¥å±‚ï¼šç®¡ç†ç½‘ç»œè¿žæŽ¥ï¼Œå‘é€æ–°çš„è¯·æ±‚ï¼ŒæŽ¥æ”¶æœåŠ¡å™¨è®¿é—® Cacheâ€”â€”ç¼“å­˜å±‚ï¼šç®¡ç†æœ¬åœ°ç¼“å­˜ I/Oâ€”â€”I/Oå±‚ï¼šå®žé™…æ•°æ®è¯»å†™å®žçŽ° Inteceptorâ€”â€”æ‹¦æˆªå™¨å±‚ï¼šæ‹¦æˆªç½‘ç»œè®¿é—®ï¼Œæ’å…¥æ‹¦æˆªé€»è¾‘ æ•´ä½“æµç¨‹å›¾ï¼š Interfaceâ€”â€”æŽ¥å£å±‚ï¼šæŽ¥å£å±‚æŽ¥æ”¶ç”¨æˆ·çš„ç½‘ç»œè®¿é—®è¯·æ±‚ï¼ˆåŒæ­¥è¯·æ±‚/å¼‚æ­¥è¯·æ±‚ï¼‰ï¼Œå‘èµ·å®žé™…çš„ç½‘ç»œè®¿é—®ã€‚OkHttpClientæ˜¯OkHttpæ¡†æž¶çš„å®¢æˆ·ç«¯ï¼Œæ›´ç¡®åˆ‡çš„è¯´æ˜¯ä¸€ä¸ªç”¨æˆ·é¢æ¿ã€‚ç”¨æˆ·ä½¿ç”¨OkHttpè¿›è¡Œå„ç§è®¾ç½®ï¼Œå‘èµ·å„ç§ç½‘ç»œè¯·æ±‚éƒ½æ˜¯é€šè¿‡OkHttpClientå®Œæˆçš„ã€‚æ¯ä¸ªOkHttpClientå†…éƒ¨éƒ½ç»´æŠ¤äº†å±žäºŽè‡ªå·±çš„ä»»åŠ¡é˜Ÿåˆ—ï¼Œè¿žæŽ¥æ± ï¼ŒCacheï¼Œæ‹¦æˆªå™¨ç­‰ï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨OkHttpä½œä¸ºç½‘ç»œæ¡†æž¶æ—¶åº”è¯¥å…¨å±€å…±äº«ä¸€ä¸ªOkHttpClientå®žä¾‹ã€‚ Callæè¿°ä¸€ä¸ªå®žé™…çš„è®¿é—®è¯·æ±‚ï¼Œç”¨æˆ·çš„æ¯ä¸€ä¸ªç½‘ç»œè¯·æ±‚éƒ½æ˜¯ä¸€ä¸ªCallå®žä¾‹ã€‚Callæœ¬èº«åªæ˜¯ä¸€ä¸ªæŽ¥å£ï¼Œå®šä¹‰äº†Callçš„æŽ¥å£æ–¹æ³•ï¼Œå®žé™…æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼ŒOkHttpä¼šä¸ºæ¯ä¸€ä¸ªè¯·æ±‚åˆ›å»ºä¸€ä¸ªRealCall,æ¯ä¸€ä¸ªRealCallå†…éƒ¨æœ‰ä¸€ä¸ªAsyncCall: 12345678910111213141516171819202122232425 final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super("OkHttp %s", redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; @Override protected void execute() &#123; ... &#125; ...&#125; AsyncCallç»§æ‰¿çš„NamedRunnableç»§æ‰¿è‡ªRunnableæŽ¥å£ï¼š 12345678910111213141516171819public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; æ‰€ä»¥æ¯ä¸€ä¸ªCallå°±æ˜¯ä¸€ä¸ªçº¿ç¨‹ï¼Œè€Œæ‰§è¡ŒCallçš„è¿‡ç¨‹å°±æ˜¯æ‰§è¡Œå…¶executeæ–¹æ³•çš„è¿‡ç¨‹ã€‚ Dispatcheræ˜¯OkHttpçš„ä»»åŠ¡é˜Ÿåˆ—ï¼Œå…¶å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œå½“æœ‰æŽ¥æ”¶åˆ°ä¸€ä¸ªCallæ—¶ï¼ŒDispatcherè´Ÿè´£åœ¨çº¿ç¨‹æ± ä¸­æ‰¾åˆ°ç©ºé—²çš„çº¿ç¨‹å¹¶æ‰§è¡Œå…¶executeæ–¹æ³•ã€‚è¿™éƒ¨åˆ†å°†ä¼šå•ç‹¬æ‹¿ä¸€ç¯‡åšå®¢è¿›è¡Œä»‹ç»ï¼Œè¯¦ç»†å†…å®¹å¯å‚è€ƒæœ¬ç³»åˆ—æŽ¥ä¸‹æ¥çš„æ–‡ç« ã€‚ Protocolâ€”â€”åè®®å±‚ï¼šå¤„ç†åè®®é€»è¾‘Protocolå±‚è´Ÿè´£å¤„ç†åè®®é€»è¾‘ï¼ŒOkHttpæ”¯æŒHttp1/Http2/WebSocketåè®®ï¼Œå¹¶åœ¨3.7ç‰ˆæœ¬ä¸­æ”¾å¼ƒäº†å¯¹Spdyåè®®ï¼Œé¼“åŠ±å¼€å‘è€…ä½¿ç”¨Http/2ã€‚ Connectionâ€”â€”è¿žæŽ¥å±‚ï¼šç®¡ç†ç½‘ç»œè¿žæŽ¥ï¼Œå‘é€æ–°çš„è¯·æ±‚ï¼ŒæŽ¥æ”¶æœåŠ¡å™¨è®¿é—®è¿žæŽ¥å±‚é¡¾åæ€ä¹‰å°±æ˜¯è´Ÿè´£ç½‘ç»œè¿žæŽ¥ã€‚åœ¨è¿žæŽ¥å±‚ä¸­æœ‰ä¸€ä¸ªè¿žæŽ¥æ± ï¼Œç»Ÿä¸€ç®¡ç†æ‰€æœ‰çš„Socketè¿žæŽ¥ï¼Œå½“ç”¨æˆ·æ–°å‘èµ·ä¸€ä¸ªç½‘ç»œè¯·æ±‚æ—¶ï¼ŒOkHttpä¼šé¦–å…ˆä»Žè¿žæŽ¥æ± ä¸­æŸ¥æ‰¾æ˜¯å¦æœ‰ç¬¦åˆè¦æ±‚çš„è¿žæŽ¥ï¼Œå¦‚æžœæœ‰åˆ™ç›´æŽ¥é€šè¿‡è¯¥è¿žæŽ¥å‘é€ç½‘ç»œè¯·æ±‚ï¼›å¦åˆ™æ–°åˆ›å»ºä¸€ä¸ªç½‘ç»œè¿žæŽ¥ã€‚ RealConnectionæè¿°ä¸€ä¸ªç‰©ç†Socketè¿žæŽ¥ï¼Œè¿žæŽ¥æ± ä¸­ç»´æŠ¤å¤šä¸ªRealConnectionå®žä¾‹ã€‚ç”±äºŽHttp/2æ”¯æŒå¤šè·¯å¤ç”¨ï¼Œä¸€ä¸ªRealConnectionå¯ä»¥æ”¯æŒå¤šä¸ªç½‘ç»œè®¿é—®è¯·æ±‚ï¼Œæ‰€ä»¥OkHttpåˆå¼•å…¥äº†StreamAllocationæ¥æè¿°ä¸€ä¸ªå®žé™…çš„ç½‘ç»œè¯·æ±‚å¼€é”€ï¼ˆä»Žé€»è¾‘ä¸Šä¸€ä¸ªStreamå¯¹åº”ä¸€ä¸ªCallï¼Œä½†åœ¨å®žé™…ç½‘ç»œè¯·æ±‚è¿‡ç¨‹ä¸­ä¸€ä¸ªCallå¸¸å¸¸æ¶‰åŠåˆ°å¤šæ¬¡è¯·æ±‚ã€‚å¦‚é‡å®šå‘ï¼ŒAuthenticateç­‰åœºæ™¯ã€‚æ‰€ä»¥å‡†ç¡®åœ°è¯´ï¼Œä¸€ä¸ªStreamå¯¹åº”ä¸€æ¬¡è¯·æ±‚ï¼Œè€Œä¸€ä¸ªCallå¯¹åº”ä¸€ç»„æœ‰é€»è¾‘å…³è”çš„Streamï¼‰ï¼Œä¸€ä¸ªRealConnectionå¯¹åº”ä¸€ä¸ªæˆ–å¤šä¸ªStreamAllocation,æ‰€ä»¥StreamAllocationå¯ä»¥çœ‹åšæ˜¯RealConenctionçš„è®¡æ•°å™¨ï¼Œå½“RealConnectionçš„å¼•ç”¨è®¡æ•°å˜ä¸º0ï¼Œä¸”é•¿æ—¶é—´æ²¡æœ‰è¢«å…¶ä»–è¯·æ±‚é‡æ–°å ç”¨å°±å°†è¢«é‡Šæ”¾ã€‚ è¿žæŽ¥å±‚æ˜¯OkHttpçš„æ ¸å¿ƒéƒ¨åˆ†ï¼Œè¿™éƒ¨åˆ†å½“ç„¶ä¹Ÿä¼šå•ç‹¬æ‹¿ä¸€ç¯‡åšå®¢è¯¦ç»†è®²è§£ï¼Œè¯¦ç»†å†…å®¹å¯å‚è€ƒæœ¬ä¸“é¢˜ç›¸å…³æ–‡ç« ã€‚ Cacheâ€”â€”ç¼“å­˜å±‚ï¼šç®¡ç†æœ¬åœ°ç¼“å­˜Cacheå±‚è´Ÿè´£ç»´æŠ¤è¯·æ±‚ç¼“å­˜ï¼Œå½“ç”¨æˆ·çš„ç½‘ç»œè¯·æ±‚åœ¨æœ¬åœ°å·²æœ‰ç¬¦åˆè¦æ±‚çš„ç¼“å­˜æ—¶ï¼ŒOkHttpä¼šç›´æŽ¥ä»Žç¼“å­˜ä¸­è¿”å›žç»“æžœï¼Œä»Žè€ŒèŠ‚çœç½‘ç»œå¼€é”€ã€‚è¿™éƒ¨åˆ†å†…å®¹ä¹Ÿä¼šå•ç‹¬æ‹¿ä¸€ç¯‡åšå®¢è¿›è¡Œä»‹ç»ï¼Œè¯¦ç»†å†…å®¹å¯å‚è€ƒæœ¬ä¸“é¢˜ç›¸å…³æ–‡ç« ã€‚ I/Oâ€”â€”I/Oå±‚ï¼šå®žé™…æ•°æ®è¯»å†™å®žçŽ°I/Oå±‚è´Ÿè´£å®žé™…çš„æ•°æ®è¯»å†™ã€‚OkHttpçš„å¦ä¸€å¤§æœ‰ç‚¹å°±æ˜¯å…¶é«˜æ•ˆçš„I/Oæ“ä½œï¼Œè¿™å½’å› äºŽå…¶é«˜æ•ˆçš„I/Oåº“okio è¿™éƒ¨åˆ†å†…å®¹ç¬”è€…ä¹Ÿæ‰“ç®—å¦å¼€ä¸€ä¸ªä¸“é¢˜è¿›è¡Œä»‹ç»ã€‚è¯¦ç»†å†…å®¹å¯ä»¥å‚è€ƒæœ¬åšå®¢ç›¸å…³å†…å®¹ã€‚ Inteceptorâ€”â€”æ‹¦æˆªå™¨å±‚ï¼šæ‹¦æˆªç½‘ç»œè®¿é—®ï¼Œæ’å…¥æ‹¦æˆªé€»è¾‘æ‹¦æˆªå™¨å±‚æä¾›äº†ä¸€ä¸ªç±»AOPæŽ¥å£ï¼Œæ–¹ä¾¿ç”¨æˆ·å¯ä»¥åˆ‡å…¥åˆ°å„ä¸ªå±‚é¢å¯¹ç½‘ç»œè®¿é—®è¿›è¡Œæ‹¦æˆªå¹¶æ‰§è¡Œç›¸å…³é€»è¾‘ã€‚åœ¨ä¸‹ä¸€ç¯‡åšå®¢ä¸­ï¼Œç¬”è€…å°†é€šè¿‡ä»‹ç»ä¸€ä¸ªå®žé™…çš„ç½‘ç»œè®¿é—®è¯·æ±‚å®žä¾‹æ¥ä»‹ç»æ‹¦æˆªå™¨çš„åŽŸç†ã€‚ OkHttpæºç åˆ†æžâ€”â€”æ‹¦æˆªå™¨ å‰ä¸€ç¯‡åšå®¢ä¸­æˆ‘ä»¬ä»‹ç»äº†OkHttpçš„æ€»ä½“æž¶æž„ï¼ŒæŽ¥ä¸‹æ¥æˆ‘ä»¬ä»¥ä¸€ä¸ªå…·ä½“çš„ç½‘ç»œè¯·æ±‚æ¥è®²è¿°OkHttpè¿›è¡Œç½‘ç»œè®¿é—®çš„å…·ä½“è¿‡ç¨‹ã€‚ç”±äºŽè¯¥éƒ¨åˆ†ä¸ŽOkHttpçš„æ‹¦æˆªå™¨æ¦‚å¿µç´§å¯†è”ç³»åœ¨ä¸€èµ·ï¼Œæ‰€ä»¥å°†è¿™ä¸¤éƒ¨åˆ†æ”¾åœ¨ä¸€èµ·è¿›è¡Œè®²è§£ã€‚ 1.æž„é€ Demoé¦–å…ˆæž„é€ ä¸€ä¸ªç®€å•çš„å¼‚æ­¥ç½‘ç»œè®¿é—®Demo: 12345678910111213141516OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d("OkHttp", "Call Failed:" + e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d("OkHttp", "Call succeeded:" + response.message()); &#125;&#125;); 2. å‘èµ·è¯·æ±‚OkHttpClient.newCallå®žé™…æ˜¯åˆ›å»ºä¸€ä¸ªRealCallå®žä¾‹ï¼š 123456/** * Prepares the &#123;@code request&#125; to be executed at some point in the future. */@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */);&#125; RealCall.enqueueå®žé™…å°±æ˜¯è®²ä¸€ä¸ªRealCallæ”¾å…¥åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œç­‰å¾…åˆé€‚çš„æœºä¼šæ‰§è¡Œ: 12345678@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; ä»Žä»£ç ä¸­å¯ä»¥çœ‹åˆ°æœ€ç»ˆRealCallè¢«è½¬åŒ–æˆä¸€ä¸ªAsyncCallå¹¶è¢«æ”¾å…¥åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­ï¼Œä»»åŠ¡é˜Ÿåˆ—ä¸­çš„åˆ†å‘é€»è¾‘è¿™é‡Œå…ˆä¸è¯´ï¼Œç›¸å…³å®žçŽ°ä¼šæ”¾åœ¨OkHttpæºç åˆ†æžâ€”â€”ä»»åŠ¡é˜Ÿåˆ—ç–‘é—®è¿›è¡Œä»‹ç»ã€‚è¿™é‡Œåªéœ€è¦çŸ¥é“AsyncCallçš„excuteæ–¹æ³•æœ€ç»ˆå°†ä¼šè¢«æ‰§è¡Œ: 123456789101112131415161718192021222324[RealCall.java] @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; &#125; executeæ–¹æ³•çš„é€»è¾‘å¹¶ä¸å¤æ‚ï¼Œç®€å•çš„è¯´å°±æ˜¯ï¼š è°ƒç”¨getResponseWithInterceptorChainèŽ·å–æœåŠ¡å™¨è¿”å›ž é€šçŸ¥ä»»åŠ¡åˆ†å‘å™¨(client.dispatcher)è¯¥ä»»åŠ¡å·²ç»“æŸ getResponseWithInterceptorChainæž„å»ºäº†ä¸€ä¸ªæ‹¦æˆªå™¨é“¾ï¼Œé€šè¿‡ä¾æ¬¡æ‰§è¡Œè¯¥æ‹¦æˆªå™¨é“¾ä¸­çš„æ¯ä¸€ä¸ªæ‹¦æˆªå™¨æœ€ç»ˆå¾—åˆ°æœåŠ¡å™¨è¿”å›žã€‚ 3. æž„å»ºæ‹¦æˆªå™¨é“¾é¦–å…ˆæ¥çœ‹ä¸‹getResponseWithInterceptorChainçš„å®žçŽ°ï¼š 123456789101112131415161718[RealCall.java] Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; å…¶é€»è¾‘å¤§è‡´åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼š åˆ›å»ºä¸€ç³»åˆ—æ‹¦æˆªå™¨ï¼Œå¹¶å°†å…¶æ”¾å…¥ä¸€ä¸ªæ‹¦æˆªå™¨æ•°ç»„ä¸­ã€‚è¿™éƒ¨åˆ†æ‹¦æˆªå™¨å³åŒ…æ‹¬ç”¨æˆ·è‡ªå®šä¹‰çš„æ‹¦æˆªå™¨ä¹ŸåŒ…æ‹¬æ¡†æž¶å†…éƒ¨æ‹¦æˆªå™¨ åˆ›å»ºä¸€ä¸ªæ‹¦æˆªå™¨é“¾RealInterceptorChain,å¹¶æ‰§è¡Œæ‹¦æˆªå™¨é“¾çš„proceedæ–¹æ³• æŽ¥ä¸‹æ¥çœ‹ä¸‹RealInterceptorChainçš„å®žçŽ°é€»è¾‘ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[RealInterceptorChain.java]public final class RealInterceptorChain implements Interceptor.Chain &#123; private final List&lt;Interceptor&gt; interceptors; private final StreamAllocation streamAllocation; private final HttpCodec httpCodec; private final RealConnection connection; private final int index; private final Request request; private int calls; public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection, int index, Request request) &#123; this.interceptors = interceptors; this.connection = connection; this.streamAllocation = streamAllocation; this.httpCodec = httpCodec; this.index = index; this.request = request; &#125; @Override public Connection connection() &#123; return connection; &#125; public StreamAllocation streamAllocation() &#123; return streamAllocation; &#125; public HttpCodec httpStream() &#123; return httpCodec; &#125; @Override public Request request() &#123; return request; &#125; @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; ...... // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); ...... return response; &#125;&#125; åœ¨proceedæ–¹æ³•ä¸­çš„æ ¸å¿ƒä»£ç å¯ä»¥çœ‹åˆ°ï¼Œproceedå®žé™…ä¸Šä¹Ÿåšäº†ä¸¤ä»¶äº‹ï¼š åˆ›å»ºä¸‹ä¸€ä¸ªæ‹¦æˆªé“¾ã€‚ä¼ å…¥index + 1ä½¿å¾—ä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨é“¾åªèƒ½ä»Žä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨å¼€å§‹è®¿é—® æ‰§è¡Œç´¢å¼•ä¸ºindexçš„interceptæ–¹æ³•ï¼Œå¹¶å°†ä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨é“¾ä¼ å…¥è¯¥æ–¹æ³• æŽ¥ä¸‹æ¥å†çœ‹ä¸‹ç¬¬ä¸€ä¸ªæ‹¦æˆªå™¨RetryAndFollowUpInterceptorçš„interceptæ–¹æ³•ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[RetryAndFollowUpInterceptor.java]public final class RetryAndFollowUpInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); streamAllocation = new StreamAllocation( client.connectionPool(), createAddress(request.url()), callStackTrace); int followUpCount = 0; Response priorResponse = null; while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException("Canceled"); &#125; Response response = null; boolean releaseConnection = true; try &#123; //æ‰§è¡Œä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨é“¾çš„proceedæ–¹æ³• response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), false, request)) &#123; throw e.getLastConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. ...... Request followUp = followUpRequest(response); closeQuietly(response.body()); ... &#125; &#125;&#125; è¿™æ®µä»£ç æœ€å…³é”®çš„ä»£ç æ˜¯: 1response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); è¿™è¡Œä»£ç å°±æ˜¯æ‰§è¡Œä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨é“¾çš„proceedæ–¹æ³•ã€‚è€Œæˆ‘ä»¬çŸ¥é“åœ¨ä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨é“¾ä¸­åˆä¼šæ‰§è¡Œä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨çš„interceptæ–¹æ³•ã€‚æ‰€ä»¥æ•´ä¸ªæ‰§è¡Œé“¾å°±åœ¨æ‹¦æˆªå™¨ä¸Žæ‹¦æˆªå™¨é“¾ä¸­äº¤æ›¿æ‰§è¡Œï¼Œæœ€ç»ˆå®Œæˆæ‰€æœ‰æ‹¦æˆªå™¨çš„æ“ä½œã€‚è¿™ä¹Ÿæ˜¯OkHttpæ‹¦æˆªå™¨çš„é“¾å¼æ‰§è¡Œé€»è¾‘ã€‚è€Œä¸€ä¸ªæ‹¦æˆªå™¨çš„interceptæ–¹æ³•æ‰€æ‰§è¡Œçš„é€»è¾‘å¤§è‡´åˆ†ä¸ºä¸‰éƒ¨åˆ†ï¼š åœ¨å‘èµ·è¯·æ±‚å‰å¯¹requestè¿›è¡Œå¤„ç† è°ƒç”¨ä¸‹ä¸€ä¸ªæ‹¦æˆªå™¨ï¼ŒèŽ·å–response å¯¹responseè¿›è¡Œå¤„ç†ï¼Œè¿”å›žç»™ä¸Šä¸€ä¸ªæ‹¦æˆªå™¨ è¿™å°±æ˜¯OkHttpæ‹¦æˆªå™¨æœºåˆ¶çš„æ ¸å¿ƒé€»è¾‘ã€‚æ‰€ä»¥ä¸€ä¸ªç½‘ç»œè¯·æ±‚å®žé™…ä¸Šå°±æ˜¯ä¸€ä¸ªä¸ªæ‹¦æˆªå™¨æ‰§è¡Œå…¶interceptæ–¹æ³•çš„è¿‡ç¨‹ã€‚è€Œè¿™å…¶ä¸­é™¤äº†ç”¨æˆ·è‡ªå®šä¹‰çš„æ‹¦æˆªå™¨å¤–è¿˜æœ‰å‡ ä¸ªæ ¸å¿ƒæ‹¦æˆªå™¨å®Œæˆäº†ç½‘ç»œè®¿é—®çš„æ ¸å¿ƒé€»è¾‘ï¼ŒæŒ‰ç…§å…ˆåŽé¡ºåºä¾æ¬¡æ˜¯ï¼š RetryAndFollowUpInterceptor BridgeInterceptor CacheInterceptor ConnectIntercetot CallServerInterceptor 4 RetryAndFollowUpInterceptorå¦‚ä¸Šæ–‡ä»£ç æ‰€ç¤ºï¼ŒRetryAndFollowUpInterceptorè´Ÿè´£ä¸¤éƒ¨åˆ†é€»è¾‘ï¼š åœ¨ç½‘ç»œè¯·æ±‚å¤±è´¥åŽè¿›è¡Œé‡è¯• å½“æœåŠ¡å™¨è¿”å›žå½“å‰è¯·æ±‚éœ€è¦è¿›è¡Œé‡å®šå‘æ—¶ç›´æŽ¥å‘èµ·æ–°çš„è¯·æ±‚ï¼Œå¹¶åœ¨æ¡ä»¶å…è®¸æƒ…å†µä¸‹å¤ç”¨å½“å‰è¿žæŽ¥ 5 BridgeInterceptor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public final class BridgeInterceptor implements Interceptor &#123; private final CookieJar cookieJar; public BridgeInterceptor(CookieJar cookieJar) &#123; this.cookieJar = cookieJar; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "BridgeInterceptor.intercept"); Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header("Content-Type", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header("Content-Length", Long.toString(contentLength)); requestBuilder.removeHeader("Transfer-Encoding"); &#125; else &#123; requestBuilder.header("Transfer-Encoding", "chunked"); requestBuilder.removeHeader("Content-Length"); &#125; &#125; if (userRequest.header("Host") == null) &#123; requestBuilder.header("Host", hostHeader(userRequest.url(), false)); &#125; if (userRequest.header("Connection") == null) &#123; requestBuilder.header("Connection", "Keep-Alive"); &#125; // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header("Accept-Encoding") == null &amp;&amp; userRequest.header("Range") == null) &#123; transparentGzip = true; requestBuilder.header("Accept-Encoding", "gzip"); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header("Cookie", cookieHeader(cookies)); &#125; if (userRequest.header("User-Agent") == null) &#123; requestBuilder.header("User-Agent", Version.userAgent()); &#125; Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll("Content-Encoding") .removeAll("Content-Length") .build(); responseBuilder.headers(strippedHeaders); responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125;&#125; BridgeInterceptorä¸»è¦è´Ÿè´£ä»¥ä¸‹å‡ éƒ¨åˆ†å†…å®¹ï¼š è®¾ç½®å†…å®¹é•¿åº¦ï¼Œå†…å®¹ç¼–ç  è®¾ç½®gzipåŽ‹ç¼©ï¼Œå¹¶åœ¨æŽ¥æ”¶åˆ°å†…å®¹åŽè¿›è¡Œè§£åŽ‹ã€‚çœåŽ»äº†åº”ç”¨å±‚å¤„ç†æ•°æ®è§£åŽ‹çš„éº»çƒ¦ æ·»åŠ cookie è®¾ç½®å…¶ä»–æŠ¥å¤´ï¼Œå¦‚User-Agent,Host,Keep-aliveç­‰ã€‚å…¶ä¸­Keep-Aliveæ˜¯å®žçŽ°å¤šè·¯å¤ç”¨çš„å¿…è¦æ­¥éª¤ 6. CacheInterceptor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697[CacheInterceptor.intercept] @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "CacheInterceptor.intercept"); Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don't need the network, we're done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; CacheInterceptorçš„èŒè´£å¾ˆæ˜Žç¡®ï¼Œå°±æ˜¯è´Ÿè´£Cacheçš„ç®¡ç† å½“ç½‘ç»œè¯·æ±‚æœ‰ç¬¦åˆè¦æ±‚çš„Cacheæ—¶ç›´æŽ¥è¿”å›žCache å½“æœåŠ¡å™¨è¿”å›žå†…å®¹æœ‰æ”¹å˜æ—¶æ›´æ–°å½“å‰cache å¦‚æžœå½“å‰cacheå¤±æ•ˆï¼Œåˆ é™¤ 7 ConnectInterceptor12345678910111213141516171819202122[ConnectInterceptor.java]public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "ConnectInterceptor.intercept"); RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals("GET"); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125; ConnectInterceptorçš„interceptæ–¹æ³•åªæœ‰ä¸€è¡Œå…³é”®ä»£ç : 1RealConnection connection = streamAllocation.connection(); å³ä¸ºå½“å‰è¯·æ±‚æ‰¾åˆ°åˆé€‚çš„è¿žæŽ¥ï¼Œå¯èƒ½å¤ç”¨å·²æœ‰è¿žæŽ¥ä¹Ÿå¯èƒ½æ˜¯é‡æ–°åˆ›å»ºçš„è¿žæŽ¥ï¼Œè¿”å›žçš„è¿žæŽ¥ç”±è¿žæŽ¥æ± è´Ÿè´£å†³å®šã€‚ 8. CallServerInterceptor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[CallServerInterceptor.java]@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); httpCodec.writeRequestHeaders(request); Response.Builder responseBuilder = null; ...... httpCodec.finishRequest(); if (responseBuilder == null) &#123; responseBuilder = httpCodec.readResponseHeaders(false); &#125; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if ("close".equalsIgnoreCase(response.request().header("Connection")) || "close".equalsIgnoreCase(response.header("Connection"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength()); &#125; return response; &#125; CallServerInterceptorè´Ÿè´£å‘æœåŠ¡å™¨å‘èµ·çœŸæ­£çš„è®¿é—®è¯·æ±‚ï¼Œå¹¶åœ¨æŽ¥æ”¶åˆ°æœåŠ¡å™¨è¿”å›žåŽè¯»å–å“åº”è¿”å›žã€‚ 8.æ•´ä½“æµç¨‹ä»¥ä¸Šå°±æ˜¯æ•´ä¸ªç½‘ç»œè®¿é—®çš„æ ¸å¿ƒæ­¥éª¤ï¼Œæ€»ç»“èµ·æ¥å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š OkHttpæºç åˆ†æžâ€”â€”ä»»åŠ¡é˜Ÿåˆ— å‰é¢çš„åšå®¢å·²ç»æåˆ°è¿‡ï¼ŒOkHttpçš„ä¸€ä¸ªé«˜æ•ˆä¹‹å¤„åœ¨äºŽåœ¨å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªçº¿ç¨‹æ± ï¼Œæ–¹ä¾¿é«˜æ•ˆåœ°æ‰§è¡Œå¼‚æ­¥è¯·æ±‚ã€‚æœ¬ç¯‡åšå®¢å°†è¯¦ç»†ä»‹ç»OkHttpçš„ä»»åŠ¡é˜Ÿåˆ—æœºåˆ¶ã€‚ 1. çº¿ç¨‹æ± çš„ä¼˜ç‚¹OkHttpçš„ä»»åŠ¡é˜Ÿåˆ—åœ¨å†…éƒ¨ç»´æŠ¤äº†ä¸€ä¸ªçº¿ç¨‹æ± ç”¨äºŽæ‰§è¡Œå…·ä½“çš„ç½‘ç»œè¯·æ±‚ã€‚è€Œçº¿ç¨‹æ± æœ€å¤§çš„å¥½å¤„åœ¨äºŽé€šè¿‡çº¿ç¨‹å¤ç”¨å‡å°‘éžæ ¸å¿ƒä»»åŠ¡çš„æŸè€—ã€‚ å¤šçº¿ç¨‹æŠ€æœ¯ä¸»è¦è§£å†³å¤„ç†å™¨å•å…ƒå†…å¤šä¸ªçº¿ç¨‹æ‰§è¡Œçš„é—®é¢˜ï¼Œå®ƒå¯ä»¥æ˜¾è‘—å‡å°‘å¤„ç†å™¨å•å…ƒçš„é—²ç½®æ—¶é—´ï¼Œå¢žåŠ å¤„ç†å™¨å•å…ƒçš„åžåèƒ½åŠ›ã€‚ä½†å¦‚æžœå¯¹å¤šçº¿ç¨‹åº”ç”¨ä¸å½“ï¼Œä¼šå¢žåŠ å¯¹å•ä¸ªä»»åŠ¡çš„å¤„ç†æ—¶é—´ã€‚å¯ä»¥ä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼š å‡è®¾åœ¨ä¸€å°æœåŠ¡å™¨å®Œæˆä¸€é¡¹ä»»åŠ¡çš„æ—¶é—´ä¸ºT 1234&gt; T1 åˆ›å»ºçº¿ç¨‹çš„æ—¶é—´&gt; T2 åœ¨çº¿ç¨‹ä¸­æ‰§è¡Œä»»åŠ¡çš„æ—¶é—´ï¼ŒåŒ…æ‹¬çº¿ç¨‹é—´åŒæ­¥æ‰€éœ€æ—¶é—´&gt; T3 çº¿ç¨‹é”€æ¯çš„æ—¶é—´&gt; &gt; æ˜¾ç„¶T ï¼ T1ï¼‹T2ï¼‹T3ã€‚æ³¨æ„è¿™æ˜¯ä¸€ä¸ªæžåº¦ç®€åŒ–çš„å‡è®¾ã€‚å¯ä»¥çœ‹å‡ºT1,T3æ˜¯å¤šçº¿ç¨‹æœ¬èº«çš„å¸¦æ¥çš„å¼€é”€ï¼ˆåœ¨Javaä¸­ï¼Œé€šè¿‡æ˜ å°„pTheadï¼Œå¹¶è¿›ä¸€æ­¥é€šè¿‡&gt;SystemCallå®žçŽ°nativeçº¿ç¨‹ï¼‰ï¼Œæˆ‘ä»¬æ¸´æœ›å‡å°‘T1,T3æ‰€ç”¨çš„æ—¶é—´ï¼Œä»Žè€Œå‡å°‘Tçš„æ—¶é—´ã€‚ä½†ä¸€äº›çº¿&gt;ç¨‹çš„ä½¿ç”¨è€…å¹¶æ²¡æœ‰æ³¨æ„åˆ°è¿™ä¸€ç‚¹ï¼Œæ‰€ä»¥åœ¨ç¨‹åºä¸­é¢‘ç¹çš„åˆ›å»ºæˆ–é”€æ¯çº¿ç¨‹ï¼Œè¿™å¯¼è‡´T1å’ŒT3åœ¨Tä¸­å æœ‰&gt;ç›¸å½“æ¯”ä¾‹ã€‚æ˜¾ç„¶è¿™æ˜¯çªå‡ºäº†çº¿ç¨‹çš„å¼±ç‚¹ï¼ˆT1ï¼ŒT3ï¼‰ï¼Œè€Œä¸æ˜¯ä¼˜ç‚¹ï¼ˆå¹¶å‘æ€§ï¼‰ã€‚ çº¿ç¨‹æ± æŠ€æœ¯æ­£æ˜¯å…³æ³¨å¦‚ä½•ç¼©çŸ­æˆ–è°ƒæ•´T1ï¼ŒT3æ—¶é—´çš„æŠ€æœ¯ï¼Œä»Žè€Œæé«˜æœåŠ¡å™¨ç¨‹åºæ€§èƒ½çš„ã€‚ é€šè¿‡å¯¹çº¿ç¨‹è¿›è¡Œç¼“å­˜ï¼Œå‡å°‘äº†åˆ›å»ºé”€æ¯çš„æ—¶é—´æŸå¤± é€šè¿‡æŽ§åˆ¶çº¿ç¨‹æ•°é‡é˜€å€¼ï¼Œå‡å°‘äº†å½“çº¿ç¨‹è¿‡å°‘æ—¶å¸¦æ¥çš„CPUé—²ç½®ï¼ˆæ¯”å¦‚è¯´é•¿æ—¶é—´å¡åœ¨I/Oä¸Šäº†ï¼‰ä¸Žçº¿ç¨‹è¿‡å¤šæ—¶å¯¹JVMçš„å†…å­˜ä¸Žçº¿ç¨‹åˆ‡æ¢æ—¶ç³»ç»Ÿè°ƒç”¨çš„åŽ‹åŠ› ç±»ä¼¼çš„è¿˜æœ‰Socketè¿žæŽ¥æ± ã€DBè¿žæŽ¥æ± ã€CommonPool(æ¯”å¦‚Jedis)ç­‰æŠ€æœ¯ã€‚ 2. OkHttpçš„ä»»åŠ¡é˜Ÿåˆ—OkHttpçš„ä»»åŠ¡é˜Ÿåˆ—ä¸»è¦ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼š ä»»åŠ¡åˆ†å‘å™¨dispatcherï¼šè´Ÿè´£ä¸ºä»»åŠ¡æ‰¾åˆ°åˆé€‚çš„æ‰§è¡Œçº¿ç¨‹ ç½‘ç»œè¯·æ±‚ä»»åŠ¡çº¿ç¨‹æ±  12345678910111213141516171819202122232425262728293031323334public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; private Runnable idleCallback; /** Executes calls. Created lazily. */ private ExecutorService executorService; /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); public Dispatcher(ExecutorService executorService) &#123; this.executorService = executorService; &#125; public Dispatcher() &#123; &#125; public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; ...&#125; å‚æ•°è¯´æ˜Žå¦‚ä¸‹ï¼š readyAsyncCallsï¼šå¾…æ‰§è¡Œå¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ— runningAsyncCallsï¼šè¿è¡Œä¸­å¼‚æ­¥ä»»åŠ¡é˜Ÿåˆ— runningSyncCallsï¼šè¿è¡Œä¸­åŒæ­¥ä»»åŠ¡é˜Ÿåˆ— executorServiceï¼šä»»åŠ¡é˜Ÿåˆ—çº¿ç¨‹æ± ï¼š 123456789&gt; public ThreadPoolExecutor(int corePoolSize,&gt; int maximumPoolSize,&gt; long keepAliveTime,&gt; TimeUnit unit,&gt; BlockingQueue&lt;Runnable&gt; workQueue,&gt; ThreadFactory threadFactory) &#123;&gt; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,&gt; threadFactory, defaultHandler);&gt; &gt; int corePoolSize: æœ€å°å¹¶å‘çº¿ç¨‹æ•°ï¼Œè¿™é‡Œå¹¶å‘åŒæ—¶åŒ…æ‹¬ç©ºé—²ä¸Žæ´»åŠ¨çš„çº¿ç¨‹ï¼Œå¦‚æžœæ˜¯0çš„è¯ï¼Œç©ºé—²ä¸€æ®µæ—¶é—´åŽæ‰€æœ‰çº¿ç¨‹å°†å…¨éƒ¨è¢«é”€æ¯ int maximumPoolSize: æœ€å¤§çº¿ç¨‹æ•°ï¼Œå½“ä»»åŠ¡è¿›æ¥æ—¶å¯ä»¥æ‰©å……çš„çº¿ç¨‹æœ€å¤§å€¼ï¼Œå½“å¤§äºŽäº†è¿™ä¸ªå€¼å°±ä¼šæ ¹æ®ä¸¢å¼ƒå¤„ç†æœºåˆ¶æ¥å¤„ç† long keepAliveTime: å½“çº¿ç¨‹æ•°å¤§äºŽcorePoolSizeæ—¶ï¼Œå¤šä½™çš„ç©ºé—²çº¿ç¨‹çš„æœ€å¤§å­˜æ´»æ—¶é—´ï¼Œç±»ä¼¼äºŽHTTPä¸­çš„Keep-alive TimeUnit unit: æ—¶é—´å•ä½ï¼Œä¸€èˆ¬ç”¨ç§’ BlockingQueue workQueue: å·¥ä½œé˜Ÿåˆ—ï¼Œå…ˆè¿›å…ˆå‡ºï¼Œå¯ä»¥çœ‹å‡ºå¹¶ä¸åƒPicassoé‚£æ ·è®¾ç½®ä¼˜å…ˆé˜Ÿåˆ— ThreadFactory threadFactory: å•ä¸ªçº¿ç¨‹çš„å·¥åŽ‚ï¼Œå¯ä»¥æ‰“Logï¼Œè®¾ç½®Daemon(å³å½“JVMé€€å‡ºæ—¶ï¼Œçº¿ç¨‹è‡ªåŠ¨ç»“æŸ)ç­‰ å¯ä»¥çœ‹å‡ºï¼Œåœ¨Okhttpä¸­ï¼Œæž„å»ºäº†ä¸€ä¸ªé˜€å€¼ä¸º[0, Integer.MAX_VALUE]çš„çº¿ç¨‹æ± ï¼Œå®ƒä¸ä¿ç•™ä»»ä½•æœ€å°çº¿ç¨‹æ•°ï¼Œéšæ—¶åˆ›å»ºæ›´å¤šçš„çº¿ç¨‹æ•°ï¼Œå½“çº¿ç¨‹ç©ºé—²æ—¶åªèƒ½æ´»60ç§’ï¼Œå®ƒä½¿ç”¨äº†ä¸€ä¸ªä¸å­˜å‚¨å…ƒç´ çš„é˜»å¡žå·¥ä½œé˜Ÿåˆ—ï¼Œä¸€ä¸ªå«åšâ€OkHttp Dispatcherâ€çš„çº¿ç¨‹å·¥åŽ‚ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨å®žé™…è¿è¡Œä¸­ï¼Œå½“æ”¶åˆ°10ä¸ªå¹¶å‘è¯·æ±‚æ—¶ï¼Œçº¿ç¨‹æ± ä¼šåˆ›å»ºåä¸ªçº¿ç¨‹ï¼Œå½“å·¥ä½œå®ŒæˆåŽï¼Œçº¿ç¨‹æ± ä¼šåœ¨60såŽç›¸ç»§å…³é—­æ‰€æœ‰çº¿ç¨‹ã€‚ 3. Dispatcheråˆ†å‘å™¨dispatcheråˆ†å‘å™¨ç±»ä¼¼äºŽNgnixä¸­çš„åå‘ä»£ç†ï¼Œé€šè¿‡Dispatcherå°†ä»»åŠ¡åˆ†å‘åˆ°åˆé€‚çš„ç©ºé—²çº¿ç¨‹ï¼Œå®žçŽ°éžé˜»å¡žï¼Œé«˜å¯ç”¨ï¼Œé«˜å¹¶å‘è¿žæŽ¥ 1.åŒæ­¥è¯·æ±‚å½“æˆ‘ä»¬ä½¿ç”¨OkHttpè¿›è¡ŒåŒæ­¥è¯·æ±‚æ—¶ï¼Œä¸€èˆ¬æž„é€ å¦‚ä¸‹ï¼š 12345OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();Response response = client.newCall(request).execute(); æŽ¥ä¸‹æ¥çœ‹çœ‹RealCall.execute 123456789101112131415@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; åŒæ­¥è°ƒç”¨çš„æ‰§è¡Œé€»è¾‘æ˜¯ï¼š å°†å¯¹åº”ä»»åŠ¡åŠ å…¥åˆ†å‘å™¨ æ‰§è¡Œä»»åŠ¡ æ‰§è¡Œå®ŒæˆåŽé€šçŸ¥dispatcherå¯¹åº”ä»»åŠ¡å·²å®Œæˆï¼Œå¯¹åº”ä»»åŠ¡å‡ºé˜Ÿ 2.å¼‚æ­¥è¯·æ±‚å¼‚æ­¥è¯·æ±‚ä¸€èˆ¬æž„é€ å¦‚ä¸‹ï¼š 12345678910111213141516OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d("OkHttp", "Call Failed:" + e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d("OkHttp", "Call succeeded:" + response.message()); &#125;&#125;); å½“HttpClientçš„è¯·æ±‚å…¥é˜Ÿæ—¶ï¼Œæ ¹æ®ä»£ç ï¼Œæˆ‘ä»¬å¯ä»¥å‘çŽ°å®žé™…ä¸Šæ˜¯Dispatcherè¿›è¡Œäº†å…¥é˜Ÿæ“ä½œã€‚ 1234567891011synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; //æ·»åŠ æ­£åœ¨è¿è¡Œçš„è¯·æ±‚ runningAsyncCalls.add(call); //çº¿ç¨‹æ± æ‰§è¡Œè¯·æ±‚ executorService().execute(call); &#125; else &#123; //æ·»åŠ åˆ°ç¼“å­˜é˜Ÿåˆ—æŽ’é˜Ÿç­‰å¾… readyAsyncCalls.add(call); &#125;&#125; å¦‚æžœæ»¡è¶³æ¡ä»¶ï¼š å½“å‰è¯·æ±‚æ•°å°äºŽæœ€å¤§è¯·æ±‚æ•°ï¼ˆ64ï¼‰ å¯¹å•ä¸€hostçš„è¯·æ±‚å°äºŽé˜ˆå€¼ï¼ˆ5ï¼‰ å°†è¯¥ä»»åŠ¡æ’å…¥æ­£åœ¨æ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—ï¼Œå¹¶æ‰§è¡Œå¯¹åº”ä»»åŠ¡ã€‚å¦‚æžœä¸æ»¡è¶³åˆ™å°†å…¶æ”¾å…¥å¾…æ‰§è¡Œé˜Ÿåˆ—ã€‚ æŽ¥ä¸‹æ¥çœ‹çœ‹AsyncCall.execute 1234567891011121314151617181920212223242526@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //æ‰§è¡Œè€—æ—¶IOä»»åŠ¡ Response response = getResponseWithInterceptorChain(forWebSocket); if (canceled) &#123; signalledCallback = true; //å›žè°ƒï¼Œæ³¨æ„è¿™é‡Œå›žè°ƒæ˜¯åœ¨çº¿ç¨‹æ± ä¸­ï¼Œè€Œä¸æ˜¯æƒ³å½“ç„¶çš„ä¸»çº¿ç¨‹å›žè°ƒ responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; //å›žè°ƒï¼ŒåŒä¸Š responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; //æœ€å…³é”®çš„ä»£ç  client.dispatcher().finished(this); &#125;&#125; å½“ä»»åŠ¡æ‰§è¡Œå®ŒæˆåŽï¼Œæ— è®ºæˆåŠŸä¸Žå¦éƒ½ä¼šè°ƒç”¨dispatcher.finishedæ–¹æ³•ï¼Œé€šçŸ¥åˆ†å‘å™¨ç›¸å…³ä»»åŠ¡å·²ç»“æŸï¼š 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; ç©ºé—²å‡ºå¤šä½™çº¿ç¨‹ï¼Œè°ƒç”¨promoteCallsè°ƒç”¨å¾…æ‰§è¡Œçš„ä»»åŠ¡ å¦‚æžœå½“å‰æ•´ä¸ªçº¿ç¨‹æ± éƒ½ç©ºé—²ä¸‹æ¥ï¼Œæ‰§è¡Œç©ºé—²é€šçŸ¥å›žè°ƒçº¿ç¨‹(idleCallback) æŽ¥ä¸‹æ¥çœ‹çœ‹promoteCallsï¼š 12345678910111213141516private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125;&#125; promoteCallsçš„é€»è¾‘ä¹Ÿå¾ˆç®€å•ï¼šæ‰«æå¾…æ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—ï¼Œå°†ä»»åŠ¡æ”¾å…¥æ­£åœ¨æ‰§è¡Œä»»åŠ¡é˜Ÿåˆ—ï¼Œå¹¶æ‰§è¡Œè¯¥ä»»åŠ¡ã€‚ 4. æ€»ç»“ä»¥ä¸Šå°±æ˜¯æ•´ä¸ªä»»åŠ¡é˜Ÿåˆ—çš„å®žçŽ°ç»†èŠ‚ï¼Œæ€»ç»“èµ·æ¥æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š OkHttpé‡‡ç”¨DispatcheræŠ€æœ¯ï¼Œç±»ä¼¼äºŽNginxï¼Œä¸Žçº¿ç¨‹æ± é…åˆå®žçŽ°äº†é«˜å¹¶å‘ï¼Œä½Žé˜»å¡žçš„è¿è¡Œ Okhttpé‡‡ç”¨Dequeä½œä¸ºç¼“å­˜ï¼ŒæŒ‰ç…§å…¥é˜Ÿçš„é¡ºåºå…ˆè¿›å…ˆå‡º OkHttpæœ€å‡ºå½©çš„åœ°æ–¹å°±æ˜¯åœ¨try/finallyä¸­è°ƒç”¨äº†finishedå‡½æ•°ï¼Œå¯ä»¥ä¸»åŠ¨æŽ§åˆ¶ç­‰å¾…é˜Ÿåˆ—çš„ç§»åŠ¨ï¼Œè€Œä¸æ˜¯é‡‡ç”¨é”æˆ–è€…wait/notifyï¼Œæžå¤§å‡å°‘äº†ç¼–ç å¤æ‚æ€§ OkHttpæºç åˆ†æžâ€”â€”ç¼“å­˜ç­–ç•¥ åˆç†åœ°åˆ©ç”¨æœ¬åœ°ç¼“å­˜å¯ä»¥æœ‰æ•ˆåœ°å‡å°‘ç½‘ç»œå¼€é”€ï¼Œå‡å°‘å“åº”å»¶è¿Ÿã€‚HTTPæŠ¥å¤´ä¹Ÿå®šä¹‰äº†å¾ˆå¤šä¸Žç¼“å­˜æœ‰å…³çš„åŸŸæ¥æŽ§åˆ¶ç¼“å­˜ã€‚ä»Šå¤©å°±æ¥è®²è®²OkHttpä¸­å…³äºŽç¼“å­˜éƒ¨åˆ†çš„å®žçŽ°ç»†èŠ‚ã€‚ 1. HTTPç¼“å­˜ç­–ç•¥é¦–å…ˆæ¥äº†è§£ä¸‹HTTPåè®®ä¸­ç¼“å­˜éƒ¨åˆ†çš„ç›¸å…³åŸŸã€‚ 1.1 Expiresè¶…æ—¶æ—¶é—´ï¼Œä¸€èˆ¬ç”¨åœ¨æœåŠ¡å™¨çš„responseæŠ¥å¤´ä¸­ç”¨äºŽå‘ŠçŸ¥å®¢æˆ·ç«¯å¯¹åº”èµ„æºçš„è¿‡æœŸæ—¶é—´ã€‚å½“å®¢æˆ·ç«¯éœ€è¦å†æ¬¡è¯·æ±‚ç›¸åŒèµ„æºæ—¶å…ˆæ¯”è¾ƒå…¶è¿‡æœŸæ—¶é—´ï¼Œå¦‚æžœå°šæœªè¶…è¿‡è¿‡æœŸæ—¶é—´åˆ™ç›´æŽ¥è¿”å›žç¼“å­˜ç»“æžœï¼Œå¦‚æžœå·²ç»è¶…è¿‡åˆ™é‡æ–°è¯·æ±‚ã€‚ 1.2 Cache-Controlç›¸å¯¹å€¼ï¼Œå•ä½æ—¶ç§’ï¼Œè¡¨ç¤ºå½“å‰èµ„æºçš„æœ‰æ•ˆæœŸã€‚Cache-Controlæ¯”Expiresä¼˜å…ˆçº§æ›´é«˜ï¼š 1Cache-Control:max-age=31536000,public 1.3 æ¡ä»¶GETè¯·æ±‚1.3.1 Last-Modified-Dateå®¢æˆ·ç«¯ç¬¬ä¸€æ¬¡è¯·æ±‚æ—¶ï¼ŒæœåŠ¡å™¨è¿”å›žï¼š 1Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT å½“å®¢æˆ·ç«¯äºŒæ¬¡è¯·æ±‚æ—¶ï¼Œå¯ä»¥å¤´éƒ¨åŠ ä¸Šå¦‚ä¸‹header: 1If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT å¦‚æžœå½“å‰èµ„æºæ²¡æœ‰è¢«äºŒæ¬¡ä¿®æ”¹ï¼ŒæœåŠ¡å™¨è¿”å›ž304å‘ŠçŸ¥å®¢æˆ·ç«¯ç›´æŽ¥å¤ç”¨æœ¬åœ°ç¼“å­˜ã€‚ 1.3.2 ETagETagæ˜¯å¯¹èµ„æºæ–‡ä»¶çš„ä¸€ç§æ‘˜è¦ï¼Œå¯ä»¥é€šè¿‡ETagå€¼æ¥åˆ¤æ–­æ–‡ä»¶æ˜¯å¦æœ‰ä¿®æ”¹ã€‚å½“å®¢æˆ·ç«¯ç¬¬ä¸€æ¬¡è¯·æ±‚æŸèµ„æºæ—¶ï¼ŒæœåŠ¡å™¨è¿”å›žï¼š 1ETag: &quot;5694c7ef-24dc&quot; å®¢æˆ·ç«¯å†æ¬¡è¯·æ±‚æ—¶ï¼Œå¯åœ¨å¤´éƒ¨åŠ ä¸Šå¦‚ä¸‹åŸŸï¼š 1If-None-Match: &quot;5694c7ef-24dc&quot; å¦‚æžœæ–‡ä»¶å¹¶æœªæ”¹å˜ï¼Œåˆ™æœåŠ¡å™¨è¿”å›ž304å‘ŠçŸ¥å®¢æˆ·ç«¯å¯ä»¥å¤ç”¨æœ¬åœ°ç¼“å­˜ã€‚ 1.4 no-cache/no-storeä¸ä½¿ç”¨ç¼“å­˜ 1.5 only-if-cachedåªä½¿ç”¨ç¼“å­˜ 2. Cacheæºç åˆ†æžOkHttpçš„ç¼“å­˜å·¥ä½œéƒ½æ˜¯åœ¨CacheInterceptorä¸­å®Œæˆçš„,Cacheéƒ¨åˆ†æœ‰å¦‚ä¸‹å‡ ä¸ªå…³é”®ç±»ï¼š Cacheï¼šCacheç®¡ç†å™¨ï¼Œå…¶å†…éƒ¨åŒ…å«ä¸€ä¸ªDiskLruCacheå°†cacheå†™å…¥æ–‡ä»¶ç³»ç»Ÿ: 12345678910111213141516171819202122&gt; * &lt;h3&gt;Cache Optimization&lt;/h3&gt;&gt; *&gt; * &lt;p&gt;To measure cache effectiveness, this class tracks three statistics:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #requestCount() Request Count:&#125;&lt;/strong&gt; the number of HTTP&gt; * requests issued since this cache was created.&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #networkCount() Network Count:&#125;&lt;/strong&gt; the number of those&gt; * requests that required network use.&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #hitCount() Hit Count:&#125;&lt;/strong&gt; the number of those requests&gt; * whose responses were served by the cache.&gt; * &lt;/ul&gt;&gt; *&gt; * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of&gt; * the response, the client will issue a conditional &#123;@code GET&#125;. The server will then send either&gt; * the updated response if it has changed, or a short &apos;not modified&apos; response if the client&apos;s copy&gt; * is still valid. Such responses increment both the network count and hit count.&gt; *&gt; * &lt;p&gt;The best way to improve the cache hit rate is by configuring the web server to return&gt; * cacheable responses. Although this client honors all &lt;a&gt; * href=&quot;http://tools.ietf.org/html/rfc7234&quot;&gt;HTTP/1.1 (RFC 7234)&lt;/a&gt; cache headers, it doesn&apos;t cache&gt; * partial responses.&gt; &gt; Cacheå†…éƒ¨é€šè¿‡requestCount,networkCount,hitCountä¸‰ä¸ªç»Ÿè®¡æŒ‡æ ‡æ¥ä¼˜åŒ–ç¼“å­˜æ•ˆçŽ‡ CacheStrategyï¼šç¼“å­˜ç­–ç•¥ã€‚å…¶å†…éƒ¨ç»´æŠ¤ä¸€ä¸ªrequestå’Œresponseï¼Œé€šè¿‡æŒ‡å®šrequestå’Œresponseæ¥æè¿°æ˜¯é€šè¿‡ç½‘ç»œè¿˜æ˜¯ç¼“å­˜èŽ·å–responseï¼ŒæŠ‘æˆ–äºŒè€…åŒæ—¶ä½¿ç”¨ 123456789101112131415161718&gt; [CacheStrategy.java]&gt; /**&gt; * Given a request and cached response, this figures out whether to use the network, the cache, or&gt; * both.&gt; *&gt; * &lt;p&gt;Selecting a cache strategy may add conditions to the request (like the &quot;If-Modified-Since&quot;&gt; * header for conditional GETs) or warnings to the cached response (if the cached data is&gt; * potentially stale).&gt; */&gt; public final class CacheStrategy &#123;&gt; /** The request to send on the network, or null if this call doesn&apos;t use the network. */&gt; public final Request networkRequest;&gt;&gt; /** The cached response to return or validate; or null if this call doesn&apos;t use a cache. */&gt; public final Response cacheResponse;&gt; ......&gt; &#125;&gt; CacheStrategy$Factory:ç¼“å­˜ç­–ç•¥å·¥åŽ‚ç±»æ ¹æ®å®žé™…è¯·æ±‚è¿”å›žå¯¹åº”çš„ç¼“å­˜ç­–ç•¥ æ—¢ç„¶å®žé™…çš„ç¼“å­˜å·¥ä½œéƒ½æ˜¯åœ¨CacheInterceptorä¸­å®Œæˆçš„ï¼Œé‚£ä¹ˆæŽ¥ä¸‹æ¥çœ‹ä¸‹CahceInterceptorçš„æ ¸å¿ƒæ–¹æ³•interceptæ–¹æ³•æºç : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101[CacheInterceptor.java]@Override public Response intercept(Chain chain) throws IOException &#123; //é¦–å…ˆå°è¯•èŽ·å–ç¼“å­˜ Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //èŽ·å–ç¼“å­˜ç­–ç•¥ CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; //å¦‚æžœæœ‰ç¼“å­˜ï¼Œæ›´æ–°ä¸‹ç›¸å…³ç»Ÿè®¡æŒ‡æ ‡ï¼šå‘½ä¸­çŽ‡ if (cache != null) &#123; cache.trackResponse(strategy); &#125; //å¦‚æžœå½“å‰ç¼“å­˜ä¸ç¬¦åˆè¦æ±‚ï¼Œå°†å…¶close if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // å¦‚æžœä¸èƒ½ä½¿ç”¨ç½‘ç»œï¼ŒåŒæ—¶åˆæ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„ç¼“å­˜ï¼Œç›´æŽ¥æŠ›504é”™è¯¯ if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // å¦‚æžœæœ‰ç¼“å­˜åŒæ—¶åˆä¸ä½¿ç”¨ç½‘ç»œï¼Œåˆ™ç›´æŽ¥è¿”å›žç¼“å­˜ç»“æžœ if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; //å°è¯•é€šè¿‡ç½‘ç»œèŽ·å–å›žå¤ Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // å¦‚æžœæ—¢æœ‰ç¼“å­˜ï¼ŒåŒæ—¶åˆå‘èµ·äº†è¯·æ±‚ï¼Œè¯´æ˜Žæ­¤æ—¶æ˜¯ä¸€ä¸ªConditional Getè¯·æ±‚ if (cacheResponse != null) &#123; // å¦‚æžœæœåŠ¡ç«¯è¿”å›žçš„æ˜¯NOT_MODIFIED,ç¼“å­˜æœ‰æ•ˆï¼Œå°†æœ¬åœ°ç¼“å­˜å’Œç½‘ç»œå“åº”åšåˆå¹¶ if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123;// å¦‚æžœå“åº”èµ„æºæœ‰æ›´æ–°ï¼Œå…³æŽ‰åŽŸæœ‰ç¼“å­˜ closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // å°†ç½‘ç»œå“åº”å†™å…¥cacheä¸­ CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; æ ¸å¿ƒé€»è¾‘éƒ½ä»¥ä¸­æ–‡æ³¨é‡Šçš„å½¢å¼åœ¨ä»£ç ä¸­æ ‡æ³¨å‡ºæ¥äº†ï¼Œå¤§å®¶çœ‹ä»£ç å³å¯ã€‚é€šè¿‡ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼Œå‡ ä¹Žæ‰€æœ‰çš„åŠ¨ä½œéƒ½æ˜¯ä»¥CacheStrategyç¼“å­˜ç­–ç•¥ä¸ºä¾æ®åšå‡ºçš„ï¼Œé‚£ä¹ˆæŽ¥ä¸‹æ¥çœ‹ä¸‹ç¼“å­˜ç­–ç•¥æ˜¯å¦‚ä½•ç”Ÿæˆçš„ï¼Œç›¸å…³ä»£ç å®žçŽ°åœ¨CacheStrategy$Factory.get()æ–¹æ³•ä¸­ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[CacheStrategy$Factory] /** * Returns a strategy to satisfy &#123;@code request&#125; using the a cached response &#123;@code response&#125;. */ public CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) &#123; // We're forbidden from using the network and the cache is insufficient. return new CacheStrategy(null, null); &#125; return candidate; &#125; /** Returns a strategy to use assuming the request can use the network. */ private CacheStrategy getCandidate() &#123; // è‹¥æœ¬åœ°æ²¡æœ‰ç¼“å­˜ï¼Œå‘èµ·ç½‘ç»œè¯·æ±‚ if (cacheResponse == null) &#123; return new CacheStrategy(request, null); &#125; // å¦‚æžœå½“å‰è¯·æ±‚æ˜¯HTTPSï¼Œè€Œç¼“å­˜æ²¡æœ‰TLSæ¡æ‰‹ï¼Œé‡æ–°å‘èµ·ç½‘ç»œè¯·æ±‚ if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123; return new CacheStrategy(request, null); &#125; // If this response shouldn't have been stored, it should never be used // as a response source. This check should be redundant as long as the // persistence store is well-behaved and the rules are constant. if (!isCacheable(cacheResponse, request)) &#123; return new CacheStrategy(request, null); &#125; //å¦‚æžœå½“å‰çš„ç¼“å­˜ç­–ç•¥æ˜¯ä¸ç¼“å­˜æˆ–è€…æ˜¯conditional getï¼Œå‘èµ·ç½‘ç»œè¯·æ±‚ CacheControl requestCaching = request.cacheControl(); if (requestCaching.noCache() || hasConditions(request)) &#123; return new CacheStrategy(request, null); &#125; //ageMillis:ç¼“å­˜age long ageMillis = cacheResponseAge(); //freshMillisï¼šç¼“å­˜ä¿é²œæ—¶é—´ long freshMillis = computeFreshnessLifetime(); if (requestCaching.maxAgeSeconds() != -1) &#123; freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds())); &#125; long minFreshMillis = 0; if (requestCaching.minFreshSeconds() != -1) &#123; minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds()); &#125; long maxStaleMillis = 0; CacheControl responseCaching = cacheResponse.cacheControl(); if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123; maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds()); &#125; //å¦‚æžœ age + min-fresh &gt;= max-age &amp;&amp; age + min-fresh &lt; max-age + max-staleï¼Œåˆ™è™½ç„¶ç¼“å­˜è¿‡æœŸäº†ï¼Œ //ä½†æ˜¯ç¼“å­˜ç»§ç»­å¯ä»¥ä½¿ç”¨ï¼Œåªæ˜¯åœ¨å¤´éƒ¨æ·»åŠ  110 è­¦å‘Šç  if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123; Response.Builder builder = cacheResponse.newBuilder(); if (ageMillis + minFreshMillis &gt;= freshMillis) &#123; builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\""); &#125; long oneDayMillis = 24 * 60 * 60 * 1000L; if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123; builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\""); &#125; return new CacheStrategy(null, builder.build()); &#125; // å‘èµ·conditional getè¯·æ±‚ String conditionName; String conditionValue; if (etag != null) &#123; conditionName = "If-None-Match"; conditionValue = etag; &#125; else if (lastModified != null) &#123; conditionName = "If-Modified-Since"; conditionValue = lastModifiedString; &#125; else if (servedDate != null) &#123; conditionName = "If-Modified-Since"; conditionValue = servedDateString; &#125; else &#123; return new CacheStrategy(request, null); // No condition! Make a regular request. &#125; Headers.Builder conditionalRequestHeaders = request.headers().newBuilder(); Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue); Request conditionalRequest = request.newBuilder() .headers(conditionalRequestHeaders.build()) .build(); return new CacheStrategy(conditionalRequest, cacheResponse); &#125; å¯ä»¥çœ‹åˆ°å…¶æ ¸å¿ƒé€»è¾‘åœ¨getCandidateå‡½æ•°ä¸­ã€‚åŸºæœ¬å°±æ˜¯HTTPç¼“å­˜åè®®çš„å®žçŽ°ï¼Œæ ¸å¿ƒä»£ç é€»è¾‘å·²é€šè¿‡ä¸­æ–‡æ³¨é‡Šè¯´æ˜Žï¼Œå¤§å®¶ç›´æŽ¥çœ‹ä»£ç å°±å¥½ã€‚ 3. DiskLruCacheCacheå†…éƒ¨é€šè¿‡DiskLruCacheç®¡ç†cacheåœ¨æ–‡ä»¶ç³»ç»Ÿå±‚é¢çš„åˆ›å»ºï¼Œè¯»å–ï¼Œæ¸…ç†ç­‰ç­‰å·¥ä½œï¼ŒæŽ¥ä¸‹æ¥çœ‹ä¸‹DiskLruCacheçš„ä¸»è¦é€»è¾‘ï¼š 123456789101112131415161718192021222324252627282930313233343536public final class DiskLruCache implements Closeable, Flushable &#123; final FileSystem fileSystem; final File directory; private final File journalFile; private final File journalFileTmp; private final File journalFileBackup; private final int appVersion; private long maxSize; final int valueCount; private long size = 0; BufferedSink journalWriter; final LinkedHashMap&lt;String, Entry&gt; lruEntries = new LinkedHashMap&lt;&gt;(0, 0.75f, true); // Must be read and written when synchronized on 'this'. boolean initialized; boolean closed; boolean mostRecentTrimFailed; boolean mostRecentRebuildFailed; /** * To differentiate between old and current snapshots, each entry is given a sequence number each * time an edit is committed. A snapshot is stale if its sequence number is not equal to its * entry's sequence number. */ private long nextSequenceNumber = 0; /** Used to run 'cleanupRunnable' for journal rebuilds. */ private final Executor executor; private final Runnable cleanupRunnable = new Runnable() &#123; public void run() &#123; ...... &#125; &#125;; ... &#125; 3.1 journalFileDiskLruCacheå†…éƒ¨æ—¥å¿—æ–‡ä»¶ï¼Œå¯¹cacheçš„æ¯ä¸€æ¬¡è¯»å†™éƒ½å¯¹åº”ä¸€æ¡æ—¥å¿—è®°å½•ï¼ŒDiskLruCacheé€šè¿‡åˆ†æžæ—¥å¿—åˆ†æžå’Œåˆ›å»ºcacheã€‚æ—¥å¿—æ–‡ä»¶æ ¼å¼å¦‚ä¸‹ï¼š 123456789101112131415161718192021 libcore.io.DiskLruCache 1 100 2 CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c4c6028171cfddfbaae1a9c313c52 CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342 REMOVE 335c4c6028171cfddfbaae1a9c313c52 DIRTY 1ab96a171faeeee38496d8b330771a7a CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234 READ 335c4c6028171cfddfbaae1a9c313c52 READ 3400330d1dfc7f3f7f4b8d4d803dfcf6å‰5è¡Œå›ºå®šä¸å˜ï¼Œåˆ†åˆ«ä¸ºï¼šå¸¸é‡ï¼šlibcore.io.DiskLruCacheï¼›diskCacheç‰ˆæœ¬ï¼›åº”ç”¨ç¨‹åºç‰ˆæœ¬ï¼›valueCount(åŽæ–‡ä»‹ç»)ï¼Œç©ºè¡ŒæŽ¥ä¸‹æ¥æ¯ä¸€è¡Œå¯¹åº”ä¸€ä¸ªcache entryçš„ä¸€æ¬¡çŠ¶æ€è®°å½•ï¼Œå…¶æ ¼å¼ä¸ºï¼š[çŠ¶æ€ï¼ˆDIRTY,CLEAN,READ,REMOVEï¼‰ï¼Œkeyï¼ŒçŠ¶æ€ç›¸å…³value(å¯é€‰)]:- DIRTY:è¡¨æ˜Žä¸€ä¸ªcache entryæ­£åœ¨è¢«åˆ›å»ºæˆ–æ›´æ–°ï¼Œæ¯ä¸€ä¸ªæˆåŠŸçš„DIRTYè®°å½•éƒ½åº”è¯¥å¯¹åº”ä¸€ä¸ªCLEANæˆ–REMOVEæ“ä½œã€‚å¦‚æžœä¸€ä¸ªDIRTYç¼ºå°‘é¢„æœŸåŒ¹é…çš„CLEAN/REMOVEï¼Œåˆ™å¯¹åº”entryæ“ä½œå¤±è´¥ï¼Œéœ€è¦å°†å…¶ä»ŽlruEntriesä¸­åˆ é™¤- CLEAN:è¯´æ˜Žcacheå·²ç»è¢«æˆåŠŸæ“ä½œï¼Œå½“å‰å¯ä»¥è¢«æ­£å¸¸è¯»å–ã€‚æ¯ä¸€ä¸ªCLEANè¡Œè¿˜éœ€è¦è®°å½•å…¶æ¯ä¸€ä¸ªvalueçš„é•¿åº¦- READ: è®°å½•ä¸€æ¬¡cacheè¯»å–æ“ä½œ- REMOVE:è®°å½•ä¸€æ¬¡cacheæ¸…é™¤ æ—¥å¿—æ–‡ä»¶çš„åº”ç”¨åœºæ™¯ä¸»è¦æœ‰å››ä¸ªï¼š DiskCacheLruåˆå§‹åŒ–æ—¶é€šè¿‡è¯»å–æ—¥å¿—æ–‡ä»¶åˆ›å»ºcacheå®¹å™¨ï¼šlruEntriesã€‚åŒæ—¶é€šè¿‡æ—¥å¿—è¿‡æ»¤æ“ä½œä¸æˆåŠŸçš„cacheé¡¹ã€‚ç›¸å…³é€»è¾‘åœ¨DiskLruCache.readJournalLine,DiskLruCache.processJournal åˆå§‹åŒ–å®ŒæˆåŽï¼Œä¸ºé¿å…æ—¥å¿—æ–‡ä»¶ä¸æ–­è†¨èƒ€ï¼Œå¯¹æ—¥å¿—è¿›è¡Œé‡å»ºç²¾ç®€ï¼Œå…·ä½“é€»è¾‘åœ¨DiskLruCache.rebuildJournal æ¯å½“æœ‰cacheæ“ä½œæ—¶å°†å…¶è®°å½•å…¥æ—¥å¿—æ–‡ä»¶ä¸­ä»¥å¤‡ä¸‹æ¬¡åˆå§‹åŒ–æ—¶ä½¿ç”¨ å½“å†—ä½™æ—¥å¿—è¿‡å¤šæ—¶ï¼Œé€šè¿‡è°ƒç”¨cleanUpRunnableçº¿ç¨‹é‡å»ºæ—¥å¿— 3.2 DiskLruCache.Entryæ¯ä¸€ä¸ªDiskLruCache.Entryå¯¹åº”ä¸€ä¸ªcacheè®°å½•ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private final class Entry &#123; final String key; /** Lengths of this entry's files. */ final long[] lengths; final File[] cleanFiles; final File[] dirtyFiles; /** True if this entry has ever been published. */ boolean readable; /** The ongoing edit or null if this entry is not being edited. */ Editor currentEditor; /** The sequence number of the most recently committed edit to this entry. */ long sequenceNumber; Entry(String key) &#123; this.key = key; lengths = new long[valueCount]; cleanFiles = new File[valueCount]; dirtyFiles = new File[valueCount]; // The names are repetitive so re-use the same builder to avoid allocations. StringBuilder fileBuilder = new StringBuilder(key).append('.'); int truncateTo = fileBuilder.length(); for (int i = 0; i &lt; valueCount; i++) &#123; fileBuilder.append(i); cleanFiles[i] = new File(directory, fileBuilder.toString()); fileBuilder.append(".tmp"); dirtyFiles[i] = new File(directory, fileBuilder.toString()); fileBuilder.setLength(truncateTo); &#125; &#125; ... /** * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a * single published snapshot. If we opened streams lazily then the streams could come from * different edits. */ Snapshot snapshot() &#123; if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError(); Source[] sources = new Source[valueCount]; long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out. try &#123; for (int i = 0; i &lt; valueCount; i++) &#123; sources[i] = fileSystem.source(cleanFiles[i]); &#125; return new Snapshot(key, sequenceNumber, sources, lengths); &#125; catch (FileNotFoundException e) &#123; // A file must have been deleted manually! for (int i = 0; i &lt; valueCount; i++) &#123; if (sources[i] != null) &#123; Util.closeQuietly(sources[i]); &#125; else &#123; break; &#125; &#125; // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache // size.) try &#123; removeEntry(this); &#125; catch (IOException ignored) &#123; &#125; return null; &#125; &#125;&#125; ä¸€ä¸ªEntryä¸»è¦ç”±ä»¥ä¸‹å‡ éƒ¨åˆ†æž„æˆï¼š keyï¼šæ¯ä¸ªcacheéƒ½æœ‰ä¸€ä¸ªkeyä½œä¸ºå…¶æ ‡è¯†ç¬¦ã€‚å½“å‰cacheçš„keyä¸ºå…¶å¯¹åº”URLçš„MD5å­—ç¬¦ä¸² cleanFiles/dirtyFilesï¼šæ¯ä¸€ä¸ªEntryå¯¹åº”å¤šä¸ªæ–‡ä»¶ï¼Œå…¶å¯¹åº”çš„æ–‡ä»¶æ•°ç”±DiskLruCache.valueCountæŒ‡å®šã€‚å½“å‰åœ¨OkHttpä¸­valueCountä¸º2ã€‚å³æ¯ä¸ªcacheå¯¹åº”2ä¸ªcleanFilesï¼Œ2ä¸ªdirtyFilesã€‚å…¶ä¸­ç¬¬ä¸€ä¸ªcleanFiles/dirtyFilesè®°å½•cacheçš„metaæ•°æ®ï¼ˆå¦‚URL,åˆ›å»ºæ—¶é—´ï¼ŒSSLæ¡æ‰‹è®°å½•ç­‰ç­‰ï¼‰ï¼Œç¬¬äºŒä¸ªæ–‡ä»¶è®°å½•cacheçš„çœŸæ­£å†…å®¹ã€‚cleanFilesè®°å½•å¤„äºŽç¨³å®šçŠ¶æ€çš„cacheç»“æžœï¼ŒdirtyFilesè®°å½•å¤„äºŽåˆ›å»ºæˆ–æ›´æ–°çŠ¶æ€çš„cache currentEditorï¼šentryç¼–è¾‘å™¨ï¼Œå¯¹entryçš„æ‰€æœ‰æ“ä½œéƒ½æ˜¯é€šè¿‡å…¶ç¼–è¾‘å™¨å®Œæˆã€‚ç¼–è¾‘å™¨å†…éƒ¨æ·»åŠ äº†åŒæ­¥é” 3.3 cleanupRunnableæ¸…ç†çº¿ç¨‹ï¼Œç”¨äºŽé‡å»ºç²¾ç®€æ—¥å¿—ï¼š 12345678910111213141516171819202122232425private final Runnable cleanupRunnable = new Runnable() &#123; public void run() &#123; synchronized (DiskLruCache.this) &#123; if (!initialized | closed) &#123; return; // Nothing to do &#125; try &#123; trimToSize(); &#125; catch (IOException ignored) &#123; mostRecentTrimFailed = true; &#125; try &#123; if (journalRebuildRequired()) &#123; rebuildJournal(); redundantOpCount = 0; &#125; &#125; catch (IOException e) &#123; mostRecentRebuildFailed = true; journalWriter = Okio.buffer(Okio.blackhole()); &#125; &#125; &#125;&#125;; å…¶è§¦å‘æ¡ä»¶åœ¨journalRebuildRequired()æ–¹æ³•ä¸­ï¼š 123456789/** * We only rebuild the journal when it will halve the size of the journal and eliminate at least * 2000 ops. */boolean journalRebuildRequired() &#123; final int redundantOpCompactThreshold = 2000; return redundantOpCount &gt;= redundantOpCompactThreshold &amp;&amp; redundantOpCount &gt;= lruEntries.size();&#125; å½“å†—ä½™æ—¥å¿—è¶…è¿‡æ—¥å¿—æ–‡ä»¶æœ¬èº«çš„ä¸€èˆ¬ä¸”æ€»æ¡æ•°è¶…è¿‡2000æ—¶æ‰§è¡Œ 3.4 SnapShotcacheå¿«ç…§ï¼Œè®°å½•äº†ç‰¹å®šcacheåœ¨æŸä¸€ä¸ªç‰¹å®šæ—¶åˆ»çš„å†…å®¹ã€‚æ¯æ¬¡å‘DiskLruCacheè¯·æ±‚æ—¶è¿”å›žçš„éƒ½æ˜¯ç›®æ ‡cacheçš„ä¸€ä¸ªå¿«ç…§,ç›¸å…³é€»è¾‘åœ¨DiskLruCache.getä¸­ï¼š 12345678910111213141516171819202122232425[DiskLruCache.java] /** * Returns a snapshot of the entry named &#123;@code key&#125;, or null if it doesn't exist is not currently * readable. If a value is returned, it is moved to the head of the LRU queue. */ public synchronized Snapshot get(String key) throws IOException &#123; initialize(); checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (entry == null || !entry.readable) return null; Snapshot snapshot = entry.snapshot(); if (snapshot == null) return null; redundantOpCount++; //æ—¥å¿—è®°å½• journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n'); if (journalRebuildRequired()) &#123; executor.execute(cleanupRunnable); &#125; return snapshot; &#125; 3.5 lruEntriesç®¡ç†cache entryçš„å®¹å™¨ï¼Œå…¶æ•°æ®ç»“æž„æ˜¯LinkedHashMapã€‚é€šè¿‡LinkedHashMapæœ¬èº«çš„å®žçŽ°é€»è¾‘è¾¾åˆ°cacheçš„LRUæ›¿æ¢ 3.6 FileSystemä½¿ç”¨Okioå¯¹Fileçš„å°è£…ï¼Œç®€åŒ–äº†I/Oæ“ä½œã€‚ 3.7 DiskLruCache.editDiskLruCacheå¯ä»¥çœ‹æˆæ˜¯Cacheåœ¨æ–‡ä»¶ç³»ç»Ÿå±‚çš„å…·ä½“å®žçŽ°ï¼Œæ‰€ä»¥å…¶åŸºæœ¬æ“ä½œæŽ¥å£å­˜åœ¨ä¸€ä¸€å¯¹åº”çš„å…³ç³»ï¼š Cache.get() â€”&gt;DiskLruCache.get() Cache.put()â€”&gt;DiskLruCache.edit() //cacheæ’å…¥ Cache.remove()â€”&gt;DiskLruCache.remove() Cache.update()â€”&gt;DiskLruCache.edit()//cacheæ›´æ–° å…¶ä¸­getæ“ä½œåœ¨3.4å·²ç»ä»‹ç»äº†ï¼Œremoveæ“ä½œè¾ƒä¸ºç®€å•ï¼Œputå’Œupdateå¤§è‡´é€»è¾‘ç›¸ä¼¼ï¼Œå› ä¸ºç¯‡å¹…é™åˆ¶ï¼Œè¿™é‡Œä»…ä»‹ç»Cache.putæ“ä½œçš„é€»è¾‘ï¼Œå…¶ä»–çš„æ“ä½œå¤§å®¶çœ‹ä»£ç å°±å¥½: 12345678910111213141516171819202122232425262728293031323334353637[okhttp3.Cache.java] CacheRequest put(Response response) &#123; String requestMethod = response.request().method(); if (HttpMethod.invalidatesCache(response.request().method())) &#123; try &#123; remove(response.request()); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; return null; &#125; if (!requestMethod.equals("GET")) &#123; // Don't cache non-GET responses. We're technically allowed to cache // HEAD requests and some POST requests, but the complexity of doing // so is high and the benefit is low. return null; &#125; if (HttpHeaders.hasVaryAll(response)) &#123; return null; &#125; Entry entry = new Entry(response); DiskLruCache.Editor editor = null; try &#123; editor = cache.edit(key(response.request().url())); if (editor == null) &#123; return null; &#125; entry.writeTo(editor); return new CacheRequestImpl(editor); &#125; catch (IOException e) &#123; abortQuietly(editor); return null; &#125; &#125; å¯ä»¥çœ‹åˆ°æ ¸å¿ƒé€»è¾‘åœ¨editor = cache.edit(key(response.request().url()));,ç›¸å…³ä»£ç åœ¨DiskLruCache.edit: 12345678910111213141516171819202122232425262728293031323334353637383940[okhttp3.internal.cache.DiskLruCache.java] synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; initialize(); checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // Snapshot is stale. &#125; if (entry != null &amp;&amp; entry.currentEditor != null) &#123; return null; // å½“å‰cache entryæ­£åœ¨è¢«å…¶ä»–å¯¹è±¡æ“ä½œ &#125; if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123; // The OS has become our enemy! If the trim job failed, it means we are storing more data than // requested by the user. Do not allow edits so we do not go over that limit any further. If // the journal rebuild failed, the journal writer will not be active, meaning we will not be // able to record the edit, causing file leaks. In both cases, we want to retry the clean up // so we can get out of this state! executor.execute(cleanupRunnable); return null; &#125; // æ—¥å¿—æŽ¥å…¥DIRTYè®°å½• journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n'); journalWriter.flush(); if (hasJournalErrors) &#123; return null; // Don't edit; the journal can't be written. &#125; if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; return editor; &#125; editæ–¹æ³•è¿”å›žå¯¹åº”CacheEntryçš„editorç¼–è¾‘å™¨ã€‚æŽ¥ä¸‹æ¥å†æ¥çœ‹ä¸‹Cache.put()æ–¹æ³•çš„entry.writeTo(editor);,å…¶ç›¸å…³é€»è¾‘ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[okhttp3.internal.cache.DiskLruCache.java] public void writeTo(DiskLruCache.Editor editor) throws IOException &#123; BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA)); sink.writeUtf8(url) .writeByte('\n'); sink.writeUtf8(requestMethod) .writeByte('\n'); sink.writeDecimalLong(varyHeaders.size()) .writeByte('\n'); for (int i = 0, size = varyHeaders.size(); i &lt; size; i++) &#123; sink.writeUtf8(varyHeaders.name(i)) .writeUtf8(": ") .writeUtf8(varyHeaders.value(i)) .writeByte('\n'); &#125; sink.writeUtf8(new StatusLine(protocol, code, message).toString()) .writeByte('\n'); sink.writeDecimalLong(responseHeaders.size() + 2) .writeByte('\n'); for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123; sink.writeUtf8(responseHeaders.name(i)) .writeUtf8(": ") .writeUtf8(responseHeaders.value(i)) .writeByte('\n'); &#125; sink.writeUtf8(SENT_MILLIS) .writeUtf8(": ") .writeDecimalLong(sentRequestMillis) .writeByte('\n'); sink.writeUtf8(RECEIVED_MILLIS) .writeUtf8(": ") .writeDecimalLong(receivedResponseMillis) .writeByte('\n'); if (isHttps()) &#123; sink.writeByte('\n'); sink.writeUtf8(handshake.cipherSuite().javaName()) .writeByte('\n'); writeCertList(sink, handshake.peerCertificates()); writeCertList(sink, handshake.localCertificates()); // The handshakeâ€™s TLS version is null on HttpsURLConnection and on older cached responses. if (handshake.tlsVersion() != null) &#123; sink.writeUtf8(handshake.tlsVersion().javaName()) .writeByte('\n'); &#125; &#125; sink.close(); &#125; å…¶ä¸»è¦é€»è¾‘å°±æ˜¯å°†å¯¹åº”è¯·æ±‚çš„metaæ•°æ®å†™å…¥å¯¹åº”CacheEntryçš„ç´¢å¼•ä¸ºENTRY_METADATAï¼ˆ0ï¼‰çš„dirtyfileä¸­ã€‚ æœ€åŽå†æ¥çœ‹Cache.put()æ–¹æ³•çš„return new CacheRequestImpl(editor);: 1234567891011121314151617181920212223242526272829303132333435363738394041424344[okhttp3.Cache$CacheRequestImpl]private final class CacheRequestImpl implements CacheRequest &#123; private final DiskLruCache.Editor editor; private Sink cacheOut; private Sink body; boolean done; public CacheRequestImpl(final DiskLruCache.Editor editor) &#123; this.editor = editor; this.cacheOut = editor.newSink(ENTRY_BODY); this.body = new ForwardingSink(cacheOut) &#123; @Override public void close() throws IOException &#123; synchronized (Cache.this) &#123; if (done) &#123; return; &#125; done = true; writeSuccessCount++; &#125; super.close(); editor.commit(); &#125; &#125;; &#125; @Override public void abort() &#123; synchronized (Cache.this) &#123; if (done) &#123; return; &#125; done = true; writeAbortCount++; &#125; Util.closeQuietly(cacheOut); try &#123; editor.abort(); &#125; catch (IOException ignored) &#123; &#125; &#125; @Override public Sink body() &#123; return body; &#125; &#125; å…¶ä¸­close,abortæ–¹æ³•ä¼šè°ƒç”¨editor.abortå’Œeditor.commitæ¥æ›´æ–°æ—¥å¿—ï¼Œeditor.commitè¿˜ä¼šå°†dirtyFileé‡ç½®ä¸ºcleanFileä½œä¸ºç¨³å®šå¯ç”¨çš„ç¼“å­˜ï¼Œç›¸å…³é€»è¾‘åœ¨okhttp3.internal.cache.DiskLruCache$Editor.completeEditä¸­: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[okhttp3.internal.cache.DiskLruCache$Editor.completeEdit] synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; if (entry.currentEditor != editor) &#123; throw new IllegalStateException(); &#125; // If this edit is creating the entry for the first time, every index must have a value. if (success &amp;&amp; !entry.readable) &#123; for (int i = 0; i &lt; valueCount; i++) &#123; if (!editor.written[i]) &#123; editor.abort(); throw new IllegalStateException("Newly created entry didn't create value for index " + i); &#125; if (!fileSystem.exists(entry.dirtyFiles[i])) &#123; editor.abort(); return; &#125; &#125; &#125; for (int i = 0; i &lt; valueCount; i++) &#123; File dirty = entry.dirtyFiles[i]; if (success) &#123; if (fileSystem.exists(dirty)) &#123; File clean = entry.cleanFiles[i]; fileSystem.rename(dirty, clean);//å°†dirtyfileç½®ä¸ºcleanfile long oldLength = entry.lengths[i]; long newLength = fileSystem.size(clean); entry.lengths[i] = newLength; size = size - oldLength + newLength; &#125; &#125; else &#123; fileSystem.delete(dirty);//è‹¥å¤±è´¥åˆ™åˆ é™¤dirtyfile &#125; &#125; redundantOpCount++; entry.currentEditor = null; //æ›´æ–°æ—¥å¿— if (entry.readable | success) &#123; entry.readable = true; journalWriter.writeUtf8(CLEAN).writeByte(' '); journalWriter.writeUtf8(entry.key); entry.writeLengths(journalWriter); journalWriter.writeByte('\n'); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; lruEntries.remove(entry.key); journalWriter.writeUtf8(REMOVE).writeByte(' '); journalWriter.writeUtf8(entry.key); journalWriter.writeByte('\n'); &#125; journalWriter.flush(); if (size &gt; maxSize || journalRebuildRequired()) &#123; executor.execute(cleanupRunnable); &#125; &#125; CacheRequestImplå®žçŽ°CacheRequestæŽ¥å£ï¼Œå‘å¤–éƒ¨ç±»(ä¸»è¦æ˜¯CacheInterceptor)é€å‡ºï¼Œå¤–éƒ¨å¯¹è±¡é€šè¿‡CacheRequestImplæ›´æ–°æˆ–å†™å…¥ç¼“å­˜æ•°æ®ã€‚ 3.8æ€»ç»“æ€»ç»“èµ·æ¥DiskLruCacheä¸»è¦æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š é€šè¿‡LinkedHashMapå®žçŽ°LRUæ›¿æ¢ é€šè¿‡æœ¬åœ°ç»´æŠ¤Cacheæ“ä½œæ—¥å¿—ä¿è¯CacheåŽŸå­æ€§ä¸Žå¯ç”¨æ€§ï¼ŒåŒæ—¶ä¸ºé˜²æ­¢æ—¥å¿—è¿‡åˆ†è†¨èƒ€å®šæ—¶æ‰§è¡Œæ—¥å¿—ç²¾ç®€ æ¯ä¸€ä¸ªCacheé¡¹å¯¹åº”ä¸¤ä¸ªçŠ¶æ€å‰¯æœ¬ï¼šDIRTY,CLEANã€‚CLEANè¡¨ç¤ºå½“å‰å¯ç”¨çŠ¶æ€Cacheï¼Œå¤–éƒ¨è®¿é—®åˆ°çš„cacheå¿«ç…§å‡ä¸ºCLEANçŠ¶æ€ï¼›DIRTYä¸ºæ›´æ–°æ€Cacheã€‚ç”±äºŽæ›´æ–°å’Œåˆ›å»ºéƒ½åªæ“ä½œDIRTYçŠ¶æ€å‰¯æœ¬ï¼Œå®žçŽ°äº†Cacheçš„è¯»å†™åˆ†ç¦» æ¯ä¸€ä¸ªCacheé¡¹æœ‰å››ä¸ªæ–‡ä»¶ï¼Œä¸¤ä¸ªçŠ¶æ€ï¼ˆDIRTY,CLEANï¼‰,æ¯ä¸ªçŠ¶æ€å¯¹åº”ä¸¤ä¸ªæ–‡ä»¶ï¼šä¸€ä¸ªæ–‡ä»¶å­˜å‚¨Cache metaæ•°æ®ï¼Œä¸€ä¸ªæ–‡ä»¶å­˜å‚¨Cacheå†…å®¹æ•°æ® OkHttpæºç åˆ†æžâ€”â€”å¤šè·¯å¤ç”¨ æŽ¥ä¸‹æ¥è®²ä¸‹OkHttpçš„è¿žæŽ¥æ± ç®¡ç†ï¼Œè¿™ä¹Ÿæ˜¯OkHttpçš„æ ¸å¿ƒéƒ¨åˆ†ã€‚é€šè¿‡ç»´æŠ¤è¿žæŽ¥æ± ï¼Œæœ€å¤§é™åº¦é‡ç”¨çŽ°æœ‰è¿žæŽ¥ï¼Œå‡å°‘ç½‘ç»œè¿žæŽ¥çš„åˆ›å»ºå¼€é”€ï¼Œä»¥æ­¤æå‡ç½‘ç»œè¯·æ±‚æ•ˆçŽ‡ã€‚ 1. èƒŒæ™¯1.1 keep-aliveæœºåˆ¶åœ¨HTTP1.0ä¸­HTTPçš„è¯·æ±‚æµç¨‹å¦‚ä¸‹ï¼š è¿™ç§æ–¹æ³•çš„å¥½å¤„æ˜¯ç®€å•ï¼Œå„ä¸ªè¯·æ±‚äº’ä¸å¹²æ‰°ã€‚ä½†åœ¨å¤æ‚çš„ç½‘ç»œè¯·æ±‚åœºæ™¯ä¸‹è¿™ç§æ–¹å¼å‡ ä¹Žä¸å¯ç”¨ã€‚ä¾‹å¦‚ï¼šæµè§ˆå™¨åŠ è½½ä¸€ä¸ªHTMLç½‘é¡µï¼ŒHTMLä¸­å¯èƒ½éœ€è¦åŠ è½½æ•°åä¸ªèµ„æºï¼Œå…¸åž‹åœºæ™¯ä¸‹è¿™äº›èµ„æºä¸­å¤§éƒ¨åˆ†æ¥è‡ªåŒä¸€ä¸ªç«™ç‚¹ã€‚æŒ‰ç…§HTTP1.0çš„åšæ³•ï¼Œè¿™éœ€è¦å»ºç«‹æ•°åä¸ªTCPè¿žæŽ¥ï¼Œæ¯ä¸ªè¿žæŽ¥è´Ÿè´£ä¸€ä¸ªèµ„æºè¯·æ±‚ã€‚åˆ›å»ºä¸€ä¸ªTCPè¿žæŽ¥éœ€è¦3æ¬¡æ¡æ‰‹ï¼Œè€Œé‡Šæ”¾è¿žæŽ¥åˆ™éœ€è¦2æ¬¡æˆ–4æ¬¡æ¡æ‰‹ã€‚é‡å¤çš„åˆ›å»ºå’Œé‡Šæ”¾è¿žæŽ¥æžå¤§åœ°å½±å“äº†ç½‘ç»œæ•ˆçŽ‡ï¼ŒåŒæ—¶ä¹Ÿå¢žåŠ äº†ç³»ç»Ÿå¼€é”€ã€‚ ä¸ºäº†æœ‰æ•ˆåœ°è§£å†³è¿™ä¸€é—®é¢˜ï¼ŒHTTP/1.1æå‡ºäº†Keep-Aliveæœºåˆ¶ï¼šå½“ä¸€ä¸ªHTTPè¯·æ±‚çš„æ•°æ®ä¼ è¾“ç»“æŸåŽï¼ŒTCPè¿žæŽ¥ä¸ç«‹å³é‡Šæ”¾ï¼Œå¦‚æžœæ­¤æ—¶æœ‰æ–°çš„HTTPè¯·æ±‚ï¼Œä¸”å…¶è¯·æ±‚çš„Hosté€šä¸Šæ¬¡è¯·æ±‚ç›¸åŒï¼Œåˆ™å¯ä»¥ç›´æŽ¥å¤ç”¨ä¸ºé‡Šæ”¾çš„TCPè¿žæŽ¥ï¼Œä»Žè€ŒçœåŽ»äº†TCPçš„é‡Šæ”¾å’Œå†æ¬¡åˆ›å»ºçš„å¼€é”€ï¼Œå‡å°‘äº†ç½‘ç»œå»¶æ—¶: åœ¨çŽ°ä»£æµè§ˆå™¨ä¸­ï¼Œä¸€èˆ¬åŒæ—¶å¼€å¯6ï½ž8ä¸ªkeepalive connectionsçš„socketè¿žæŽ¥ï¼Œå¹¶ä¿æŒä¸€å®šçš„é“¾è·¯ç”Ÿå‘½ï¼Œå½“ä¸éœ€è¦æ—¶å†å…³é—­ï¼›è€Œåœ¨æœåŠ¡å™¨ä¸­ï¼Œä¸€èˆ¬æ˜¯ç”±è½¯ä»¶æ ¹æ®è´Ÿè½½æƒ…å†µ(æ¯”å¦‚FDæœ€å¤§å€¼ã€Socketå†…å­˜ã€è¶…æ—¶æ—¶é—´ã€æ ˆå†…å­˜ã€æ ˆæ•°é‡ç­‰)å†³å®šæ˜¯å¦ä¸»åŠ¨å…³é—­ã€‚ 1.2 HTTP/2åœ¨HTTP/1.xä¸­ï¼Œå¦‚æžœå®¢æˆ·ç«¯æƒ³å‘èµ·å¤šä¸ªå¹¶è¡Œè¯·æ±‚å¿…é¡»å»ºç«‹å¤šä¸ªTCPè¿žæŽ¥ï¼Œè¿™æ— ç–‘å¢žå¤§äº†ç½‘ç»œå¼€é”€ã€‚å¦å¤–HTTP/1.xä¸ä¼šåŽ‹ç¼©è¯·æ±‚å’Œå“åº”æŠ¥å¤´ï¼Œå¯¼è‡´äº†ä¸å¿…è¦çš„ç½‘ç»œæµé‡ï¼›HTTP/1.xä¸æ”¯æŒèµ„æºä¼˜å…ˆçº§å¯¼è‡´åº•å±‚TCPè¿žæŽ¥åˆ©ç”¨çŽ‡ä½Žä¸‹ã€‚è€Œè¿™äº›é—®é¢˜éƒ½æ˜¯HTTP/2è¦ç€åŠ›è§£å†³çš„ã€‚ç®€å•æ¥è¯´HTTP/2ä¸»è¦è§£å†³äº†ä»¥ä¸‹é—®é¢˜ï¼š æŠ¥å¤´åŽ‹ç¼©ï¼šHTTP/2ä½¿ç”¨HPACKåŽ‹ç¼©æ ¼å¼åŽ‹ç¼©è¯·æ±‚å’Œå“åº”æŠ¥å¤´æ•°æ®ï¼Œå‡å°‘ä¸å¿…è¦æµé‡å¼€é”€ è¯·æ±‚ä¸Žå“åº”å¤ç”¨ï¼šHTTP/2é€šè¿‡å¼•å…¥æ–°çš„äºŒè¿›åˆ¶åˆ†å¸§å±‚å®žçŽ°äº†å®Œæ•´çš„è¯·æ±‚å’Œå“åº”å¤ç”¨ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨å¯ä»¥å°†HTTPæ¶ˆæ¯åˆ†è§£ä¸ºäº’ä¸ä¾èµ–çš„å¸§ï¼Œç„¶åŽäº¤é”™å‘é€ï¼Œæœ€åŽå†åœ¨å¦ä¸€ç«¯å°†å…¶é‡æ–°ç»„è£… æŒ‡å®šæ•°æ®æµä¼˜å…ˆçº§ï¼šå°† HTTP æ¶ˆæ¯åˆ†è§£ä¸ºå¾ˆå¤šç‹¬ç«‹çš„å¸§ä¹‹åŽï¼Œæˆ‘ä»¬å°±å¯ä»¥å¤ç”¨å¤šä¸ªæ•°æ®æµä¸­çš„å¸§ï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨äº¤é”™å‘é€å’Œä¼ è¾“è¿™äº›å¸§çš„é¡ºåºå°±æˆä¸ºå…³é”®çš„æ€§èƒ½å†³å®šå› ç´ ã€‚ä¸ºäº†åšåˆ°è¿™ä¸€ç‚¹ï¼ŒHTTP/2 æ ‡å‡†å…è®¸æ¯ä¸ªæ•°æ®æµéƒ½æœ‰ä¸€ä¸ªå…³è”çš„æƒé‡å’Œä¾èµ–å…³ç³» æµæŽ§åˆ¶ï¼šHTTP/2 æä¾›äº†ä¸€ç»„ç®€å•çš„æž„å»ºå—ï¼Œè¿™äº›æž„å»ºå—å…è®¸å®¢æˆ·ç«¯å’ŒæœåŠ¡å™¨å®žçŽ°å…¶è‡ªå·±çš„æ•°æ®æµå’Œè¿žæŽ¥çº§æµæŽ§åˆ¶ HTTP/2æ‰€æœ‰æ€§èƒ½å¢žå¼ºçš„æ ¸å¿ƒåœ¨äºŽæ–°çš„äºŒè¿›åˆ¶åˆ†å¸§å±‚ï¼Œå®ƒå®šä¹‰äº†å¦‚ä½•å°è£…HTTPæ¶ˆæ¯å¹¶åœ¨å®¢æˆ·ç«¯ä¸ŽæœåŠ¡å™¨ä¹‹é—´è¿›è¡Œä¼ è¾“: åŒæ—¶HTTP/2å¼•å…¥äº†ä¸‰ä¸ªæ–°çš„æ¦‚å¿µï¼š æ•°æ®æµï¼šåŸºäºŽTCPè¿žæŽ¥ä¹‹ä¸Šçš„é€»è¾‘åŒå‘å­—èŠ‚æµï¼Œå¯¹åº”ä¸€ä¸ªè¯·æ±‚åŠå…¶å“åº”ã€‚å®¢æˆ·ç«¯æ¯å‘èµ·ä¸€ä¸ªè¯·æ±‚å°±å»ºç«‹ä¸€ä¸ªæ•°æ®æµï¼ŒåŽç»­è¯¥è¯·æ±‚åŠå…¶å“åº”çš„æ‰€æœ‰æ•°æ®éƒ½é€šè¿‡è¯¥æ•°æ®æµä¼ è¾“ æ¶ˆæ¯ï¼šä¸€ä¸ªè¯·æ±‚æˆ–å“åº”å¯¹åº”çš„ä¸€ç³»åˆ—æ•°æ®å¸§ å¸§ï¼šHTTP/2çš„æœ€å°æ•°æ®åˆ‡ç‰‡å•ä½ ä¸Šè¿°æ¦‚å¿µä¹‹é—´çš„é€»è¾‘å…³ç³»ï¼š æ‰€æœ‰é€šä¿¡éƒ½åœ¨ä¸€ä¸ª TCP è¿žæŽ¥ä¸Šå®Œæˆï¼Œæ­¤è¿žæŽ¥å¯ä»¥æ‰¿è½½ä»»æ„æ•°é‡çš„åŒå‘æ•°æ®æµ æ¯ä¸ªæ•°æ®æµéƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„æ ‡è¯†ç¬¦å’Œå¯é€‰çš„ä¼˜å…ˆçº§ä¿¡æ¯ï¼Œç”¨äºŽæ‰¿è½½åŒå‘æ¶ˆæ¯ æ¯æ¡æ¶ˆæ¯éƒ½æ˜¯ä¸€æ¡é€»è¾‘ HTTP æ¶ˆæ¯ï¼ˆä¾‹å¦‚è¯·æ±‚æˆ–å“åº”ï¼‰ï¼ŒåŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªå¸§ å¸§æ˜¯æœ€å°çš„é€šä¿¡å•ä½ï¼Œæ‰¿è½½ç€ç‰¹å®šç±»åž‹çš„æ•°æ®ï¼Œä¾‹å¦‚ HTTP æ ‡å¤´ã€æ¶ˆæ¯è´Ÿè½½ï¼Œç­‰ç­‰ã€‚ æ¥è‡ªä¸åŒæ•°æ®æµçš„å¸§å¯ä»¥äº¤é”™å‘é€ï¼Œç„¶åŽå†æ ¹æ®æ¯ä¸ªå¸§å¤´çš„æ•°æ®æµæ ‡è¯†ç¬¦é‡æ–°ç»„è£… æ¯ä¸ªHTTPæ¶ˆæ¯è¢«åˆ†è§£ä¸ºå¤šä¸ªç‹¬ç«‹çš„å¸§åŽå¯ä»¥äº¤é”™å‘é€ï¼Œä»Žè€Œåœ¨å®è§‚ä¸Šå®žçŽ°äº†å¤šä¸ªè¯·æ±‚æˆ–å“åº”å¹¶è¡Œä¼ è¾“çš„æ•ˆæžœã€‚è¿™ç±»ä¼¼äºŽå¤šè¿›ç¨‹çŽ¯å¢ƒä¸‹çš„æ—¶é—´åˆ†ç‰‡æœºåˆ¶ 2. è¿žæŽ¥æ± çš„ä½¿ç”¨ä¸Žåˆ†æžæ— è®ºæ˜¯HTTP/1.1çš„Keep-Aliveæœºåˆ¶è¿˜æ˜¯HTTP/2çš„å¤šè·¯å¤ç”¨æœºåˆ¶ï¼Œåœ¨å®žçŽ°ä¸Šéƒ½éœ€è¦å¼•å…¥è¿žæŽ¥æ± æ¥ç»´æŠ¤ç½‘ç»œè¿žæŽ¥ã€‚æŽ¥ä¸‹æ¥çœ‹ä¸‹OkHttpä¸­çš„è¿žæŽ¥æ± å®žçŽ°ã€‚ OkHttpå†…éƒ¨é€šè¿‡ConnectionPoolæ¥ç®¡ç†è¿žæŽ¥æ± ï¼Œé¦–å…ˆæ¥çœ‹ä¸‹ConnectionPoolçš„ä¸»è¦æˆå‘˜ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public final class ConnectionPool &#123; private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp ConnectionPool", true)); /** The maximum number of idle connections for each address. */ private final int maxIdleConnections; private final long keepAliveDurationNs; private final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; ...... &#125; &#125;; private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); final RouteDatabase routeDatabase = new RouteDatabase(); boolean cleanupRunning; ...... /** *è¿”å›žç¬¦åˆè¦æ±‚çš„å¯é‡ç”¨è¿žæŽ¥ï¼Œå¦‚æžœæ²¡æœ‰è¿”å›žNULL */ RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; ...... &#125; /* * åŽ»é™¤é‡å¤è¿žæŽ¥ã€‚ä¸»è¦é’ˆå¯¹å¤šè·¯å¤ç”¨åœºæ™¯ä¸‹ä¸€ä¸ªaddressåªéœ€è¦ä¸€ä¸ªè¿žæŽ¥ */ Socket deduplicate(Address address, StreamAllocation streamAllocation) &#123; ...... &#125; /* * å°†è¿žæŽ¥åŠ å…¥è¿žæŽ¥æ±  */ void put(RealConnection connection) &#123; ...... &#125; /* * å½“æœ‰è¿žæŽ¥ç©ºé—²æ—¶å”¤èµ·cleanupçº¿ç¨‹æ¸…æ´—è¿žæŽ¥æ±  */ boolean connectionBecameIdle(RealConnection connection) &#123; ...... &#125; /** * æ‰«æè¿žæŽ¥æ± ï¼Œæ¸…é™¤ç©ºé—²è¿žæŽ¥ */ long cleanup(long now) &#123; ...... &#125; /* * æ ‡è®°æ³„éœ²è¿žæŽ¥ */ private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; ...... &#125;&#125; ç›¸å…³æ¦‚å¿µï¼š Callï¼šå¯¹Httpè¯·æ±‚çš„å°è£… Connection/RealConnection:ç‰©ç†è¿žæŽ¥çš„å°è£…ï¼Œå…¶å†…éƒ¨æœ‰List&lt;WeakReference&lt;StreamAllocation&gt;&gt;çš„å¼•ç”¨è®¡æ•° StreamAllocation: okhttpä¸­å¼•å…¥äº†StreamAllocationè´Ÿè´£ç®¡ç†ä¸€ä¸ªè¿žæŽ¥ä¸Šçš„æµï¼ŒåŒæ—¶åœ¨connectionä¸­ä¹Ÿé€šè¿‡ä¸€ä¸ªStreamAllocationçš„å¼•ç”¨çš„åˆ—è¡¨æ¥ç®¡ç†ä¸€ä¸ªè¿žæŽ¥çš„æµï¼Œä»Žè€Œä½¿å¾—è¿žæŽ¥ä¸Žæµä¹‹é—´è§£è€¦ã€‚å…³äºŽStreamAllocationçš„å®šä¹‰å¯ä»¥çœ‹ä¸‹è¿™ç¯‡æ–‡ç« :okhttpæºç å­¦ä¹ ç¬”è®°ï¼ˆäºŒï¼‰â€“ è¿žæŽ¥ä¸Žè¿žæŽ¥ç®¡ç† connections: DequeåŒç«¯é˜Ÿåˆ—ï¼Œç”¨äºŽç»´æŠ¤è¿žæŽ¥çš„å®¹å™¨ routeDatabase:ç”¨æ¥è®°å½•è¿žæŽ¥å¤±è´¥çš„Routeçš„é»‘åå•ï¼Œå½“è¿žæŽ¥å¤±è´¥çš„æ—¶å€™å°±ä¼šæŠŠå¤±è´¥çš„çº¿è·¯åŠ è¿›åŽ» 2.1 å®žä¾‹åŒ–é¦–å…ˆæ¥çœ‹ä¸‹ConnectionPoolçš„å®žä¾‹åŒ–è¿‡ç¨‹ï¼Œä¸€ä¸ªOkHttpClientåªåŒ…å«ä¸€ä¸ªConnectionPoolï¼Œå…¶å®žä¾‹åŒ–è¿‡ç¨‹ä¹Ÿåœ¨OkHttpClientçš„å®žä¾‹åŒ–è¿‡ç¨‹ä¸­å®žçŽ°ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ConnectionPoolå„ä¸ªæ–¹æ³•çš„è°ƒç”¨å¹¶æ²¡æœ‰ç›´æŽ¥å¯¹å¤–æš´éœ²ï¼Œè€Œæ˜¯é€šè¿‡OkHttpClientçš„InternalæŽ¥å£ç»Ÿä¸€å¯¹å¤–æš´éœ²ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory &#123; static &#123; Internal.instance = new Internal() &#123; @Override public void addLenient(Headers.Builder builder, String line) &#123; builder.addLenient(line); &#125; @Override public void addLenient(Headers.Builder builder, String name, String value) &#123; builder.addLenient(name, value); &#125; @Override public void setCache(Builder builder, InternalCache internalCache) &#123; builder.setInternalCache(internalCache); &#125; @Override public boolean connectionBecameIdle( ConnectionPool pool, RealConnection connection) &#123; return pool.connectionBecameIdle(connection); &#125; @Override public RealConnection get(ConnectionPool pool, Address address, StreamAllocation streamAllocation, Route route) &#123; return pool.get(address, streamAllocation, route); &#125; @Override public boolean equalsNonHost(Address a, Address b) &#123; return a.equalsNonHost(b); &#125; @Override public Socket deduplicate( ConnectionPool pool, Address address, StreamAllocation streamAllocation) &#123; return pool.deduplicate(address, streamAllocation); &#125; @Override public void put(ConnectionPool pool, RealConnection connection) &#123; pool.put(connection); &#125; @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) &#123; return connectionPool.routeDatabase; &#125; @Override public int code(Response.Builder responseBuilder) &#123; return responseBuilder.code; &#125; @Override public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) &#123; tlsConfiguration.apply(sslSocket, isFallback); &#125; @Override public HttpUrl getHttpUrlChecked(String url) throws MalformedURLException, UnknownHostException &#123; return HttpUrl.getChecked(url); &#125; @Override public StreamAllocation streamAllocation(Call call) &#123; return ((RealCall) call).streamAllocation(); &#125; @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) &#123; return new RealCall(client, originalRequest, true); &#125; &#125;; ......&#125; è¿™æ ·åšçš„åŽŸå› æ˜¯ï¼š 12Escalate internal APIs in &#123;@code okhttp3&#125; so they can be used from OkHttp&apos;s implementationpackages. The only implementation of this interface is in &#123;@link OkHttpClient&#125;. Internalçš„å”¯ä¸€å®žçŽ°åœ¨OkHttpClientä¸­ï¼ŒOkHttpClienté€šè¿‡è¿™ç§æ–¹å¼æš´éœ²å…¶APIç»™å¤–éƒ¨ç±»ä½¿ç”¨ã€‚ 2.2 è¿žæŽ¥æ± ç»´æŠ¤ConnectionPoolå†…éƒ¨é€šè¿‡ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—(dequeue)æ¥ç»´æŠ¤å½“å‰æ‰€æœ‰è¿žæŽ¥ï¼Œä¸»è¦æ¶‰åŠåˆ°çš„æ“ä½œåŒ…æ‹¬ï¼š putï¼šæ”¾å…¥æ–°è¿žæŽ¥ getï¼šä»Žè¿žæŽ¥æ± ä¸­èŽ·å–è¿žæŽ¥ evictAllï¼šå…³é—­æ‰€æœ‰è¿žæŽ¥ connectionBecameIdleï¼šè¿žæŽ¥å˜ç©ºé—²åŽè°ƒç”¨æ¸…ç†çº¿ç¨‹ deduplicateï¼šæ¸…é™¤é‡å¤çš„å¤šè·¯å¤ç”¨çº¿ç¨‹ 2.2.1 StreamAllocation.findConnectiongetæ˜¯ConnectionPoolä¸­æœ€ä¸ºé‡è¦çš„æ–¹æ³•ï¼ŒStreamAllocationåœ¨å…¶findConnectionæ–¹æ³•å†…éƒ¨é€šè¿‡è°ƒç”¨getæ–¹æ³•ä¸ºå…¶æ‰¾åˆ°streamæ‰¾åˆ°åˆé€‚çš„è¿žæŽ¥ï¼Œå¦‚æžœæ²¡æœ‰åˆ™æ–°å»ºä¸€ä¸ªè¿žæŽ¥ã€‚é¦–å…ˆæ¥çœ‹ä¸‹findConnectionçš„é€»è¾‘ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123; Route selectedRoute; synchronized (connectionPool) &#123; if (released) throw new IllegalStateException("released"); if (codec != null) throw new IllegalStateException("codec != null"); if (canceled) throw new IOException("Canceled"); // ä¸€ä¸ªStreamAllocationåˆ»ç”»çš„æ˜¯ä¸€ä¸ªCallçš„æ•°æ®æµåŠ¨ï¼Œä¸€ä¸ªCallå¯èƒ½å­˜åœ¨å¤šæ¬¡è¯·æ±‚(é‡å®šå‘ï¼ŒAuthenticateç­‰)ï¼Œæ‰€ä»¥å½“å‘ç”Ÿç±»ä¼¼é‡å®šå‘ç­‰äº‹ä»¶æ—¶ä¼˜å…ˆä½¿ç”¨åŽŸæœ‰çš„è¿žæŽ¥ RealConnection allocatedConnection = this.connection; if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123; return allocatedConnection; &#125; // è¯•å›¾ä»Žè¿žæŽ¥æ± ä¸­æ‰¾åˆ°å¯å¤ç”¨çš„è¿žæŽ¥ Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; return connection; &#125; selectedRoute = route; &#125; // èŽ·å–è·¯ç”±é…ç½®ï¼Œæ‰€è°“è·¯ç”±å…¶å®žå°±æ˜¯ä»£ç†ï¼Œipåœ°å€ç­‰å‚æ•°çš„ä¸€ä¸ªç»„åˆ if (selectedRoute == null) &#123; selectedRoute = routeSelector.next(); &#125; RealConnection result; synchronized (connectionPool) &#123; if (canceled) throw new IOException("Canceled"); //æ‹¿åˆ°è·¯ç”±åŽå¯ä»¥å°è¯•é‡æ–°ä»Žè¿žæŽ¥æ± ä¸­èŽ·å–è¿žæŽ¥ï¼Œè¿™é‡Œä¸»è¦é’ˆå¯¹http2åè®®ä¸‹æ¸…é™¤åŸŸåç¢Žç‰‡æœºåˆ¶ Internal.instance.get(connectionPool, address, this, selectedRoute); if (connection != null) return connection; //æ–°å»ºè¿žæŽ¥ route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); //ä¿®æ”¹resultè¿žæŽ¥streamè®¡æ•°ï¼Œæ–¹ä¾¿connectionæ ‡è®°æ¸…ç† acquire(result); &#125; // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; // å°†æ–°å»ºçš„è¿žæŽ¥æ”¾å…¥åˆ°è¿žæŽ¥æ± ä¸­ Internal.instance.put(connectionPool, result); // å¦‚æžœåŒæ—¶å­˜åœ¨å¤šä¸ªè¿žå‘åŒä¸€ä¸ªåœ°å€çš„å¤šè·¯å¤ç”¨è¿žæŽ¥ï¼Œåˆ™å…³é—­å¤šä½™è¿žæŽ¥ï¼Œåªä¿ç•™ä¸€ä¸ª if (result.isMultiplexed()) &#123; socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; closeQuietly(socket); return result; &#125; å…¶ä¸»è¦é€»è¾‘å¤§è‡´åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªæ­¥éª¤ï¼š æŸ¥çœ‹å½“å‰streamAllocationæ˜¯å¦æœ‰ä¹‹å‰å·²ç»åˆ†é…è¿‡çš„è¿žæŽ¥ï¼Œæœ‰åˆ™ç›´æŽ¥ä½¿ç”¨ ä»Žè¿žæŽ¥æ± ä¸­æŸ¥æ‰¾å¯å¤ç”¨çš„è¿žæŽ¥ï¼Œæœ‰åˆ™è¿”å›žè¯¥è¿žæŽ¥ é…ç½®è·¯ç”±ï¼Œé…ç½®åŽå†æ¬¡ä»Žè¿žæŽ¥æ± ä¸­æŸ¥æ‰¾æ˜¯å¦æœ‰å¯å¤ç”¨è¿žæŽ¥ï¼Œæœ‰åˆ™ç›´æŽ¥è¿”å›ž æ–°å»ºä¸€ä¸ªè¿žæŽ¥ï¼Œå¹¶ä¿®æ”¹å…¶StreamAllocationæ ‡è®°è®¡æ•°ï¼Œå°†å…¶æ”¾å…¥è¿žæŽ¥æ± ä¸­ æŸ¥çœ‹è¿žæŽ¥æ± æ˜¯å¦æœ‰é‡å¤çš„å¤šè·¯å¤ç”¨è¿žæŽ¥ï¼Œæœ‰åˆ™æ¸…é™¤ 2.2.2 ConnectionPool.getæŽ¥ä¸‹æ¥å†æ¥çœ‹getæ–¹æ³•çš„æºç ï¼š 1234567891011[ConnectionPool.java] RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; if (connection.isEligible(address, route)) &#123; streamAllocation.acquire(connection); return connection; &#125; &#125; return null; &#125; å…¶é€»è¾‘æ¯”è¾ƒç®€å•ï¼ŒéåŽ†å½“å‰è¿žæŽ¥æ± ï¼Œå¦‚æžœæœ‰ç¬¦åˆæ¡ä»¶çš„è¿žæŽ¥åˆ™ä¿®æ”¹å™¨æ ‡è®°è®¡æ•°ï¼Œç„¶åŽè¿”å›žã€‚è¿™é‡Œçš„å…³é”®é€»è¾‘åœ¨RealConnection.isEligibleæ–¹æ³•ï¼š 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[RealConnection.java]/** * Returns true if this connection can carry a stream allocation to &#123;@code address&#125;. If non-null * &#123;@code route&#125; is the resolved route for a connection. */ public boolean isEligible(Address address, Route route) &#123; // If this connection is not accepting new streams, we&apos;re done. if (allocations.size() &gt;= allocationLimit || noNewStreams) return false; // If the non-host fields of the address don&apos;t overlap, we&apos;re done. if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false; // If the host exactly matches, we&apos;re done: this connection can carry the address. if (address.url().host().equals(this.route().address().url().host())) &#123; return true; // This connection is a perfect match. &#125; // At this point we don&apos;t have a hostname match. But we still be able to carry the request if // our connection coalescing requirements are met. See also: // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/ // 1. This connection must be HTTP/2. if (http2Connection == null) return false; // 2. The routes must share an IP address. This requires us to have a DNS address for both // hosts, which only happens after route planning. We can&apos;t coalesce connections that use a // proxy, since proxies don&apos;t tell us the origin server&apos;s IP address. if (route == null) return false; if (route.proxy().type() != Proxy.Type.DIRECT) return false; if (this.route.proxy().type() != Proxy.Type.DIRECT) return false; if (!this.route.socketAddress().equals(route.socketAddress())) return false; // 3. This connection&apos;s server certificate&apos;s must cover the new host. if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false; if (!supportsUrl(address.url())) return false; // 4. Certificate pinning must match the host. try &#123; address.certificatePinner().check(address.url().host(), handshake().peerCertificates()); &#125; catch (SSLPeerUnverifiedException e) &#123; return false; &#125; return true; // The caller&apos;s address can be carried by this connection. &#125; è¿žæŽ¥æ²¡æœ‰è¾¾åˆ°å…±äº«ä¸Šé™ éžhoståŸŸå¿…é¡»å®Œå…¨ä¸€æ · å¦‚æžœæ­¤æ—¶hoståŸŸä¹Ÿç›¸åŒï¼Œåˆ™ç¬¦åˆæ¡ä»¶ï¼Œå¯ä»¥è¢«å¤ç”¨ å¦‚æžœhostä¸ç›¸åŒï¼Œåœ¨HTTP/2çš„åŸŸååˆ‡ç‰‡åœºæ™¯ä¸‹ä¸€æ ·å¯ä»¥å¤ç”¨ï¼Œå…·ä½“ç»†èŠ‚å¯ä»¥å‚è€ƒï¼šhttps://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding 2.2.3 deduplicatededuplicateæ–¹æ³•ä¸»è¦æ˜¯é’ˆå¯¹åœ¨HTTP/2åœºæ™¯ä¸‹å¤šä¸ªå¤šè·¯å¤ç”¨è¿žæŽ¥æ¸…é™¤çš„åœºæ™¯ã€‚å¦‚æžœå½“å‰è¿žæŽ¥æ˜¯HTTP/2ï¼Œé‚£ä¹ˆæ‰€æœ‰æŒ‡å‘è¯¥ç«™ç‚¹çš„è¯·æ±‚éƒ½åº”è¯¥åŸºäºŽåŒä¸€ä¸ªTCPè¿žæŽ¥ï¼š 12345678910111213141516[ConnectionPool.java] /** * Replaces the connection held by &#123;@code streamAllocation&#125; with a shared connection if possible. * This recovers when multiple multiplexed connections are created concurrently. */ Socket deduplicate(Address address, StreamAllocation streamAllocation) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; if (connection.isEligible(address, null) &amp;&amp; connection.isMultiplexed() &amp;&amp; connection != streamAllocation.connection()) &#123; return streamAllocation.releaseAndAcquire(connection); &#125; &#125; return null; &#125; putå’ŒevictAllæ¯”è¾ƒç®€å•ï¼Œåœ¨è¿™é‡Œå°±ä¸å†™äº†ï¼Œå¤§å®¶è‡ªè¡Œçœ‹æºç ã€‚ 2.3 è‡ªåŠ¨å›žæ”¶è¿žæŽ¥æ± ä¸­æœ‰socketå›žæ”¶ï¼Œè€Œè¿™ä¸ªå›žæ”¶æ˜¯ä»¥RealConnectionçš„å¼±å¼•ç”¨List&lt;Reference&lt;StreamAllocation&gt;&gt;æ˜¯å¦ä¸º0æ¥ä¸ºä¾æ®çš„ã€‚ConnectionPoolæœ‰ä¸€ä¸ªç‹¬ç«‹çš„çº¿ç¨‹cleanupRunnableæ¥æ¸…ç†è¿žæŽ¥æ± ï¼Œå…¶è§¦å‘æ—¶æœºæœ‰ä¸¤ä¸ªï¼š å½“è¿žæŽ¥æ± ä¸­putæ–°çš„è¿žæŽ¥æ—¶ å½“connectionBecameIdleæŽ¥å£è¢«è°ƒç”¨æ—¶ å…¶ä»£ç å¦‚ä¸‹ï¼š 1234567891011121314while (true) &#123; //æ‰§è¡Œæ¸…ç†å¹¶è¿”å›žä¸‹åœºéœ€è¦æ¸…ç†çš„æ—¶é—´ long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; synchronized (ConnectionPool.this) &#123; try &#123; //åœ¨timeoutå†…é‡Šæ”¾é”ä¸Žæ—¶é—´ç‰‡ ConnectionPool.this.wait(TimeUnit.NANOSECONDS.toMillis(waitNanos)); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125;&#125; è¿™æ®µæ­»å¾ªçŽ¯å®žé™…ä¸Šæ˜¯ä¸€ä¸ªé˜»å¡žçš„æ¸…ç†ä»»åŠ¡ï¼Œé¦–å…ˆè¿›è¡Œæ¸…ç†(clean)ï¼Œå¹¶è¿”å›žä¸‹æ¬¡éœ€è¦æ¸…ç†çš„é—´éš”æ—¶é—´ï¼Œç„¶åŽè°ƒç”¨wait(timeout)è¿›è¡Œç­‰å¾…ä»¥é‡Šæ”¾é”ä¸Žæ—¶é—´ç‰‡ï¼Œå½“ç­‰å¾…æ—¶é—´åˆ°äº†åŽï¼Œå†æ¬¡è¿›è¡Œæ¸…ç†ï¼Œå¹¶è¿”å›žä¸‹æ¬¡è¦æ¸…ç†çš„é—´éš”æ—¶é—´â€¦ æŽ¥ä¸‹æ¥çœ‹ä¸‹cleanupå‡½æ•°: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[ConnectionPool.java]long cleanup(long now) &#123; int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; //éåŽ†`Deque`ä¸­æ‰€æœ‰çš„`RealConnection`ï¼Œæ ‡è®°æ³„æ¼çš„è¿žæŽ¥ synchronized (this) &#123; for (RealConnection connection : connections) &#123; // æŸ¥è¯¢æ­¤è¿žæŽ¥å†…éƒ¨StreamAllocationçš„å¼•ç”¨æ•°é‡ if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; inUseConnectionCount++; continue; &#125; idleConnectionCount++; //é€‰æ‹©æŽ’åºæ³•ï¼Œæ ‡è®°å‡ºç©ºé—²è¿žæŽ¥ long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) &#123; longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; &#125; &#125; if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) &#123; //å¦‚æžœ(`ç©ºé—²socketè¿žæŽ¥è¶…è¿‡5ä¸ª` //ä¸”`keepaliveæ—¶é—´å¤§äºŽ5åˆ†é’Ÿ`) //å°±å°†æ­¤æ³„æ¼è¿žæŽ¥ä»Ž`Deque`ä¸­ç§»é™¤ connections.remove(longestIdleConnection); &#125; else if (idleConnectionCount &gt; 0) &#123; //è¿”å›žæ­¤è¿žæŽ¥å³å°†åˆ°æœŸçš„æ—¶é—´ï¼Œä¾›ä¸‹æ¬¡æ¸…ç† //è¿™é‡Œä¾æ®æ˜¯åœ¨ä¸Šæ–‡`connectionBecameIdle`ä¸­è®¾å®šçš„è®¡æ—¶ return keepAliveDurationNs - longestIdleDurationNs; &#125; else if (inUseConnectionCount &gt; 0) &#123; //å…¨éƒ¨éƒ½æ˜¯æ´»è·ƒçš„è¿žæŽ¥ï¼Œ5åˆ†é’ŸåŽå†æ¬¡æ¸…ç† return keepAliveDurationNs; &#125; else &#123; //æ²¡æœ‰ä»»ä½•è¿žæŽ¥ï¼Œè·³å‡ºå¾ªçŽ¯ cleanupRunning = false; return -1; &#125; &#125; //å…³é—­è¿žæŽ¥ï¼Œè¿”å›ž`0`ï¼Œä¹Ÿå°±æ˜¯ç«‹åˆ»å†æ¬¡æ¸…ç† closeQuietly(longestIdleConnection.socket()); return 0;&#125; å…¶åŸºæœ¬é€»è¾‘å¦‚ä¸‹ï¼š éåŽ†è¿žæŽ¥æ± ä¸­æ‰€æœ‰è¿žæŽ¥ï¼Œæ ‡è®°æ³„éœ²è¿žæŽ¥ å¦‚æžœè¢«æ ‡è®°çš„è¿žæŽ¥æ»¡è¶³(ç©ºé—²socketè¿žæŽ¥è¶…è¿‡5ä¸ª&amp;&amp;keepaliveæ—¶é—´å¤§äºŽ5åˆ†é’Ÿ)ï¼Œå°±å°†æ­¤è¿žæŽ¥ä»ŽDequeä¸­ç§»é™¤ï¼Œå¹¶å…³é—­è¿žæŽ¥ï¼Œè¿”å›ž0ï¼Œä¹Ÿå°±æ˜¯å°†è¦æ‰§è¡Œwait(0)ï¼Œæé†’ç«‹åˆ»å†æ¬¡æ‰«æ å¦‚æžœ(ç›®å‰è¿˜å¯ä»¥å¡žå¾—ä¸‹5ä¸ªè¿žæŽ¥ï¼Œä½†æ˜¯æœ‰å¯èƒ½æ³„æ¼çš„è¿žæŽ¥(å³ç©ºé—²æ—¶é—´å³å°†è¾¾åˆ°5åˆ†é’Ÿ))ï¼Œå°±è¿”å›žæ­¤è¿žæŽ¥å³å°†åˆ°æœŸçš„å‰©ä½™æ—¶é—´ï¼Œä¾›ä¸‹æ¬¡æ¸…ç† å¦‚æžœ(å…¨éƒ¨éƒ½æ˜¯æ´»è·ƒçš„è¿žæŽ¥)ï¼Œå°±è¿”å›žé»˜è®¤çš„keep-aliveæ—¶é—´ï¼Œä¹Ÿå°±æ˜¯5åˆ†é’ŸåŽå†æ‰§è¡Œæ¸…ç† è€ŒpruneAndGetAllocationCountè´Ÿè´£æ ‡è®°å¹¶æ‰¾åˆ°ä¸æ´»è·ƒè¿žæŽ¥: 1234567891011121314151617181920212223242526272829[ConnnecitonPool.java]//ç±»ä¼¼äºŽå¼•ç”¨è®¡æ•°æ³•ï¼Œå¦‚æžœå¼•ç”¨å…¨éƒ¨ä¸ºç©ºï¼Œè¿”å›žç«‹åˆ»æ¸…ç†private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; //è™šå¼•ç”¨åˆ—è¡¨ List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations; //éåŽ†å¼±å¼•ç”¨åˆ—è¡¨ for (int i = 0; i &lt; references.size(); ) &#123; Reference&lt;StreamAllocation&gt; reference = references.get(i); //å¦‚æžœæ­£åœ¨è¢«ä½¿ç”¨ï¼Œè·³è¿‡ï¼ŒæŽ¥ç€å¾ªçŽ¯ //æ˜¯å¦ç½®ç©ºæ˜¯åœ¨ä¸Šæ–‡`connectionBecameIdle`çš„`release`æŽ§åˆ¶çš„ if (reference.get() != null) &#123; //éžå¸¸æ˜Žæ˜¾çš„å¼•ç”¨è®¡æ•° i++; continue; &#125; //å¦åˆ™ç§»é™¤å¼•ç”¨ references.remove(i); connection.noNewStreams = true; //å¦‚æžœæ‰€æœ‰åˆ†é…çš„æµå‡æ²¡äº†ï¼Œæ ‡è®°ä¸ºå·²ç»è·ç¦»çŽ°åœ¨ç©ºé—²äº†5åˆ†é’Ÿ if (references.isEmpty()) &#123; connection.idleAtNanos = now - keepAliveDurationNs; return 0; &#125; &#125; return references.size();&#125; OkHttpçš„è¿žæŽ¥æ± é€šè¿‡è®¡æ•°+æ ‡è®°æ¸…ç†çš„æœºåˆ¶æ¥ç®¡ç†è¿žæŽ¥æ± ï¼Œä½¿å¾—æ— ç”¨è¿žæŽ¥å¯ä»¥è¢«ä¼šå›žæ”¶ï¼Œå¹¶ä¿æŒå¤šä¸ªå¥åº·çš„keep-aliveè¿žæŽ¥ã€‚è¿™ä¹Ÿæ˜¯OkHttpçš„è¿žæŽ¥æ± èƒ½ä¿æŒé«˜æ•ˆçš„å…³é”®åŽŸå› ã€‚]]></content>
      <categories>
        <category>æ‹†è½®å­</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMapã€LinkedHashMapã€ConcurrentHashMap]]></title>
    <url>%2F2018%2F03%2F27%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMapHashMap æ˜¯åŸºäºŽå“ˆå¸Œè¡¨çš„ Map æŽ¥å£çš„å®žçŽ°ï¼Œä»¥ Key-Value çš„å½¢å¼å­˜åœ¨ï¼Œå³å­˜å‚¨çš„å¯¹è±¡æ˜¯ Entry (åŒæ—¶åŒ…å«äº† Key å’Œ Value) ã€‚åœ¨HashMapä¸­ï¼Œå…¶ä¼šæ ¹æ®hashç®—æ³•æ¥è®¡ç®—key-valueçš„å­˜å‚¨ä½ç½®å¹¶è¿›è¡Œå¿«é€Ÿå­˜å–ã€‚ç‰¹åˆ«åœ°ï¼ŒHashMapæœ€å¤šåªå…è®¸ä¸€æ¡Entryçš„é”®ä¸ºNull(å¤šæ¡ä¼šè¦†ç›–)ï¼Œä½†å…è®¸å¤šæ¡Entryçš„å€¼ä¸ºNullã€‚æ­¤å¤–ï¼ŒHashMap æ˜¯ Map çš„ä¸€ä¸ªéžåŒæ­¥çš„å®žçŽ°ã€‚ æˆ‘ä»¬çŸ¥é“ï¼Œåœ¨Javaä¸­æœ€å¸¸ç”¨çš„ä¸¤ç§ç»“æž„æ˜¯æ•°ç»„å’Œé“¾è¡¨ï¼Œå‡ ä¹Žæ‰€æœ‰çš„æ•°æ®ç»“æž„éƒ½å¯ä»¥åˆ©ç”¨è¿™ä¸¤ç§æ¥ç»„åˆå®žçŽ°ï¼ŒHashMap å°±æ˜¯è¿™ç§åº”ç”¨çš„ä¸€ä¸ªå…¸åž‹ã€‚å®žé™…ä¸Šï¼ŒHashMap å°±æ˜¯ä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œå¦‚ä¸‹æ˜¯å®ƒæ•°æ®ç»“æž„ï¼š æˆ‘ä»¬å¯ä»¥å½¢è±¡åœ°çœ‹å‡ºHashMapåº•å±‚å®žçŽ°è¿˜æ˜¯æ•°ç»„ï¼Œåªæ˜¯æ•°ç»„çš„æ¯ä¸€é¡¹éƒ½æ˜¯ä¸€æ¡é“¾ã€‚å…¶ä¸­å‚æ•°initialCapacity å°±ä»£è¡¨äº†è¯¥æ•°ç»„çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯æ¡¶çš„ä¸ªæ•°ã€‚åœ¨ç¬¬ä¸‰èŠ‚æˆ‘ä»¬å·²ç»äº†è§£äº†HashMap çš„é»˜è®¤æž„é€ å‡½æ•°çš„æºç ï¼š 1234567891011121314/** * Constructs an empty HashMap with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; //è´Ÿè½½å› å­:ç”¨äºŽè¡¡é‡çš„æ˜¯ä¸€ä¸ªæ•£åˆ—è¡¨çš„ç©ºé—´çš„ä½¿ç”¨ç¨‹åº¦ this.loadFactor = DEFAULT_LOAD_FACTOR; //HashMapè¿›è¡Œæ‰©å®¹çš„é˜ˆå€¼ï¼Œå®ƒçš„å€¼ç­‰äºŽ HashMap çš„å®¹é‡ä¹˜ä»¥è´Ÿè½½å› å­ threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // HashMapçš„åº•å±‚å®žçŽ°ä»æ˜¯æ•°ç»„ï¼Œåªæ˜¯æ•°ç»„çš„æ¯ä¸€é¡¹éƒ½æ˜¯ä¸€æ¡é“¾ table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); &#125; æ¯æ¬¡æ–°å»ºä¸€ä¸ªHashMapæ—¶ï¼Œéƒ½ä¼šåˆå§‹åŒ–ä¸€ä¸ªEntryç±»åž‹çš„tableæ•°ç»„ï¼Œå…¶ä¸­ Entryç±»åž‹çš„å®šä¹‰å¦‚ä¸‹ï¼š 1234567891011121314151617181920static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; // é”®å€¼å¯¹çš„é”® V value; // é”®å€¼å¯¹çš„å€¼ Entry&lt;K,V&gt; next; // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ final int hash; // hash(key.hashCode())æ–¹æ³•çš„è¿”å›žå€¼ /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; // Entry çš„æž„é€ å‡½æ•° value = v; next = n; key = k; hash = h; &#125; ......&#125; LinkedHashMapå‘é“¾è¡¨åˆäºŒä¸ºä¸€å³æ˜¯LinkedHashMapã€‚æ‰€è°“LinkedHashMapï¼Œå…¶è½è„šç‚¹åœ¨HashMapï¼Œå› æ­¤æ›´å‡†ç¡®åœ°è¯´ï¼Œå®ƒæ˜¯ä¸€ä¸ªå°†æ‰€æœ‰EntryèŠ‚ç‚¹é“¾å…¥ä¸€ä¸ªåŒå‘é“¾è¡¨åŒå‘é“¾è¡¨çš„HashMapã€‚åœ¨LinkedHashMapMapä¸­ï¼Œæ‰€æœ‰putè¿›æ¥çš„Entryéƒ½ä¿å­˜åœ¨å¦‚ä¸‹é¢ç¬¬ä¸€ä¸ªå›¾æ‰€ç¤ºçš„å“ˆå¸Œè¡¨ä¸­ï¼Œä½†ç”±äºŽå®ƒåˆé¢å¤–å®šä¹‰äº†ä¸€ä¸ªä»¥headä¸ºå¤´ç»“ç‚¹çš„åŒå‘é“¾è¡¨(å¦‚ä¸‹é¢ç¬¬äºŒä¸ªå›¾æ‰€ç¤º)ï¼Œå› æ­¤å¯¹äºŽæ¯æ¬¡putè¿›æ¥Entryï¼Œé™¤äº†å°†å…¶ä¿å­˜åˆ°å“ˆå¸Œè¡¨ä¸­å¯¹åº”çš„ä½ç½®ä¸Šä¹‹å¤–ï¼Œè¿˜ä¼šå°†å…¶æ’å…¥åˆ°åŒå‘é“¾è¡¨çš„å°¾éƒ¨ã€‚ æ›´ç›´è§‚åœ°ï¼Œä¸‹å›¾å¾ˆå¥½åœ°è¿˜åŽŸäº†LinkedHashMapçš„åŽŸè²Œï¼šHashMapå’ŒåŒå‘é“¾è¡¨çš„å¯†åˆ‡é…åˆå’Œåˆ†å·¥åˆä½œé€ å°±äº†LinkedHashMapã€‚ç‰¹åˆ«éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œnextç”¨äºŽç»´æŠ¤HashMapå„ä¸ªæ¡¶ä¸­çš„Entryé“¾ï¼Œbeforeã€afterç”¨äºŽç»´æŠ¤LinkedHashMapçš„åŒå‘é“¾è¡¨ï¼Œè™½ç„¶å®ƒä»¬çš„ä½œç”¨å¯¹è±¡éƒ½æ˜¯Entryï¼Œä½†æ˜¯å„è‡ªåˆ†ç¦»ï¼Œæ˜¯ä¸¤ç äº‹å„¿ã€‚ å…¶ä¸­ï¼ŒHashMapä¸ŽLinkedHashMapçš„Entryç»“æž„ç¤ºæ„å›¾å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š åŸºæœ¬å…ƒç´  Entry LinkedHashMapé‡‡ç”¨çš„hashç®—æ³•å’ŒHashMapç›¸åŒï¼Œä½†æ˜¯å®ƒé‡æ–°å®šä¹‰äº†Entryã€‚LinkedHashMapä¸­çš„Entryå¢žåŠ äº†ä¸¤ä¸ªæŒ‡é’ˆ before å’Œ afterï¼Œå®ƒä»¬åˆ†åˆ«ç”¨äºŽç»´æŠ¤åŒå‘é“¾æŽ¥åˆ—è¡¨ã€‚ç‰¹åˆ«éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œnextç”¨äºŽç»´æŠ¤HashMapå„ä¸ªæ¡¶ä¸­Entryçš„è¿žæŽ¥é¡ºåºï¼Œbeforeã€afterç”¨äºŽç»´æŠ¤Entryæ’å…¥çš„å…ˆåŽé¡ºåºçš„ï¼Œæºä»£ç å¦‚ä¸‹ï¼š 12345678910private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; ...&#125; ç‰¹åˆ«åœ°ï¼Œç”±äºŽLinkedHashMapæ˜¯HashMapçš„å­ç±»ï¼Œæ‰€ä»¥LinkedHashMapè‡ªç„¶ä¼šæ‹¥æœ‰HashMapçš„æ‰€æœ‰ç‰¹æ€§ã€‚æ¯”å¦‚ï¼ŒLinkedHashMapä¹Ÿæœ€å¤šåªå…è®¸ä¸€æ¡Entryçš„é”®ä¸ºNull(å¤šæ¡ä¼šè¦†ç›–)ï¼Œä½†å…è®¸å¤šæ¡Entryçš„å€¼ä¸ºNullã€‚æ­¤å¤–ï¼ŒLinkedHashMap ä¹Ÿæ˜¯ Map çš„ä¸€ä¸ªéžåŒæ­¥çš„å®žçŽ°ã€‚æ­¤å¤–ï¼ŒLinkedHashMapè¿˜å¯ä»¥ç”¨æ¥å®žçŽ°LRU (Least recently used, æœ€è¿‘æœ€å°‘ä½¿ç”¨)ç®—æ³•ã€‚ ConcurrentHashMapçº¿ç¨‹ä¸å®‰å…¨çš„HashMap å› ä¸ºå¤šçº¿ç¨‹çŽ¯å¢ƒä¸‹ï¼Œä½¿ç”¨HashMapè¿›è¡Œputæ“ä½œä¼šå¼•èµ·æ­»å¾ªçŽ¯ï¼Œå¯¼è‡´CPUåˆ©ç”¨çŽ‡æŽ¥è¿‘100%ï¼Œæ‰€ä»¥åœ¨å¹¶å‘æƒ…å†µä¸‹ä¸èƒ½ä½¿ç”¨HashMap. æ•ˆçŽ‡ä½Žä¸‹çš„HashTableå®¹å™¨ HashTableå®¹å™¨ä½¿ç”¨synchronizedæ¥ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œä½†åœ¨çº¿ç¨‹ç«žäº‰æ¿€çƒˆçš„æƒ…å†µä¸‹HashTableçš„æ•ˆçŽ‡éžå¸¸ä½Žä¸‹ã€‚å› ä¸ºå½“ä¸€ä¸ªçº¿ç¨‹è®¿é—®HashTableçš„åŒæ­¥æ–¹æ³•æ—¶ï¼Œå…¶ä»–çº¿ç¨‹è®¿é—®HashTableçš„åŒæ­¥æ–¹æ³•æ—¶ï¼Œå¯èƒ½ä¼šè¿›å…¥é˜»å¡žæˆ–è½®è¯¢çŠ¶æ€ã€‚å¦‚çº¿ç¨‹1ä½¿ç”¨putè¿›è¡Œæ·»åŠ å…ƒç´ ï¼Œçº¿ç¨‹2ä¸ä½†ä¸èƒ½ä½¿ç”¨putæ–¹æ³•æ·»åŠ å…ƒç´ ï¼Œå¹¶ä¸”ä¹Ÿä¸èƒ½ä½¿ç”¨getæ–¹æ³•æ¥èŽ·å–å…ƒç´ ï¼Œæ‰€ä»¥ç«žäº‰è¶Šæ¿€çƒˆæ•ˆçŽ‡è¶Šä½Žã€‚ é”åˆ†æ®µæŠ€æœ¯ HashTableå®¹å™¨åœ¨ç«žäº‰æ¿€çƒˆçš„å¹¶å‘çŽ¯å¢ƒä¸‹è¡¨çŽ°å‡ºæ•ˆçŽ‡ä½Žä¸‹çš„åŽŸå› æ˜¯æ‰€æœ‰è®¿é—®HashTableçš„çº¿ç¨‹éƒ½å¿…é¡»ç«žäº‰åŒä¸€æŠŠé”ï¼Œé‚£å‡å¦‚å®¹å™¨é‡Œæœ‰å¤šæŠŠé”ï¼Œæ¯ä¸€æŠŠé”ç”¨äºŽé”å®¹å™¨å…¶ä¸­ä¸€éƒ¨åˆ†æ•°æ®ï¼Œé‚£ä¹ˆå½“å¤šçº¿ç¨‹è®¿é—®å®¹å™¨é‡Œä¸åŒæ•°æ®æ®µçš„æ•°æ®æ—¶ï¼Œçº¿ç¨‹é—´å°±ä¸ä¼šå­˜åœ¨é”ç«žäº‰ï¼Œä»Žè€Œå¯ä»¥æœ‰æ•ˆçš„æé«˜å¹¶å‘è®¿é—®æ•ˆçŽ‡ï¼Œè¿™å°±æ˜¯ConcurrentHashMapæ‰€ä½¿ç”¨çš„é”åˆ†æ®µæŠ€æœ¯ï¼Œé¦–å…ˆå°†æ•°æ®åˆ†æˆä¸€æ®µä¸€æ®µçš„å­˜å‚¨ï¼Œç„¶åŽç»™æ¯ä¸€æ®µæ•°æ®é…ä¸€æŠŠé”ï¼Œå½“ä¸€ä¸ªçº¿ç¨‹å ç”¨é”è®¿é—®å…¶ä¸­ä¸€ä¸ªæ®µæ•°æ®çš„æ—¶å€™ï¼Œå…¶ä»–æ®µçš„æ•°æ®ä¹Ÿèƒ½è¢«å…¶ä»–çº¿ç¨‹è®¿é—®ã€‚ ConcurrentHashMapçš„ç»“æž„ æˆ‘ä»¬é€šè¿‡ConcurrentHashMapçš„ç±»å›¾æ¥åˆ†æžConcurrentHashMapçš„ç»“æž„ã€‚ ConcurrentHashMapæ˜¯ç”±Segmentæ•°ç»„ç»“æž„å’ŒHashEntryæ•°ç»„ç»“æž„ç»„æˆã€‚Segmentæ˜¯ä¸€ç§å¯é‡å…¥é”ReentrantLockï¼Œåœ¨ConcurrentHashMapé‡Œæ‰®æ¼”é”çš„è§’è‰²ï¼ŒHashEntryåˆ™ç”¨äºŽå­˜å‚¨é”®å€¼å¯¹æ•°æ®ã€‚ä¸€ä¸ªConcurrentHashMapé‡ŒåŒ…å«ä¸€ä¸ªSegmentæ•°ç»„ï¼ŒSegmentçš„ç»“æž„å’ŒHashMapç±»ä¼¼ï¼Œæ˜¯ä¸€ç§æ•°ç»„å’Œé“¾è¡¨ç»“æž„ï¼Œ ä¸€ä¸ªSegmenté‡ŒåŒ…å«ä¸€ä¸ªHashEntryæ•°ç»„ï¼Œæ¯ä¸ªHashEntryæ˜¯ä¸€ä¸ªé“¾è¡¨ç»“æž„çš„å…ƒç´ ï¼Œ æ¯ä¸ªSegmentå®ˆæŠ¤è€…ä¸€ä¸ªHashEntryæ•°ç»„é‡Œçš„å…ƒç´ ,å½“å¯¹HashEntryæ•°ç»„çš„æ•°æ®è¿›è¡Œä¿®æ”¹æ—¶ï¼Œå¿…é¡»é¦–å…ˆèŽ·å¾—å®ƒå¯¹åº”çš„Segmenté”ã€‚ SparseArray SparseArrayæ˜¯ä½¿ç”¨ä¸¤ä¸ªæ•°ç»„æ¥å®žçŽ°çš„ï¼Œâ¼€ä¸ªintç±»åž‹çš„mKeysï¼Œâ¼€ä¸ªObjectç±»åž‹mValuesï¼Œå…¶ä¸­mKeys æ˜¯ä¸€ä¸ªå­˜å‚¨keyçš„æ•°ç»„ï¼Œå®ƒæ˜¯æœ‰åºæŽ’åˆ—çš„ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾å¾ˆå¿«åœ°ç¡®è®¤key åœ¨mKeysæ‰€å¤„ä½ç½®indexï¼Œç„¶åŽå¹¶æŠŠvalueæ’å…¥åˆ°Valuesçš„indexå¯¹åº”ä½ç½®ã€‚ SparseArrayæ›´åŠ èŠ‚çº¦å†…å­˜ï¼Œä¸€ä¸ªint[]æ•°ç»„å­˜å‚¨æ‰€æœ‰çš„keyï¼Œä¸€ä¸ªobject[] æ•°ç»„å­˜å‚¨æ‰€æœ‰çš„value. HashMapé‡åˆ°å†²çªæ—¶,æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚è€ŒSparseArrayä¸ä¼šæœ‰å†²çªï¼Œé‡‡ç”¨äºŒåˆ†æœç´¢ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(lgn). ArrayMapArrayMapä¹Ÿæ˜¯ç”¨ç”¨ä¸¤ä¸ªæ•°ç»„æ¥æ¨¡æ‹ŸMapï¼Œç¬¬ä¸€ä¸ªæ•°ç»„å­˜æ”¾å­˜æ”¾itemçš„hashå€¼ï¼Œç¬¬äºŒæ•°ç»„æ˜¯æŠŠkeyï¼Œvalueè¿žç»­çš„å­˜æ”¾åœ¨æ•°ç»„é‡Œï¼Œé€šè¿‡å…ˆç®—hashåœ¨ç¬¬ä¸€ä¸ªæ•°ç»„é‡Œæ‰¾åˆ°å®ƒçš„hash indexï¼Œæ ¹æ®è¿™ä¸ªindexåœ¨åŽ»ç¬¬äºŒä¸ªæ•°ç»„é‡Œæ‰¾åˆ°è¿™ä¸ªkey-valueã€‚åœ¨è¿™é‡Œï¼Œåœ¨ç¬¬ä¸€ä¸ªæ•°ç»„é‡ŒæŸ¥æ‰¾hash indexçš„æ–¹æ³•å½“ç„¶æ˜¯ç”¨äºŒåˆ†æŸ¥æ‰¾å•¦ï¼ˆbinary searchï¼‰ã€‚]]></content>
      <categories>
        <category>å®¹å™¨</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmapçš„åŠ è½½å’ŒCache]]></title>
    <url>%2F2018%2F03%2F21%2FBitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache%2F</url>
    <content type="text"><![CDATA[Bitmapçš„é«˜æ•ˆåŠ è½½å…ˆæ¥ç®€å•ä»‹ç»ä¸€ä¸‹å¦‚ä½•åŠ è½½ä¸€ä¸ªBitmap, Bitmapåœ¨androidä¸­æŒ‡çš„æ˜¯ä¸€å¼ å›¾ç‰‡, å¯ä»¥æ˜¯pngæ ¼å¼ä¹Ÿå¯ä»¥æ˜¯jpgç­‰å…¶ä»–å¸¸è§çš„å›¾ç‰‡æ ¼å¼. é‚£ä¹ˆå¦‚ä½•åŠ è½½ä¸€ä¸ªå›¾ç‰‡?é¦–å…ˆBitmapFactoryç±»æä¾›äº†å››ç§æ–¹æ³•: decodeFile(), decodeResource(), decodeStream(), decodeByteArray(). åˆ†åˆ«ç”¨äºŽä»Žæ–‡ä»¶ç³»ç»Ÿ, èµ„æºæ–‡ä»¶, è¾“å…¥æµä»¥åŠå­—èŠ‚æ•°ç»„åŠ è½½å‡ºä¸€ä¸ªBitmapå¯¹è±¡. å…¶ä¸­decodeFileå’ŒdecodeResourceåˆé—´æŽ¥è°ƒç”¨äº†decodeStream()æ–¹æ³•, è¿™å››ç±»æ–¹æ³•æœ€ç»ˆæ˜¯åœ¨Androidçš„åº•å±‚å®žçŽ°çš„, å¯¹åº”ç€BitmapFactoryç±»çš„å‡ ä¸ªnativeæ–¹æ³•. é«˜æ•ˆåŠ è½½çš„Bitmapçš„æ ¸å¿ƒæ€æƒ³:é‡‡ç”¨BitmapFactory.Optionsæ¥åŠ è½½æ‰€éœ€å°ºå¯¸çš„å›¾ç‰‡. æ¯”å¦‚è¯´ä¸€ä¸ªImageViewæŽ§ä»¶çš„å¤§å°ä¸º300*300. è€Œå›¾ç‰‡çš„å¤§å°ä¸º800*800. è¿™ä¸ªæ—¶å€™å¦‚æžœç›´æŽ¥åŠ è½½é‚£ä¹ˆå°±æ¯”è¾ƒæµªè´¹èµ„æº, éœ€è¦æ›´å¤šçš„å†…å­˜ç©ºé—´æ¥åŠ è½½å›¾ç‰‡, è¿™ä¸æ˜¯å¾ˆå¿…è¦çš„. è¿™é‡Œæˆ‘ä»¬å°±å¯ä»¥å…ˆæŠŠå›¾ç‰‡æŒ‰ä¸€å®šçš„é‡‡æ ·çŽ‡æ¥ç¼©å°å›¾ç‰‡åœ¨è¿›è¡ŒåŠ è½½. ä¸ä»…é™ä½Žäº†å†…å­˜å ç”¨,è¿˜åœ¨ä¸€å®šç¨‹åº¦ä¸Šé¿å…äº†OOMå¼‚å¸¸. ä¹Ÿæé«˜äº†åŠ è½½bitmapæ—¶çš„æ€§èƒ½. è€Œé€šè¿‡Optionså‚æ•°æ¥ç¼©æ”¾å›¾ç‰‡: ä¸»è¦æ˜¯ç”¨åˆ°äº†inSampleSizeå‚æ•°, å³é‡‡æ ·çŽ‡. å¦‚æžœæ˜¯inSampleSize=1é‚£ä¹ˆå’ŒåŽŸå›¾å¤§å°ä¸€æ ·, å¦‚æžœæ˜¯inSampleSize=2é‚£ä¹ˆå®½é«˜éƒ½ä¸ºåŽŸå›¾1/2, è€Œåƒç´ ä¸ºåŽŸå›¾çš„1/4, å ç”¨çš„å†…å­˜å¤§å°ä¹Ÿä¸ºåŽŸå›¾çš„1/4 å¦‚æžœæ˜¯inSampleSize=3é‚£ä¹ˆå®½é«˜éƒ½ä¸ºåŽŸå›¾1/3, è€Œåƒç´ ä¸ºåŽŸå›¾çš„1/9, å ç”¨çš„å†…å­˜å¤§å°ä¹Ÿä¸ºåŽŸå›¾çš„1/9 ä»¥æ­¤ç±»æŽ¨â€¦.. è¦çŸ¥é“Androidä¸­åŠ è½½å›¾ç‰‡å…·ä½“åœ¨å†…å­˜ä¸­çš„å æœ‰çš„å¤§å°æ˜¯æ ¹æ®å›¾ç‰‡çš„åƒç´ å†³å®šçš„, è€Œä¸Žå›¾ç‰‡çš„å®žé™…å ç”¨ç©ºé—´å¤§å°æ²¡æœ‰å…³ç³».è€Œä¸”å¦‚æžœè¦åŠ è½½mipmapä¸‹çš„å›¾ç‰‡, è¿˜ä¼šæ ¹æ®ä¸åŒçš„åˆ†è¾¨çŽ‡ä¸‹çš„æ–‡ä»¶å¤¹è¿›è¡Œä¸åŒçš„æ”¾å¤§ç¼©å°. åˆ—ä¸¾çŽ°åœ¨æœ‰ä¸€å¼ å›¾ç‰‡åƒç´ ä¸º:1024*1024, å¦‚æžœé‡‡ç”¨ARGB8888(å››ä¸ªé¢œè‰²é€šé“æ¯ä¸ªå æœ‰ä¸€ä¸ªå­—èŠ‚,ç›¸å½“äºŽ1ç‚¹åƒç´ å ç”¨4ä¸ªå­—èŠ‚çš„ç©ºé—´)çš„æ ¼å¼æ¥å­˜å‚¨.(è¿™é‡Œä¸è€ƒè™‘ä¸åŒçš„èµ„æºæ–‡ä»¶ä¸‹æƒ…å†µåˆ†æž) é‚£ä¹ˆå›¾ç‰‡çš„å æœ‰å¤§å°å°±æ˜¯1024*1024*4é‚£çŽ°åœ¨è¿™å¼ å›¾ç‰‡åœ¨å†…å­˜ä¸­å ç”¨4MB. å¦‚æžœé’ˆå¯¹åˆšæ‰çš„å›¾ç‰‡è¿›è¡ŒinSampleSize=2, é‚£ä¹ˆæœ€åŽå ç”¨å†…å­˜å¤§å°ä¸º512*512*4, ä¹Ÿå°±æ˜¯1MB é‡‡æ ·çŽ‡çš„æ•°å€¼å¿…é¡»æ˜¯å¤§äºŽ1çš„æ•´æ•°æ˜¯æ‰ä¼šæœ‰ç¼©æ”¾æ•ˆæžœ, å¹¶ä¸”é‡‡æ ·çŽ‡åŒæ—¶ä½œç”¨äºŽå®½/é«˜, è¿™å°†å¯¼è‡´ç¼©æ”¾åŽçš„å›¾ç‰‡ä»¥è¿™ä¸ªé‡‡æ ·çŽ‡çš„2æ¬¡æ–¹é€’å‡, å³å†…å­˜å ç”¨ç¼©æ”¾å¤§å°ä¸º1/(inSampleSizeçš„äºŒæ¬¡æ–¹). å¦‚æžœå°äºŽ1é‚£ä¹ˆç›¸å½“äºŽ=1çš„æ—¶å€™. åœ¨å®˜æ–¹æ–‡æ¡£ä¸­æŒ‡å‡º, inSampleSizeçš„å–å€¼åº”è¯¥æ€»æ˜¯ä¸º2çš„æŒ‡æ•°, æ¯”å¦‚1,2,4,8,16,32â€¦å¦‚æžœå¤–ç•Œä¼ é€’inSampleSizeä¸ä¸º2çš„æŒ‡æ•°, é‚£ä¹ˆç³»ç»Ÿä¼šå‘ä¸‹å–æ•´å¹¶é€‰æ‹©ä¸€ä¸ªæœ€æŽ¥è¿‘çš„2çš„æŒ‡æ•°æ¥ä»£æ›¿. æ¯”å¦‚å¦‚æžœinSampleSize=3,é‚£ä¹ˆç³»ç»Ÿä¼šé€‰æ‹©2æ¥ä»£æ›¿. ä½†æ˜¯è¿™æ¡è§„åˆ™å¹¶ä¸ä½œç”¨äºŽæ‰€æœ‰çš„androidç‰ˆæœ¬, æ‰€ä»¥å¯ä»¥å½“æˆä¸€ä¸ªå¼€å‘å»ºè®® æ•´ç†ä¸€ä¸‹å¼€å‘ä¸­ä»£ç æµç¨‹: å°†BitmapFactory.Optionsçš„inJustDecodeBoundså‚æ•°è®¾ç½®ä¸ºtrueå¹¶åŠ è½½å›¾ç‰‡. ä»ŽBitmapFactory.Optionså–å‡ºå›¾ç‰‡çš„åŽŸå§‹å®½é«˜ä¿¡æ¯, ä»–ä»¬å¯¹åº”äºŽoutWidthå’ŒoutHeightå‚æ•° æ ¹æ®é‡‡æ ·çŽ‡çš„è§„åˆ™å¹¶ç»“åˆç›®æ ‡Viewçš„æ‰€éœ€å¤§å°è®¡ç®—å‡ºé‡‡æ ·çŽ‡inSampleSize å°†BitmapFactory.Optionsçš„inJustDecodeBoundså‚æ•°è®¾ä¸ºfalse, ç„¶åŽé‡æ–°åŠ è½½. ç¬¬ä¸€ä¸ªæ­¥éª¤è®¾ç½®äº†ä¸€ä¸ªå‚æ•°, è¿™ä¸ªå‚æ•°çš„ä½œç”¨å°±æ˜¯åœ¨åŠ è½½å›¾ç‰‡çš„æ—¶å€™æ˜¯å¦åªæ˜¯åŠ è½½å›¾ç‰‡å®½é«˜ä¿¡æ¯è€Œä¸æŠŠå›¾ç‰‡å…¨éƒ¨åŠ è½½åˆ°å†…å­˜. æ‰€ä»¥è¿™ä¸ªæ“ä½œæ˜¯ä¸ªè½»é‡çº§çš„. é€šè¿‡è¿™äº›æ­¥éª¤å°±å¯ä»¥æ•´ç†å‡ºä»¥ä¸‹çš„å·¥å…·åŠ è½½å›¾ç‰‡ç±»è°ƒç”¨decodeFixedSizeForResource()å³å¯. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyBitmapLoadUtil &#123; /** * å¯¹ä¸€ä¸ªResourcesçš„èµ„æºæ–‡ä»¶è¿›è¡ŒæŒ‡å®šé•¿å®½æ¥åŠ è½½è¿›å†…å­˜, å¹¶æŠŠè¿™ä¸ªbitmapå¯¹è±¡è¿”å›ž * * @param res èµ„æºæ–‡ä»¶å¯¹è±¡ * @param resId è¦æ“ä½œçš„å›¾ç‰‡id * @param reqWidth æœ€ç»ˆæƒ³è¦å¾—åˆ°bitmapçš„å®½åº¦ * @param reqHeight æœ€ç»ˆæƒ³è¦å¾—åˆ°bitmapçš„é«˜åº¦ * @return è¿”å›žé‡‡æ ·ä¹‹åŽçš„bitmapå¯¹è±¡ */ public static Bitmap decodeFixedSizeForResource(Resources res, int resId, int reqWidth, int reqHeight)&#123; // é¦–å…ˆå…ˆæŒ‡å®šåŠ è½½çš„æ¨¡å¼ ä¸ºåªæ˜¯èŽ·å–èµ„æºæ–‡ä»¶çš„å¤§å° BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); //Calculate Size è®¡ç®—è¦è®¾ç½®çš„é‡‡æ ·çŽ‡ å¹¶æŠŠå€¼è®¾ç½®åˆ°optionä¸Š options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // å…³é—­åªåŠ è½½å±žæ€§æ¨¡å¼, å¹¶é‡æ–°åŠ è½½çš„æ—¶å€™ä¼ å…¥è‡ªå®šä¹‰çš„optionså¯¹è±¡ options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options); &#125; /** * ä¸€ä¸ªè®¡ç®—å·¥å…·ç±»çš„æ–¹æ³•, ä¼ å…¥å›¾ç‰‡çš„å±žæ€§å¯¹è±¡å’Œ æƒ³è¦å®žçŽ°çš„ç›®æ ‡å¤§å°. é€šè¿‡è®¡ç®—å¾—åˆ°é‡‡æ ·å€¼ */ private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; //Raw height and width of image //åŽŸå§‹å›¾ç‰‡çš„å®½é«˜å±žæ€§ final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; // å¦‚æžœæƒ³è¦å®žçŽ°çš„å®½é«˜æ¯”åŽŸå§‹å›¾ç‰‡çš„å®½é«˜å°é‚£ä¹ˆå°±å¯ä»¥è®¡ç®—å‡ºé‡‡æ ·çŽ‡, å¦åˆ™ä¸éœ€è¦æ”¹å˜é‡‡æ ·çŽ‡ if (reqWidth &lt; height || reqHeight &lt; width)&#123; int halfWidth = width/2; int halfHeight = height/2; // åˆ¤æ–­åŽŸå§‹é•¿å®½çš„ä¸€åŠæ˜¯å¦æ¯”ç›®æ ‡å¤§å°å°, å¦‚æžœå°é‚£ä¹ˆå¢žå¤§é‡‡æ ·çŽ‡2å€, ç›´åˆ°å‡ºçŽ°ä¿®æ”¹åŽåŽŸå§‹å€¼ä¼šæ¯”ç›®æ ‡å€¼å¤§çš„æ—¶å€™ while((halfHeight/inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth/inSampleSize) &gt;= reqWidth)&#123; inSampleSize *= 2; &#125; &#125; return inSampleSize; &#125;&#125; å½“ç»™ImageViewè®¾ç½®çš„æ—¶å€™ä¼ å…¥æŽ§ä»¶çš„å¤§å°, å°±ä¼šè‡ªåŠ¨è½¬æ¢è¿”å›ž. å¯ä»¥çœ‹ä¸€ä¸‹ä¸‹é¢çš„ä¸¤å¼ å›¾, å½“åŠ è½½ä¸€ä¸ªåˆ†è¾¨çŽ‡å¾ˆå¤§çš„å›¾ç‰‡å¦‚æžœä¸ä½¿ç”¨æ­¤æ–¹æ³•é‚£ä¹ˆå°±å‡ºç¨‹åºå´©æºƒ äº†è§£ä¸€ä¸‹ä¸€ä¸ªåŽŸå§‹å›¾ç‰‡åˆ°æ‰‹æœºæ˜¾ç¤ºçš„æœ€ç»ˆå ç”¨å†…å­˜å¤§å° Androidä¸­çš„ç¼“å­˜ç­–ç•¥ç›®å‰å¸¸ç”¨çš„ä¸€ç§ç¼“å­˜ç®—æ³•æ˜¯LRU(Least Recently Used), æœ€è¿‘æœ€å°‘ä½¿ç”¨ç®—æ³•. æ ¸å¿ƒæ€æƒ³: å½“ç¼“å­˜å­˜æ»¡æ—¶, ä¼šä¼˜å…ˆæ·˜æ±°é‚£äº›è¿‘æœŸæœ€å°‘ä½¿ç”¨çš„ç¼“å­˜å¯¹è±¡. é‡‡ç”¨LRUç®—æ³•çš„ç¼“å­˜æœ‰ä¸¤ç§: LruCacheå’ŒDiskLruCacheã€‚LruCacheç”¨äºŽå®žçŽ°å†…å­˜ç¼“å­˜, DiskLruCacheåˆ™å……å½“äº†å­˜å‚¨è®¾å¤‡ç¼“å­˜, å½“ç»„åˆä½¿ç”¨åŽå°±å¯ä»¥å®žçŽ°ä¸€ä¸ªç±»ä¼¼ImageLoaderè¿™æ ·çš„ç±»åº“. LruCacheLruCacheæ˜¯Android 3.1æ‰€æä¾›çš„ä¸€ä¸ªç¼“å­˜ç±», é€šè¿‡support-v4å…¼å®¹åŒ…å¯ä»¥å…¼å®¹åˆ°æ—©æœŸçš„Androidç‰ˆæœ¬ LruCacheæ˜¯ä¸€ä¸ªæ³›åž‹ç±», å®ƒå†…éƒ¨é‡‡ç”¨äº†ä¸€ä¸ªLinkedHashMapä»¥å¼ºå¼•ç”¨çš„æ–¹å¼å­˜å‚¨å¤–ç•Œçš„ç¼“å­˜å¯¹è±¡, å…¶æä¾›äº†getå’Œputæ–¹æ³•æ¥å®Œæˆç¼“å­˜çš„èŽ·å–å’Œæ·»åŠ çš„æ“ä½œ. å½“ç¼“å­˜æ»¡äº†æ—¶, LruCacheä¼šç§»é™¤è¾ƒæ—©ä½¿ç”¨çš„ç¼“å­˜å¯¹è±¡, ç„¶åŽåœ¨æ·»åŠ æ–°çš„ç¼“å­˜å¯¹è±¡. æ™®åŠä¸€ä¸‹å„ç§å¼•ç”¨çš„åŒºåˆ«: å¼ºå¼•ç”¨: ç›´æŽ¥çš„å¯¹è±¡å¼•ç”¨ è½¯å¼•ç”¨: å½“ä¸€ä¸ªå¯¹è±¡åªæœ‰è½¯å¼•ç”¨å­˜åœ¨æ—¶, ç³»ç»Ÿå†…å­˜ä¸è¶³æ—¶æ­¤å¯¹è±¡ä¼šè¢«gcå›žæ”¶ å¼±å¼•ç”¨: å½“ä¸€ä¸ªå¯¹è±¡åªæœ‰å¼±å¼•ç”¨å­˜åœ¨æ—¶, å¯¹è±¡ä¼šéšä¸‹ä¸€æ¬¡gcæ—¶è¢«å›žæ”¶ åˆ›å»ºçš„ç¼“å­˜å¯¹è±¡å¤§å°é€šè¿‡å¯ç”¨å†…å­˜çš„1/8æ¥è¿›è¡Œåˆ†é…, å¹¶éœ€è¦é‡å†™sizeOf()æ–¹æ³•, sizeOf()æ˜¯è®¡ç®—ç¼“å­˜å¯¹è±¡çš„å¤§å°, å¦‚æžœæœ‰éœ€è¦è¿˜å¯ä»¥é‡å†™entryRemoved(),åœ¨Lruç§»é™¤æ—§ç¼“å­˜çš„æ—¶å€™å›žè°ƒç”¨æ­¤æ–¹æ³•. 12345678int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);int cacheSize = maxMemory / 8;mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @override protected int sizeof(String key, Bitmap bitmap) &#123; return bitmap.getRowBytes() * bitmap.getHeight() / 1024; &#125;&#125; èŽ·å–ã€æ·»åŠ ã€ åˆ é™¤ä¸€ä¸ªç¼“å­˜å¯¹è±¡ï¼š 123mMemoryCache.get(key);mMemoryCache.put(key);mMemoryCache.remove(key); DiskLruCacheDiskLruCacheç”¨äºŽå®žçŽ°å­˜å‚¨è®¾å¤‡ç¼“å­˜, å³ç£ç›˜ç¼“å­˜. å®ƒé€šè¿‡å°†ç¼“å­˜å¯¹è±¡å†™å…¥æ–‡ä»¶ç³»ç»Ÿä»Žè€Œå®žçŽ°ç¼“å­˜çš„æ•ˆæžœ. å‚è€ƒï¼š Android DiskLruCacheå®Œå…¨è§£æžï¼Œç¡¬ç›˜ç¼“å­˜çš„æœ€ä½³æ–¹æ¡ˆ 1. DiskLruCacheçš„åˆ›å»º DiskLruCacheå¹¶ä¸èƒ½é€šè¿‡æž„é€ æ–¹æ³•æ¥åˆ›å»º, ä»–æä¾›äº†open()æ–¹æ³•ç”¨äºŽåˆ›å»ºè‡ªèº«, å¦‚ä¸‹æ‰€ç¤º 1public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) è¿™ä¸ªæ–¹æ³•æœ‰å››ä¸ªå‚æ•°: File directory: è¡¨ç¤ºç£ç›˜ç¼“å­˜åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„å­˜å‚¨è·¯å¾„. å¯ä»¥é€‰æ‹©SDå¡ä¸Šçš„ç¼“å­˜ç›®å½•, å…·ä½“æ˜¯æŒ‡/sdcard/Andriod/data/package_name/cacheç›®å½•, package_nameè¡¨ç¤ºå½“å‰åº”ç”¨çš„åŒ…å, å½“åº”ç”¨è¢«å¸è½½åŽ, æ­¤ç›®å½•ä¼šä¸€å¹¶åˆ é™¤æŽ‰. ä¹Ÿå¯ä»¥é€‰æ‹©dataç›®å½•ä¸‹. æˆ–è€…å…¶ä»–åœ°æ–¹. è¿™é‡Œç»™å‡ºçš„å»ºè®®:å¦‚æžœåº”ç”¨å¸è½½åŽå°±å¸Œæœ›åˆ é™¤ç¼“å­˜æ–‡ä»¶çš„è¯ , é‚£ä¹ˆå°±é€‰æ‹©SDå¡ä¸Šçš„ç¼“å­˜ç›®å½•, å¦‚æžœå¸Œæœ›ä¿ç•™ç¼“å­˜æ•°æ®é‚£å°±åº”è¯¥é€‰æ‹©SDå¡ä¸Šçš„å…¶ä»–ç›®å½•. int appVersion: è¡¨ç¤ºåº”ç”¨çš„ç‰ˆæœ¬å·, ä¸€èˆ¬è®¾ä¸º1å³å¯. å½“ç‰ˆæœ¬å·å‘ç”Ÿæ”¹å˜çš„æ—¶å€™DiskLruCacheä¼šæ¸…ç©ºä¹‹å‰æ‰€æœ‰çš„ç¼“å­˜æ–‡ä»¶, åœ¨å®žé™…å¼€å‘ä¸­è¿™ä¸ªå®žç”¨æ€§ä¸å¤§. int valueCount: è¡¨ç¤ºå•ä¸ªèŠ‚ç‚¹æ‰€å¯¹åº”çš„æ•°æ®çš„ä¸ªæ•°, ä¸€èˆ¬è®¾ä¸º1. long maxSize: è¡¨ç¤ºç¼“å­˜çš„æ€»å¤§å°, æ¯”å¦‚50MB, å½“ç¼“å­˜å¤§å°è¶…å‡ºè¿™ä¸ªè®¾å®šå€¼åŽ, DiskLruCacheä¼šæ¸…é™¤ä¸€äº›ç¼“å­˜è€Œä¿è¯æ€»å¤§å°ä¸å¤§äºŽè¿™ä¸ªè®¾å®šå€¼. 2. DiskLruCacheçš„ç¼“å­˜æ·»åŠ  DiskLruCacheçš„ç¼“å­˜æ·»åŠ çš„æ“ä½œæ˜¯é€šè¿‡Editorå®Œæˆçš„, Editorè¡¨ç¤ºä¸€ä¸ªç¼“å­˜å¯¹è±¡çš„ç¼–è¾‘å¯¹è±¡. å¦‚æžœè¿˜æ˜¯ç¼“å­˜å›¾ç‰‡ä¸ºä¾‹å­, æ¯ä¸€å¼ å›¾ç‰‡éƒ½é€šè¿‡å›¾ç‰‡çš„urlä¸ºkey, è¿™é‡Œç”±äºŽurlå¯èƒ½ä¼šæœ‰ç‰¹æ®Šå­—ç¬¦æ‰€ä»¥é‡‡ç”¨urlçš„md5å€¼ä½œä¸ºkey. æ ¹æ®è¿™ä¸ªkeyå°±å¯ä»¥é€šè¿‡edit()æ¥èŽ·å–Editorå¯¹è±¡, å¦‚æžœè¿™ä¸ªç¼“å­˜å¯¹è±¡æ­£åœ¨è¢«ç¼–è¾‘, é‚£ä¹ˆedit()å°±ä¼šè¿”å›žnull. å³DiskLruCacheä¸å…è®¸åŒæ—¶ç¼–è¾‘ä¸€ä¸ªç¼“å­˜å¯¹è±¡. å½“ç”¨.edit(key)èŽ·å¾—äº†Editorå¯¹è±¡ä¹‹åŽ. é€šè¿‡editor.newOutputStream(0)å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªæ–‡ä»¶è¾“å‡ºæµ. ç”±äºŽä¹‹å‰open()æ–¹æ³•è®¾ç½®äº†ä¸€ä¸ªèŠ‚ç‚¹åªèƒ½æœ‰ä¸€ä¸ªæ•°æ®. æ‰€ä»¥åœ¨èŽ·å¾—è¾“å‡ºæµçš„æ—¶å€™ä¼ å…¥å¸¸é‡0å³å¯. æœ‰äº†æ–‡ä»¶è¾“å‡ºæµ, å¯ä»¥å½“ç½‘ç»œä¸‹è½½å›¾ç‰‡æ—¶, å›¾ç‰‡å°±å¯ä»¥é€šè¿‡è¿™ä¸ªæ–‡ä»¶è¾“å‡ºæµå†™å…¥åˆ°æ–‡ä»¶ç³»ç»Ÿä¸Š. åˆ«å¿˜äº†ä½¿ç”¨Bufferedxxxxxå†™å®Œä¹‹åŽ, è¦é€šè¿‡Editorä¸­commit()æ¥æäº¤å†™æ“ä½œ, å¦‚æžœä¸‹è½½ä¸­å‘ç”Ÿå¼‚å¸¸, é‚£ä¹ˆä½¿ç”¨Editorä¸­abort()æ¥å›žé€€æ•´ä¸ªæ“ä½œ. 3. DiskLruCacheçš„ç¼“å­˜æŸ¥æ‰¾ å’Œç¼“å­˜çš„æ·»åŠ è¿‡ç¨‹ç±»ä¼¼, ç¼“å­˜æŸ¥æ‰¾è¿‡ç¨‹ä¹Ÿéœ€è¦å°†urlè½¬æ¢æˆkey, ç„¶åŽé€šè¿‡DiskLruCache#get()æ–¹æ³•å¯ä»¥å¾—åˆ°ä¸€ä¸ªSnapshotå¯¹è±¡, æŽ¥ç€åœ¨é€šè¿‡Snapshotå¯¹è±¡å³å¯å¾—åˆ°ç¼“å­˜çš„æ–‡ä»¶è¾“å…¥æµ, æœ‰äº†æ–‡ä»¶è¾“å…¥æµ, è‡ªç„¶å°±å¯ä»¥å¾—åˆ°Bitmapå¯¹è±¡. ä¸ºäº†é¿å…åŠ è½½å›¾ç‰‡å‡ºçŽ°OOMæ‰€ä»¥é‡‡ç”¨åŽ‹ç¼©çš„æ–¹å¼. åœ¨å‰é¢å¯¹BitmapFactory.Optionsçš„ä½¿ç”¨è¯´æ˜Žäº†. ä½†æ˜¯è¿™ä¸­æ–¹æ³•å¯¹FileInputStreamçš„ç¼©æ”¾å­˜åœ¨é—®é¢˜. åŽŸå› æ˜¯FileInputStreamæ˜¯ä¸€ç§æœ‰åºçš„æ–‡ä»¶æµ, è€Œä¸¤æ¬¡decodeStreamè°ƒç”¨ä¼šå½±å“æ–‡ä»¶çš„ä½ç½®å±žæ€§, è¿™æ ·åœ¨ç¬¬äºŒæ¬¡decodeStreamçš„æ—¶å€™å¾—åˆ°çš„ä¼šæ˜¯null. é’ˆå¯¹è¿™ä¸€ä¸ªé—®é¢˜, å¯ä»¥é€šè¿‡æ–‡ä»¶æµæ¥å¾—åˆ°å®ƒæ‰€å¯¹åº”çš„æ–‡ä»¶æè¿°ç¬¦, ç„¶åŽé€šè¿‡BitmapFactory.decodeFileDescription()æ¥åŠ è½½ä¸€å¼ ç¼©æ”¾åŽçš„å›¾ç‰‡. ImageLoaderçš„å®žçŽ°ä¸€ä¸ªå¥½çš„ImageLoaderåº”è¯¥å…·å¤‡ä»¥ä¸‹å‡ ç‚¹: å›¾ç‰‡çš„åŽ‹ç¼© ç½‘ç»œæ‹‰å– å†…å­˜ç¼“å­˜ ç£ç›˜ç¼“å­˜ å›¾ç‰‡çš„åŒæ­¥åŠ è½½ å›¾ç‰‡çš„å¼‚æ­¥åŠ è½½ ä¹Ÿå¯ä»¥åˆ©ç”¨picassoå’Œglideè¿™ç§å›¾ç‰‡åŠ è½½ç±»åº“, ä½¿ç”¨æž„å»ºè€…æ¨¡å¼æä¾›ä½¿ç”¨. æœ¬æ–‡ç»ƒä¹ demoå®žçŽ°äº†é“¾å¼è°ƒç”¨è®¾ç½®æŽ§ä»¶,å¹¶åˆ¶å®šurlç„¶åŽè‡ªåŠ¨åŽ»èŽ·å–. ç›¸å…³è”çš„ç±»åœ¨loadåŒ…ä¸­ å¯ä»¥çœ‹çœ‹æœ‰äº†ç¼“å­˜çš„åŒºåˆ« ImageLoaderçš„ä½¿ç”¨ç…§ç‰‡å¢™æ•ˆæžœè¿™é‡Œå®šä¹‰ä¸€ä¸ªè‡ªå®šä¹‰çš„ImageViewä½œä¸ºGridViewçš„itemå¸ƒå±€æŽ§ä»¶, ä¹‹æ‰€ä»¥è¿™æ ·æ˜¯æƒ³è®©å›¾ç‰‡çš„æŽ§ä»¶è‡ªåŠ¨åŽ»ä½¿ç”¨è®¾å¤‡è¾¾åˆ°å®½é«˜ç›¸ç­‰çš„æ•ˆæžœæ¯”è¾ƒå¥½çœ‹äº› 1234567891011121314151617181920public class SquareImageView extends ImageView &#123; public SquareImageView(Context context) &#123; super(context); &#125; public SquareImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // ç”±äºŽè¿™é‡Œå‡†å¤‡æä¾›ç»™GridViewæŽ§ä»¶ä½¿ç”¨, å¯¹äºŽä¸€ä¸ªæ°´å¹³çº¿æœ‰å‡ ä¸ªæ˜¯æœªçŸ¥çš„ // é‚£ä¹ˆé€šè¿‡çˆ¶æŽ§ä»¶çš„æµ‹é‡ä¼ åˆ°è¿™é‡Œçš„å®½åº¦è§„æ ¼, ä¹Ÿå½“åšé«˜åº¦å³å¯ super.onMeasure(widthMeasureSpec, widthMeasureSpec); &#125;&#125; è¿™ä¸ªå®žçŽ°å¾ˆç®€å•, åˆ©ç”¨åŠ¨æ€çš„å®½åº¦åŒæ—¶ä¹Ÿå½“åšé«˜åº¦å³å¯å®žçŽ°é¢„æœŸçš„æ•ˆæžœ. è¿™ä¸ªå°±æ˜¯ç»“æžœ, æˆ–è®¸åº”è¯¥å¯¹ç½‘ç»œåŠ ä¸Šåˆ¤æ–­éžwifiç»™ä¸€ä¸ªæç¤º, å¯èƒ½é¦–æ¬¡åŠ è½½ä¼šéœ€è¦æ¯”è¾ƒå¤šçš„æµé‡. 1234567891011121314151617181920212223242526272829303132333435 // æ ¹æ®è¿žæŽ¥ç½‘ç»œçš„æƒ…å†µåˆ¤æ–­æ˜¯å¦åŠ è½½å›¾ç‰‡if (!NetWorkUtil.isWifi(getApplicationContext())) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage("é¦–æ¬¡ä½¿ç”¨ä¼šä»Žæ‰‹æœºç½‘ç»œä¸‹è½½å›¾ç‰‡, æ˜¯å¦ç¡®è®¤ä¸‹è½½?") .setTitle("å‹æƒ…æç¤º") .setPositiveButton("å¥½çš„.", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; mCanLoadForPhoneNet = true; imageAdapter.notifyDataSetChanged(); &#125; &#125;) .setNegativeButton("ä¸è¡Œ!", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(getApplicationContext(), "çž…ä½ æ‰£é‚£æ ·!!!", Toast.LENGTH_LONG).show(); &#125; &#125;).show();&#125;else&#123; mCanLoadForPhoneNet = true;&#125;// NetWorkUtilç±»public class NetWorkUtil &#123; public static boolean isWifi(Context context) &#123; ConnectivityManager connectivityManager = (ConnectivityManager) context .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetInfo = connectivityManager.getActiveNetworkInfo(); if (activeNetInfo != null &amp;&amp; activeNetInfo.getType() == ConnectivityManager.TYPE_WIFI) &#123; return true; &#125; return false; &#125;&#125; ç„¶åŽä¼˜åŒ–åˆ—è¡¨ åªæœ‰åœ¨GridViewé™æ­¢çš„æ—¶å€™æ‰è¿›è¡Œå›¾ç‰‡åŠ è½½, é¿å…æ»‘åŠ¨æ—¶å€™çš„æ— è°“çš„çº¿ç¨‹åŠ è½½æ¶ˆè€—(å³ä½¿ImageLoaderå†…éƒ¨ä½¿ç”¨äº†çº¿ç¨‹æ± , ä½ ä»ç„¶æœ‰è¿™ä¹ˆåšçš„å¿…è¦) 12345678910111213141516171819GridView gv_main = (GridView) findViewById(R.id.gv_main);// ç›‘å¬GridViewçš„æ»‘åŠ¨çŠ¶æ€ gv_main.setOnScrollListener(new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE)&#123; mIsGridViewIdle = true; // å¹¶è§¦å‘æ›´æ–°adapter imageAdapter.notifyDataSetChanged(); &#125;else&#123; mIsGridViewIdle = false; &#125; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; &#125; &#125;); æœ€åŽåœ¨adapterä¸­çš„getView()è®¾ç½®æ ‡è®°ä½çš„åˆ¤æ–­, åªæœ‰åœ¨wifiå’Œé™æ­¢çš„çŠ¶æ€ä¸‹æ‰è¿›è¡ŒåŠ è½½è¯·æ±‚ä¸‹é¢æ˜¯getView()ä»£ç  123456789101112131415161718192021222324252627@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null)&#123; convertView = View.inflate(mContext, R.layout.item_photo_wall, null); holder = new ViewHolder(); holder.mImageView = (ImageView) convertView.findViewById(R.id.iv_square); convertView.setTag(holder); &#125;else&#123; holder = (ViewHolder) convertView.getTag(); &#125; // è®¾ç½®é»˜è®¤å›¾ç‰‡ ImageView mImageView = holder.mImageView; mImageView.setImageResource(android.R.drawable.screen_background_dark_transparent); // æ£€æµ‹æ˜¯å¦wifi å’Œ æ˜¯å¦æ˜¯æ»‘åŠ¨çŠ¶æ€ // ä¼˜åŒ–é‡ç‚¹ if (mCanLoadForPhoneNet &amp;&amp; mIsGridViewIdle)&#123; // åŠ è½½å›¾ç‰‡ mImageLoader.setImageView(mImageView).url(mUrls.get(position)); &#125; return convertView;&#125;]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
        <tag>å›¾ç‰‡ç¼“å­˜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FutureTask & Callable]]></title>
    <url>%2F2018%2F03%2F19%2FCallable%E5%92%8CFutureTask%2F</url>
    <content type="text"><![CDATA[åœ¨é˜…è¯»AsyncTaskæºç æ—¶å€™ï¼Œæœ‰çœ‹åˆ°FutureTaskçš„æ¦‚å¿µï¼Œå½“æ—¶åªçŸ¥é“å®ƒä¸Žçº¿ç¨‹åˆ›å»ºæœ‰å…³ç³»ã€‚ä»Šå¤©æ¥æŽ¢ç©¶ä¸€ä¸‹å®ƒçš„æºç ç»“æž„ã€‚ åŒæ—¶ä¹Ÿæœ‰ä¸€äº›é¢è¯•é¢˜ï¼Œè¯¢é—®Javaä¸­åˆ›å»ºçº¿ç¨‹çš„å‡ ç§æ–¹å¼ï¼Œé™¤äº†Threadå’ŒRunnableä¹‹å¤–ï¼Œæåˆ°äº†Callableçš„æ¦‚å¿µã€‚æœ¬æ–‡é‡ç‚¹åˆ†æžä¸€ä¸‹è¿™ä¸¤ä¸ªæ¦‚å¿µçš„ç”¨æ³•ã€‚ Runnableç‚¹è¿›åŽ»çœ‹ä¸€ä¸‹RunnableæŽ¥å£çš„å®šä¹‰ï¼š 1234 @FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; Runnableçš„ä»£ç éžå¸¸ç®€å•ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŽ¥å£ä¸”åªæœ‰ä¸€ä¸ªrun()ï¼Œåˆ›å»ºä¸€ä¸ªç±»å®žçŽ°å®ƒï¼ŒæŠŠä¸€äº›è´¹æ—¶æ“ä½œå†™åœ¨å…¶ä¸­ï¼Œç„¶åŽä½¿ç”¨æŸä¸ªçº¿ç¨‹åŽ»æ‰§è¡Œè¯¥Runnableå®žçŽ°ç±»å³å¯å®žçŽ°å¤šçº¿ç¨‹ã€‚ Callableè·Ÿç€IDEä¸­çš„æºç è¿›å…¥åˆ°Callableçš„å£°æ˜Žä¸­äº†è§£ä¸€ä¸‹å…¶ç»“æž„ï¼š 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Callableçš„ä»£ç ä¹Ÿéžå¸¸ç®€å•ï¼Œä¸åŒçš„æ˜¯å®ƒæ˜¯ä¸€ä¸ªæ³›åž‹æŽ¥å£ï¼Œcall()å‡½æ•°è¿”å›žçš„ç±»åž‹å°±æ˜¯åˆ›å»ºCallableä¼ è¿›æ¥çš„Vç±»åž‹ã€‚Callableä¸ŽRunnableçš„åŠŸèƒ½å¤§è‡´ç›¸ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯Callableåœ¨çº¿ç¨‹æ‰§è¡Œå®ŒåŽï¼Œå¯ä»¥è¿”å›žå€¼ï¼Œå¹¶ä¸”èƒ½æŠ›å‡ºå¼‚å¸¸ã€‚ FutureFutureæ ¹æ®æºä»£ç è§£é‡Šå…¶ä½œç”¨æ˜¯å¯¹Callableæˆ–è€…Runnableè¿›è¡Œç®¡ç†ï¼Œå–æ¶ˆã€æ£€æµ‹å®Œæˆä¸Žå¦èŽ·å–æœ€ç»ˆç»“æžœç­‰ã€‚ 123456789public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; cancelæ–¹æ³•ç”¨æ¥å–æ¶ˆä»»åŠ¡ï¼Œå¦‚æžœå–æ¶ˆä»»åŠ¡æˆåŠŸåˆ™è¿”å›žtrueï¼Œå¦‚æžœå–æ¶ˆä»»åŠ¡å¤±è´¥åˆ™è¿”å›žfalseã€‚å‚æ•°mayInterruptIfRunningè¡¨ç¤ºæ˜¯å¦å…è®¸å–æ¶ˆæ­£åœ¨æ‰§è¡Œå´æ²¡æœ‰æ‰§è¡Œå®Œæ¯•çš„ä»»åŠ¡ï¼Œå¦‚æžœè®¾ç½®trueï¼Œåˆ™è¡¨ç¤ºå¯ä»¥å–æ¶ˆæ­£åœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­çš„ä»»åŠ¡ã€‚å¦‚æžœä»»åŠ¡å·²ç»å®Œæˆï¼Œåˆ™æ— è®ºmayInterruptIfRunningä¸ºtrueè¿˜æ˜¯falseï¼Œæ­¤æ–¹æ³•è‚¯å®šè¿”å›žfalseï¼Œå³å¦‚æžœå–æ¶ˆå·²ç»å®Œæˆçš„ä»»åŠ¡ä¼šè¿”å›žfalseï¼›å¦‚æžœä»»åŠ¡æ­£åœ¨æ‰§è¡Œï¼Œè‹¥mayInterruptIfRunningè®¾ç½®ä¸ºtrueï¼Œåˆ™è¿”å›žtrueï¼Œè‹¥mayInterruptIfRunningè®¾ç½®ä¸ºfalseï¼Œåˆ™è¿”å›žfalseï¼›å¦‚æžœä»»åŠ¡è¿˜æ²¡æœ‰æ‰§è¡Œï¼Œåˆ™æ— è®ºmayInterruptIfRunningä¸ºtrueè¿˜æ˜¯falseï¼Œè‚¯å®šè¿”å›žtrueã€‚ isCancelledæ–¹æ³•è¡¨ç¤ºä»»åŠ¡æ˜¯å¦è¢«å–æ¶ˆæˆåŠŸï¼Œå¦‚æžœåœ¨ä»»åŠ¡æ­£å¸¸å®Œæˆå‰è¢«å–æ¶ˆæˆåŠŸï¼Œåˆ™è¿”å›ž trueã€‚ isDoneæ–¹æ³•è¡¨ç¤ºä»»åŠ¡æ˜¯å¦å·²ç»å®Œæˆï¼Œè‹¥ä»»åŠ¡å®Œæˆï¼Œåˆ™è¿”å›žtrueï¼› get()æ–¹æ³•ç”¨æ¥èŽ·å–æ‰§è¡Œç»“æžœï¼Œè¿™ä¸ªæ–¹æ³•ä¼šäº§ç”Ÿé˜»å¡žï¼Œä¼šä¸€ç›´ç­‰åˆ°ä»»åŠ¡æ‰§è¡Œå®Œæ¯•æ‰è¿”å›žï¼› get(long timeout, TimeUnit unit) èŽ·å–å¼‚æ­¥æ‰§è¡Œç»“æžœï¼Œå¦‚æžœæ²¡æœ‰ç»“æžœå¯ç”¨ï¼Œæ­¤æ–¹æ³•ä¼šé˜»å¡žï¼Œä½†æ˜¯ä¼šæœ‰æ—¶é—´é™åˆ¶ï¼Œå¦‚æžœé˜»å¡žæ—¶é—´è¶…è¿‡è®¾å®šçš„timeoutæ—¶é—´ï¼Œè¯¥æ–¹æ³•å°†æŠ›å‡ºå¼‚å¸¸ã€‚ â€‹ Futureå’ŒCallableçš„åŸºæœ¬ç”¨æ³•123456789101112131415161718192021class MyCallable implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; System.out.println("åšä¸€äº›è€—æ—¶çš„ä»»åŠ¡..."); Thread.sleep(5000); return "OK"; &#125;&#125;public class FutureSimpleDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable()); System.out.println("dosomething..."); System.out.println("å¾—åˆ°å¼‚æ­¥ä»»åŠ¡è¿”å›žç»“æžœï¼š" + future.get()); System.out.println("Completed!"); &#125;&#125; ä¸Šé¢æ˜¯FutureåŸºæœ¬ç”¨æ³•çš„ä»£ç ä»¥åŠå¹¶è¿è¡Œï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼š çº¿ç¨‹æ˜¯å±žäºŽå¼‚æ­¥è®¡ç®—æ¨¡åž‹ï¼Œæ‰€ä»¥ä½ ä¸å¯èƒ½ç›´æŽ¥ä»Žåˆ«çš„çº¿ç¨‹ä¸­å¾—åˆ°æ–¹æ³•è¿”å›žå€¼ã€‚ è¿™æ—¶å€™ï¼ŒFutureå°±å‡ºåœºäº†ã€‚ Futrueå¯ä»¥ç›‘è§†ç›®æ ‡çº¿ç¨‹è°ƒç”¨callçš„æƒ…å†µï¼Œå½“ä½ è°ƒç”¨Futureçš„get()æ–¹æ³•ä»¥èŽ·å¾—ç»“æžœæ—¶ï¼Œå½“å‰çº¿ç¨‹å°±å¼€å§‹é˜»å¡žï¼Œç›´æŽ¥callæ–¹æ³•ç»“æŸè¿”å›žç»“æžœã€‚ Futureå¼•ç”¨å¯¹è±¡æŒ‡å‘çš„å®žé™…æ˜¯FutureTaskã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œæ€»ç»“ä¸€å¥è¯ï¼ŒFutureå¯ä»¥å¾—åˆ°åˆ«çš„çº¿ç¨‹ä»»åŠ¡æ–¹æ³•çš„è¿”å›žå€¼ã€‚ FutureTaskæŽ¥ä¸‹æ¥é‡ç‚¹çœ‹ä¸€ä¸‹ç¤ºä¾‹ä¸­taskçš„åŒ…è£…ç±»FutureTaskã€‚å¦‚ä¸‹æ‰€ç¤ºå‘çŽ°RutureTaskæ˜¯å®žçŽ°RunnableFutureæŽ¥å£çš„ä¸€ä¸ªç±»ï¼š 1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; è€Œè¿™ä¸ªRunnableFutureæŽ¥å£ç»“æž„ï¼š 1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; FutureTaskæž„é€ æ–¹æ³• 123456public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; 1234public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; åœ¨è¿™é‡Œæˆ‘ä»¬å¯ä»¥äº†è§£åˆ°ï¼š FutureTaskæœ€ç»ˆéƒ½æ˜¯æ‰§è¡ŒCallableç±»åž‹çš„ä»»åŠ¡ã€‚ å¦‚æžœæž„é€ å‡½æ•°å‚æ•°æ˜¯Runnableï¼Œä¼šè¢«Executors.callableæ–¹æ³•è½¬æ¢ä¸ºCallableç±»åž‹ã€‚ æŽ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹Executors.callableæ–¹æ³•ä»£ç  12345public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125; ä»£ç å¾ˆç®€å•ï¼Œç›´æŽ¥è¿”å›žä¸€ä¸ªRunnableAdapterå®žä¾‹ã€‚ æŽ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹RunnableAdapteræ–¹æ³•ä»£ç  123456789101112131415/** * A callable that runs given task and returns given result */static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125;&#125; å¯ä»¥äº†è§£åˆ°ï¼š RunnableAdapteræ˜¯Excutorsçš„ä¸€ä¸ªé™æ€å†…éƒ¨ç±»å¹¶ä¸”å®žçŽ°äº†Callableï¼Œä¹Ÿå°±æ˜¯è¯´RunnableAdapteræ˜¯Callableå­ç±»ã€‚ callæ–¹æ³•å®žçŽ°ä»£ç æ˜¯ï¼Œæ‰§è¡ŒRunnableçš„runæ–¹æ³•ï¼Œå¹¶è¿”å›žæž„é€ FutureTaskä¼ å…¥resultå‚æ•°ã€‚ FutureTaskæ€»ç»“FutureTaskå®žçŽ°äº†ä¸¤ä¸ªæŽ¥å£ï¼ŒRunnableå’ŒFutureï¼Œæ‰€ä»¥å®ƒæ—¢å¯ä»¥ä½œä¸ºRunnableè¢«çº¿ç¨‹æ‰§è¡Œï¼Œåˆå¯ä»¥ä½œä¸ºFutureå¾—åˆ°Callableçš„è¿”å›žå€¼ï¼Œé‚£ä¹ˆè¿™ä¸ªç»„åˆçš„ä½¿ç”¨æœ‰ä»€ä¹ˆå¥½å¤„å‘¢ï¼Ÿå‡è®¾æœ‰ä¸€ä¸ªå¾ˆè´¹æ—¶é€»è¾‘éœ€è¦è®¡ç®—å¹¶ä¸”è¿”å›žè¿™ä¸ªå€¼ï¼ŒåŒæ—¶è¿™ä¸ªå€¼ä¸æ˜¯é©¬ä¸Šéœ€è¦ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨è¿™ä¸ªç»„åˆï¼Œç”¨å¦ä¸€ä¸ªçº¿ç¨‹åŽ»è®¡ç®—è¿”å›žå€¼ï¼Œè€Œå½“å‰çº¿ç¨‹åœ¨ä½¿ç”¨è¿™ä¸ªè¿”å›žå€¼ä¹‹å‰å¯ä»¥åšå…¶å®ƒçš„æ“ä½œï¼Œç­‰åˆ°éœ€è¦è¿™ä¸ªè¿”å›žå€¼æ—¶ï¼Œå†é€šè¿‡Futureå¾—åˆ°ï¼ FutureTaskåŸºæœ¬ç”¨æ³• 12345678910111213141516171819public class CallableAndFuture &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; public Integer call() throws Exception &#123; return new Random().nextInt(100); &#125; &#125;; FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable); new Thread(future).start(); try &#123; Thread.sleep(3000);// ä¸»çº¿ç¨‹å¯èƒ½åšä¸€äº›äº‹æƒ… System.out.println(future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ç»“åˆçº¿ç¨‹æ± ä½¿ç”¨12345678910111213141516171819202122232425262728293031323334public class FutureTaskDemo &#123; public static void main(String[] args) &#123; // åˆ›å»ºä¸€ä¸ªExecutorServiceå¯¹è±¡ ExecutorService executor = Executors.newCachedThreadPool(); // new ä¸€ä¸ªCallableå®žä¾‹ Task task = new Task(); // newä¸€ä¸ª FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task); // æäº¤futureTaskå¯¹è±¡è¿›å…¥çº¿ç¨‹æ±  executor.submit(futureTask); // å…³é—­çº¿ç¨‹æ±  executor.shutdown(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println("ä¸»çº¿ç¨‹åœ¨æ‰§è¡Œä»»åŠ¡"); try &#123; // èŽ·å–futuretaskç»“æžœ System.out.println("taskè¿è¡Œç»“æžœ" + futureTask.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println("æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæ¯•"); &#125;&#125; åŒæ—¶å®šä¹‰ä¸€ä¸ªå®žçŽ°CallableæŽ¥å£çš„Taskç±»å¦‚ä¸‹æ‰€ç¤ºï¼š 1234567891011public static class Task implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println("å­çº¿ç¨‹åœ¨è¿›è¡Œè®¡ç®—"); Thread.sleep(3000); int sum = 0; for (int i = 0; i &lt; 100; i++) sum += i; return sum; &#125; &#125; ç»“æžœè¾“å‡ºï¼š 1234å­çº¿ç¨‹åœ¨è¿›è¡Œè®¡ç®—ä¸»çº¿ç¨‹åœ¨æ‰§è¡Œä»»åŠ¡taskè¿è¡Œç»“æžœ4950æ‰€æœ‰ä»»åŠ¡æ‰§è¡Œå®Œæ¯• ä»ŽFutureTaskç”¨æ³•ä»¥åŠè¿”å›žçš„ç»“æžœå¯è§FutureTaskæ˜¯å¯ä»¥åŽ»æ‰§è¡ŒCallableçš„ï¼Œå¹¶ä¸”Callableç‹¬ç«‹çš„çº¿ç¨‹å¯ä»¥è¿”å›žè‡ªå·±çš„æ‰§è¡Œç»“æžœã€‚]]></content>
      <categories>
        <category>å¤šçº¿ç¨‹</category>
      </categories>
      <tags>
        <tag>Callable</tag>
        <tag>FutureTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Androidçš„çº¿ç¨‹å’Œçº¿ç¨‹æ± ]]></title>
    <url>%2F2018%2F03%2F15%2FAndroid%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[ç¬¬11ç« : ä¸ä»…ä»…æ˜¯åœ¨Androidä¸­, å°±ç®—javaä¸­çº¿ç¨‹éƒ½æ˜¯ä¸€å—å¾ˆé‡è¦çš„çŸ¥è¯†, å æœ‰ä¸å°çš„æ¯”é‡. é™¤äº†æœ€å¸¸ä½¿ç”¨çš„Threadä¹‹å¤–, åœ¨Androidä¹‹ä¸­å¯ä»¥æ‰®æ¼”çº¿ç¨‹è§’è‰²çš„è¿˜æœ‰å¾ˆå¤š: å¦‚AsyncTaskå’ŒIntentService, åŒæ—¶HandlerThreadä¹Ÿæ˜¯ä¸€ç§ç‰¹æ®Šçš„çº¿ç¨‹. è™½ç„¶è¿™äº›çº¿ç¨‹çš„è¡¨çŽ°å½¢å¼æœ‰åˆ«äºŽåŸºç¡€çº¿ç¨‹. ä½†æ˜¯æœ¬è´¨ä¸Šè¿˜æ˜¯ä¼ ç»Ÿçš„çº¿ç¨‹. ä¾‹å¦‚AsyncTaskå®ƒçš„åº•å±‚ä½¿ç”¨äº†çº¿ç¨‹æ± . è€Œå¯¹äºŽIntentServiceå’ŒHandlerThreadæ¥è¯´, ä»–ä»¬çš„åº•å±‚åˆ™ç›´æŽ¥ä½¿ç”¨äº†çº¿ç¨‹. æ ¹æ®ä¸åŒçš„ç‰¹æ€§æ¥å®žçŽ°ä¸åŒçš„åœºæ™¯ AsyncTask: å°è£…äº†çº¿ç¨‹æ± å’ŒHandler, å®ƒä¸»è¦æ˜¯ä¸ºäº†æ–¹ä¾¿å¼€å‘è€…åœ¨å­çº¿ç¨‹ä¸­æ›´æ–°UI. HandlerThread: æ˜¯ä¸€ç§å…·æœ‰æ¶ˆæ¯å¾ªçŽ¯çš„çº¿ç¨‹, åœ¨å®ƒçš„å†…éƒ¨å¯ä»¥ä½¿ç”¨Handler. IntentService: æ˜¯ä¸€ä¸ªæœåŠ¡, ç³»ç»Ÿå¯¹å…¶è¿›è¡Œäº†å°è£…ä½¿å…¶å¯ä»¥æ›´æ–¹ä¾¿åœ°æ‰§è¡ŒåŽå°ä»»åŠ¡, IntentServiceå†…éƒ¨é‡‡ç”¨äº†HandlerThreadæ¥æ‰§è¡Œä»»åŠ¡, å½“ä»»åŠ¡æ‰§è¡Œå®Œæ¯•åŽIntentServiceä¼šè‡ªåŠ¨é€€å‡º. ä»Žæ‰§è¡Œä»»åŠ¡çš„è§’åº¦æ¥çœ‹, æ›´åƒä¸€ä¸ªåŽå°çš„çº¿ç¨‹. ä½†æ˜¯å› ä¸ºå…¶æœ¬èº«æ˜¯ä¸€ç§æœåŠ¡, æ‰€ä»¥å¯¼è‡´ä¸å®¹æ˜“è¢«ç³»ç»Ÿæ€æ­»ä»Žè€Œä¿è¯ä»»åŠ¡çš„æ‰§è¡Œ. è€Œå¦‚æžœæ˜¯ä¸€ä¸ªåŽå°çº¿ç¨‹, ç”±äºŽè¿™ä¸ªæ—¶å€™è¿›è¡Œä¸­æ²¡æœ‰æ´»åŠ¨çš„å››å¤§ç»„ä»¶, é‚£ä¹ˆè¿™ä¸ªè¿›ç¨‹çš„ä¼˜å…ˆçº§ä¼šå¾ˆä½Ž, å¾ˆå®¹æ˜“è¢«ç³»ç»Ÿæ€æ­», è¿™å°±æ˜¯IntentServiceçš„ä¼˜ç‚¹. çº¿ç¨‹çš„ç®€å•æ¦‚è¿° åœ¨æ“ä½œç³»ç»Ÿä¸­, çº¿ç¨‹æ˜¯æ“ä½œç³»ç»Ÿè°ƒåº¦çš„æœ€å°å•å…ƒ, åŒæ—¶çº¿ç¨‹åˆæ˜¯ä¸€ç§å—é™çš„ç³»ç»Ÿèµ„æº, å³çº¿ç¨‹ä¸å¯èƒ½æ— é™åˆ¶çš„äº§ç”Ÿ, å¹¶ä¸”çº¿ç¨‹çš„åˆ›å»ºå’Œé”€æ¯éƒ½ä¼šæœ‰ç›¸åº”çš„å¼€é”€. å½“ç³»ç»Ÿä¸­å­˜åœ¨å¤§é‡çš„çº¿ç¨‹æ—¶, ç³»ç»Ÿä¼šé€šè¿‡æ—¶é—´ç‰‡è½¬è½®çš„æ–¹å¼è°ƒåº¦æ¯ä¸ªçº¿ç¨‹, å› æ­¤çº¿ç¨‹ä¸å¯èƒ½åšåˆ°ç»å¯¹çš„å¹¶è¡Œ, é™¤éžçº¿ç¨‹æ•°é‡å°äºŽç­‰äºŽcpuçš„æ ¸å¿ƒæ•°. ä½†è¿™ç§æƒ…å†µå¤ªå°‘äº†, æ‰€ä»¥çº¿ç¨‹æ± çš„æ¦‚å¿µå°±ç”±æ­¤å‡ºçŽ°. é€šè¿‡çº¿ç¨‹æ± å°±å¯ä»¥é¿å…å› ä¸ºé¢‘ç¹åˆ›å»ºå’Œé”€æ¯çº¿ç¨‹æ‰€å¸¦æ¥çš„ç³»ç»Ÿå¼€é”€. ä¸»çº¿ç¨‹å’Œå­çº¿ç¨‹ä¸»çº¿ç¨‹æ˜¯æŒ‡è¿›ç¨‹æ‰€æ‹¥æœ‰çš„çº¿ç¨‹, åœ¨Javaä¸­é»˜è®¤æƒ…å†µä¸‹ä¸€ä¸ªè¿›ç¨‹åªæœ‰ä¸€ä¸ªçº¿ç¨‹, è¿™ä¸ªçº¿ç¨‹å°±æ˜¯ä¸»çº¿ç¨‹. ä¸»çº¿ç¨‹ä¸»è¦å¤„ç†ç•Œé¢äº¤äº’ç›¸å…³çš„é€»è¾‘, å› ä¸ºç”¨æˆ·éšæ—¶ä¼šå’Œç•Œé¢å‘ç”Ÿäº¤äº’, å› æ­¤ä¸»çº¿ç¨‹åœ¨ä»»ä½•æ—¶å€™éƒ½å¿…é¡»æœ‰è¾ƒé«˜çš„å“åº”é€Ÿåº¦, å¦åˆ™å°±ä¼šäº§ç”Ÿä¸€ç§ç•Œé¢å¡é¡¿çš„æ„Ÿè§‰. ä¸ºäº†ä¿æŒè¾ƒé«˜çš„å“åº”é€Ÿåº¦, è¿™å°±è¦æ±‚ä¸»çº¿ç¨‹ä¸­ä¸èƒ½æ‰§è¡Œè€—æ—¶çš„ä»»åŠ¡, è¿™ä¸ªæ—¶å€™å­çº¿ç¨‹å°±æ´¾ä¸Šç”¨åœº. å­çº¿ç¨‹ä¹Ÿå«ä½œå·¥ä½œçº¿ç¨‹, é™¤äº†ä¸»çº¿ç¨‹ä»¥å¤–çš„çº¿ç¨‹éƒ½å«åšå­çº¿ç¨‹ Androidæ²¿ç”¨äº†Javaçš„çº¿ç¨‹æ¨¡åž‹, å…¶ä¸­çš„çº¿ç¨‹ä¹Ÿåˆ†ä¸ºä¸»çº¿ç¨‹å’Œå­çº¿ç¨‹, å…¶ä¸­ä¸»çº¿ç¨‹ä¹Ÿå«UIçº¿ç¨‹. ä¸»çº¿ç¨‹çš„ä½œç”¨æ˜¯è¿è¡Œå››å¤§ç»„ä»¶ä»¥åŠå¤„ç†å®ƒä»¬å’Œç”¨æˆ·çš„äº¤äº’. è€Œå­çº¿ç¨‹çš„ä½œç”¨åˆ™æ˜¯æ‰§è¡Œè€—æ—¶ä»»åŠ¡, æ¯”å¦‚ç½‘ç»œè¯·æ±‚, I/Oæ“ä½œç­‰. ä»ŽAndroid 3.0 å¼€å§‹ç³»ç»Ÿè¦æ±‚ç½‘ç»œè®¿é—®å¿…é¡»åœ¨å­çº¿ç¨‹ä¸­è¿›è¡Œ, å¦åˆ™ç½‘ç»œè®¿é—®å°†ä¼šå¤±è´¥å¹¶æŠ›å‡ºNetworkOnMainThreadExceptionè¿™ä¸ªå¼‚å¸¸, è¿™æ ·åšæ˜¯ä¸ºäº†é¿å…ä¸»çº¿ç¨‹ç”±äºŽè€—æ—¶æ“ä½œæ‰€é˜»å¡žä»Žè€Œå‡ºçŽ°ANRçŽ°è±¡. Androidä¸­çš„çº¿ç¨‹å½¢æ€AsyncTask AsyncTaskæ˜¯ä¸€ç§è½»é‡çº§çš„å¼‚æ­¥ä»»åŠ¡ç±», ä»–å¯ä»¥åœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡ŒåŽå°ä»»åŠ¡, ç„¶åŽæŠŠæ‰§è¡Œçš„è¿›åº¦å’Œæœ€ç»ˆçš„ç»“æžœä¼ é€’ç»™ä¸»çº¿ç¨‹å¹¶åœ¨ä¸»çº¿ç¨‹æ›´æ–°UI. ä»Žå®žçŽ°ä¸Šæ¥è¯´. AsyncTaskå°è£…äº†Threadå’ŒHandler, é€šè¿‡AsyncTaskå¯ä»¥æ›´åŠ æ–¹ä¾¿åœ°æ‰§è¡ŒåŽå°ä»»åŠ¡, å¯¹äºŽç‰¹åˆ«è€—æ—¶çš„ä»»åŠ¡æ¥è¯´, å»ºè®®ä½¿ç”¨çº¿ç¨‹æ± . 123public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; // çœç•¥ä¸€å¤§å¨ä»£ç &#125; AsyncTaskå°±æ˜¯ä¸€ä¸ªæŠ½è±¡çš„æ³›åž‹ç±». è¿™ä¸‰ä¸ªæ³›åž‹çš„æ„ä¹‰. Params: è¡¨ç¤ºå‚æ•°çš„ç±»åž‹ Progress: è¡¨ç¤ºåŽå°ä»»åŠ¡çš„æ‰§è¡Œè¿›åº¦çš„ç±»åž‹ Result: åˆ™è¡¨ç¤ºåŽå°ä»»åŠ¡çš„è¿”å›žç»“æžœçš„ç±»åž‹ å¦‚æžœä¸éœ€è¦ä¼ é€’å…·ä½“çš„å‚æ•°, é‚£ä¹ˆè¿™ä¸‰ä¸ªæ³›åž‹å‚æ•°å¯ä»¥ç”¨Voidæ¥ä»£æ›¿. AsyncTaskæä¾›äº†4ä¸ªæ ¸å¿ƒæ–¹æ³•, å«ä¹‰å¦‚ä¸‹ onPreExecute(): åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ, åœ¨å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œä¹‹å‰, æ­¤æ–¹æ³•ä¼šè¢«è°ƒç”¨, ä¸€èˆ¬å¯ä»¥ç”¨äºŽåšä¸€äº›å‡†å¤‡å·¥ä½œ protected abstract Result doInBackground(Params... params): åœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡Œ, æ­¤æ–¹æ³•ç”¨äºŽæ‰§è¡Œå¼‚æ­¥ä»»åŠ¡, å‚æ•°paramsè¡¨ç¤ºå¼‚æ­¥ä»»åŠ¡çš„è¾“å…¥å‚æ•°. åœ¨æ­¤æ–¹æ³•ä¸­å¯ä»¥é€šè¿‡publishProgress()æ–¹æ³•æ¥æ›´æ–°ä»»åŠ¡çš„è¿›åº¦, publishProgress()æ–¹æ³•ä¼šè°ƒç”¨onProgressUpdate()æ–¹æ³•. å¦å¤–æ­¤æ–¹æ³•éœ€è¦è¿”å›žè®¡ç®—ç»“æžœç»™onPostExecute() onProgressUpdate(Progress... values): åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ,åœ¨å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œä¹‹åŽ, æ­¤æ–¹æ³•ä¼šè¢«è°ƒç”¨, å…¶ä¸­resultå‚æ•°æ˜¯åŽå°ä»»åŠ¡çš„è¿”å›žå€¼, å³doInBackground()çš„è¿”å›žå€¼. onPostExecute(Result result): åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ, åœ¨å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œä¹‹åŽ, æ­¤æ–¹æ³•ä¼šè¢«è°ƒç”¨, å…¶ä¸­resultå‚æ•°æ˜¯åŽå°ä»»åŠ¡çš„è¿”å›žå€¼, å³doInBackgroundçš„è¿”å›žå€¼. é™¤äº†ä¸Šè¿°çš„å››ç§æ–¹æ³•,è¿˜æœ‰onCancelled(), å®ƒåŒæ ·åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ, å½“å¼‚æ­¥ä»»åŠ¡è¢«å–æ¶ˆæ—¶, onCancelled()æ–¹æ³•ä¼šè¢«è°ƒç”¨, è¿™ä¸ªæ—¶å€™onPostExecute()åˆ™ä¸ä¼šè¢«è°ƒç”¨. AsyncTaskåœ¨ä½¿ç”¨è¿‡ç¨‹ä¸­æœ‰ä¸€äº›æ¡ä»¶é™åˆ¶ AsyncTaskçš„ç±»å¿…é¡»åœ¨ä¸»çº¿ç¨‹è¢«åŠ è½½, è¿™å°±æ„å‘³ç€ç¬¬ä¸€æ¬¡è®¿é—®AsyncTaskå¿…é¡»å‘ç”Ÿåœ¨ä¸»çº¿ç¨‹, è¿™ä¸ªé—®é¢˜ä¸æ˜¯ç»å¯¹, å› ä¸ºåœ¨Android 4.1åŠä»¥ä¸Šçš„ç‰ˆæœ¬å·²ç»è¢«ç³»ç»Ÿè‡ªåŠ¨å®Œæˆ. åœ¨Android 5.0çš„æºç ä¸­, å¯ä»¥çœ‹åˆ°ActivityThread#main()ä¼šè°ƒç”¨AsyncTask#init()æ–¹æ³•. AsyncTaskçš„å¯¹è±¡å¿…é¡»åœ¨ä¸»çº¿ç¨‹ä¸­åˆ›å»º. executeæ–¹æ³•å¿…é¡»åœ¨UIçº¿ç¨‹è°ƒç”¨. ä¸è¦åœ¨ç¨‹åºä¸­ç›´æŽ¥è°ƒç”¨onPreExecute(), onPostExecute(), doInBackgroundå’ŒonProgressUpdate() ä¸€ä¸ªAsyncTaskå¯¹è±¡åªèƒ½æ‰§è¡Œä¸€æ¬¡, å³åªèƒ½è°ƒç”¨ä¸€æ¬¡execute()æ–¹æ³•, å¦åˆ™ä¼šæŠ¥è¿è¡Œæ—¶å¼‚å¸¸. åœ¨Android 1.6ä¹‹å‰, AsyncTaskæ˜¯ä¸²è¡Œæ‰§è¡Œä»»åŠ¡çš„; Android 1.6çš„æ—¶å€™AsyncTaskå¼€å§‹é‡‡ç”¨çº¿ç¨‹æ± é‡Œå¤„ç†å¹¶è¡Œä»»åŠ¡; ä½†æ˜¯Android 3.0å¼€å§‹, ä¸ºäº†é¿å…AsyncTaskå¸¦æ¥çš„å¹¶å‘é”™è¯¯, AsyncTaskåˆé‡‡ç”¨äº†ä¸€ä¸ªçº¿ç¨‹æ¥ä¸²è¡Œçš„æ‰§è¡Œä»»åŠ¡. å°½ç®¡å¦‚æ­¤åœ¨3.0ä»¥åŽ, ä»ç„¶å¯ä»¥é€šè¿‡AsyncTask#executeOnExecutor()æ–¹æ³•æ¥å¹¶è¡Œæ‰§è¡Œä»»åŠ¡. AsyncTaskçš„å·¥ä½œåŽŸç†è¿™é‡Œä»¥æºç 5.0æ¥åˆ†æž, ä¸åŒçš„ç‰ˆæœ¬æºç å…·ä½“å®žçŽ°æ˜¯ä¸åŒçš„. ä¸ºäº†åˆ†æžAsyncTaskçš„å·¥ä½œåŽŸç†, å¯ä»¥ä»Žå®ƒçš„execute()æ–¹æ³•å¼€å§‹åˆ†æž, execute()æ–¹æ³•åˆä¼šè°ƒç”¨executeOnExecutor()æ–¹æ³•. 123456789101112131415161718192021222324252627public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; sDefaultExecutorå®žé™…ä¸Šæ˜¯ä¸€ä¸ªä¸²è¡Œçš„çº¿ç¨‹æ± , ä¸€ä¸ªè¿›ç¨‹ä¸­æ‰€æœ‰çš„AsyncTaskå…¨éƒ½åœ¨è¿™ä¸ªä¸²è¡Œçš„çº¿ç¨‹æ± ä¸­æŽ’é˜Ÿæ‰§è¡Œ, ç„¶åŽä¼šå…ˆè°ƒç”¨AsyncTask#onPreExecute()æ–¹æ³•, ç„¶åŽçº¿ç¨‹æ± å¼€å§‹æ‰§è¡Œ. çœ‹çœ‹SerialExecutor()çš„æºç å®žçŽ°: 123456789101112131415161718192021222324252627public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; åœ¨SerialExecutorçš„å®žçŽ°å¯ä»¥åˆ†æžAsyncTaskçš„æŽ’é˜Ÿæ‰§è¡Œçš„è¿‡ç¨‹. é¦–å…ˆç³»ç»Ÿä¼šæŠŠAsyncTask#Paramså‚æ•°å°è£…æˆFutureTaskå¯¹è±¡, FutureTaskæ˜¯ä¸€ä¸ªå¹¶å‘ç±», åœ¨è¿™é‡Œå……å½“äº†Runnableçš„ä½œç”¨. æŽ¥ç€è¿™ä¸ªFutureTaskä¼šäº¤ç»™SerialExecutor#execute()æ–¹æ³•åŽ»å¤„ç†. è¿™ä¸ªæ–¹æ³•é¦–å…ˆä¼šæŠŠFutureTaskå¯¹è±¡æ’å…¥åˆ°ä»»åŠ¡é˜Ÿåˆ—mTasksä¸­, å¦‚æžœè¿™ä¸ªæ—¶å€™æ²¡æœ‰æ­£åœ¨æ´»åŠ¨AsyncTaskä»»åŠ¡, é‚£ä¹ˆå°±ä¼šè°ƒç”¨SerialExecutor#scheduleNext()æ–¹æ³•æ¥æ‰§è¡Œä¸‹ä¸€ä¸ªAsyncTaskä»»åŠ¡. åŒæ—¶å½“ä¸€ä¸ªAsyncTaskä»»åŠ¡æ‰§è¡Œå®ŒåŽ, AsyncTaskä¼šç»§ç»­æ‰§è¡Œå…¶ä»–ä»»åŠ¡ç›´åˆ°æ‰€æœ‰çš„ä»»åŠ¡éƒ½æ‰§è¡Œå®Œæ¯•ä¸ºæ­¢, ä»Žè¿™ä¸€ç‚¹å¯ä»¥çœ‹å‡º, åœ¨é»˜è®¤æƒ…å†µä¸‹, AsyncTaskæ˜¯ä¸²è¡Œæ‰§è¡Œçš„ AsyncTaskä¸­æœ‰ä¸¤ä¸ªçº¿ç¨‹æ± (SerialExecutorä¸²è¡Œå’ŒTHREAD_POOL_EXECUTORå¹¶å‘)å’Œä¸€ä¸ªHandler(InternalHandler), å…¶ä¸­çº¿ç¨‹æ± SerialExecutorç”¨äºŽä»»åŠ¡çš„æŽ’åˆ—, è€Œçº¿ç¨‹æ± THREAD_POOL_EXECUTORç”¨äºŽçœŸæ­£çš„æ‰§è¡Œä»»åŠ¡, è€ŒInternalHandlerç”¨äºŽå°†æ‰§è¡ŒçŽ¯å¢ƒä»Žçº¿ç¨‹åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹, å…¶æœ¬è´¨ä»ç„¶æ˜¯çº¿ç¨‹çš„è°ƒç”¨è¿‡ç¨‹. åœ¨AsyncTaskçš„æž„é€ æ–¹æ³•ä¸­æœ‰å¦‚ä¸‹è¿™æ®µä»£ç , ç”±äºŽFutureTask#run()æ–¹æ³•ä¼šè°ƒç”¨mWorker.call()æ–¹æ³•, å› æ­¤mWorkerçš„callæ–¹æ³•æœ€ç»ˆä¼šåœ¨çº¿ç¨‹æ± ä¸­æ‰§è¡Œ. 123456789mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); &#125; &#125;; åœ¨mWorker.call()æ–¹æ³•ä¸­, é¦–å…ˆå°†mTaskInvokedè®¾ä¸ºäº†true. è¡¨ç¤ºå½“å‰ä»»åŠ¡å·²ç»è¢«è°ƒç”¨è¿‡äº†. ç„¶åŽæ‰§è¡ŒAsyncTask#doInBackground()æ–¹æ³•, æŽ¥ç€å°†å…¶è¿”å›žå€¼ä¼ é€’ç»™postResult(), è¿™ä¸ªæ–¹æ³•çš„å®žçŽ°: 1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; è¿™é‡Œ, postResult()ä¼šé€šè¿‡sHandlerå‘é€ä¸€ä¸ªMESSAGE_POST_RESULTæ¶ˆæ¯, è€ŒsHandlerçš„å®šä¹‰å¦‚ä¸‹: 123456789101112131415161718private static final InternalHandler sHandler = new InternalHandler();private static class InternalHandler extends Handler &#123; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; å¯ä»¥çœ‹å‡ºsHandleræ˜¯ä¸€ä¸ªé™æ€çš„Handlerå¯¹è±¡, ä¸ºäº†èƒ½å¤Ÿå°†æ‰§è¡ŒçŽ¯å¢ƒåˆ‡æ¢åˆ°ä¸»çº¿ç¨‹, è¿™å°±è¦æ±‚sHandlerè¿™ä¸ªå¯¹è±¡å¿…é¡»åœ¨ä¸»çº¿ç¨‹ä¸­åˆ›å»º. ç”±äºŽé™æ€æˆå‘˜ä¼šåœ¨åŠ è½½ç±»çš„æ—¶å€™è¿›è¡Œåˆå§‹åŒ–, å› æ­¤è¿™å°±å˜ç›¸è¦æ±‚AsyncTaskçš„ç±»å¿…é¡»åœ¨ä¸»çº¿ç¨‹ä¸­åŠ è½½, å¦åˆ™åŒä¸€ä¸ªè¿›ç¨‹ä¸­çš„AsyncTaskéƒ½æ— æ³•æ­£å¸¸å·¥ä½œ.sHandleræ”¶åˆ°äº†æ¶ˆæ¯åŽä¼šè°ƒç”¨AsyncTask#finish()æ–¹æ³•, å¦‚ä¸‹: 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; è¿™ä¸ªfinish()æ–¹æ³•å¾ˆç®€å•, å¦‚æžœAsyncTaskè¢«å–æ¶ˆäº†, é‚£ä¹ˆå°±è°ƒç”¨onCancelled()æ–¹æ³•, å¦åˆ™å°±ä¼šè°ƒç”¨onPostExecute()æ–¹æ³•, å¯ä»¥çœ‹åˆ°doInBackgroundçš„åé¦ˆç»“æžœä¼šä¼ é€’ç»™onPostExecute()æ–¹æ³•. é€šè¿‡æºç åˆ†æž, å¯ä»¥ç¡®å®šä»Ž3.0å¼€å§‹, é»˜è®¤æƒ…å†µä¸‹AsyncTaskå°±æ˜¯ä¸²è¡Œçš„. é€šè¿‡ä¸€æ®µä»£ç æµ‹è¯•. 1234567891011121314151617181920212223242526272829303132333435 @Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_main: new MyAsync("ä»»åŠ¡_1").execute(""); new MyAsync("ä»»åŠ¡_2").execute(""); new MyAsync("ä»»åŠ¡_3").execute(""); new MyAsync("ä»»åŠ¡_4").execute(""); new MyAsync("ä»»åŠ¡_5").execute(""); break; &#125;&#125;private static class MyAsync extends AsyncTask&lt;String, Integer, String&gt;&#123; private static final String TAG = MyAsync.class.getSimpleName(); private final String mTaskName; public MyAsync(String taskName)&#123; mTaskName = taskName; &#125; @Override protected String doInBackground(String... params) &#123; SystemClock.sleep(3000); return mTaskName; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss"); Log.e(TAG, s+" onPostExecute finish time: " +df.format(new Date())); &#125;&#125; ç»™æŒ‰é’®æ·»åŠ ä¸€ä¸ªç‚¹å‡»è§¦å‘, ç‚¹å‡»çš„æ—¶å€™ä¼šè§¦å‘äº”ä¸ªAsyncTaskçš„åˆ›å»ºå’Œæ‰§è¡Œ , çœ‹ä¸€ä¸‹ç»“æžœ åœ¨5.0æœºå™¨ä¸Šæµ‹è¯•æ‰€æœ‰çš„ä»»åŠ¡æ˜¯ä¸²è¡Œæ‰§è¡Œçš„. æ€»å…±è€—è´¹äº†15ç§’. è€Œåœ¨2.xçš„ç‰ˆæœ¬æ‰€æœ‰çš„ç»“æŸæ—¶é—´å´éƒ½æ˜¯ä¸€æ ·çš„. ä¸ºäº†è®©AsyncTaskå¯ä»¥åœ¨Android 3.0åŠä»¥ä¸Šç‰ˆæœ¬å¹¶è¡Œï¼Œå¯ä»¥ä½¿ç”¨executeOnExecutor()é‚£ä¹ˆç»“æžœçœ‹ä¸€ä¸‹: 12345678910/*** åœ¨ç‰ˆæœ¬3.0ä»¥ä¸Šä½¿ç”¨å¹¶è¡Œçš„æ–¹å¼å¼€å¯*/private void checkConcurrent() &#123; new MyAsync("ä»»åŠ¡_1").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("ä»»åŠ¡_2").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("ä»»åŠ¡_3").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("ä»»åŠ¡_4").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("ä»»åŠ¡_5").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,"");&#125; ok, æŒ‰ç…§ä½ çš„éœ€æ±‚å¯ä»¥é€‰æ‹©ä½¿ç”¨å“ªç§å®žçŽ°æ–¹å¼. HandlerThreadHandlerThreadç»§æ‰¿äº†Thread, å®ƒæ˜¯ä¸€ç§å¯ä»¥ä½¿ç”¨Handlerçš„Thread, å®ƒçš„å®žçŽ°ä¹Ÿå¾ˆç®€å•, å°±æ˜¯runæ–¹æ³•ä¸­é€šè¿‡Looper.prepare()æ¥åˆ›å»ºæ¶ˆæ¯é˜Ÿåˆ—, å¹¶é€šè¿‡Looper.loop()æ¥å¼€å¯æ¶ˆæ¯å¾ªçŽ¯, è¿™æ ·åœ¨å®žé™…çš„ä½¿ç”¨ä¸­å°±å…è®¸åœ¨HandlerThreadä¸­åˆ›å»ºHandler, çœ‹ä¸€ä¸‹run()æ–¹æ³•. 12345678910111213@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; ä»ŽHandlerThreadçš„å®žçŽ°æ¥çœ‹, å®ƒå’Œæ™®é€šçš„Threadæœ‰æ˜¾è‘—çš„ä¸åŒä¹‹å¤„. æ™®é€šçš„Threadä¸»è¦ç”¨äºŽåœ¨runæ–¹æ³•ä¸­æ‰§è¡Œä¸€ä¸ªè€—æ—¶ä»»åŠ¡; è€ŒHandlerThreadåœ¨å†…éƒ¨åˆ›å»ºäº†æ¶ˆæ¯é˜Ÿåˆ—, å¤–ç•Œéœ€è¦é€šè¿‡Handlerçš„æ¶ˆæ¯æ–¹å¼æ¥é€šçŸ¥HandlerThreadæ‰§è¡Œä¸€ä¸ªå…·ä½“çš„ä»»åŠ¡. HandlerThreadæ˜¯ä¸€ä¸ªå¾ˆæœ‰ç”¨çš„ç±», åœ¨Androidä¸­ä¸€ä¸ªå…·ä½“ä½¿ç”¨åœºæ™¯å°±æ˜¯IntentService. ç”±äºŽHandlerThread#run()æ˜¯ä¸€ä¸ªæ— çº¿å¾ªçŽ¯æ–¹æ³•, å› æ­¤å½“æ˜Žç¡®ä¸éœ€è¦å†ä½¿ç”¨HandlerThreadæ—¶, æœ€å¥½é€šè¿‡quit()æˆ–è€…quitSafely()æ–¹æ³•æ¥ç»ˆæ­¢çº¿ç¨‹çš„æ‰§è¡Œ. IntentServiceIntentServiceæ˜¯ä¸€ç§ç‰¹æ®Šçš„Service, å®ƒç»§æ‰¿äº†Serviceå¹¶ä¸”å®ƒæ˜¯ä¸€ä¸ªæŠ½è±¡ç±», å› æ­¤éœ€è¦åˆ›å»ºå­ç±»æ‰èƒ½ä½¿ç”¨. IntentServiceå¯ä»¥ç”¨äºŽæ‰§è¡ŒåŽå°è€—æ—¶ä»»åŠ¡, å½“ä»»åŠ¡æ‰§è¡ŒåŽä¼šè‡ªåŠ¨åœæ­¢, åŒæ—¶ç”±äºŽæœ¬è´¨æ˜¯æœåŠ¡çš„åŽŸå› , è¿™å¯¼è‡´äº†å®ƒçš„ä¼˜å…ˆçº§æ¯”å•çº¯çš„çº¿ç¨‹è¦é«˜å¾ˆå¤š, æ‰€ä»¥IntentServiceæ¯”è¾ƒé€‚åˆæ‰§è¡Œä¸€äº›é«˜ä¼˜å…ˆçº§çš„åŽå°ä»»åŠ¡. IntentServiceå°è£…äº†Handlerå’ŒHandlerThread. è¿™æ˜¯åœ¨onCreate()æ¥å®žçŽ°çš„. 12345678910111213@Overridepublic void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; å½“ç¬¬ä¸€æ¬¡å¯åŠ¨çš„æ—¶å€™, onCreate()å°±ä¼šè¢«è°ƒç”¨, å†…éƒ¨å°±ä¼šåˆ›å»ºä¸€ä¸ªHandlerThread, ç„¶åŽä½¿ç”¨å®ƒçš„Looperæ¥æž„é€ ä¸€ä¸ªHandlerå¯¹è±¡mServiceHandler. è¿™æ ·é€šè¿‡ mServiceHandlerå‘é€çš„æ¶ˆæ¯æœ€ç»ˆéƒ½ä¼šåœ¨HandlerThreadä¸­æ‰§è¡Œ, ä»Žè¿™ä¸ªè§’åº¦çœ‹IntentServiceä¹Ÿå¯ä»¥ç”¨äºŽæ‰§è¡ŒåŽå°ä»»åŠ¡. æ¯æ¬¡å¯åŠ¨IntentServiceçš„æ—¶å€™, å®ƒçš„onStartCommand()æ–¹æ³•å°±ä¼šè¢«è°ƒç”¨ä¸€æ¬¡, IntentServiceåœ¨onStartCommand()ä¸­å¤„ç†æ¯ä¸ªåŽå°ä»»åŠ¡çš„Intent. çœ‹çœ‹æºç æ˜¯å¦‚ä½•å¤„ç†å¤–ç•Œçš„Intentçš„. é¦–å…ˆonStartCommand()è°ƒç”¨äº†onStart() 1234567@Overridepublic void onStart(Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; è¿™ä¸ªæ–¹æ³•åªæ˜¯é€šè¿‡mServiceHandlerå‘é€äº†ä¸€ä¸ªæ¶ˆæ¯, æ‰€ä»¥è¿™ä¸ªæ¶ˆæ¯ä¼šåœ¨HandlerThreadä¸­è¢«å¤„ç†. æ¶ˆæ¯æ”¶åˆ°åŽ, ä¼šå°†Intentå¯¹è±¡ä¼ é€’ç»™onHandlerIntent()æ–¹æ³•åŽ»å¤„ç†. æ³¨æ„è¿™ä¸ªIntentå¯¹è±¡å’Œå¤–ç•ŒstartService()å‚æ•°ä¼ é€’å†…å®¹æ˜¯ä¸€æ ·çš„. é€šè¿‡Intentçš„å‚æ•°å°±å¯ä»¥åŒºåˆ†å…·ä½“çš„åŽå°ä»»åŠ¡, è¿™æ ·åœ¨onHandlerIntent()æ–¹æ³•ä¸­å°±å¯ä»¥å¯¹ä¸åŒçš„åŽå°ä»»åŠ¡åšå¤„ç†äº†. å½“onHandlerIntent()æ–¹æ³•æ‰§è¡Œå®Œæ¯•åŽ, IntentServiceä¼šé€šè¿‡stopSelf()æ–¹æ³•æ¥åœæ­¢æœåŠ¡. è¿™é‡Œä½¿ç”¨çš„æ–¹æ³•æ˜¯æœ‰å‚æ•°çš„, ä¸ä½¿ç”¨æ— å‚æ•°çš„stopSelf()æ˜¯å› ä¸ºæ— å‚å‡½æ•°ä¼šç«‹åˆ»åœæ­¢æœåŠ¡, å¯èƒ½ä¼šå¯¼è‡´è¿˜æœ‰æ²¡æ‰§è¡Œå®Œçš„ä»»åŠ¡å¤±æ•ˆ. æœ‰å‚çš„stopSelf(int startId)åœ¨å°è¯• åœæ­¢æœåŠ¡ä¹‹å‰ä¼šåˆ¤æ–­æœ€è¿‘å¯åŠ¨çš„æœåŠ¡æ¬¡æ•°æ˜¯å¦å’ŒstartIdè¿™ä¸ªå‚æ•°å€¼ç›¸ç­‰, å¦‚æžœç›¸ç­‰å°±ç«‹åˆ»åœæ­¢æœåŠ¡, å¦åˆ™åä¹‹. è¿™ä¸ªç­–ç•¥å¯ä»¥ä»ŽAMS#stopServiceToken()æ–¹æ³•çš„å®žçŽ°ä¸­æ‰¾åˆ°ä¾æ®. IntentService#onHandleIntent()æ–¹æ³•æ˜¯ä¸€ä¸ªæŠ½è±¡æ–¹æ³•, ä»–éœ€è¦æˆ‘ä»¬åœ¨å­ç±»ä¸­å®žçŽ°, å®ƒçš„ä½œç”¨æ˜¯ä»ŽIntentå‚æ•°ä¸­åŒºåˆ†å…·ä½“çš„ä»»åŠ¡å¹¶æ‰§è¡Œè¿™äº›ä»»åŠ¡. å¦‚æžœç›®å‰åªå­˜åœ¨ä¸€ä¸ªåŽå°ä»»åŠ¡, é‚£ä¹ˆonHandleIntent()æ–¹æ³•æ‰§è¡Œå®ŒæˆåŽ, stopSelf(int startId)ä¼šç«‹å³åœæ­¢æœåŠ¡; å¦‚æžœç›®å‰å­˜åœ¨å¤šä¸ªåŽå°ä»»åŠ¡, é‚£ä¹ˆå½“onHandleIntent()æ–¹æ³•æ‰§è¡Œå®Œæœ€åŽä¸€ä¸ªä»»åŠ¡æ—¶, stopSelf(int startId)æ‰ä¼šåœæ­¢ä»»åŠ¡. å¦å¤–ç”±äºŽæ¯æ¬¡æ‰§è¡Œä¸€ä¸ªåŽå°ä»»åŠ¡éƒ½å¿…é¡»å¯åŠ¨ä¸€æ¬¡IntentService, è€Œå…¶å†…éƒ¨åˆ™é€šè¿‡æ¶ˆæ¯çš„æ–¹å¼å‘HandlerThreadè¯·æ±‚æ‰§è¡Œä»»åŠ¡, Handlerä¸­çš„Looperæ˜¯é¡ºåºå¤„ç†æ¶ˆæ¯çš„, è¿™å°±æ„å‘³ç€IntentServiceä¹Ÿæ˜¯é¡ºåºæ‰§è¡ŒåŽå°ä»»åŠ¡çš„, å½“æœ‰å¤šä¸ªåŽå°ä»»åŠ¡åŒæ—¶å­˜åœ¨æ—¶, è¿™äº›åŽå°ä»»åŠ¡ä¼šæŒ‰ç…§å¤–ç•Œå‘èµ·çš„é¡ºåºæŽ’é˜Ÿæ‰§è¡Œ. ç”¨ä»£ç æ¥æ¼”ç¤ºä¸€é: 123456789101112131415161718192021222324252627282930313233// æ´¾ç”Ÿä¸€ä¸ªIntentService çš„å­ç±»public static class LocalIntentService extends IntentService &#123; private static final String TAG = LocalIntentService.class.getSimpleName(); public LocalIntentService() &#123; super(TAG); &#125; @Override protected void onHandleIntent(Intent intent) &#123; String task = intent.getStringExtra("task"); Log.d(TAG, "receiver task :"+task); SystemClock.sleep(2000); &#125; @Override public void onDestroy() &#123; Log.w(TAG, "onDestroy: å‡†å¤‡å…³é—­" ); super.onDestroy(); &#125;&#125;// å¼€å¯3ä¸ªæœåŠ¡Intent service = new Intent(this, LocalIntentService.class);service.putExtra("task", "hi, æˆ‘æ˜¯æ•°æ®1");startService(service);service.putExtra("task", "hi, æˆ‘æ˜¯æ•°æ®2");startService(service);service.putExtra("task", "hi, æˆ‘æ˜¯æ•°æ®3");startService(service); å¯ä»¥çœ‹å‡º, ä¸‰ä¸ªåŽå°ä»»åŠ¡æ˜¯ä¸²è¡Œæ‰§è¡Œçš„, ä»–ä»¬çš„æ‰§è¡Œé¡ºåºå°±æ˜¯å‘èµ·è¯·æ±‚çš„é¡ºåº. å½“ä»»åŠ¡3å®Œæˆäº†ä¹‹åŽ. LocalIntentServiceæ‰çœŸæ­£çš„åœæ­¢, å› ä¸ºè¿™æ˜¯æ—¶å€™æ‰§è¡Œäº†onDestroy(). Androidä¸­çš„çº¿ç¨‹æ± æ¦‚æ‹¬ä¸€ä¸‹çº¿ç¨‹æ± çš„ä¼˜ç‚¹: é‡ç”¨çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹, é¿å…å› ä¸ºçº¿ç¨‹çš„åˆ›å»ºå’Œé”€æ¯æ‰€å¸¦æ¥çš„æ€§èƒ½å¼€é”€. èƒ½æœ‰æ•ˆæŽ§åˆ¶çº¿ç¨‹çš„æœ€å¤§å¹¶å¤§æ•°, é¿å…å¤§é‡çš„çº¿ç¨‹ä¹‹é—´å› äº’ç›¸æŠ¢å ç³»ç»Ÿèµ„æºè€Œå¯¼è‡´çš„é˜»å¡žçŽ°è±¡. èƒ½å¤Ÿå¯¹çº¿ç¨‹è¿›è¡Œç®€å•çš„ç®¡ç†, å¹¶æä¾›å®šæ—¶æ‰§è¡Œä»¥åŠæŒ‡å®šé—´éš”å¾ªçŽ¯æ‰§è¡Œç­‰èƒ½åŠ›. Androidä¸­çš„çº¿ç¨‹æ± çš„æ¦‚å¿µæ¥æºäºŽJavaä¸­çš„Executor, Executoræ˜¯ä¸€ä¸ªæŽ¥å£, çœŸæ­£çš„çº¿ç¨‹æ± çš„å®žçŽ°ä¸ºThreadPoolExecutor. ThreadPoolExecutoræä¾›äº†ä¸€ç³»åˆ—å‚æ•°æ¥é…åˆ¶çº¿ç¨‹æ± , é€šè¿‡ä¸åŒçš„å‚æ•°å¯ä»¥åˆ›å»ºä¸åŒçš„çº¿ç¨‹æ± . è€Œä»ŽåŠŸèƒ½çš„ç‰¹æ€§æ¥åˆ†çš„è¯å¯ä»¥åˆ†æˆå››ç±». ä¸‹é¢è¯´æ˜Ž. ThreadPoolExecutorThreadPoolExecutoræ˜¯çº¿ç¨‹æ± çš„çœŸæ­£å®žçŽ°, å®ƒçš„æž„é€ æ–¹æ³•æä¾›äº†ä¸€ç³»åˆ—å‚æ•°æ¥é…ç½®çº¿ç¨‹æ± , ä¸‹é¢å¯¹æž„é€ æ–¹æ³•ä¸­å‚æ•°è¿›è¡Œä¸€ä¸‹è¯´æ˜Ž, è¿™äº›å‚æ•°å°†ä¼šç›´æŽ¥å½±å“åˆ°çº¿ç¨‹æ± çš„åŠŸèƒ½ç‰¹æ€§. 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize: çº¿ç¨‹æ± çš„æ ¸å¿ƒçº¿ç¨‹æ•°, é»˜è®¤æƒ…å†µä¸‹, æ ¸å¿ƒçº¿ç¨‹ä¼šåœ¨çº¿ç¨‹æ± ä¸­ä¸€ç›´å­˜æ´», å³ä½¿éƒ½å¤„äºŽé—²ç½®çŠ¶æ€. å¦‚æžœå°†ThreadPoolExecutor#allowCoreThreadTimeOutå±žæ€§è®¾ç½®ä¸ºtrue, é‚£ä¹ˆé—²ç½®çš„æ ¸å¿ƒçº¿ç¨‹åœ¨ç­‰å¾…æ–°ä»»åŠ¡åˆ°æ¥æ—¶ä¼šæœ‰è¶…æ—¶çš„ç­–ç•¥, è¿™ä¸ªæ—¶é—´é—´éš”ç”±keepAliveTimeå±žæ€§æ¥å†³å®š. å½“ç­‰å¾…æ—¶é—´è¶…è¿‡äº†keepAliveTimeè®¾å®šçš„å€¼é‚£ä¹ˆæ ¸å¿ƒçº¿ç¨‹å°†ä¼šç»ˆæ­¢. maximumPoolSize: çº¿ç¨‹æ± æ‰€èƒ½å®¹çº³çš„æœ€å¤§çº¿ç¨‹æ•°, å½“æ´»åŠ¨çº¿ç¨‹æ•°è¾¾åˆ°è¿™ä¸ªæ•°å€¼ä¹‹åŽ, åŽç»­çš„ä»»åŠ¡å°†ä¼šè¢«é˜»å¡ž. keepAliveTime: éžæ ¸å¿ƒçº¿ç¨‹é—²ç½®çš„è¶…æ—¶æ—¶é•¿, è¶…è¿‡è¿™ä¸ªæ—¶é•¿, éžæ ¸å¿ƒçº¿ç¨‹å°±ä¼šè¢«å›žæ”¶. allowCoreThreadTimeOutè¿™ä¸ªå±žæ€§ä¸ºtrueçš„æ—¶å€™, è¿™ä¸ªå±žæ€§åŒæ ·ä¼šä½œç”¨äºŽæ ¸å¿ƒçº¿ç¨‹. unit: ç”¨äºŽæŒ‡å®škeepAliveTimeå‚æ•°çš„æ—¶é—´å•ä½, è¿™æ˜¯ä¸€ä¸ªæžšä¸¾, å¸¸ç”¨çš„æœ‰TimeUtil.MILLISECONDS(æ¯«ç§’), TimeUtil.SECONDS(ç§’)ä»¥åŠTimeUtil.MINUTES(åˆ†) workQueue: çº¿ç¨‹æ± ä¸­çš„ä»»åŠ¡é˜Ÿåˆ—, é€šè¿‡çº¿ç¨‹æ± çš„executeæ–¹æ³•æäº¤çš„Runnableå¯¹è±¡ä¼šå­˜å‚¨åœ¨è¿™ä¸ªå‚æ•°ä¸­. threadFactory: çº¿ç¨‹å·¥åŽ‚, ä¸ºçº¿ç¨‹æ± æä¾›åˆ›å»ºæ–°çº¿ç¨‹çš„åŠŸèƒ½. ThreadFactoryæ˜¯ä¸€ä¸ªæŽ¥å£. çº¿ç¨‹æ± æ‰§è¡Œä»»åŠ¡æ—¶å¤§è‡´éµå¾ªå¦‚ä¸‹è§„åˆ™: å¦‚æžœçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡æœªè¾¾åˆ°æ ¸å¿ƒçº¿ç¨‹çš„æ•°é‡, é‚£ä¹ˆä¼šç›´æŽ¥å¯åŠ¨ä¸€ä¸ªæ ¸å¿ƒçº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡. å¦‚æžœçº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹æ•°é‡å·²ç»è¾¾åˆ°æˆ–è€…è¶…è¿‡æ ¸å¿ƒçº¿ç¨‹çš„æ•°é‡, é‚£ä¹ˆä»»åŠ¡ä¼šè¢«æ’å…¥åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­æŽ’é˜Ÿç­‰å¾…æ‰§è¡Œ. å¦‚æžœåœ¨æ­¥éª¤2ä¸­æ— æ³•å°†ä»»åŠ¡æ’å…¥åˆ°ä»»åŠ¡é˜Ÿåˆ—ä¸­, è¿™é€šå¸¸æ˜¯å› ä¸ºä»»åŠ¡é˜Ÿåˆ—å·²æ»¡, è¿™ä¸ªæ—¶å€™å¦‚æžœçº¿ç¨‹æ•°é‡æœªè¾¾åˆ°çº¿ç¨‹æ± çš„è§„å®šçš„æœ€å¤§å€¼, é‚£ä¹ˆä¼šç«‹åˆ»å¯åŠ¨ä¸€ä¸ªéžæ ¸å¿ƒçº¿ç¨‹æ¥æ‰§è¡Œä»»åŠ¡. å¦‚æžœæ­¥éª¤3ä¸­çš„çº¿ç¨‹æ•°é‡å·²ç»è¾¾åˆ°æœ€å¤§å€¼çš„æ—¶å€™, é‚£ä¹ˆä¼šæ‹’ç»æ‰§è¡Œæ­¤ä»»åŠ¡, ThreadPoolExecutorä¼šè°ƒç”¨RejectedExecutionæ–¹æ³•æ¥é€šçŸ¥è°ƒç”¨è€…. ThreadPoolExecutorçš„å‚æ•°é…ç½®åœ¨AsyncTaskä¸­æœ‰æ˜Žæ˜¾çš„ä½“çŽ°, ä¸‹é¢æ˜¯Android 5.0æºç çš„é…ç½®æƒ…å†µï¼š 12345678910111213141516171819202122private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/*** An &#123;@link Executor&#125; that can be used to execute tasks in parallel.*/public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); è¿™ä¸ªé…ç½®åŽçš„è§„æ ¼æ˜¯è¿™æ ·çš„ æ ¸å¿ƒçº¿ç¨‹æ•°ç­‰äºŽCPUæ ¸å¿ƒæ•° + 1; çº¿ç¨‹æ± çš„æœ€å¤§çº¿ç¨‹æ•°ä¸ºCPUæ ¸å¿ƒæ•°çš„2å€ + 1; æ ¸å¿ƒçº¿ç¨‹æ— è¶…æ—¶æœºåˆ¶, éžæ ¸å¿ƒçº¿ç¨‹åœ¨é—²ç½®æ—¶æœ‰è¶…æ—¶æœºåˆ¶,è¶…æ—¶æ—¶é—´ä¸º1ç§’. ä»»åŠ¡é˜Ÿåˆ—çš„å®¹é‡ä¸º128 çº¿ç¨‹æ± çš„åˆ†ç±»1. FixedThreadPool é€šè¿‡Executors#newFixedThreadPool()æ–¹æ³•æ¥åˆ›å»º. å®ƒæ˜¯ä¸€ç§çº¿ç¨‹æ•°é‡å›ºå®šçš„çº¿ç¨‹æ± , å½“çº¿ç¨‹å¤„äºŽç©ºé—²çŠ¶æ€æ—¶, å®ƒä»¬å¹¶ä¸ä¼šè¢«å›žæ”¶, é™¤éžçº¿ç¨‹æ± å…³é—­äº†. å½“æ‰€æœ‰çš„çº¿ç¨‹éƒ½å¤„äºŽæ´»åŠ¨çŠ¶æ€æ—¶, æ–°ä»»åŠ¡éƒ½ä¼šå¤„äºŽç­‰å¾…çŠ¶æ€, ç›´åˆ°æœ‰çº¿ç¨‹ç©ºé—²å‡ºæ¥. ç”±äºŽFixedThreadPoolåªæœ‰æ ¸å¿ƒçº¿ç¨‹å¹¶ä¸”è¿™äº›æ ¸å¿ƒçº¿ç¨‹ä¸ä¼šè¢«å›žæ”¶, è¿™æ„å‘³ç€å®ƒèƒ½å¤Ÿæ›´åŠ å¿«é€Ÿåœ°å“åº”å¤–ç•Œçš„è¯·æ±‚. 1234567891011121314151617181920/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 2. CachedThreadPoolé€šè¿‡Executors#newCachedThreadPool()æ–¹æ³•æ¥åˆ›å»º. å®ƒæ˜¯ä¸€ç§çº¿ç¨‹æ•°é‡ä¸å®šçš„çº¿ç¨‹æ± , å®ƒåªæœ‰éžæ ¸å¿ƒçº¿ç¨‹, å¹¶ä¸”å…¶æœ€å¤§å€¼çº¿ç¨‹æ•°ä¸ºInteger.MAX_VALUE. è¿™å°±å¯ä»¥è®¤ä¸ºè¿™ä¸ªæœ€å¤§çº¿ç¨‹æ•°ä¸ºä»»æ„å¤§äº†. å½“çº¿ç¨‹æ± ä¸­çš„çº¿ç¨‹éƒ½å¤„äºŽæ´»åŠ¨çš„æ—¶å€™, çº¿ç¨‹æ± ä¼šåˆ›å»ºæ–°çš„çº¿ç¨‹æ¥å¤„ç†æ–°ä»»åŠ¡, å¦åˆ™å°±ä¼šåˆ©ç”¨ç©ºé—²çš„çº¿ç¨‹æ¥å¤„ç†æ–°ä»»åŠ¡. çº¿ç¨‹æ± ä¸­çš„ç©ºé—²çº¿ç¨‹éƒ½æœ‰è¶…æ—¶æœºåˆ¶, è¿™ä¸ªè¶…æ—¶æ—¶é•¿ä¸º60S, è¶…è¿‡è¿™ä¸ªæ—¶é—´é‚£ä¹ˆç©ºé—²çº¿ç¨‹å°±ä¼šè¢«å›žæ”¶. å’ŒFixedThreadPoolä¸åŒçš„æ˜¯, CachedThreadPoolçš„ä»»åŠ¡é˜Ÿåˆ—å…¶å®žç›¸å½“äºŽä¸€ä¸ªç©ºé›†åˆ, è¿™å°†å¯¼è‡´ä»»ä½•ä»»åŠ¡éƒ½ä¼šç«‹å³è¢«æ‰§è¡Œ, å› ä¸ºåœ¨è¿™ç§åœºæ™¯ä¸‹SynchronousQueueæ˜¯æ— æ³•æ’å…¥ä»»åŠ¡çš„. SynchronousQueueæ˜¯ä¸€ä¸ªéžå¸¸ç‰¹æ®Šçš„é˜Ÿåˆ—, åœ¨å¾ˆå¤šæƒ…å†µä¸‹å¯ä»¥æŠŠå®ƒç®€å•ç†è§£ä¸ºä¸€ä¸ªæ— æ³•å­˜å‚¨å…ƒç´ çš„é˜Ÿåˆ—. åœ¨å®žé™…ä½¿ç”¨ä¸­å¾ˆå°‘ä½¿ç”¨.è¿™ç±»çº¿ç¨‹æ¯”è¾ƒé€‚åˆæ‰§è¡Œå¤§é‡çš„è€—æ—¶è¾ƒå°‘çš„ä»»åŠ¡ 123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 3. ScheduledThreadPool é€šè¿‡Executors#newScheduledThreadPool()æ–¹æ³•æ¥åˆ›å»º. å®ƒçš„æ ¸å¿ƒçº¿ç¨‹æ•°é‡æ˜¯å›ºå®šçš„, è€Œéžæ ¸å¿ƒçº¿ç¨‹æ•°æ˜¯æ²¡æœ‰é™åˆ¶çš„, å¹¶ä¸”å½“éžæ ¸å¿ƒçº¿ç¨‹é—²ç½®æ—¶ä¼šç«‹åˆ»è¢«å›žæ”¶æŽ‰. è¿™ç±»çº¿ç¨‹æ± ç”¨äºŽæ‰§è¡Œå®šæ—¶ä»»åŠ¡å’Œå…·æœ‰å›ºå®šå‘¨æœŸçš„é‡å¤ä»»åŠ¡ 12345678910111213141516171819202122232425 /** * Creates a thread pool that can schedule commands to run after a * given delay, or to execute periodically. * @param corePoolSize the number of threads to keep in the pool, * even if they are idle * @return a newly created scheduled thread pool * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */ public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;/** * Creates a new &#123;@code ScheduledThreadPoolExecutor&#125; with the * given core pool size. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */ public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; 4. SingleThreadExecutor é€šè¿‡Executors#newSingleThreadPool()æ–¹æ³•æ¥åˆ›å»º. è¿™ç±»çº¿ç¨‹æ± å†…éƒ¨åªæœ‰ä¸€ä¸ªæ ¸å¿ƒçº¿ç¨‹, å®ƒç¡®ä¿æ‰€æœ‰çš„ä»»åŠ¡éƒ½åœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸­æŒ‰é¡ºåºæ‰§è¡Œ. è¿™ç±»çº¿ç¨‹æ± æ„ä¹‰åœ¨äºŽç»Ÿä¸€æ‰€æœ‰çš„å¤–ç•Œä»»åŠ¡åˆ°ä¸€ä¸ªçº¿ç¨‹ä¸­, è¿™ä½¿å¾—åœ¨è¿™äº›ä»»åŠ¡ä¹‹é—´ä¸éœ€è¦å¤„ç†çº¿ç¨‹åŒæ­¥çš„é—®é¢˜ 12345678910111213141516171819/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.) Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */ public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>çº¿ç¨‹å’Œçº¿ç¨‹æ± </tag>
        <tag>AsyncTask</tag>
        <tag>HandlerThread</tag>
        <tag>IntentService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activityå¯åŠ¨åˆ†æž]]></title>
    <url>%2F2018%2F03%2F14%2FActivity%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[åŸºäºŽAndroid 6.0çš„æºç å‰–æžï¼Œ åˆ†æžandroid Activityå¯åŠ¨æµç¨‹ï¼Œç›¸å…³æºç ï¼š 1234567891011121314151617frameworks/base/services/core/java/com/android/server/am/ - ActivityManagerService.java - ActivityStackSupervisor.java - ActivityStack.java - ActivityRecord.java - ProcessRecord.javaframeworks/base/core/java/android/app/ - IActivityManager.java - ActivityManagerNative.java (å†…å«AMP) - ActivityManager.java - IApplicationThread.java - ApplicationThreadNative.java (å†…å«ATP) - ActivityThread.java (å†…å«ApplicationThread) - ContextImpl.java ä¸€. æ¦‚è¿°startActivityçš„æ•´ä½“æµç¨‹ä¸ŽstartServiceå¯åŠ¨è¿‡ç¨‹åˆ†æžéžå¸¸ç›¸è¿‘ï¼Œä½†æ¯”Serviceå¯åŠ¨æ›´ä¸ºå¤æ‚ï¼Œå¤šäº†stack/taskä»¥åŠUIçš„ç›¸å…³å†…å®¹ä»¥åŠActivityçš„ç”Ÿå‘½å‘¨æœŸæ›´ä¸ºä¸°å¯Œã€‚ Activityå¯åŠ¨å‘èµ·åŽï¼Œé€šè¿‡Binderæœ€ç»ˆäº¤ç”±systemè¿›ç¨‹ä¸­çš„AMSæ¥å®Œæˆï¼Œåˆ™å¯åŠ¨æµç¨‹å¦‚ä¸‹å›¾ï¼š æŽ¥ä¸‹æ¥ï¼Œä»Žæºç æ¥è¯´è¯´æ¯ä¸ªè¿‡ç¨‹ã€‚ äºŒ. å¯åŠ¨æµç¨‹2.1 Activity.startActivity[-&gt; Activity.java] 123456789101112public void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; //[è§å°èŠ‚2.2] startActivityForResult(intent, -1); &#125;&#125; 2.2 startActivityForResult[-&gt; Activity.java] 12345678910111213141516171819202122232425public void startActivityForResult(Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null);&#125;public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; //[è§å°èŠ‚2.3] Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; //æ­¤æ—¶requestCode =-1 if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); &#125; else &#123; ... &#125;&#125; execStartActivity()æ–¹æ³•çš„å‚æ•°: mAppThread: æ•°æ®ç±»åž‹ä¸ºApplicationThreadï¼Œé€šè¿‡mMainThread.getApplicationThread()æ–¹æ³•èŽ·å–ã€‚ mToken: æ•°æ®ç±»åž‹ä¸ºIBinder. 2.3 execStartActivity[-&gt; Instrumentation.java] 12345678910111213141516171819202122232425262728293031323334353637public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ... if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; //å½“è¯¥monitoré˜»å¡žactivityå¯åŠ¨,åˆ™ç›´æŽ¥è¿”å›ž if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); //[è§å°èŠ‚2.4] int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //æ£€æŸ¥activityæ˜¯å¦å¯åŠ¨æˆåŠŸ checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null;&#125; å…³äºŽ ActivityManagerNative.getDefault()è¿”å›žçš„æ˜¯ActivityManagerProxyå¯¹è±¡(è·¨è¿›ç¨‹è¿”å›žStub.Proxyå¯¹è±¡). æ­¤å¤„startActivity()çš„å…±æœ‰10ä¸ªå‚æ•°, ä¸‹é¢è¯´è¯´æ¯ä¸ªå‚æ•°ä¼ é€’AMP.startActivity()æ¯ä¸€é¡¹çš„å¯¹åº”å€¼: caller: å½“å‰åº”ç”¨çš„ApplicationThreadå¯¹è±¡mAppThread; callingPackage: è°ƒç”¨å½“å‰ContextImpl.getBasePackageName(),èŽ·å–å½“å‰Activityæ‰€åœ¨åŒ…å; intent: è¿™ä¾¿æ˜¯å¯åŠ¨Activityæ—¶,ä¼ é€’è¿‡æ¥çš„å‚æ•°; resolvedType: è°ƒç”¨intent.resolveTypeIfNeededè€ŒèŽ·å–; resultTo: æ¥è‡ªäºŽå½“å‰Activity.mToken resultWho: æ¥è‡ªäºŽå½“å‰Activity.mEmbeddedID requestCode = -1; startFlags = 0; profilerInfo = null; options = null; 2.4 AMP.startActivity[-&gt; ActivityManagerNative.java :: ActivityManagerProxy] 123456789101112131415161718192021222324252627282930313233343536class ActivityManagerProxy implements IActivityManager &#123; ... public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; if (options != null) &#123; data.writeInt(1); options.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; //[è§æµç¨‹2.5] mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; ...&#125; AMPç»è¿‡binder IPC,è¿›å…¥ActivityManagerNative(ç®€ç§°AMN)ã€‚æŽ¥ä¸‹æ¥ç¨‹åºè¿›å…¥äº†system_severè¿›ç¨‹ï¼Œå¼€å§‹ç»§ç»­æ‰§è¡Œã€‚ 2.5 AMN.onTransact[-&gt; ActivityManagerNative.java] 123456789101112131415161718192021222324252627public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); String callingPackage = data.readString(); Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); IBinder resultTo = data.readStrongBinder(); String resultWho = data.readString(); int requestCode = data.readInt(); int startFlags = data.readInt(); ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; Bundle options = data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null; //[è§æµç¨‹2.6] int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125; ... &#125; &#125; 2.6 AMS.startActivity[-&gt; ActivityManagerService.java] 123456789101112131415public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); //[è§å°èŠ‚2.7] return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null);&#125; æ­¤å¤„mStackSupervisorçš„æ•°æ®ç±»åž‹ä¸ºActivityStackSupervisor 2.7 ASS.startActivityMayWaitå½“ç¨‹åºè¿è¡Œåˆ°è¿™é‡Œæ—¶, ASS.startActivityMayWaitçš„å„ä¸ªå‚æ•°å–å€¼å¦‚ä¸‹: caller = ApplicationThreadProxy, ç”¨äºŽè·Ÿè°ƒç”¨è€…è¿›ç¨‹ApplicationThreadè¿›è¡Œé€šä¿¡çš„binderä»£ç†ç±». callingUid = -1; callingPackage = ContextImpl.getBasePackageName(),èŽ·å–è°ƒç”¨è€…Activityæ‰€åœ¨åŒ…å intent: è¿™æ˜¯å¯åŠ¨Activityæ—¶ä¼ é€’è¿‡æ¥çš„å‚æ•°; resolvedType = intent.resolveTypeIfNeeded voiceSession = null; voiceInteractor = null; resultTo = Activity.mToken, å…¶ä¸­Activityæ˜¯æŒ‡è°ƒç”¨è€…æ‰€åœ¨Activity, mTokenå¯¹è±¡ä¿å­˜è‡ªå·±æ‰€å¤„çš„ActivityRecordä¿¡æ¯ resultWho = Activity.mEmbeddedID, å…¶ä¸­Activityæ˜¯æŒ‡è°ƒç”¨è€…æ‰€åœ¨Activity requestCode = -1; startFlags = 0; profilerInfo = null; outResult = null; config = null; options = null; ignoreTargetSecurity = false; userId = AMS.handleIncomingUser, å½“è°ƒç”¨è€…userIdè·Ÿå½“å‰å¤„äºŽåŒä¸€ä¸ªuserId,åˆ™ç›´æŽ¥è¿”å›žè¯¥userId;å½“ä¸ç›¸ç­‰æ—¶åˆ™æ ¹æ®è°ƒç”¨è€…userIdæ¥å†³å®šæ˜¯å¦éœ€è¦å°†callingUserIdè½¬æ¢ä¸ºmCurrentUserId. iContainer = null; inTask = null; å†æ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•çš„æºç : [-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; ... boolean componentSpecified = intent.getComponent() != null; //åˆ›å»ºæ–°çš„Intentå¯¹è±¡ï¼Œå³ä¾¿intentè¢«ä¿®æ”¹ä¹Ÿä¸å—å½±å“ intent = new Intent(intent); //æ”¶é›†Intentæ‰€æŒ‡å‘çš„Activityä¿¡æ¯, å½“å­˜åœ¨å¤šä¸ªå¯ä¾›é€‰æ‹©çš„Activity,åˆ™ç›´æŽ¥å‘ç”¨æˆ·å¼¹å‡ºresolveActivity [è§2.7.1] ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId); ActivityContainer container = (ActivityContainer)iContainer; synchronized (mService) &#123; if (container != null &amp;&amp; container.mParentActivity != null &amp;&amp; container.mParentActivity.state != RESUMED) &#123; ... //ä¸è¿›å…¥è¯¥åˆ†æ”¯, container == nul &#125; final int realCallingPid = Binder.getCallingPid(); final int realCallingUid = Binder.getCallingUid(); int callingPid; if (callingUid &gt;= 0) &#123; callingPid = -1; &#125; else if (caller == null) &#123; callingPid = realCallingPid; callingUid = realCallingUid; &#125; else &#123; callingPid = callingUid = -1; &#125; final ActivityStack stack; if (container == null || container.mStack.isOnHomeDisplay()) &#123; stack = mFocusedStack; // è¿›å…¥è¯¥åˆ†æ”¯ &#125; else &#123; stack = container.mStack; &#125; //æ­¤æ—¶mConfigWillChange = false stack.mConfigWillChange = config != null &amp;&amp; mService.mConfiguration.diff(config) != 0; final long origId = Binder.clearCallingIdentity(); if (aInfo != null &amp;&amp; (aInfo.applicationInfo.privateFlags &amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; // heavy-weightè¿›ç¨‹å¤„ç†æµç¨‹, ä¸€èˆ¬æƒ…å†µä¸‹ä¸è¿›å…¥è¯¥åˆ†æ”¯ if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123; ... &#125; &#125; //[è§æµç¨‹2.8] int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); Binder.restoreCallingIdentity(origId); if (stack.mConfigWillChange) &#123; ... //ä¸è¿›å…¥è¯¥åˆ†æ”¯ &#125; if (outResult != null) &#123; ... //ä¸è¿›å…¥è¯¥åˆ†æ”¯ &#125; return res; &#125;&#125; è¯¥è¿‡ç¨‹ä¸»è¦åŠŸèƒ½ï¼šé€šè¿‡resolveActivityæ¥èŽ·å–ActivityInfoä¿¡æ¯, ç„¶åŽå†è¿›å…¥ASS.startActivityLocked().å…ˆæ¥çœ‹çœ‹ 2.7.1 ASS.resolveActivity12345678910111213141516171819// startFlags = 0; profilerInfo = null; userIdä»£è¡¨caller UserIdActivityInfo resolveActivity(Intent intent, String resolvedType, int startFlags, ProfilerInfo profilerInfo, int userId) &#123; ActivityInfo aInfo; ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent( intent, resolvedType, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS, userId); aInfo = rInfo != null ? rInfo.activityInfo : null; if (aInfo != null) &#123; intent.setComponent(new ComponentName( aInfo.applicationInfo.packageName, aInfo.name)); if (!aInfo.processName.equals("system")) &#123; ... //å¯¹äºŽéžsystemè¿›ç¨‹ï¼Œæ ¹æ®flagsæ¥è®¾ç½®ç›¸åº”çš„debugä¿¡æ¯ &#125; &#125; return aInfo;&#125; ActivityManagerç±»æœ‰å¦‚ä¸‹4ä¸ªflagsç”¨äºŽè°ƒè¯•ï¼š START_FLAG_DEBUGï¼šç”¨äºŽè°ƒè¯•debug app START_FLAG_OPENGL_TRACESï¼šç”¨äºŽè°ƒè¯•OpenGL tracing START_FLAG_NATIVE_DEBUGGINGï¼šç”¨äºŽè°ƒè¯•native START_FLAG_TRACK_ALLOCATION: ç”¨äºŽè°ƒè¯•allocation tracking 2.7.2 PKMS.resolveIntentAppGlobals.getPackageManager()ç»è¿‡å‡½æ•°å±‚å±‚è°ƒç”¨ï¼ŒèŽ·å–çš„æ˜¯ApplicationPackageManagerå¯¹è±¡ã€‚ç»è¿‡binder IPCè°ƒç”¨ï¼Œæœ€ç»ˆä¼šè°ƒç”¨PackageManagerServiceå¯¹è±¡ã€‚æ•…æ­¤æ—¶è°ƒç”¨æ–¹æ³•ä¸ºPMS.resolveIntent(). [-&gt; PackageManagerService.java] 12345678public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return null; enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "resolve intent"); //[è§æµç¨‹2.7.3] List&lt;ResolveInfo&gt; query = queryIntentActivities(intent, resolvedType, flags, userId); //æ ¹æ®priorityï¼Œpreferredé€‰æ‹©æœ€ä½³çš„Activity return chooseBestActivity(intent, resolvedType, flags, query, userId); &#125; 2.7.3 PMS.queryIntentActivities123456789101112131415161718192021222324public List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) &#123; ... ComponentName comp = intent.getComponent(); if (comp == null) &#123; if (intent.getSelector() != null) &#123; intent = intent.getSelector(); comp = intent.getComponent(); &#125; &#125; if (comp != null) &#123; final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1); //èŽ·å–Activityä¿¡æ¯ final ActivityInfo ai = getActivityInfo(comp, flags, userId); if (ai != null) &#123; final ResolveInfo ri = new ResolveInfo(); ri.activityInfo = ai; list.add(ri); &#125; return list; &#125; ...&#125; ASS.resolveActivity()æ–¹æ³•çš„æ ¸å¿ƒåŠŸèƒ½æ˜¯æ‰¾åˆ°ç›¸åº”çš„Activityç»„ä»¶ï¼Œå¹¶ä¿å­˜åˆ°intentå¯¹è±¡ã€‚ 2.8 ASS.startActivityLocked[-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; //èŽ·å–è°ƒç”¨è€…çš„è¿›ç¨‹è®°å½•å¯¹è±¡ ProcessRecord callerApp = null; if (caller != null) &#123; callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; if (resultTo != null) &#123; //èŽ·å–è°ƒç”¨è€…æ‰€åœ¨çš„Activity sourceRecord = isInAnyStackLocked(resultTo); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; ... //requestCode = -1 åˆ™ä¸è¿›å…¥ &#125; &#125; &#125; final int launchFlags = intent.getFlags(); if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; ... // activityæ‰§è¡Œç»“æžœçš„è¿”å›žç”±æºActivityè½¬æ¢åˆ°æ–°Activity, ä¸éœ€è¦è¿”å›žç»“æžœåˆ™ä¸ä¼šè¿›å…¥è¯¥åˆ†æ”¯ &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; //ä»ŽIntentä¸­æ— æ³•æ‰¾åˆ°ç›¸åº”çš„Component err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; //ä»ŽIntentä¸­æ— æ³•æ‰¾åˆ°ç›¸åº”çš„ActivityInfo err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; !isCurrentProfileLocked(userId) &amp;&amp; (aInfo.flags &amp; FLAG_SHOW_FOR_ALL_USERS) == 0) &#123; //å°è¯•å¯åŠ¨ä¸€ä¸ªåŽå°Activity, ä½†è¯¥Activityå¯¹å½“å‰ç”¨æˆ·ä¸å¯è§ err = ActivityManager.START_NOT_CURRENT_USER_ACTIVITY; &#125; ... //æ‰§è¡ŒåŽresultStack = null final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack; ... //æƒé™æ£€æŸ¥ // ActivityControllerä¸ä¸ºç©ºçš„æƒ…å†µï¼Œæ¯”å¦‚monkeyæµ‹è¯•è¿‡ç¨‹ if (mService.mController != null) &#123; Intent watchIntent = intent.cloneFilter(); abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); &#125; if (abort) &#123; ... //æƒé™æ£€æŸ¥ä¸æ»¡è¶³,æ‰è¿›å…¥è¯¥åˆ†æ”¯åˆ™ç›´æŽ¥è¿”å›žï¼› return ActivityManager.START_SUCCESS; &#125; // åˆ›å»ºActivityè®°å½•å¯¹è±¡ ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, this, container, options); if (outActivity != null) &#123; outActivity[0] = r; &#125; if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123; r.appTimeTracker = sourceRecord.appTimeTracker; &#125; // å°†mFocusedStackèµ‹äºˆå½“å‰stack final ActivityStack stack = mFocusedStack; if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123; // å‰å°stackè¿˜æ²¡æœ‰resumeçŠ¶æ€çš„Activityæ—¶, åˆ™æ£€æŸ¥appåˆ‡æ¢æ˜¯å¦å…è®¸ [è§æµç¨‹2.8.1] if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, realCallingPid, realCallingUid, "Activity start")) &#123; PendingActivityLaunch pal = new PendingActivityLaunch(r, sourceRecord, startFlags, stack); // å½“ä¸å…è®¸åˆ‡æ¢,åˆ™æŠŠè¦å¯åŠ¨çš„Activityæ·»åŠ åˆ°mPendingActivityLauncheså¯¹è±¡, å¹¶ä¸”ç›´æŽ¥è¿”å›ž. mPendingActivityLaunches.add(pal); ActivityOptions.abort(options); return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; if (mService.mDidAppSwitch) &#123; //ä»Žä¸Šæ¬¡ç¦æ­¢appåˆ‡æ¢ä»¥æ¥,è¿™æ˜¯ç¬¬äºŒæ¬¡å…è®¸appåˆ‡æ¢,å› æ­¤å°†å…è®¸åˆ‡æ¢æ—¶é—´è®¾ç½®ä¸º0,åˆ™è¡¨ç¤ºå¯ä»¥ä»»æ„åˆ‡æ¢app mService.mAppSwitchesAllowedTime = 0; &#125; else &#123; mService.mDidAppSwitch = true; &#125; //å¤„ç† pendind Activityçš„å¯åŠ¨, è¿™äº›Activityæ˜¯ç”±äºŽapp switchç¦ç”¨ä»Žè€Œè¢«holdçš„ç­‰å¾…å¯åŠ¨activity [è§æµç¨‹2.8.2] doPendingActivityLaunchesLocked(false); //[è§æµç¨‹2.9] err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); if (err &lt; 0) &#123; notifyActivityDrawnForKeyguard(); &#125; return err;&#125; å…¶ä¸­æœ‰ä¸¤ä¸ªè¿”å›žå€¼ä»£è¡¨å¯åŠ¨Activityå¤±è´¥ï¼š START_INTENT_NOT_RESOLVED: ä»ŽIntentä¸­æ— æ³•æ‰¾åˆ°ç›¸åº”çš„Componentæˆ–è€…ActivityInfo START_NOT_CURRENT_USER_ACTIVITYï¼šè¯¥Activityå¯¹å½“å‰ç”¨æˆ·ä¸å¯è§ 2.8.1 AMS.checkAppSwitchAllowedLocked1234567891011121314151617181920212223boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid, int callingPid, int callingUid, String name) &#123; if (mAppSwitchesAllowedTime &lt; SystemClock.uptimeMillis()) &#123; return true; &#125; int perm = checkComponentPermission( android.Manifest.permission.STOP_APP_SWITCHES, sourcePid, sourceUid, -1, true); if (perm == PackageManager.PERMISSION_GRANTED) &#123; return true; &#125; if (callingUid != -1 &amp;&amp; callingUid != sourceUid) &#123; perm = checkComponentPermission( android.Manifest.permission.STOP_APP_SWITCHES, callingPid, callingUid, -1, true); if (perm == PackageManager.PERMISSION_GRANTED) &#123; return true; &#125; &#125; return false;&#125; å½“mAppSwitchesAllowedTimeæ—¶é—´å°äºŽå½“å‰æ—¶é•¿,æˆ–è€…å…·æœ‰STOP_APP_SWITCHESçš„æƒé™,åˆ™å…è®¸appå‘ç”Ÿåˆ‡æ¢æ“ä½œ. å…¶ä¸­mAppSwitchesAllowedTime, åœ¨AMS.stopAppSwitches()çš„è¿‡ç¨‹ä¸­ä¼šè®¾ç½®ä¸º:mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME. ç¦æ­¢appåˆ‡æ¢çš„timeoutæ—¶é•¿ä¸º5s(APP_SWITCH_DELAY_TIME = 5s). å½“å‘é€5ç§’è¶…æ—¶æˆ–è€…æ‰§è¡ŒAMS.resumeAppSwitches()è¿‡ç¨‹ä¼šå°†mAppSwitchesAllowedTimeè®¾ç½®0, éƒ½ä¼šå¼€å¯å…è®¸appæ‰§è¡Œåˆ‡æ¢çš„æ“ä½œ.å¦å¤–,ç¦æ­¢Appåˆ‡æ¢çš„æ“ä½œ,å¯¹äºŽåŒä¸€ä¸ªappæ˜¯ä¸å—å½±å“çš„,æœ‰å…´è¶£å¯ä»¥è¿›ä¸€æ­¥æŸ¥çœ‹checkComponentPermissionè¿‡ç¨‹. 2.8.2 ASS.doPendingActivityLaunchesLocked[-&gt; ActivityStackSupervisor.java] 123456789101112final void doPendingActivityLaunchesLocked(boolean doResume) &#123; while (!mPendingActivityLaunches.isEmpty()) &#123; PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); try &#123; //[è§æµç¨‹2.9] startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags, doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null); &#125; catch (Exception e) &#123; ... &#125; &#125;&#125; mPendingActivityLaunchesè®°å½•ç€æ‰€æœ‰å°†è¦å¯åŠ¨çš„Activity, æ˜¯ç”±äºŽåœ¨startActivityLockedçš„è¿‡ç¨‹æ—¶Appåˆ‡æ¢åŠŸèƒ½è¢«ç¦æ­¢, ä¹Ÿå°±æ˜¯ä¸è¿è¡Œåˆ‡æ¢Activity, é‚£ä¹ˆæ­¤æ—¶ä¾¿ä¼šæŠŠç›¸åº”çš„ActivityåŠ å…¥åˆ°mPendingActivityLaunchesé˜Ÿåˆ—. è¯¥é˜Ÿåˆ—çš„æˆå‘˜åœ¨æ‰§è¡Œå®ŒdoPendingActivityLaunchesLockedä¾¿ä¼šæ¸…ç©º. å¯åŠ¨mPendingActivityLaunchesä¸­æ‰€æœ‰çš„Activity, ç”±äºŽdoResume = false, é‚£ä¹ˆè¿™äº›activtityå¹¶ä¸ä¼šè¿›å…¥resumeçŠ¶æ€,è€Œæ˜¯è®¾ç½®delayedResume = true, ä¼šå»¶è¿Ÿresume. 2.9 ASS.startActivityUncheckedLocked[-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404// sourceRecordæ˜¯æŒ‡è°ƒç”¨è€…ï¼Œ ræ˜¯æŒ‡æœ¬æ¬¡å°†è¦å¯åŠ¨çš„Activityfinal int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, Bundle options, TaskRecord inTask) &#123; final Intent intent = r.intent; final int callingUid = r.launchedFromUid; if (inTask != null &amp;&amp; !inTask.inRecents) &#123; inTask = null; &#125; final boolean launchSingleTop = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP; final boolean launchSingleInstance = r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE; final boolean launchSingleTask = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK; int launchFlags = intent.getFlags(); // å½“intentå’Œactivity manifestå­˜åœ¨å†²çªï¼Œåˆ™manifestä¼˜å…ˆ if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0 &amp;&amp; (launchSingleInstance || launchSingleTask)) &#123; launchFlags &amp;= ~(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK); &#125; else &#123; ... &#125; final boolean launchTaskBehind = r.mLaunchTaskBehind &amp;&amp; !launchSingleTask &amp;&amp; !launchSingleInstance &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0; if (r.resultTo != null &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; r.resultTo.task.stack != null) &#123; r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); r.resultTo = null; &#125; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0 &amp;&amp; r.resultTo == null) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; if (launchTaskBehind || r.info.documentLaunchMode == ActivityInfo.DOCUMENT_LAUNCH_ALWAYS) &#123; launchFlags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK; &#125; &#125; mUserLeaving = (launchFlags &amp; Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0; //å½“æœ¬æ¬¡ä¸éœ€è¦resumeï¼Œåˆ™è®¾ç½®ä¸ºå»¶è¿Ÿresumeçš„çŠ¶æ€ if (!doResume) &#123; r.delayedResume = true; &#125; ActivityRecord notTop = (launchFlags &amp; Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null; if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; ActivityRecord checkedCaller = sourceRecord; if (checkedCaller == null) &#123; checkedCaller = mFocusedStack.topRunningNonDelayedActivityLocked(notTop); &#125; if (!checkedCaller.realActivity.equals(r.realActivity)) &#123; //è°ƒç”¨è€… ä¸Žå°†è¦å¯åŠ¨çš„Activityä¸ç›¸åŒæ—¶ï¼Œè¿›å…¥è¯¥åˆ†æ”¯ã€‚ startFlags &amp;= ~ActivityManager.START_FLAG_ONLY_IF_NEEDED; &#125; &#125; boolean addingToTask = false; TaskRecord reuseTask = null; //å½“è°ƒç”¨è€…ä¸æ˜¯æ¥è‡ªactivityï¼Œè€Œæ˜¯æ˜Žç¡®æŒ‡å®štaskçš„æƒ…å†µã€‚ if (sourceRecord == null &amp;&amp; inTask != null &amp;&amp; inTask.stack != null) &#123; ... //ç›®å‰sourceRecordä¸ä¸ºç©ºï¼Œåˆ™ä¸è¿›å…¥è¯¥åˆ†æ”¯ &#125; else &#123; inTask = null; &#125; if (inTask == null) &#123; if (sourceRecord == null) &#123; //è°ƒç”¨è€…å¹¶ä¸æ˜¯Activity context,åˆ™å¼ºåˆ¶åˆ›å»ºæ–°task if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; inTask == null) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; &#125; else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; //è°ƒç”¨è€…activityå¸¦æœ‰single instanceï¼Œåˆ™åˆ›å»ºæ–°task launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; else if (launchSingleInstance || launchSingleTask) &#123; //ç›®æ ‡activityå¸¦æœ‰single instanceæˆ–è€…single taskï¼Œåˆ™åˆ›å»ºæ–°task launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; &#125; ActivityInfo newTaskInfo = null; Intent newTaskIntent = null; ActivityStack sourceStack; if (sourceRecord != null) &#123; if (sourceRecord.finishing) &#123; //è°ƒç”¨è€…å¤„äºŽå³å°†finishçŠ¶æ€ï¼Œåˆ™åˆ›å»ºæ–°task if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; newTaskInfo = sourceRecord.info; newTaskIntent = sourceRecord.task.intent; &#125; sourceRecord = null; sourceStack = null; &#125; else &#123; //å½“è°ƒç”¨è€…Activityä¸ä¸ºç©ºï¼Œä¸”ä¸å¤„äºŽfinishingçŠ¶æ€ï¼Œåˆ™å…¶æ‰€åœ¨æ ˆèµ‹äºŽsourceStack sourceStack = sourceRecord.task.stack; &#125; &#125; else &#123; sourceStack = null; &#125; boolean movedHome = false; ActivityStack targetStack; intent.setFlags(launchFlags); final boolean noAnimation = (launchFlags &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0; if (((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || launchSingleInstance || launchSingleTask) &#123; if (inTask == null &amp;&amp; r.resultTo == null) &#123; //ä»ŽmActivityDisplayså¼€å§‹æŸ¥è¯¢æ˜¯å¦æœ‰ç›¸åº”ActivityRecord ActivityRecord intentActivity = !launchSingleInstance ? findTaskLocked(r) : findActivityLocked(intent, r.info); if (intentActivity != null) &#123; if (isLockTaskModeViolation(intentActivity.task, (launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; if (r.task == null) &#123; r.task = intentActivity.task; &#125; if (intentActivity.task.intent == null) &#123; intentActivity.task.setIntent(r); &#125; targetStack = intentActivity.task.stack; targetStack.mLastPausedActivity = null; final ActivityStack focusStack = getFocusedStack(); ActivityRecord curTop = (focusStack == null) ? null : focusStack.topRunningNonDelayedActivityLocked(notTop); boolean movedToFront = false; if (curTop != null &amp;&amp; (curTop.task != intentActivity.task || curTop.task != focusStack.topTask())) &#123; r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT); if (sourceRecord == null || (sourceStack.topActivity() != null &amp;&amp; sourceStack.topActivity().task == sourceRecord.task)) &#123; if (launchTaskBehind &amp;&amp; sourceRecord != null) &#123; intentActivity.setTaskToAffiliateWith(sourceRecord.task); &#125; movedHome = true; //å°†è¯¥taskç§»è‡³å‰å° targetStack.moveTaskToFrontLocked(intentActivity.task, noAnimation, options, r.appTimeTracker, "bringingFoundTaskToFront"); movedToFront = true; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; //å°†toReturnToè®¾ç½®ä¸ºhome intentActivity.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; options = null; &#125; &#125; if (!movedToFront) &#123; targetStack.moveToFront("intentActivityFound"); &#125; if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; //é‡ç½®ç›®æ ‡task intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r); &#125; if ((startFlags &amp; ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; if (doResume) &#123; resumeTopActivitiesLocked(targetStack, null, options); //å½“æ²¡æœ‰å¯åŠ¨è‡³å‰å°ï¼Œåˆ™é€šçŸ¥Keyguard if (!movedToFront) &#123; notifyActivityDrawnForKeyguard(); &#125; &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) &#123; reuseTask = intentActivity.task; //ç§»é™¤æ‰€æœ‰è·Ÿå·²å­˜åœ¨çš„taskæœ‰å…³è”çš„activity reuseTask.performClearTaskLocked(); reuseTask.setIntent(r); &#125; else if ((launchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0 || launchSingleInstance || launchSingleTask) &#123; ActivityRecord top = intentActivity.task.performClearTaskLocked(r, launchFlags); if (top != null) &#123; if (top.frontOfTask) &#123; top.task.setIntent(r); &#125; //è§¦å‘onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); &#125; else &#123; sourceRecord = intentActivity; TaskRecord task = sourceRecord.task; if (task != null &amp;&amp; task.stack == null) &#123; targetStack = computeStackFocus(sourceRecord, false /* newTask */); targetStack.addTask( task, !launchTaskBehind /* toTop */, false /* moving */); &#125; &#125; &#125; else if (r.realActivity.equals(intentActivity.task.realActivity)) &#123; if (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop) &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) &#123; if (intentActivity.frontOfTask) &#123; intentActivity.task.setIntent(r); &#125; //è§¦å‘onNewIntent() intentActivity.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); &#125; else if (!r.intent.filterEquals(intentActivity.task.intent)) &#123; addingToTask = true; sourceRecord = intentActivity; &#125; &#125; else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) &#123; addingToTask = true; sourceRecord = intentActivity; &#125; else if (!intentActivity.task.rootWasReset) &#123; intentActivity.task.setIntent(r); &#125; if (!addingToTask &amp;&amp; reuseTask == null) &#123; if (doResume) &#123; targetStack.resumeTopActivityLocked(null, options); if (!movedToFront) &#123; notifyActivityDrawnForKeyguard(); &#125; &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_TASK_TO_FRONT; &#125; &#125; &#125; &#125; if (r.packageName != null) &#123; //å½“å¯åŠ¨çš„activityè·Ÿå‰å°æ˜¾ç¤ºæ˜¯åŒä¸€ä¸ªçš„æƒ…å†µ ActivityStack topStack = mFocusedStack; ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop); if (top != null &amp;&amp; r.resultTo == null) &#123; if (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if (top.app != null &amp;&amp; top.app.thread != null) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; topStack.mLastPausedActivity = null; if (doResume) &#123; resumeTopActivitiesLocked(); &#125; ActivityOptions.abort(options); if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; &#125; //è§¦å‘onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; &#125; &#125; &#125; else &#123; if (r.resultTo != null &amp;&amp; r.resultTo.task.stack != null) &#123; r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return ActivityManager.START_CLASS_NOT_FOUND; &#125; boolean newTask = false; boolean keepCurTransition = false; TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != null ? sourceRecord.task : null; if (r.resultTo == null &amp;&amp; inTask == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; targetStack = computeStackFocus(r, newTask); targetStack.moveToFront("startingNewTask"); if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, voiceSession, voiceInteractor, !launchTaskBehind /* toTop */), taskToAffiliate); &#125; else &#123; r.setTask(reuseTask, taskToAffiliate); &#125; if (isLockTaskModeViolation(r.task)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; if (!movedHome) &#123; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; &#125; &#125; else if (sourceRecord != null) &#123; final TaskRecord sourceTask = sourceRecord.task; if (isLockTaskModeViolation(sourceTask)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = sourceTask.stack; targetStack.moveToFront("sourceStackToFront"); final TaskRecord topTask = targetStack.topTask(); if (topTask != sourceTask) &#123; targetStack.moveTaskToFrontLocked(sourceTask, noAnimation, options, r.appTimeTracker, "sourceTaskToFront"); &#125; if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) &#123; ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags); keepCurTransition = true; if (top != null) &#123; //è§¦å‘onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; ActivityOptions.abort(options); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) &#123; final ActivityRecord top = sourceTask.findActivityInHistoryLocked(r); if (top != null) &#123; final TaskRecord task = top.task; task.moveActivityToFrontLocked(top); top.updateOptionsLocked(options); //è§¦å‘onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; r.setTask(sourceTask, null); &#125; else if (inTask != null) &#123; if (isLockTaskModeViolation(inTask)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = inTask.stack; targetStack.moveTaskToFrontLocked(inTask, noAnimation, options, r.appTimeTracker, "inTaskToFront"); ActivityRecord top = inTask.getTopActivity(); if (top != null &amp;&amp; top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; //è§¦å‘onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; if (!addingToTask) &#123; ActivityOptions.abort(options); return ActivityManager.START_TASK_TO_FRONT; &#125; r.setTask(inTask, null); &#125; else &#123; targetStack = computeStackFocus(r, newTask); targetStack.moveToFront("addingToTopTask"); ActivityRecord prev = targetStack.topActivity(); r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(), r.info, intent, null, null, true), null); mWindowManager.moveTaskToTop(r.task.taskId); &#125; mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName, intent, r.getUriPermissionsLocked(), r.userId); if (sourceRecord != null &amp;&amp; sourceRecord.isRecentsActivity()) &#123; r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE); &#125; targetStack.mLastPausedActivity = null; //åˆ›å»ºactivity [è§æµç¨‹2.10] targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) &#123; mService.setFocusedActivityLocked(r, "startedActivity"); &#125; return ActivityManager.START_SUCCESS;&#125; æ‰¾åˆ°æˆ–åˆ›å»ºæ–°çš„Activitæ‰€å±žäºŽçš„Taskå¯¹è±¡ï¼Œä¹‹åŽè°ƒç”¨AS.startActivityLocked 2.9.1 Launch Modeå…ˆæ¥è¯´è¯´åœ¨ActivityInfo.javaä¸­å®šä¹‰äº†4ç±»Launch Modeï¼š LAUNCH_MULTIPLE(standard)ï¼šæœ€å¸¸è§çš„æƒ…å½¢ï¼Œæ¯æ¬¡å¯åŠ¨Activityéƒ½æ˜¯åˆ›å»ºæ–°çš„Activity; LAUNCH_SINGLE_TOP: å½“Taské¡¶éƒ¨å­˜åœ¨åŒä¸€ä¸ªActivityåˆ™ä¸å†é‡æ–°åˆ›å»ºï¼›å…¶ä½™æƒ…å†µåŒä¸Šï¼› LAUNCH_SINGLE_TASKï¼šå½“Taskæ ˆå­˜åœ¨åŒä¸€ä¸ªActivity(ä¸åœ¨taské¡¶éƒ¨)ï¼Œåˆ™ä¸é‡æ–°åˆ›å»ºï¼Œè€Œç§»é™¤è¯¥Activityä¸Šé¢å…¶ä»–çš„Activityï¼›å…¶ä½™æƒ…å†µåŒä¸Šï¼› LAUNCH_SINGLE_INSTANCEï¼šæ¯ä¸ªTaskåªæœ‰ä¸€ä¸ªActivity. å†æ¥è¯´è¯´å‡ ä¸ªå¸¸è§çš„flagå«ä¹‰ï¼š FLAG_ACTIVITY_NEW_TASKï¼šå°†Activityæ”¾å…¥ä¸€ä¸ªæ–°å¯åŠ¨çš„Taskï¼› FLAG_ACTIVITY_CLEAR_TASKï¼šå¯åŠ¨Activityæ—¶ï¼Œå°†ç›®æ ‡Activityå…³è”çš„Taskæ¸…é™¤ï¼Œå†å¯åŠ¨æ–°Taskï¼Œå°†è¯¥Activityæ”¾å…¥è¯¥Taskã€‚è¯¥flagsè·ŸFLAG_ACTIVITY_NEW_TASKé…åˆä½¿ç”¨ã€‚ FLAG_ACTIVITY_CLEAR_TOPï¼šå¯åŠ¨éžæ ˆé¡¶Activityæ—¶ï¼Œå…ˆæ¸…é™¤è¯¥Activityä¹‹ä¸Šçš„Activityã€‚ä¾‹å¦‚Taskå·²æœ‰Aã€Bã€C3ä¸ªActivityï¼Œå¯åŠ¨Aï¼Œåˆ™æ¸…é™¤Bï¼ŒCã€‚ç±»ä¼¼äºŽSingleTopã€‚ æœ€åŽå†è¯´è¯´ï¼šè®¾ç½®FLAG_ACTIVITY_NEW_TASKçš„å‡ ä¸ªæƒ…å†µï¼š è°ƒç”¨è€…å¹¶ä¸æ˜¯Activity contextï¼› è°ƒç”¨è€…activityå¸¦æœ‰single instanceï¼› ç›®æ ‡activityå¸¦æœ‰single instanceæˆ–è€…single taskï¼› è°ƒç”¨è€…å¤„äºŽfinishingçŠ¶æ€ï¼› 2.10 AS.startActivityLocked[-&gt; ActivityStack.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) &#123; TaskRecord rTask = r.task; final int taskId = rTask.taskId; if (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == null || newTask)) &#123; //taskä¸­çš„ä¸Šä¸€ä¸ªactivityå·²è¢«ç§»é™¤ï¼Œæˆ–è€…amsé‡ç”¨è¯¥task,åˆ™å°†è¯¥taskç§»åˆ°é¡¶éƒ¨ insertTaskAtTop(rTask, r); mWindowManager.moveTaskToTop(taskId); &#125; TaskRecord task = null; if (!newTask) &#123; boolean startIt = true; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; task = mTaskHistory.get(taskNdx); if (task.getTopActivity() == null) &#123; //è¯¥taskæ‰€æœ‰activityéƒ½finishing continue; &#125; if (task == r.task) &#123; if (!startIt) &#123; task.addActivityToTop(r); r.putInHistory(); mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); ActivityOptions.abort(options); return; &#125; break; &#125; else if (task.numFullscreen &gt; 0) &#123; startIt = false; &#125; &#125; &#125; if (task == r.task &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) &#123; mStackSupervisor.mUserLeaving = false; &#125; task = r.task; task.addActivityToTop(r); task.setFrontOfTask(); r.putInHistory(); mActivityTrigger.activityStartTrigger(r.intent, r.info, r.appInfo); if (!isHomeStack() || numActivities() &gt; 0) &#123; //å½“åˆ‡æ¢åˆ°æ–°çš„taskï¼Œæˆ–è€…ä¸‹ä¸€ä¸ªactivityè¿›ç¨‹ç›®å‰å¹¶æ²¡æœ‰è¿è¡Œï¼Œåˆ™ boolean showStartingIcon = newTask; ProcessRecord proc = r.app; if (proc == null) &#123; proc = mService.mProcessNames.get(r.processName, r.info.applicationInfo.uid); &#125; if (proc == null || proc.thread == null) &#123; showStartingIcon = true; &#125; if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, keepCurTransition); mNoAnimActivities.add(r); &#125; else &#123; mWindowManager.prepareAppTransition(newTask ? r.mLaunchTaskBehind ? AppTransition.TRANSIT_TASK_OPEN_BEHIND : AppTransition.TRANSIT_TASK_OPEN : AppTransition.TRANSIT_ACTIVITY_OPEN, keepCurTransition); mNoAnimActivities.remove(r); &#125; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); boolean doShow = true; if (newTask) &#123; if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; resetTaskIfNeededLocked(r, r); doShow = topRunningNonDelayedActivityLocked(null) == r; &#125; &#125; else if (options != null &amp;&amp; new ActivityOptions(options).getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123; doShow = false; &#125; if (r.mLaunchTaskBehind) &#123; mWindowManager.setAppVisibility(r.appToken, true); ensureActivitiesVisibleLocked(null, 0); &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; ActivityRecord prev = mResumedActivity; if (prev != null) &#123; //å½“å‰activityæ‰€å±žä¸åŒçš„task if (prev.task != r.task) &#123; prev = null; &#125; //å½“å‰activityå·²ç»displayed else if (prev.nowVisible) &#123; prev = null; &#125; &#125; mWindowManager.setAppStartingWindow( r.appToken, r.packageName, r.theme, mService.compatibilityInfoForPackageLocked( r.info.applicationInfo), r.nonLocalizedLabel, r.labelRes, r.icon, r.logo, r.windowFlags, prev != null ? prev.appToken : null, showStartingIcon); r.mStartingWindowShown = true; &#125; &#125; else &#123; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); ActivityOptions.abort(options); options = null; &#125; if (doResume) &#123; // [è§æµç¨‹2.11] mStackSupervisor.resumeTopActivitiesLocked(this, r, options); &#125;&#125; 2.11 ASS.resumeTopActivitiesLocked1234567891011121314151617181920212223242526boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) &#123; if (targetStack == null) &#123; targetStack = mFocusedStack; &#125; boolean result = false; if (isFrontStack(targetStack)) &#123; //[è§æµç¨‹2.12] result = targetStack.resumeTopActivityLocked(target, targetOptions); &#125; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; final ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (stack == targetStack) &#123; //ä¸Šé¢åˆšå·²å¯åŠ¨ continue; &#125; if (isFrontStack(stack)) &#123; stack.resumeTopActivityLocked(null); &#125; &#125; &#125; return result;&#125; 2.12 AS.resumeTopActivityLocked12345678910111213141516171819final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; return false; //é˜²æ­¢é€’å½’å¯åŠ¨ &#125; boolean result = false; try &#123; mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; //[è§æµç¨‹2.13] result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; inResumeTopActivityç”¨äºŽä¿è¯æ¯æ¬¡åªæœ‰ä¸€ä¸ªActivityæ‰§è¡ŒresumeTopActivityLocked()æ“ä½œ. 2.13 AS.resumeTopActivityInnerLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123; ... //ç³»ç»Ÿæ²¡æœ‰è¿›å…¥bootingæˆ–bootedçŠ¶æ€ï¼Œåˆ™ä¸å…è®¸å¯åŠ¨Activity ActivityRecord parent = mActivityContainer.mParentActivity; if ((parent != null &amp;&amp; parent.state != ActivityState.RESUMED) || !mActivityContainer.isAttachedLocked()) &#123; return false; &#125; //top runningä¹‹åŽçš„ä»»æ„å¤„äºŽåˆå§‹åŒ–çŠ¶æ€ä¸”æœ‰æ˜¾ç¤ºStartingWindow, åˆ™ç§»é™¤StartingWindow cancelInitializingActivities(); //æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ²¡æœ‰finishingçš„æ ˆé¡¶activity final ActivityRecord next = topRunningActivityLocked(null); final boolean userLeaving = mStackSupervisor.mUserLeaving; mStackSupervisor.mUserLeaving = false; final TaskRecord prevTask = prev != null ? prev.task : null; if (next == null) &#123; final String reason = "noMoreActivities"; if (!mFullscreen) &#123; //å½“è¯¥æ ˆæ²¡æœ‰å…¨å±ï¼Œåˆ™å°è¯•èšç„¦åˆ°ä¸‹ä¸€ä¸ªå¯è§çš„stack final ActivityStack stack = getNextVisibleStackLocked(); if (adjustFocusToNextVisibleStackLocked(stack, reason)) &#123; return mStackSupervisor.resumeTopActivitiesLocked(stack, prev, null); &#125; &#125; ActivityOptions.abort(options); final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ? HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo(); //å¯åŠ¨homeæ¡Œé¢activity return isOnHomeDisplay() &amp;&amp; mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, reason); &#125; next.delayedResume = false; if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; mWindowManager.executeAppTransition(); mNoAnimActivities.clear(); ActivityOptions.abort(options); return false; &#125; final TaskRecord nextTask = next.task; if (prevTask != null &amp;&amp; prevTask.stack == this &amp;&amp; prevTask.isOverHomeStack() &amp;&amp; prev.finishing &amp;&amp; prev.frontOfTask) &#123; if (prevTask == nextTask) &#123; prevTask.setFrontOfTask(); &#125; else if (prevTask != topTask()) &#123; final int taskNdx = mTaskHistory.indexOf(prevTask) + 1; mTaskHistory.get(taskNdx).setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; else if (!isOnHomeDisplay()) &#123; return false; &#125; else if (!isHomeStack())&#123; final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ? HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo(); return isOnHomeDisplay() &amp;&amp; mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, "prevFinished"); &#125; &#125; //å¤„äºŽç¡çœ æˆ–è€…å…³æœºçŠ¶æ€ï¼Œtop activityå·²æš‚åœçš„æƒ…å†µä¸‹ if (mService.isSleepingOrShuttingDown() &amp;&amp; mLastPausedActivity == next &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123; mWindowManager.executeAppTransition(); mNoAnimActivities.clear(); ActivityOptions.abort(options); return false; &#125; if (mService.mStartedUsers.get(next.userId) == null) &#123; return false; //æ‹¥æœ‰è¯¥activityçš„ç”¨æˆ·æ²¡æœ‰å¯åŠ¨åˆ™ç›´æŽ¥è¿”å›ž &#125; mStackSupervisor.mStoppingActivities.remove(next); mStackSupervisor.mGoingToSleepActivities.remove(next); next.sleeping = false; mStackSupervisor.mWaitingVisibleActivities.remove(next); mActivityTrigger.activityResumeTrigger(next.intent, next.info, next.appInfo); if (!mStackSupervisor.allPausedActivitiesComplete()) &#123; return false; //å½“æ­£å¤„äºŽæš‚åœactivityï¼Œåˆ™ç›´æŽ¥è¿”å›ž &#125; mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid); //éœ€è¦ç­‰å¾…æš‚åœå½“å‰activityå®Œæˆï¼Œå†resume top activity boolean dontWaitForPause = (next.info.flags&amp;ActivityInfo.FLAG_RESUME_WHILE_PAUSING) != 0; //æš‚åœå…¶ä»–Activity[è§å°èŠ‚2.13.1] boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, true, dontWaitForPause); if (mResumedActivity != null) &#123; //å½“å‰resumdçŠ¶æ€activityä¸ä¸ºç©ºï¼Œåˆ™éœ€è¦å…ˆæš‚åœè¯¥Activity pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause); &#125; if (pausing) &#123; if (next.app != null &amp;&amp; next.app.thread != null) &#123; mService.updateLruProcessLocked(next.app, true, null); &#125; return true; &#125; if (mService.isSleeping() &amp;&amp; mLastNoHistoryActivity != null &amp;&amp; !mLastNoHistoryActivity.finishing) &#123; requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED, null, "resume-no-history", false); mLastNoHistoryActivity = null; &#125; if (prev != null &amp;&amp; prev != next) &#123; if (!mStackSupervisor.mWaitingVisibleActivities.contains(prev) &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123; mStackSupervisor.mWaitingVisibleActivities.add(prev); &#125; else &#123; if (prev.finishing) &#123; mWindowManager.setAppVisibility(prev.appToken, false); &#125; &#125; &#125; AppGlobals.getPackageManager().setPackageStoppedState( next.packageName, false, next.userId); boolean anim = true; if (mIsAnimationBoostEnabled == true &amp;&amp; mPerf == null) &#123; mPerf = new BoostFramework(); &#125; if (prev != null) &#123; if (prev.finishing) &#123; if (mNoAnimActivities.contains(prev)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_CLOSE : AppTransition.TRANSIT_TASK_CLOSE, false); if(prev.task != next.task &amp;&amp; mPerf != null) &#123; mPerf.perfLockAcquire(aBoostTimeOut, aBoostParamVal); &#125; &#125; mWindowManager.setAppWillBeHidden(prev.appToken); mWindowManager.setAppVisibility(prev.appToken, false); &#125; else &#123; if (mNoAnimActivities.contains(next)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_OPEN : next.mLaunchTaskBehind ? AppTransition.TRANSIT_TASK_OPEN_BEHIND : AppTransition.TRANSIT_TASK_OPEN, false); if(prev.task != next.task &amp;&amp; mPerf != null) &#123; mPerf.perfLockAcquire(aBoostTimeOut, aBoostParamVal); &#125; &#125; &#125; &#125; else &#123; if (mNoAnimActivities.contains(next)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN, false); &#125; &#125; Bundle resumeAnimOptions = null; if (anim) &#123; ActivityOptions opts = next.getOptionsForTargetActivityLocked(); if (opts != null) &#123; resumeAnimOptions = opts.toBundle(); &#125; next.applyOptionsLocked(); &#125; else &#123; next.clearOptionsLocked(); &#125; ActivityStack lastStack = mStackSupervisor.getLastStack(); //è¿›ç¨‹å·²å­˜åœ¨çš„æƒ…å†µ if (next.app != null &amp;&amp; next.app.thread != null) &#123; //activityæ­£åœ¨æˆä¸ºå¯è§ mWindowManager.setAppVisibility(next.appToken, true); next.startLaunchTickingLocked(); ActivityRecord lastResumedActivity = lastStack == null ? null :lastStack.mResumedActivity; ActivityState lastState = next.state; mService.updateCpuStats(); //è®¾ç½®ActivityçŠ¶æ€ä¸ºresumed next.state = ActivityState.RESUMED; mResumedActivity = next; next.task.touchActiveTime(); mRecentTasks.addLocked(next.task); mService.updateLruProcessLocked(next.app, true, null); updateLRUListLocked(next); mService.updateOomAdjLocked(); boolean notUpdated = true; if (mStackSupervisor.isFrontStack(this)) &#123; Configuration config = mWindowManager.updateOrientationFromAppTokens( mService.mConfiguration, next.mayFreezeScreenLocked(next.app) ? next.appToken : null); if (config != null) &#123; next.frozenBeforeDestroy = true; &#125; notUpdated = !mService.updateConfigurationLocked(config, next, false, false); &#125; if (notUpdated) &#123; ActivityRecord nextNext = topRunningActivityLocked(null); if (nextNext != next) &#123; mStackSupervisor.scheduleResumeTopActivities(); &#125; if (mStackSupervisor.reportResumedActivityLocked(next)) &#123; mNoAnimActivities.clear(); return true; &#125; return false; &#125; try &#123; //åˆ†å‘æ‰€æœ‰pendingç»“æžœ. ArrayList&lt;ResultInfo&gt; a = next.results; if (a != null) &#123; final int N = a.size(); if (!next.finishing &amp;&amp; N &gt; 0) &#123; next.app.thread.scheduleSendResult(next.appToken, a); &#125; &#125; if (next.newIntents != null) &#123; next.app.thread.scheduleNewIntent(next.newIntents, next.appToken); &#125; next.sleeping = false; mService.showAskCompatModeDialogLocked(next); next.app.pendingUiClean = true; next.app.forceProcessStateUpTo(mService.mTopProcessState); next.clearOptionsLocked(); //è§¦å‘onResume() next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState, mService.isNextTransitionForward(), resumeAnimOptions); mStackSupervisor.checkReadyForSleepLocked(); &#125; catch (Exception e) &#123; ... return true; &#125; next.visible = true; completeResumeLocked(next); next.stopped = false; &#125; else &#123; if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; else &#123; if (SHOW_APP_STARTING_PREVIEW) &#123; mWindowManager.setAppStartingWindow( next.appToken, next.packageName, next.theme, mService.compatibilityInfoForPackageLocked( next.info.applicationInfo), next.nonLocalizedLabel, next.labelRes, next.icon, next.logo, next.windowFlags, null, true); &#125; &#125; mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true;&#125; ä¸»è¦åˆ†æ”¯åŠŸèƒ½ï¼š å½“æ‰¾ä¸åˆ°éœ€è¦resumeçš„Activityï¼Œåˆ™ç›´æŽ¥å›žåˆ°æ¡Œé¢ï¼› å¦åˆ™ï¼Œå½“mResumedActivityä¸ä¸ºç©ºï¼Œåˆ™æ‰§è¡ŒstartPausingLocked()æš‚åœè¯¥activity; ç„¶åŽå†è¿›å…¥startSpecificActivityLockedçŽ¯èŠ‚ï¼ŒæŽ¥ä¸‹æ¥ä»Žè¿™é‡Œç»§ç»­å¾€ä¸‹è¯´ã€‚ 2.13.1 ASS.pauseBackStacks123456789101112131415boolean pauseBackStacks(boolean userLeaving, boolean resuming, boolean dontWait) &#123; boolean someActivityPaused = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack) &amp;&amp; stack.mResumedActivity != null) &#123; //[è§å°èŠ‚2.13.2] someActivityPaused |= stack.startPausingLocked(userLeaving, false, resuming, dontWait); &#125; &#125; &#125; return someActivityPaused;&#125; æš‚åœæ‰€æœ‰å¤„äºŽåŽå°æ ˆçš„æ‰€æœ‰Activityã€‚ 2.13.2 AS.startPausingLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) &#123; if (mPausingActivity != null) &#123; if (!mService.isSleeping()) &#123; completePauseLocked(false); &#125; &#125; ActivityRecord prev = mResumedActivity; ... if (mActivityContainer.mParentActivity == null) &#123; //æš‚åœæ‰€æœ‰å­æ ˆçš„Activity mStackSupervisor.pauseChildStacks(prev, userLeaving, uiSleeping, resuming, dontWait); &#125; ... final ActivityRecord next = mStackSupervisor.topRunningActivityLocked(); if (prev.app != null &amp;&amp; prev.app.thread != null) &#123; EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); //æš‚åœç›®æ ‡Activity prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); &#125;else &#123; ... &#125; if (!uiSleeping &amp;&amp; !mService.isSleepingOrShuttingDown()) &#123; mStackSupervisor.acquireLaunchWakelock(); //ç”³è¯·wakelock &#125; if (mPausingActivity != null) &#123; if (!uiSleeping) &#123; prev.pauseKeyDispatchingLocked(); &#125; if (dontWait) &#123; completePauseLocked(false); return false; &#125; else &#123; Message msg = mHandler.obtainMessage(PAUSE_TIMEOUT_MSG); msg.obj = prev; prev.pauseTime = SystemClock.uptimeMillis(); //500msåŽï¼Œæ‰§è¡Œæš‚åœè¶…æ—¶çš„æ¶ˆæ¯ mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT); return true; &#125; &#125; else &#123; if (!resuming) &#123; //è°ƒåº¦æš‚åœå¤±è´¥ï¼Œåˆ™è®¤ä¸ºå·²æš‚åœå®Œæˆï¼Œå¼€å§‹æ‰§è¡Œresumeæ“ä½œ mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null); &#125; return false; &#125; è¯¥æ–¹æ³•ä¸­ï¼Œä¸‹ä¸€æ­¥é€šè¿‡Binderè°ƒç”¨ï¼Œè¿›å…¥acitivityæ‰€åœ¨è¿›ç¨‹æ¥æ‰§è¡ŒschedulePauseActivity()æ“ä½œã€‚ æŽ¥ä¸‹æ¥ï¼Œå¯¹äºŽdontWait=trueåˆ™æ‰§è¡Œæ‰§è¡ŒcompletePauseLockedï¼Œå¦åˆ™ç­‰å¾…appé€šçŸ¥æˆ–è®¸500msè¶…æ—¶å†æ‰§è¡Œè¯¥æ–¹æ³•ã€‚ 3.13.3 completePauseLocked2.14 ASS.startSpecificActivityLocked1234567891011121314151617181920212223242526void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !"android".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; //çœŸæ­£çš„å¯åŠ¨Activityã€è§æµç¨‹2.17ã€‘ realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; &#125; //å½“è¿›ç¨‹ä¸å­˜åœ¨åˆ™åˆ›å»ºè¿›ç¨‹ [è§æµç¨‹2.14.1] mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true);&#125; 2.15 AMS.startProcessLockedåœ¨æ–‡ç« ç†è§£Androidè¿›ç¨‹å¯åŠ¨ä¹‹å…¨è¿‡ç¨‹ä¸­ï¼Œè¯¦ç»†ä»‹ç»äº†AMS.startProcessLocked()æ•´ä¸ªè¿‡ç¨‹ï¼Œåˆ›å»ºå®Œæ–°è¿›ç¨‹åŽä¼šåœ¨æ–°è¿›ç¨‹ä¸­è°ƒç”¨AMP.attachApplicationï¼Œè¯¥æ–¹æ³•ç»è¿‡binder ipcåŽè°ƒç”¨åˆ°AMS.attachApplicationLockedã€‚ 1234567891011121314private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ... ////åªæœ‰å½“ç³»ç»Ÿå¯åŠ¨å®Œï¼Œæˆ–è€…appå…è®¸å¯åŠ¨è¿‡ç¨‹å…è®¸ï¼Œåˆ™ä¼štrue boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); thread.bindApplication(...); if (normalMode) &#123; //ã€è§æµç¨‹2.16ã€‘ if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; ...&#125; åœ¨æ‰§è¡Œå®ŒbindApplication()ä¹‹åŽè¿›å…¥ASS.attachApplicationLocked() 2.16 ASS.attachApplicationLocked123456789101112131415161718192021222324252627282930313233boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) &#123; continue; &#125; //èŽ·å–å‰å°stackä¸­æ ˆé¡¶ç¬¬ä¸€ä¸ªéžfinishingçš„Activity ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; //çœŸæ­£çš„å¯åŠ¨Activityã€è§æµç¨‹2.17ã€‘ if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (RemoteException e) &#123; throw e; &#125; &#125; &#125; &#125; &#125; if (!didSomething) &#123; //å¯åŠ¨Activityä¸æˆåŠŸï¼Œåˆ™ç¡®ä¿æœ‰å¯è§çš„Activity ensureActivitiesVisibleLocked(null, 0); &#125; return didSomething;&#125; 2.17 ASS.realStartActivityLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; if (andResume) &#123; r.startFreezingScreenLocked(app, 0); mWindowManager.setAppVisibility(r.appToken, true); //è°ƒåº¦å¯åŠ¨ticksç”¨ä»¥æ”¶é›†åº”ç”¨å¯åŠ¨æ…¢çš„ä¿¡æ¯ r.startLaunchTickingLocked(); &#125; if (checkConfig) &#123; Configuration config = mWindowManager.updateOrientationFromAppTokens( mService.mConfiguration, r.mayFreezeScreenLocked(app) ? r.appToken : null); //æ›´æ–°Configuration mService.updateConfigurationLocked(config, r, false, false); &#125; r.app = app; app.waitingToKill = null; r.launchCount++; r.lastLaunchTime = SystemClock.uptimeMillis(); int idx = app.activities.indexOf(r); if (idx &lt; 0) &#123; app.activities.add(r); &#125; mService.updateLruProcessLocked(app, true, null); mService.updateOomAdjLocked(); final TaskRecord task = r.task; if (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV) &#123; setLockTaskModeLocked(task, LOCK_TASK_MODE_LOCKED, "mLockTaskAuth==LAUNCHABLE", false); &#125; final ActivityStack stack = task.stack; try &#123; if (app.thread == null) &#123; throw new RemoteException(); &#125; List&lt;ResultInfo&gt; results = null; List&lt;ReferrerIntent&gt; newIntents = null; if (andResume) &#123; results = r.results; newIntents = r.newIntents; &#125; if (r.isHomeActivity() &amp;&amp; r.isNotResolverActivity()) &#123; //homeè¿›ç¨‹æ˜¯è¯¥æ ˆçš„æ ¹è¿›ç¨‹ mService.mHomeProcess = task.mActivities.get(0).app; &#125; mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName()); ... if (andResume) &#123; app.hasShownUi = true; app.pendingUiClean = true; &#125; //å°†è¯¥è¿›ç¨‹è®¾ç½®ä¸ºå‰å°è¿›ç¨‹PROCESS_STATE_TOP app.forceProcessStateUpTo(mService.mTopProcessState); //ã€è§æµç¨‹2.18ã€‘ app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); if ((app.info.privateFlags&amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; ... //å¤„ç†heavy-weightè¿›ç¨‹ &#125; &#125; catch (RemoteException e) &#123; if (r.launchFailed) &#123; //ç¬¬äºŒæ¬¡å¯åŠ¨å¤±è´¥ï¼Œåˆ™ç»“æŸè¯¥activity mService.appDiedLocked(app); stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null, "2nd-crash", false); return false; &#125; //è¿™æ˜¯ç¬¬ä¸€ä¸ªå¯åŠ¨å¤±è´¥ï¼Œåˆ™é‡å¯è¿›ç¨‹ app.activities.remove(r); throw e; &#125; //å°†è¯¥è¿›ç¨‹åŠ å…¥åˆ°mLRUActivitiesé˜Ÿåˆ—é¡¶éƒ¨ stack.updateLRUListLocked(r)ï¼› if (andResume) &#123; //å¯åŠ¨è¿‡ç¨‹çš„ä¸€éƒ¨åˆ† stack.minimalResumeActivityLocked(r); &#125; else &#123; r.state = STOPPED; r.stopped = true; &#125; if (isFrontStack(stack)) &#123; //å½“ç³»ç»Ÿå‘ç”Ÿæ›´æ–°æ—¶ï¼Œåªä¼šæ‰§è¡Œä¸€æ¬¡çš„ç”¨æˆ·å‘å¯¼ mService.startSetupActivityLocked(); &#125; //æ›´æ–°æ‰€æœ‰ä¸Žè¯¥Activityå…·æœ‰ç»‘å®šå…³ç³»çš„Serviceè¿žæŽ¥ mService.mServices.updateServiceConnectionActivitiesLocked(r.app); return true;&#125; 2.18 ATP.scheduleLaunchActivity[-&gt; ApplicationThreadProxy.java] 1234567891011121314151617181920212223242526272829303132333435public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); intent.writeToParcel(data, 0); data.writeStrongBinder(token); data.writeInt(ident); info.writeToParcel(data, 0); curConfig.writeToParcel(data, 0); if (overrideConfig != null) &#123; data.writeInt(1); overrideConfig.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; compatInfo.writeToParcel(data, 0); data.writeString(referrer); data.writeStrongBinder(voiceInteractor != null ? voiceInteractor.asBinder() : null); data.writeInt(procState); data.writeBundle(state); data.writePersistableBundle(persistentState); data.writeTypedList(pendingResults); data.writeTypedList(pendingNewIntents); data.writeInt(notResumed ? 1 : 0); data.writeInt(isForward ? 1 : 0); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; //ã€è§æµç¨‹2.19ã€‘ mRemote.transact(SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; 2.19 ATN.onTransact[-&gt; ApplicationThreadNative.java] 123456789101112131415161718192021222324252627282930313233343536public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); Intent intent = Intent.CREATOR.createFromParcel(data); IBinder b = data.readStrongBinder(); int ident = data.readInt(); ActivityInfo info = ActivityInfo.CREATOR.createFromParcel(data); Configuration curConfig = Configuration.CREATOR.createFromParcel(data); Configuration overrideConfig = null; if (data.readInt() != 0) &#123; overrideConfig = Configuration.CREATOR.createFromParcel(data); &#125; CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data); String referrer = data.readString(); IVoiceInteractor voiceInteractor = IVoiceInteractor.Stub.asInterface( data.readStrongBinder()); int procState = data.readInt(); Bundle state = data.readBundle(); PersistableBundle persistentState = data.readPersistableBundle(); List&lt;ResultInfo&gt; ri = data.createTypedArrayList(ResultInfo.CREATOR); List&lt;ReferrerIntent&gt; pi = data.createTypedArrayList(ReferrerIntent.CREATOR); boolean notResumed = data.readInt() != 0; boolean isForward = data.readInt() != 0; ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; //ã€è§æµç¨‹2.20ã€‘ scheduleLaunchActivity(intent, b, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, ri, pi, notResumed, isForward, profilerInfo); return true; &#125; ... &#125;&#125; 2.20 AT.scheduleLaunchActivity[-&gt; ApplicationThread.java] 1234567891011121314151617181920212223242526272829public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); //ã€è§æµç¨‹2.21ã€‘ sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 2.21 H.handleMessage[-&gt; ActivityThread.java ::H] 123456789101112public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); //ã€è§æµç¨‹2.22ã€‘ handleLaunchActivity(r, null); &#125; break; ... &#125;&#125; 2.22 ActivityThread.handleLaunchActivity[-&gt; ActivityThread.java] 12345678910111213141516171819202122232425262728private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; unscheduleGcIdler(); mSomeActivitiesChanged = true; //æœ€ç»ˆå›žè°ƒç›®æ ‡Activityçš„onConfigurationChanged() handleConfigurationChanged(null, null); //åˆå§‹åŒ–wms WindowManagerGlobal.initialize(); //æœ€ç»ˆå›žè°ƒç›®æ ‡Activityçš„onCreate[è§æµç¨‹2.23] Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //æœ€ç»ˆå›žè°ƒç›®æ ‡Activityçš„onStart,onResume. handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); r.paused = true; &#125; &#125; else &#123; //å­˜åœ¨erroråˆ™åœæ­¢è¯¥Activity ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); &#125;&#125; 2.23 ActivityThread.performLaunchActivity[-&gt; ActivityThread.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; //åˆ›å»ºApplicationå¯¹è±¡ Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; ... &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; åˆ°æ­¤ï¼Œæ­£å¼è¿›å…¥äº†Activityçš„onCreate, onStart, onResumeè¿™äº›ç”Ÿå‘½å‘¨æœŸçš„è¿‡ç¨‹ã€‚ ä¸‰. æ€»ç»“æœ¬æ–‡è¯¦ç»†startActivityçš„æ•´ä¸ªå¯åŠ¨æµç¨‹ï¼Œ æµç¨‹[2.1 ~2.4]:è¿è¡Œåœ¨è°ƒç”¨è€…æ‰€åœ¨è¿›ç¨‹ï¼Œæ¯”å¦‚ä»Žæ¡Œé¢å¯åŠ¨Activityï¼Œåˆ™è°ƒç”¨è€…æ‰€åœ¨è¿›ç¨‹ä¸ºlauncherè¿›ç¨‹ï¼Œlauncherè¿›ç¨‹åˆ©ç”¨ActivityManagerProxyä½œä¸ºBinder Clientï¼Œè¿›å…¥system_serverè¿›ç¨‹(AMSç›¸åº”çš„Serverç«¯)ã€‚ æµç¨‹[2.5 ~2.18]:è¿è¡Œåœ¨system_serverç³»ç»Ÿè¿›ç¨‹ï¼Œæ•´ä¸ªè¿‡ç¨‹æœ€ä¸ºå¤æ‚ã€æ ¸å¿ƒçš„è¿‡ç¨‹ï¼Œä¸‹é¢å…¶ä¸­éƒ¨åˆ†æ­¥éª¤ï¼šæµç¨‹[2.7]ï¼šä¼šè°ƒç”¨åˆ°resolveActivity()ï¼Œå€ŸåŠ©PackageManageræ¥æŸ¥è¯¢ç³»ç»Ÿä¸­æ‰€æœ‰ç¬¦åˆè¦æ±‚çš„Activityï¼Œå½“å­˜åœ¨å¤šä¸ªæ»¡è¶³æ¡ä»¶çš„Activityåˆ™ä¼šå¼¹æ¡†è®©ç”¨æˆ·æ¥é€‰æ‹©;æµç¨‹[2.8]ï¼šåˆ›å»ºActivityRecordå¯¹è±¡ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦è¿è¡ŒAppåˆ‡æ¢ï¼Œç„¶åŽå†å¤„ç†mPendingActivityLaunchesä¸­çš„activity;æµç¨‹[2.9]ï¼šä¸ºActivityæ‰¾åˆ°æˆ–åˆ›å»ºæ–°çš„Taskå¯¹è±¡ï¼Œè®¾ç½®flagsä¿¡æ¯ï¼›æµç¨‹[2.13]ï¼šå½“æ²¡æœ‰å¤„äºŽéžfinishingçŠ¶æ€çš„Activityï¼Œåˆ™ç›´æŽ¥å›žåˆ°æ¡Œé¢ï¼› å¦åˆ™ï¼Œå½“mResumedActivityä¸ä¸ºç©ºåˆ™æ‰§è¡ŒstartPausingLocked()æš‚åœè¯¥activity;ç„¶åŽå†è¿›å…¥startSpecificActivityLocked()çŽ¯èŠ‚;æµç¨‹[2.14]ï¼šå½“ç›®æ ‡è¿›ç¨‹å·²å­˜åœ¨åˆ™ç›´æŽ¥è¿›å…¥æµç¨‹[2.17]ï¼Œå½“è¿›ç¨‹ä¸å­˜åœ¨åˆ™åˆ›å»ºè¿›ç¨‹ï¼Œç»è¿‡å±‚å±‚è°ƒç”¨è¿˜æ˜¯ä¼šè¿›å…¥æµç¨‹[2.17];æµç¨‹[2.17]ï¼šsystem_serverè¿›ç¨‹åˆ©ç”¨çš„ATP(Binder Client)ï¼Œç»è¿‡Binderï¼Œç¨‹åºæŽ¥ä¸‹æ¥è¿›å…¥ç›®æ ‡è¿›ç¨‹ã€‚ æµç¨‹[2.19 ~2.18]:è¿è¡Œåœ¨ç›®æ ‡è¿›ç¨‹ï¼Œé€šè¿‡Handleræ¶ˆæ¯æœºåˆ¶ï¼Œè¯¥è¿›ç¨‹ä¸­çš„Binderçº¿ç¨‹å‘ä¸»çº¿ç¨‹å‘é€H.LAUNCH_ACTIVITYï¼Œæœ€ç»ˆä¼šé€šè¿‡åå°„åˆ›å»ºç›®æ ‡Activityï¼Œç„¶åŽè¿›å…¥onCreate()ç”Ÿå‘½å‘¨æœŸã€‚ ä»Žå¦ä¸€ä¸ªè§’åº¦ä¸‹å›¾æ¥æ¦‚æ‹¬ï¼š å¯åŠ¨æµç¨‹ï¼š ç‚¹å‡»æ¡Œé¢Appå›¾æ ‡ï¼ŒLauncherè¿›ç¨‹é‡‡ç”¨Binder IPCå‘system_serverè¿›ç¨‹å‘èµ·startActivityè¯·æ±‚ï¼› system_serverè¿›ç¨‹æŽ¥æ”¶åˆ°è¯·æ±‚åŽï¼Œå‘zygoteè¿›ç¨‹å‘é€åˆ›å»ºè¿›ç¨‹çš„è¯·æ±‚ï¼› Zygoteè¿›ç¨‹forkå‡ºæ–°çš„å­è¿›ç¨‹ï¼Œå³Appè¿›ç¨‹ï¼› Appè¿›ç¨‹ï¼Œé€šè¿‡Binder IPCå‘sytem_serverè¿›ç¨‹å‘èµ·attachApplicationè¯·æ±‚ï¼› system_serverè¿›ç¨‹åœ¨æ”¶åˆ°è¯·æ±‚åŽï¼Œè¿›è¡Œä¸€ç³»åˆ—å‡†å¤‡å·¥ä½œåŽï¼Œå†é€šè¿‡binder IPCå‘Appè¿›ç¨‹å‘é€scheduleLaunchActivityè¯·æ±‚ï¼› Appè¿›ç¨‹çš„binderçº¿ç¨‹ï¼ˆApplicationThreadï¼‰åœ¨æ”¶åˆ°è¯·æ±‚åŽï¼Œé€šè¿‡handlerå‘ä¸»çº¿ç¨‹å‘é€LAUNCH_ACTIVITYæ¶ˆæ¯ï¼› ä¸»çº¿ç¨‹åœ¨æ”¶åˆ°MessageåŽï¼Œé€šè¿‡å‘å°„æœºåˆ¶åˆ›å»ºç›®æ ‡Activityï¼Œå¹¶å›žè°ƒActivity.onCreate()ç­‰æ–¹æ³•ã€‚ åˆ°æ­¤ï¼ŒAppä¾¿æ­£å¼å¯åŠ¨ï¼Œå¼€å§‹è¿›å…¥Activityç”Ÿå‘½å‘¨æœŸï¼Œæ‰§è¡Œå®ŒonCreate/onStart/onResumeæ–¹æ³•ï¼ŒUIæ¸²æŸ“ç»“æŸåŽä¾¿å¯ä»¥çœ‹åˆ°Appçš„ä¸»ç•Œé¢ã€‚ å¯åŠ¨Activityè¾ƒä¸ºå¤æ‚ï¼ŒåŽç»­è®¡åˆ’å†è¿›ä¸€æ­¥è®²è§£ç”Ÿå‘½å‘¨æœŸè¿‡ç¨‹ä¸Žç³»ç»Ÿæ˜¯å¦‚ä½•äº¤äº’ï¼Œä»¥åŠUIæ¸²æŸ“è¿‡ç¨‹ï¼Œæ•¬è¯·æœŸå¾…ã€‚]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>ActivityThread</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Androidçš„æ¶ˆæ¯æœºåˆ¶]]></title>
    <url>%2F2018%2F03%2F13%2FAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Androidçš„æ¶ˆæ¯æœºåˆ¶ä¸»è¦æŒ‡Handlerçš„è¿è¡Œæœºåˆ¶, Handlerçš„è¿è¡Œéœ€è¦åº•å±‚çš„MessageQueueå’ŒLoopperçš„æ”¯æ’‘. MessageQueueæ¶ˆæ¯æœºåˆ¶, å†…éƒ¨å­˜å‚¨äº†ä¸€ç»„æ¶ˆæ¯, ä»¥é˜Ÿåˆ—çš„å½¢å¼å¯¹å¤–æä¾›æ’å…¥å’Œåˆ é™¤å·¥ä½œ. è™½ç„¶å«æ¶ˆæ¯é˜Ÿåˆ—,ä½†æ˜¯å…¶å†…éƒ¨å­˜å‚¨ç»“æž„å¹¶ä¸æ˜¯çœŸæ­£çš„é˜Ÿåˆ—,è€Œæ˜¯é‡‡ç”¨å•é“¾è¡¨çš„æ•°æ®ç»“æž„æ¥å­˜å‚¨æ¶ˆæ¯åˆ—è¡¨. Looperæ¶ˆæ¯å¾ªçŽ¯, å› ä¸ºMessageQueueæœ¬è´¨åªæ˜¯ä¸€ä¸ªæ¶ˆæ¯çš„å­˜å‚¨å•å…ƒ, å®ƒä¸èƒ½åŽ»å¤„ç†æ¶ˆæ¯, è€ŒLooperå°±æ˜¯ä¸ºå®žçŽ°å¤„ç†è€Œäº§ç”Ÿçš„. Looperä¼šä»¥æ— é™å¾ªçŽ¯çš„å½¢å¼åŽ»æŸ¥æ‰¾æ˜¯å¦æœ‰æ–°æ¶ˆæ¯, å¦‚æžœæœ‰çš„è¯å°±å¤„ç†æ¶ˆæ¯, å¦åœ¨å°±ä¸€ç›´ç­‰å¾…. Looperä¸­æœ‰ä¸€ä¸ªç‰¹æ®Šçš„æ¦‚å¿µThreadLocal, ThreadLocalå¹¶ä¸æ˜¯ä¸€ä¸ªçº¿ç¨‹, å®ƒå¯ä»¥åœ¨æ¯ä¸ªçº¿ç¨‹ä¸­è¿›è¡Œæ•°æ®çš„å­˜å‚¨. æˆ‘ä»¬ä½¿ç”¨çš„Handleråˆ›å»ºçš„æ—¶å€™éƒ½ä¼šé‡‡ç”¨å½“å‰çº¿ç¨‹çš„Looperæ¥æž„é€ æ¶ˆæ¯å¾ªçŽ¯ç³»ç»Ÿ, è€Œè¿™ä¸ªå½“å‰çº¿ç¨‹å°±æ˜¯é€šè¿‡ThreadLocalæ¥è¿›è¡Œæ“ä½œçš„. æœ‰ä¸€ç‚¹éœ€è¦è®°ä½: ä¸€ä¸ªæ–°çš„çº¿ç¨‹é»˜è®¤æ˜¯æ²¡æœ‰Looperçš„, å¦‚æžœè¦ä½¿ç”¨Handlerå°±å¿…ä¸ºçº¿ç¨‹åˆ›å»ºLooper, è€Œæˆ‘ä»¬ä½¿ç”¨ä¸»çº¿ç¨‹çš„æ—¶å€™ä¹‹æ‰€ä»¥ä¸éœ€è¦åˆ›å»ºLooperæ˜¯å› ä¸º. UIçº¿ç¨‹ä¹Ÿå°±æ˜¯ActivityThreadåœ¨è¢«åˆ›å»ºçš„æ—¶å€™å°±ä¼šåˆå§‹åŒ–Looper, æ‰€ä»¥æˆ‘ä»¬åœ¨ä¸»çº¿ç¨‹ä¹Ÿå°±å¯ä»¥ç›´æŽ¥ä½¿ç”¨Handlerçš„åŽŸå› . Android çš„æ¶ˆæ¯æœºåˆ¶æè¿°åœ¨æ—¥å¸¸å¼€å‘ä¸­å¦‚æžœä¸å°å¿ƒåœ¨å­çº¿ç¨‹æ›´æ–°äº†UIé‚£ä¹ˆå°±ä¼šæŠ›å‡ºå¼‚å¸¸, è¿™ä¸€æ­¥éª¤æ˜¯åœ¨ViewRootImpl#checkThread()æ–¹æ³•å®Œæˆçš„. 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; é‚£Handlerå¯ä»¥è®¤ä¸ºæ˜¯ä¸ºäº†åœ¨å­çº¿ç¨‹å¤„ç†å®Œæ“ä½œå¯ä»¥åˆ‡å›žåˆ°ä¸»çº¿ç¨‹è¿›è¡ŒUIæ“ä½œçš„ç”¨é€”. é‚£ä¸ºä»€ä¹ˆä¸èƒ½å†å­çº¿ç¨‹è¿›è¡ŒUIå¤„ç†å‘¢? è¿™æ˜¯å› ä¸ºAndroidçš„UIçº¿ç¨‹æŽ§ä»¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨, å¦‚æžœåœ¨å¤šçº¿ç¨‹ä¸­å¹¶å‘çš„è®¿é—®å¯èƒ½ä¼šå¯¼è‡´UIæŽ§ä»¶å¤„äºŽä¸å¯é¢„æœŸçš„çŠ¶æ€, è™½ç„¶å¯ä»¥ç”¨åŠ é”çš„å½¢å¼è®©ä¸Šè¿°é—®é¢˜æ¶ˆå¤±, ä½†æ˜¯æœ‰ä¸¤ä¸ªå¼Šç«¯: åŠ é”æœºåˆ¶ä¼šè®©UIè®¿é—®çš„é€»è¾‘å˜å¾—å¤æ‚ é”æœºåˆ¶ä¼šé™ä½ŽUIçš„è®¿é—®çš„æ•ˆçŽ‡, å› ä¸ºé”æœºåˆ¶ä¼šé˜»å¡žæŸäº›çº¿ç¨‹çš„æ‰§è¡Œ. å› ä¸ºè¿™æ ·, æœ€ç®€å•ä¸”é«˜æ•ˆçš„æ–¹æ³•å°±æ˜¯é‡‡ç”¨å•çº¿ç¨‹æ¨¡åž‹æ¥å¤„ç†UIæ“ä½œ. å½“Handler, Looper, MessageQueueéƒ½å‡†å¤‡å¥½ä¹‹åŽ. å°±å¯ä»¥é€šè¿‡Handler#post()æ–¹æ³•å°†ä¸€ä¸ªRunnableæŠ•é€’åˆ°Handlerå†…éƒ¨çš„Looperä¸­åŽ»å¤„ç†, ä¹Ÿå¯ä»¥é€šè¿‡send()æ–¹æ³•æ¥å‘é€ä¸€ä¸ªæ¶ˆæ¯, è¿™ä¸ªæ¶ˆæ¯åŒæ ·ä¼šåœ¨Looperä¸­å¤„ç†. è€Œpost()å†…éƒ¨ä¹Ÿæ˜¯é€šè¿‡send()æ¥å‘é€çš„. Androidæ¶ˆæ¯æœºåˆ¶åˆ†æžThreadLocalçš„å·¥ä½œåŽŸç†ThreadLocalæ˜¯ä¸€ä¸ªçº¿ç¨‹å†…éƒ¨çš„æ•°æ®å­˜å‚¨ç±», é€šè¿‡ä»–å¯ä»¥åœ¨æŒ‡å®šçš„çº¿ç¨‹ä¸­å­˜å‚¨æ•°æ®. æ•°æ®å­˜å‚¨ä»¥åŽ, åªèƒ½åœ¨æŒ‡å®šçº¿ç¨‹ä¸­å¯ä»¥èŽ·å–åˆ°å­˜å‚¨çš„æ•°æ®. è€Œå…¶ä»–çº¿ç¨‹æ— æ³•èŽ·å–. è€ŒAndroidä¸­çš„Looper ,ActivityThread, AMSéƒ½ç”¨åˆ°äº†ThreadLocal. å¯ä»¥è¿™æ ·æ¥è¯´: å½“æŸäº›æ•°æ®æ˜¯ä»¥çº¿ç¨‹ä¸ºä½œç”¨åŸŸå¹¶ä¸”ä¸åŒçº¿ç¨‹å…·æœ‰ä¸åŒçš„æ•°æ®å‰¯æœ¬çš„æ—¶å€™, å¯ä»¥é‡‡ç”¨ThreadLocal. å¯ä»¥è‡ªå·±ç”¨ä¸‰ä¸ªçº¿ç¨‹åˆ†åˆ«å¯¹ä¸€ä¸ªThreadLocalå¯¹è±¡è¿›è¡Œæ“ä½œ, è™½ç„¶æ“ä½œçš„æ˜¯ä¸€ä¸ªå¯¹è±¡, ä½†æ˜¯æ¯ä¸ªçº¿ç¨‹åœ¨èŽ·å–å€¼çš„æ—¶å€™å´ä¸ç›¸åŒ. è¿™æ˜¯å› ä¸º: ä¸åŒçš„çº¿ç¨‹è®¿é—®åŒä¸€ä¸ªThreadLocal#get()æ–¹æ³•çš„æ—¶å€™, ThreadLocalå†…éƒ¨ä¼šä»Žå„è‡ªçš„çº¿ç¨‹ä¸­å–å‡ºä¸€ä¸ªThreadLocalMapå¯¹è±¡, ç„¶åŽå†ä»ŽMapä¸­æ ¹æ®å½“å‰ThreadLocalçš„ç´¢å¼•åŽ»æŸ¥æ‰¾å‡ºå¯¹åº”çš„valueå€¼. å¯ä»¥çœ‹å‡ºä¸åŒçš„çº¿ç¨‹ä¸­çš„ThreadLocalMapæ˜¯ä¸ç›¸åŒçš„. æ‰€ä»¥ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆä½¿ç”¨ThreadLocalå¯ä»¥åœ¨ä¸åŒçš„çº¿ç¨‹ä¸­ç»´æŠ¤ä¸€å¥—æ•°æ®çš„å‰¯æœ¬å¹¶ä¸”å½¼æ­¤äº’ä¸å½±å“. è¿˜æ˜¯ç”¨æºç æ¥æ¢³ç†æµç¨‹ ThreadLocalæ˜¯ä¸€ä¸ªæ³›åž‹ç±», å®ƒçš„å®šä¹‰ä¸ºpublic class ThreadLocal&lt;T&gt;, çœ‹ä¸€ä¸‹set()æˆ–è€…get()å°±æ˜Žç™½äº†. 12345678910111213141516171819//ThreadLocal.javapublic void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;//Thread.java/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; é¦–å…ˆä¼šé€šè¿‡getMap()æ–¹æ³•æ¥èŽ·å–å½“å‰çº¿ç¨‹ä¸­çš„ThreadLocalæ•°æ®ã€‚åœ¨Threadç±»çš„å†…éƒ¨æœ‰ä¸€ä¸ªæˆå‘˜ä¸“é—¨ç”¨äºŽå­˜å‚¨çº¿ç¨‹çš„ThreadLocalçš„æ•°æ®ThreadLocal.ThreadLocalMap threadLocals. æ‰€ä»¥å¯¹ThreadLocalæ‰€åšçš„è¯»å†™æ“ä½œä»…é™äºŽå½“å‰çº¿ç¨‹çš„å¯¹åº”æ•°æ®ã€‚ åœ¨ThreadLocalMapä¸­æœ‰ä¸€ä¸ªæ•°ç»„private Entry[] tableï¼ŒThreadLocalè®¾ç½®çš„å€¼å°±å­˜åœ¨è¿™ä¸ªtableæ•°ç»„ä¸­. çœ‹ä¸€ä¸‹set()æ–¹æ³•. 12345678910111213141516171819202122232425262728293031323334353637/*** Set the value associated with key.** @param key the thread local object* @param value the value to be set*/private void set(ThreadLocal key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; è¿™é‡Œåªè¯´å¤§è‡´çš„è§„åˆ™, ä¸éœ€è¦å…·ä½“çœ‹å®žçŽ°çš„ç®—æ³•ï¼›å°±æ˜¯ThreadLocalçš„å€¼åœ¨ThreadLocalMapçš„tableæ•°ç»„ä¸­å­˜å‚¨çš„ã€‚ æŽ¥ç€çœ‹get()æ–¹æ³• 12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; è€ŒThreadLocal#get()æ–¹æ³•, åŒæ ·æ˜¯å–å‡ºå½“å‰çº¿ç¨‹ThreadLocalMapå¯¹è±¡, æŽ¥ç€èŽ·å–ThreadLocalMapä¸­çš„Entry[] tableæ•°ç»„é‡Œçš„å€¼. å‚è€ƒ: ç†è§£Javaä¸­çš„ThreadLocal æ¶ˆæ¯é˜Ÿåˆ—çš„å·¥ä½œåŽŸç†æ¶ˆæ¯é˜Ÿåˆ—åœ¨androidä¸­æŒ‡çš„æ˜¯MessageQueue, MessageQueueä¸»è¦åŒ…å«ä¸¤ä¸ªæ“ä½œ: æ’å…¥å’Œè¯»å–. è¯»å–æ“ä½œæœ¬èº«ä¼šä¼´éšç€åˆ é™¤çš„æ“ä½œ, æ’å…¥å’Œè¯»å–å¯¹åº”çš„æ–¹æ³•åˆ†åˆ«ä¸ºenqueueMessage(),next(). å‰è€…å°±æ˜¯å¾€æ¶ˆæ¯é˜Ÿåˆ—ä¸­æ’å…¥ä¸€æ¡æ¶ˆæ¯, è€ŒåŽè€…å°±æ˜¯å–å‡ºä¸€æ¡æ¶ˆæ¯å¹¶å°†å…¶ä»Žæ¶ˆæ¯é˜Ÿåˆ—ä¸­æ¶ˆé™¤. ä¸Šé¢è¯´è¿‡è™½ç„¶MessageQueueç§°ä¸ºæ¶ˆæ¯é˜Ÿåˆ—, ä½†æ˜¯å†…éƒ¨å®žçŽ°ä½¿ç”¨çš„æ˜¯å•é“¾è¡¨çš„æ•°æ®ç»“æž„æ¥ç»´æŠ¤çš„æ¶ˆæ¯åˆ—è¡¨. å•é“¾è¡¨åœ¨æ’å…¥å’Œåˆ é™¤ä¸Šæ¯”è¾ƒæœ‰ä¼˜åŠ¿. 123456789101112131415161718192021222324252627282930313233343536373839404142boolean enqueueMessage(Message msg, long when) &#123;// çœç•¥...synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125;&#125;return true;&#125; å¯ä»¥çœ‹åˆ°enqueueMessageçš„å®žçŽ°ä¸»è¦æ“ä½œå°±æ˜¯å•é“¾è¡¨çš„æ’å…¥æ“ä½œ. ç»§ç»­çœ‹ä¸€ä¸‹next()æ–¹æ³•. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091Message next() &#123; final long ptr = mPtr; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; next()æ˜¯ä¸€ä¸ªæ— é™å¾ªçŽ¯çš„æ–¹æ³•, å¦‚æžœæ¶ˆæ¯é˜Ÿåˆ—ä¸­æ²¡æœ‰æ¶ˆæ¯, é‚£ä¹ˆnextæ–¹æ³•ä¼šä¸€ç›´é˜»å¡žåœ¨è¿™é‡Œ. å½“æœ‰æ–°æ¶ˆæ¯åˆ°æ¥æ—¶, nextæ–¹æ³•ä¼šè¿”å›žè¿™æ¡æ¶ˆæ¯å¹¶å°†å…¶ä»Žå•é“¾è¡¨ä¸­ç§»é™¤. Looperçš„å·¥ä½œåŽŸç†Looperåœ¨Androidçš„æ¶ˆæ¯æœºåˆ¶ä¸­æ‰®æ¼”è€…æ¶ˆæ¯å¾ªçŽ¯çš„è§’è‰², å…·ä½“æ¥è¯´å°±æ˜¯ä»–ä¼šä¸åœåœ°ä»ŽMessageQueueä¸­æŸ¥çœ‹æ˜¯å¦æœ‰æ–°æ¶ˆæ¯. å¦‚æžœæœ‰æ–°æ¶ˆæ¯å°±ä¼šå¤„ç†. å¦åˆ™å°±ä¸€ç›´é˜»å¡žåœ¨é‚£é‡Œ. å…ˆä»Žæž„é€ æ–¹æ³•å¼€å§‹, åœ¨æž„é€ æ–¹æ³•ä¸­ä»–ä¼šåˆ›å»ºä¸€ä¸ªMessageQueueå³æ¶ˆæ¯é˜Ÿåˆ—, ç„¶åŽå°†å½“å‰çº¿ç¨‹çš„å¯¹è±¡ä¿å­˜èµ·æ¥. 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();//LooperæŒ‡å®šçš„çº¿ç¨‹&#125; æž„é€ å‡½æ•°æ˜¯ç§æœ‰æƒé™, è€Œå†…éƒ¨ä½¿ç”¨çš„åœ°æ–¹å°±æ˜¯Looper#prepare()æ–¹æ³•. 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; è¿™ä¹Ÿå°±æ˜¯ä¸ºä»€ä¹ˆåœ¨ä½¿ç”¨Handlerä¹‹å‰è¦æœ‰Looperçš„èŠ‚å¥, è€Œå½“è°ƒç”¨äº†Looper.prepare(). å°±ä¸ä¼šå‡ºçŽ°å¼‚å¸¸çš„åŽŸå› . Looperé™¤äº†prepare()æ–¹æ³•å¤–, è¿˜æä¾›äº†prepareMainLooper()æ–¹æ³•, è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯ç»™ä¸»çº¿ç¨‹ä¹Ÿå°±æ˜¯ActivityThreadåˆ›å»ºLooperä½¿ç”¨çš„. æœ¬è´¨ä¹Ÿæ˜¯é€šè¿‡prepare()æ¥å®žçŽ°çš„. ç”±äºŽä¸»çº¿ç¨‹çš„Looperæ¯”è¾ƒç‰¹æ®Š, æ‰€ä»¥Looperæä¾›äº†ä¸€ä¸ªgetMainLooper()æ–¹æ³•, é€šè¿‡å®ƒå¯ä»¥åœ¨ä»»ä½•åœ°æ–¹èŽ·å–åˆ°ä¸»çº¿ç¨‹çš„Looper. Looperçš„é€€å‡º: quit(): è¿™ä¸ªæ–¹æ³•ä¼šç›´æŽ¥é€€å‡ºLooper quitSafely(): è®¾å®šä¸€ä¸ªé€€å‡ºæ ‡è®°, ç„¶åŽæŠŠæ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„å·²æœ‰æ¶ˆæ¯å¤„ç†å®Œæ¯•åŽæ‰å®‰å…¨çš„é€€å‡º. å¦‚æžœLooperé€€å‡º, é€šè¿‡Handlerå‘é€çš„æ¶ˆæ¯ä¼šå¤±è´¥, è¿™ä¸ªæ—¶å€™Handlerå‘é€çš„æ¶ˆæ¯ä¼šå¤±è´¥, è€ŒHandler#send()æ–¹æ³•è¿™ä¸ªæ—¶å€™å›žè¿”å›žfalse. åœ¨å­çº¿ç¨‹ä¸­, å¦‚æžœæ‰‹åŠ¨ä¸ºå…¶åˆ›å»ºäº†Looper, é‚£ä¹ˆåœ¨æ‰€æœ‰çš„äº‹æƒ…å®Œæˆä»¥åŽåº”è¯¥è°ƒç”¨quit()æ–¹æ³•æ¥ç»ˆæ­¢æ¶ˆæ¯å¾ªçŽ¯. å¦åˆ™è¿™ä¸ªçº¿ç¨‹ä¼šä¸€ç›´å¤„äºŽç­‰å¾…çš„çŠ¶æ€, è€Œå¦‚æžœé€€å‡ºäº†Looperä»¥åŽ, è¿™ä¸ªçº¿ç¨‹å°±ä¼šç«‹åˆ»ç»ˆæ­¢. Looperæœ€é‡è¦çš„ä¸€ä¸ªæ–¹æ³•loop()æ–¹æ³•, åªæœ‰è°ƒç”¨äº†loopåŽ, æ¶ˆæ¯å¾ªçŽ¯ç³»ç»Ÿæ‰ä¼šçœŸæ­£çš„èµ·ä½œç”¨,å¦‚ä¸‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; é¦–å…ˆè¿™ä¸ªloop()æ–¹æ³•æ˜¯ä¸€ä¸ªæ­»å¾ªçŽ¯, å”¯ä¸€è·³å‡ºå¾ªçŽ¯çš„æ–¹å¼å°±æ˜¯MessageQueue#next()æ–¹æ³•è¿”å›žnull. å½“Looper#quit()è¢«è°ƒç”¨æ—¶, Looperå°±ä¼šè°ƒç”¨MessageQueue#quit()æˆ–è€…quitSafely()æ–¹æ³•æ¥é€šçŸ¥æ¶ˆæ¯é˜Ÿåˆ—é€€å‡º, å½“æ¶ˆæ¯é˜Ÿåˆ—è¢«æ ‡è¯†ä¸ºé€€å‡ºçŠ¶æ€æ—¶, å®ƒçš„next()æ–¹æ³•å°±ä¼šè¿”å›žnull. ä¹Ÿå°±æ˜¯è¯´Looperå¿…é¡»é€€å‡º, å¦åˆ™loopæ–¹æ³•å°±ä¼šæ— é™å¾ªçŽ¯ä¸‹åŽ». loop()ä¼šè°ƒç”¨MessageQueue#next()æ–¹æ³•æ¥èŽ·å–æ–°æ¶ˆæ¯. è€Œnextæ˜¯ä¸€ä¸ªé˜»å¡žæ“ä½œ, å½“æ²¡æœ‰æ¶ˆæ¯æ—¶, nextæ–¹æ³•å°±ä¼šä¸€ç›´é˜»å¡žåœ¨é‚£é‡Œ. è¿™ä¹Ÿå¯¼è‡´loop()ä¼šä¸€ç›´é˜»å¡žåœ¨é‚£é‡Œ. å¦‚æžœMessageQueue#next()è¿”å›žäº†æ–°æ¶ˆæ¯, Looperå°±ä¼šå¤„ç†è¿™æ¡æ¶ˆæ¯: msg.target.dispatchMessage(msg), è¿™é‡Œçš„msg.targetæ˜¯å‘é€è¿™æ¡æ¶ˆæ¯çš„Handlerå¯¹è±¡, è¿™æ ·Handlerå‘é€çš„æ¶ˆæ¯æœ€ç»ˆåˆäº¤ç»™å®ƒçš„dispatcherMessage()æ¥å¤„ç†. ä½†æ˜¯è¿™é‡Œä¸åŒçš„æ˜¯, Handler#dispatcherMessage()æ–¹æ³•æ˜¯åœ¨åˆ›å»ºHandleræ—¶æ‰€ä½¿ç”¨çš„Looperä¸­æ‰§è¡Œçš„ï¼Œè¿™æ ·å°±æˆåŠŸçš„å°†ä»£ç é€»è¾‘åˆ‡æ¢åˆ°LooperæŒ‡å®šçš„çº¿ç¨‹ä¸­åŽ»æ‰§è¡Œäº†. Handlerçš„å·¥ä½œåŽŸç†Handlerä¸»è¦åŒ…å«æ¶ˆæ¯çš„å‘é€å’ŒæŽ¥æ”¶è¿‡ç¨‹. æ¶ˆæ¯çš„å‘é€å¯ä»¥é€šè¿‡postçš„ä¸€ç³»åˆ—æ–¹æ³•ä»¥åŠsendçš„ä¸€ç³»åˆ—æ–¹æ³•æ¥å®žçŽ°. postçš„ä¸€ç³»åˆ—æ–¹æ³•æœ€ç»ˆå°±æ˜¯è¿˜æ˜¯é€šè¿‡sendæ–¹æ³•æ¥å®žçŽ°çš„. 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; ä¸Šé¢è¿™æ®µä»£ç æ˜¯Handler#send()ç³»åˆ—çš„æœ€ç»ˆè°ƒç”¨. å¯ä»¥çœ‹å‡º, Handlerå‘é€æ¶ˆæ¯çš„è¿‡ç¨‹ä»…ä»…æ˜¯å‘æ¶ˆæ¯é˜Ÿåˆ—ä¸­æ’å…¥äº†ä¸€æ¡æ¶ˆæ¯, MessageQueue#next()æ–¹æ³•å°±æ˜¯è¿”å›žè¿™æ¡æ¶ˆæ¯ç»™Looper, Looperæ”¶åˆ°æ¶ˆæ¯åŽå°±å¼€å§‹å¤„ç†. æœ€ç»ˆæ¶ˆæ¯æœ‰Looperäº¤ç”±Handlerå¤„ç†, å³Handler#dispatchMessage()æ–¹æ³•ä¼šè¢«è°ƒç”¨, è¿™ä¸ªæ—¶å€™Handlerå°±ä¼šè¿›å…¥äº†å¤„ç†æ¶ˆæ¯çš„é˜¶æ®µ. 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; æ•´ç†ä¸€ä¸‹: å…ˆæ£€æŸ¥msg.callbackå±žæ€§æ˜¯å¦ä¸ºnull, ä¸ä¸ºnullå°±é€šè¿‡handleCallback()æ¥å¤„ç†æ¶ˆæ¯. msg.callbackæ˜¯ä¸€ä¸ªRunnableæŽ¥å£, å®žé™…ä¸Šå°±æ˜¯post()ä¸­ä¼ é€’çš„Runnableå‚æ•°. handleCallback()å®žçŽ°å¦‚ä¸‹: 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; å…¶æ¬¡æ£€æŸ¥mCallbackæ˜¯å¦ä¸ºnull, ä¸ä¸ºnullå°±è°ƒç”¨mCallback.handleMessage(msg)æ–¹æ³•æ¥å¤„ç†æ¶ˆæ¯. Callbackæ˜¯ä¸€ä¸ªæŽ¥å£, å®šä¹‰å¦‚ä¸‹: 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; é€šè¿‡Callbackå¯ä»¥é‡‡ç”¨å¦‚ä¸‹æ–¹å¼æ¥åˆ›å»ºHandlerå¯¹è±¡: Handler handler = new Handler(callback). é€šè¿‡æºç æ³¨é‡Šäº†è§£: è¿™ä¸ªæŽ¥å£å¯ä»¥ç”¨æ¥åˆ›å»ºä¸€ä¸ªHandlerçš„å®žä¾‹ä½†å¹¶ä¸éœ€è¦æ´¾ç”ŸHandlerçš„å­ç±»å¹¶é‡å†™å…¶handleMessageæ–¹æ³•æ¥å¤„ç†å…·ä½“çš„æ¶ˆæ¯, è€ŒCallBackç»™æˆ‘ä»¬æä¾›äº†å¦å¤–ä¸€ç§æ–¹å¼ä½¿ç”¨Handler. å½“æˆ‘ä»¬ä¸æƒ³æ´¾ç”Ÿå­ç±»æ—¶, å°±å¯ä»¥é€šè¿‡Callbackæ¥å®žçŽ°. æœ€åŽ, è°ƒç”¨Handler#handleMessage()æ–¹æ³•æ¥å¤„ç†æ¶ˆæ¯. Handlerè¿˜æœ‰ä¸€ä¸ªç‰¹æ®Šçš„æž„é€ æ–¹æ³•, é‚£å°±æ˜¯é€šè¿‡ä¸€ä¸ªç‰¹å®šçš„Looperæ¥æž„é€ Handlerï¼š 123public Handler(Looper looper) &#123; this(looper, null, false);&#125; Handleré»˜è®¤çš„æž„é€ æ–¹æ³•public Handler(), è¿™ä¸ªæž„é€ æ–¹æ³•ä¼šè°ƒç”¨ä¸‹é¢çš„æž„é€ å‡½æ•°. å¾ˆæ˜Žæ˜¾è¿™å°±æ˜¯ä¸ºä»€ä¹ˆå½“å‰çº¿ç¨‹æ²¡æœ‰Looperçš„è¯, å°±ä¼šæŠ›å‡ºCan&#39;t create handler inside thread that has not called Looper.prepare()è¿™ä¸ªå¼‚å¸¸. 123456789101112public Handler(Callback callback, boolean async) &#123; //.... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; ä¸»çº¿ç¨‹çš„æ¶ˆæ¯å¾ªçŽ¯Androidçš„ä¸»çº¿ç¨‹å°±æ˜¯ActivityThread, ä¸»ç¨‹åºçš„å…¥å£æ–¹æ³•ä¸ºmain(), åœ¨main()ä¸­ç³»ç»Ÿé€šè¿‡Looper.prepareMainLooper()æ¥åˆ›å»ºä¸»çº¿ç¨‹çš„Looperä»¥åŠMessageQueue, å¹¶é€šè¿‡Looper.loop()æ¥å¼€å¯ä¸»çº¿ç¨‹çš„æ¶ˆæ¯å¾ªçŽ¯. å½“ä¸»çº¿ç¨‹çš„æ¶ˆæ¯å¾ªçŽ¯å¼€å§‹ä»¥åŽ, ActivityThreadè¿˜éœ€è¦ä¸€ä¸ªHandleræ¥å’Œæ¶ˆæ¯é˜Ÿåˆ—è¿›è¡Œäº¤äº’, è¿™ä¸ªHandlerå°±æ˜¯ActivityThread.H, å®ƒçš„å†…éƒ¨å®šä¹‰äº†ä¸€ç»„æ¶ˆæ¯ç±»åž‹, ä¸»è¦åŒ…å«äº†å››å¤§ç»„ä»¶çš„å¯åŠ¨å’Œåœæ­¢ç­‰è¿‡ç¨‹. 12345678910111213141516171819202122232425private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; public static final int SHOW_WINDOW = 105; public static final int HIDE_WINDOW = 106; public static final int RESUME_ACTIVITY = 107; public static final int SEND_RESULT = 108; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int NEW_INTENT = 112; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; public static final int CONFIGURATION_CHANGED = 118; public static final int CLEAN_UP_CONTEXT = 119; public static final int GC_WHEN_IDLE = 120; public static final int BIND_SERVICE = 121; public static final int UNBIND_SERVICE = 122;&#125; ActivityThreadé€šè¿‡ApplicationThreadå’ŒAMSè¿›è¡Œè¿›ç¨‹é—´é€šä¿¡, AMSä»¥è¿›ç¨‹é—´é€šä¿¡çš„æ–¹å¼å®ŒæˆActivityThreadçš„è¯·æ±‚åŽå›žè°ƒApplicationThreadä¸­çš„Binder()æ–¹æ³•, ç„¶åŽApplicationThreadä¼šå‘Hå‘é€æ¶ˆæ¯, Hæ”¶åˆ°æ¶ˆæ¯åŽä¼šå°†ApplicationThreadä¸­çš„é€»è¾‘åˆ‡æ¢åˆ°ActivityThreadä¸­åŽ»æ‰§è¡Œ, å³åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹åŽ»æ‰§è¡Œ, è¿™ä¸ªè¿‡ç¨‹å°±æ˜¯ä¸»çº¿ç¨‹çš„æ¶ˆæ¯å¾ªçŽ¯æ¨¡åž‹.]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>Looper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è‰ºæœ¯æŽ¢ç´¢è¯»ä¹¦ç¬”è®°]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[å››å¤§ç»„ä»¶çš„å·¥ä½œè¿‡ç¨‹ å¼•ç”¨ Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢è¯»ä¹¦ç¬”è®° å…ˆè¯´ä¸¤å¥ï¼ŒçŽ‰åˆšçš„ä¹¦ä¸­ä¸»è¦ä¾§é‡çš„æ˜¯è¿‡ç¨‹åˆ†æžå’Œä»£ç è®²è§£ï¼Œè¿™æ ·ä¸€é¡µä¸€é¡µçš„ç¿»å®Œä¹‹åŽæ€»æœ‰ä¸€ç§æ„çŠ¹æœªå°½å´ä¸å¤Ÿæ¸…æ™°çš„æ„Ÿè§‰ï¼Œä¸€å¼€å§‹æˆ‘ä¾ç„¶æ˜¯ç”¨æ–‡å­—listçš„æ–¹å¼æ¥æ¢³ç†ï¼ŒåŽæ¥å‘çŽ°çœ‹èµ·æ¥è¿˜æ˜¯æœ‰ç‚¹ä¸å¤Ÿæ¸…æ™°ï¼Œè¾¾ä¸åˆ°æˆ‘æƒ³è¦çš„æ•ˆæžœï¼Œæ‰€ä»¥æ”¹äº†ä¸¤ç‰ˆåŽæˆ‘å†³å®šç”¨å›¾ + æ–‡å­—è¯´æ˜Žçš„æ–¹å¼æ¥è¡¨çŽ°ï¼Œå¸Œæœ›å¤§å®¶å¯ä»¥çœ‹å¾—æ›´æ¸…æ™°ã€‚æ³¨æ„è¿™é‡Œå·¦ä¾§æ˜¯ç”¨UMLç”»çš„æµç¨‹å›¾ï¼Œå‘çŽ°è¿˜æŒºæ–¹ä¾¿çš„ï¼Œç±»ä¸­çš„æ–¹æ³•æ˜¯æŒ‰ç…§è°ƒç”¨é¡ºåºæŽ’åˆ—çš„ï¼Œå³ä¾§çš„UMLå›¾åˆ™æ˜¯çœŸæ­£çš„UMLå›¾ï¼Œä¼šæ ‡æ³¨å‡ºä¸€äº›é‡è¦ç±»çš„ç»“æž„å…³ç³»ï¼ŒæŽ’é™¤å„ä½çœ‹ä¹¦æ—¶çœ‹åˆ°å„ç§Aç»§æ‰¿Bï¼ŒBç»§æ‰¿Cæ—¶æ™•äº†çš„æ„Ÿè§‰ã€‚ å››å¤§ç»„ä»¶æ¦‚è¿°ï¼š Activityçš„ä¸»è¦ä½œç”¨æ˜¯å±•ç¤ºä¸€ä¸ªç•Œé¢å¹¶å’Œç”¨æˆ·äº¤äº’ï¼Œå®ƒæ‰®æ¼”çš„æ˜¯ä¸€ç§å‰å°ç•Œé¢çš„è§’è‰²ã€‚ Serviceæ˜¯ä¸€ç§è®¡ç®—åž‹ç»„ä»¶ï¼Œç”¨äºŽåœ¨åŽå°æ‰§è¡Œä¸€ç³»åˆ—è®¡ç®—ä»»åŠ¡ï¼Œä½†å› ä¸ºå…¶æœ¬èº«è¿˜æ˜¯è¿è¡Œåœ¨ä¸»çº¿ç¨‹ä¸­çš„ï¼Œå› æ­¤è€—æ—¶çš„åŽå°è®¡ç®—ä»ç„¶éœ€è¦åœ¨å•ç‹¬çš„çº¿ç¨‹ä¸­åŽ»å®Œæˆã€‚ BroadcastReceiveræ˜¯ä¸€ç§æ¶ˆæ¯åž‹ç»„ä»¶ï¼Œç”¨äºŽåœ¨ä¸åŒçš„ç»„ä»¶ä¹ƒè‡³ä¸åŒçš„åº”ç”¨ä¹‹é—´ä¼ é€’æ¶ˆæ¯ã€‚å¹¿æ’­æ³¨å†Œæœ‰ä¸¤ç§æ–¹å¼ï¼ŒåŠ¨æ€æ³¨å†Œé€šè¿‡Context.registerReceiver()æ¥å®žçŽ°ï¼Œå¿…é¡»è¦åº”ç”¨å¯åŠ¨æ‰èƒ½æ³¨å†Œï¼›é™æ€æ³¨å†Œåˆ™åœ¨AndroidManifestæ–‡ä»¶ä¸­è¿›è¡Œï¼Œåº”ç”¨å®‰è£…æ—¶ä¼šè¢«ç³»ç»Ÿè§£æžï¼Œä¸éœ€è¦å¯åŠ¨åº”ç”¨å°±å¯æŽ¥æ”¶å¹¿æ’­ã€‚ ContentProvideræ˜¯ä¸€ç§å…±äº«åž‹ç»„ä»¶ï¼Œç”¨äºŽå‘å…¶ä»–ç»„ä»¶ä¹ƒè‡³å…¶ä»–åº”ç”¨å…±äº«æ•°æ®ã€‚ â€‹ Activityçš„å·¥ä½œè¿‡ç¨‹ æ³¨ðŸ˜– å¯åŠ¨Activityçš„çœŸå®žå®žçŽ°æ˜¯ç”±ActivityManagerNative.getDefault().startActivityæ–¹æ³•æ¥å®Œæˆçš„ã€‚ ActivityManagerServiceï¼ˆAMSï¼‰ç»§æ‰¿è‡ªActivityManagerNativeï¼Œè€ŒActivityManagerNativeç»§æ‰¿è‡ªBinderå¹¶å®žçŽ°äº†IActivityManagerè¿™ä¸ªBinderæŽ¥å£ï¼Œå› æ­¤AMSä¹Ÿæ˜¯ä¸€ä¸ªBinderã€‚ AMSè¿™ä¸ªBinderå¯¹è±¡é‡‡ç”¨å•ä¾‹æ¨¡å¼å¯¹å¤–æä¾›ï¼Œç¬¬ä¸€æ¬¡è°ƒç”¨å®ƒçš„getæ–¹æ³•æ—¶ä¼šé€šè¿‡createæ–¹æ³•åˆå§‹åŒ–ï¼ŒåŽç»­è°ƒç”¨ä¸­ç›´æŽ¥è¿”å›žä¹‹å‰åˆ›å»ºçš„å¯¹è±¡ã€‚ ä»ŽmakeApplicationçš„å®žçŽ°å¯ä»¥çœ‹å‡ºï¼Œå¦‚æžœApplicationå·²ç»è¢«åˆ›å»ºè¿‡äº†ï¼Œé‚£ä¹ˆå°±ä¸ä¼šå†é‡å¤åˆ›å»ºï¼Œè¿™ä¹Ÿæ„å‘³ç€ä¸€ä¸ªåº”ç”¨åªæœ‰ä¸€ä¸ªApplicationå¯¹è±¡ã€‚Applicationçš„åˆ›å»ºä¹Ÿæ˜¯é€šè¿‡Instrumentationæ¥å®Œæˆçš„ï¼Œè¿™ä¸ªè¿‡ç¨‹å’ŒActivityå¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹ä¸€æ ·ï¼Œéƒ½æ˜¯é€šè¿‡ç±»åŠ è½½å™¨æ¥å®žçŽ°çš„ã€‚ ContextImplæ˜¯Contextçš„å…·ä½“å®žçŽ°ï¼ŒContextImplæ˜¯é€šè¿‡Activityçš„attachæ–¹æ³•æ¥å’ŒActivityå»ºç«‹å…³è”çš„ï¼Œåœ¨attachæ–¹æ³•ä¸­Activityè¿˜ä¼šå®ŒæˆWindowçš„åˆ›å»ºå¹¶å»ºç«‹è‡ªå·±å’ŒWindowçš„å…³è”ï¼Œè¿™æ ·å½“ActivityæŽ¥å—åˆ°äº‹ä»¶å°±å¯ä»¥ä¼ é€’ç»™windowäº†ã€‚ â€‹ Serviceçš„å·¥ä½œè¿‡ç¨‹å¯åŠ¨è¿‡ç¨‹ï¼š ç»‘å®šè¿‡ç¨‹æ³¨ Serviceæœ‰ä¸¤ç§çŠ¶æ€ï¼šå¯åŠ¨çŠ¶æ€å’Œç»‘å®šçŠ¶æ€ï¼Œä¸¤ç§çŠ¶æ€æ˜¯å¯ä»¥å…±å­˜çš„ã€‚ BroadcastReceiverçš„å·¥ä½œè¿‡ç¨‹BroadcastReceiverçš„å·¥ä½œè¿‡ç¨‹åŒ…æ‹¬å¹¿æ’­æ³¨å†Œè¿‡ç¨‹ã€å¹¿æ’­å‘é€å’ŒæŽ¥æ”¶è¿‡ç¨‹ã€‚ åŠ¨æ€æ³¨å†Œ å¹¿æ’­å‘é€å’ŒæŽ¥æ”¶ æ³¨ï¼š é™æ€æ³¨å†Œæ˜¯ç”±PackageManagerServiceï¼ˆPMSï¼‰åœ¨åº”ç”¨å®‰è£…çš„æ—¶å€™å®Œæˆæ•´ä¸ªæ³¨å†Œè¿‡ç¨‹çš„ï¼Œé™¤å¹¿æ’­ä»¥å¤–ï¼Œå…¶ä»–ä¸‰å¤§ç»„ä»¶ä¹Ÿéƒ½æ˜¯åœ¨åº”ç”¨å®‰è£…æ—¶ç”±PMSè§£æžå¹¶æ³¨å†Œçš„ã€‚ å¹¿æ’­çš„å‘é€æœ‰å‡ ç§ç±»åž‹ï¼šæ™®é€šå¹¿æ’­ã€æœ‰åºå¹¿æ’­å’Œç²˜æ€§å¹¿æ’­ï¼Œæœ‰åºå¹¿æ’­å’Œç²˜æ€§å¹¿æ’­ä¸Žæ™®é€šå¹¿æ’­ç›¸æ¯”å…·æœ‰ä¸åŒçš„ç‰¹æ€§ï¼Œä½†æ˜¯å‘é€å’ŒæŽ¥æ”¶è¿‡ç¨‹æ˜¯ç±»ä¼¼çš„ã€‚ FLAG_INCLUDE_STOPPED_PACKAGES:å¹¿æ’­ä¼šå‘é€ç»™å·²ç»åœæ­¢çš„åº”ç”¨ï¼ŒFLAG_EXCLUDE_STOPPED_PACKAGESå¹¿æ’­ä¸ä¼šå‘é€ç»™å·²ç»åœæ­¢çš„åº”ç”¨ ä»ŽAndroid 3.1å¼€å§‹ï¼Œå¤„äºŽåœæ­¢çŠ¶æ€çš„åº”ç”¨æ— æ³•æŽ¥å—åˆ°å¼€æœºå¹¿æ’­ã€‚ ContentProviderå¯åŠ¨è¿‡ç¨‹ å½“ContentProvideræ‰€åœ¨çš„è¿›ç¨‹å¯åŠ¨æ—¶ï¼Œä¼šåŒæ—¶è¢«å¯åŠ¨å¹¶è¢«å‘å¸ƒåˆ°AMSä¸­ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™ä¸ªæ—¶å€™å®ƒçš„onCreateè¦å…ˆåŽ»Applicationçš„onCreateæ‰§è¡Œï¼Œè¿™åœ¨å››å¤§ç»„ä»¶ä¸­æ˜¯ä¸€ä¸ªå°‘æœ‰çš„çŽ°è±¡ã€‚ ç”¨å¯åŠ¨çš„å…¥å£ä¸ºActivityThreadçš„mainæ–¹æ³•ï¼Œmainæ–¹æ³•ä¼šåˆ›å»ºActivityThreadå®žä¾‹å¹¶åˆ›å»ºä¸»çº¿ç¨‹æ¶ˆæ¯é˜Ÿåˆ—ã€‚ attachæ–¹æ³•ä¸­è¿œç¨‹è°ƒç”¨AMSçš„attachApplicationæ–¹æ³•ï¼Œå¹¶æä¾›ApplicationThreadç”¨äºŽå’ŒAMSçš„é€šä¿¡ã€‚ attachApplicationæ–¹æ³•ä¼šé€šè¿‡bindApplicationæ–¹æ³•å’ŒHæ¥ActivityThreadçš„handleBindApplicationï¼Œè¿™ä¸ªæ–¹æ³•ä¼šå…ˆåˆ›å»ºApplicationï¼Œå†åŠ è½½ContentProviderï¼Œç„¶åŽæ‰ä¼šå›žè°ƒApplicationçš„onCreateæ–¹æ³•ã€‚ ContentProviderçš„multiprocesså±žæ€§å†³å®šäº†ContentProvideræ˜¯å¦æ˜¯å•ä¾‹ï¼ˆfalseæ—¶ï¼‰ï¼Œä¸€èˆ¬éƒ½ç”¨å•ä¾‹ã€‚ ontentResolverçš„å…·ä½“ç±»æ˜¯ApplicationContentResolverï¼Œå½“ContentProvideræ‰€åœ¨è¿›ç¨‹æœªå¯åŠ¨æ—¶ï¼Œç¬¬ä¸€æ¬¡è®¿é—®å®ƒä¼šè§¦å‘ContentProviderçš„åˆ›å»ºä»¥åŠè¿›ç¨‹å¯åŠ¨ã€‚ Queryæµç¨‹ insertï¼Œdeleteå’Œupdateæ–¹æ³•ç±»ä¼¼ï¼Œè¿™é‡Œå°±ä¸åœ¨åˆ†æžäº†ã€‚ Androidçš„æ¶ˆæ¯æœºåˆ¶ ä¸‰å¤§ä»¶ï¼šHanlderï¼ŒMessageQueueï¼ŒLooperã€‚ MessageQueueå†…éƒ¨çš„æ•°æ®ç»“æž„å¹¶éžé˜Ÿåˆ—ï¼Œè€Œæ˜¯å•é“¾è¡¨ï¼Œå®ƒåªæ˜¯ç”¨æ¥å­˜å‚¨æ•°æ®ã€‚ Looperæ˜¯çœŸæ­£çš„æ•°æ®å¤„ç†è€…ï¼Œçº¿ç¨‹é»˜è®¤æ²¡æœ‰Looperï¼Œä½¿ç”¨Handlerå¿…é¡»ä¸ºçº¿ç¨‹åˆ›å»ºLooperï¼ŒUIçº¿ç¨‹ä¹Ÿå°±æ˜¯ActivityThreadåˆ›å»ºæ—¶ä¼šåˆå§‹åŒ–Looperï¼Œæ‰€ä»¥ä¸»çº¿ç¨‹ä¸­é»˜è®¤å¯ä»¥ç›´æŽ¥ä½¿ç”¨Handlerã€‚ UIçº¿ç¨‹æ£€æŸ¥å½“å‰çº¿ç¨‹çš„æ“ä½œåœ¨ViewRootImplçš„checkThreadæ–¹æ³•ä¸­ï¼Œæˆ‘ä»¬å¸¸è§çš„ä¸èƒ½åœ¨å­çº¿ç¨‹ä¸­è®¿é—®viewçš„å¼‚å¸¸å°±æ˜¯åœ¨è¿™é‡ŒæŠ›å‡ºçš„ã€‚ ä¸å…è®¸å­çº¿ç¨‹è®¿é—®ä¸»çº¿ç¨‹çš„åŽŸå› æ˜¯UIæŽ§ä»¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œè€ŒåŠ é”åˆä¼šå¯¼è‡´UIçš„æ“ä½œè¿‡äºŽå¤æ‚ã€‚ Handlerçš„å·¥ä½œè¿‡ç¨‹ï¼Œå›¾ï¼ˆpage374ï¼‰ï¼Œæˆ‘ç®€å•æ¦‚æ‹¬ä¸€ä¸‹å°±æ˜¯ï¼šå‡è®¾åˆ›å»ºHandlerçš„çº¿ç¨‹æ˜¯Aï¼Œè€—æ—¶æ“ä½œçš„çº¿ç¨‹æ˜¯Bï¼ŒBçº¿ç¨‹ä¸­æ‹¿åˆ°handlerå®žä¾‹å‘é€æ¶ˆæ¯æˆ–è€…postä¸€ä¸ªRunnableï¼Œå®žé™…æ˜¯è°ƒç”¨äº†MessageQueueçš„enqueueMessageæ–¹æ³•ï¼Œè¿›å…¥äº†æ¶ˆæ¯é˜Ÿåˆ—ï¼Œçº¿ç¨‹Aä¸­çš„Looperå‘çŽ°äº†è¿™ä¸ªæ¶ˆæ¯ï¼Œå°±ä¼šå¤„ç†è¿™ä¸ªæ¶ˆæ¯ï¼Œä¹Ÿå°±æ˜¯æ¶ˆæ¯ä¸­çš„Runnableæˆ–è€…handlerçš„handleMessageæ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼Œè¿™æ ·handlerä¸­çš„ä¸šåŠ¡é€»è¾‘å°±è¢«åˆ‡æ¢åˆ°çº¿ç¨‹Aä¸­åŽ»äº†ã€‚ ThreadLocalæˆ‘ç”¨ä¸€å¥å¤§ç™½è¯æ¥è®²è§£ï¼Œå°±æ˜¯çœ‹ä¸ŠåŽ»åªnewäº†ä¸€ä»½ï¼Œä½†åœ¨æ¯ä¸ªä¸åŒçš„çº¿ç¨‹ä¸­å´å¯ä»¥æ‹¥æœ‰ä¸åŒæ•°æ®å‰¯æœ¬çš„ç¥žå¥‡ç±»ã€‚å…¶æœ¬è´¨æ˜¯ThreadLocalä¸­çš„Valuesç±»ç»´æŠ¤äº†ä¸€ä¸ªObject[]ï¼Œè€Œæ¯ä¸ªThreadç±»ä¸­æœ‰ä¸€ä¸ªThreadLocal.Valuesæˆå‘˜ï¼Œå½“è°ƒç”¨ThreadLocalçš„setæ–¹æ³•æ—¶ï¼Œå…¶å®žæ˜¯æ ¹æ®ä¸€å®šè§„åˆ™æŠŠè¿™ä¸ªçº¿ç¨‹ä¸­å¯¹åº”çš„ThreadLocalå€¼å¡žè¿›äº†Valuesçš„Object[]æ•°ç»„ä¸­çš„æŸä¸ªindexé‡Œã€‚è¿™ä¸ªindexæ€»æ˜¯ä¸ºThreadLocalçš„referenceå­—æ®µæ‰€æ ‡è¯†çš„å¯¹è±¡çš„ä¸‹ä¸€ä¸ªä½ç½®ã€‚ MessageQueueçš„å·¥ä½œåŽŸç†ï¼šä¸»è¦æ–¹æ³•ä¸ºenqueueMessageå’Œnextã€‚a. enqueueMessagä¸»è¦å°±æ˜¯ä¸€ä¸ªå•é“¾è¡¨çš„æ’å…¥æ“ä½œï¼Œb. nextæ–¹æ³•æ˜¯ä¸€ä¸ªæ— é™å¾ªçŽ¯ï¼Œå¦‚æžœæ¶ˆæ¯é˜Ÿåˆ—ä¸­æ²¡æœ‰æ¶ˆæ¯ï¼Œnextæ–¹æ³•å°±é˜»å¡žï¼Œæœ‰æ–°æ¶ˆæ¯åˆ°æ¥æ—¶ï¼Œnextæ–¹æ³•ä¼šè¿”å›žè¿™æ¡æ¶ˆæ¯å¹¶å°†å…¶ä»Žå•é“¾è¡¨ä¸­åˆ é™¤ã€‚ Looperçš„å·¥ä½œåŽŸç†ï¼ša. prepareæ–¹æ³•ï¼Œä¸ºå½“å‰æ²¡æœ‰Looperçš„çº¿ç¨‹åˆ›å»ºLooperã€‚b. prepareMainLooperå’ŒgetMainLooperæ–¹æ³•ç”¨äºŽåˆ›å»ºå’ŒèŽ·å–ActivityThreadçš„Looperã€‚c. quitå’ŒquitSafelyæ–¹æ³•ï¼Œå‰è€…ç«‹å³é€€å‡ºï¼ŒåŽè€…åªæ˜¯è®¾å®šä¸€ä¸ªæ ‡è®°ï¼Œå½“æ¶ˆæ¯é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰æ¶ˆæ¯å¤„ç†å®Œæ¯•åŽä¼šæ‰å®‰å…¨é€€å‡ºã€‚å­çº¿ç¨‹ä¸­åˆ›å»ºçš„Looperå»ºè®®ä¸éœ€è¦çš„æ—¶å€™éƒ½è¦æ‰‹åŠ¨ç»ˆæ­¢ã€‚d. loopæ–¹æ³•ï¼Œæ­»å¾ªçŽ¯ï¼Œé˜»å¡žèŽ·å–msgå¹¶ä¸¢ç»™msg.target.dispatchMessageæ–¹æ³•åŽ»å¤„ç†ï¼Œè¿™é‡Œçš„targetå°±æ˜¯handlerã€‚ Handlerçš„å·¥ä½œåŽŸç†ï¼ša. æ— è®ºsendMessageè¿˜æ˜¯postæœ€ç»ˆéƒ½æ˜¯è°ƒç”¨çš„sendMessageAtTimeæ–¹æ³•ã€‚b. å‘é€æ¶ˆæ¯å…¶å®žå°±æ˜¯æŠŠä¸€æ¡æ¶ˆæ¯é€šè¿‡MessageQueueçš„enqueueMessageæ–¹æ³•åŠ å…¥æ¶ˆæ¯é˜Ÿåˆ—ï¼ŒLooperæ”¶åˆ°æ¶ˆæ¯å°±ä¼šè°ƒç”¨handlerçš„dispatchMessageæ–¹æ³•ã€‚å®ƒçš„å¤„ç†è¿‡ç¨‹å‚è€ƒä¹¦page388çš„æµç¨‹å›¾ï¼Œä¸€çœ‹å°±æ‡‚ï½žc. è¿™é‡Œæˆ‘è¡¥å……ä¸€ä¸ªä¸œè¥¿ï¼Œå½“æˆ‘ä»¬ç›´æŽ¥Handler h = new Handler()æ—¶ï¼Œæœ¬è´¨è°ƒç”¨çš„æ˜¯Handler(Callback callback, Boolean async)æž„é€ æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•é‡Œä¼šè°ƒç”¨Looper.myLooper()æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å…¶å®žå°±æ˜¯è¿”å›žçš„ThreadLocalé‡Œä¿å­˜çš„å½“å‰çº¿ç¨‹çš„Looperï¼Œè¿™ä¹Ÿå°±è§£é‡Šäº†ä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨ä¸»çº¿ç¨‹ä¸­è¿™æ ·newæ²¡æœ‰é—®é¢˜ï¼Œå­çº¿ç¨‹ä¸­å¦‚æžœä¸å…ˆLooper.prepareä¼šæŠ›å‡ºå¼‚å¸¸çš„åŽŸå› ï¼Œå‰é¢å¤šæ¬¡è¯´äº†ï¼Œå› ä¸ºActivityThreadä¼šåœ¨åˆå§‹åŒ–çš„æ—¶å€™åˆ›å»ºè‡ªå·±çš„Looperã€‚ ä¸»çº¿ç¨‹çš„æ¶ˆæ¯å¾ªçŽ¯ï¼š Windowå’ŒWindowManager ä¸€äº›åŸºç¡€çŸ¥è¯†ï¼š Windowçš„å®žçŽ°ç±»æ˜¯PhoneWindowã€‚ Windowçš„å…·ä½“å®žçŽ°ä½äºŽWindowManagerServiceä¸­ï¼ŒWindowManagerå’ŒWindowManagerServiceçš„äº¤äº’æ˜¯ä¸€ä¸ªIPCè¿‡ç¨‹ã€‚ Windowå®žé™…æ˜¯Viewçš„ç›´æŽ¥ç®¡ç†è€…ã€‚ å¸¸ç”¨çš„WindowManager.LayoutParamsçš„Flagå’ŒType1ï¼‰ FLAGï¼š FLAG_NOT_FOCUSABLEï¼Œå½“å‰Windowä¸èŽ·å–ç„¦ç‚¹ï¼Œä¹Ÿä¸æŽ¥æ”¶å„ç§è¾“å…¥äº‹ä»¶ï¼Œä¼šåŒæ—¶å¯ç”¨FLAG_NOT_TOUCH_MODALï¼Œäº‹ä»¶ä¼šä¼ é€’ç»™ä¸‹å±‚å…·æœ‰ç„¦ç‚¹çš„Windowã€‚ FLAG_NOT_TOUCH_MODALï¼Œå½“å‰WindowåŒºåŸŸå¤–çš„å•å‡»äº‹ä»¶ä¼ é€’ç»™åº•å±‚ï¼ŒåŒºåŸŸå†…çš„å•å‡»äº‹ä»¶è‡ªå·±å¤„ç†ï¼Œä¸€èˆ¬éƒ½éœ€è¦å¼€å¯ã€‚ FLAG_SHOW_WHEN_LOCKEDï¼Œå¯ä»¥è®©Windowæ˜¾ç¤ºåœ¨é”å±ç•Œé¢ä¸Šã€‚ 2ï¼‰ Typeï¼š åº”ç”¨Windowï¼Œä¸€èˆ¬å¯¹åº”ä¸€ä¸ªActivityã€‚å±‚çº§èŒƒå›´1ï½ž99ã€‚ å­Windowï¼Œä¸èƒ½å•ç‹¬å­˜åœ¨ï¼Œéœ€è¦ç‰¹å®šçš„çˆ¶Windowï¼Œæ¯”å¦‚ä¸€èˆ¬çš„Dialogã€‚å±‚çº§èŒƒå›´1000ï½ž1999ã€‚ ç³»ç»ŸWindowï¼Œéœ€è¦æƒé™å£°æ˜Žï¼Œæ¯”å¦‚Toastã€‚å±‚çº§èŒƒå›´2000ï½ž2999ã€‚ä¸€èˆ¬å¯ä»¥é€‰ç”¨WindowManager.LayoutParams.TYPE_SYSTEM_ERRORï¼ŒåŒæ—¶å£°æ˜Žæƒé™ã€‚ 3ï¼‰ WindowManageræä¾›çš„åŠŸèƒ½ï¼šaddViewï¼ŒupdateViewLayoutï¼ŒremoveView Windowçš„å†…éƒ¨æœºåˆ¶ï¼šWindowå¹¶ä¸å®žé™…å­˜åœ¨ï¼Œä»¥Viewçš„å½¢å¼å­˜åœ¨ã€‚æ¯ä¸ªWindowå¯¹åº”ç€ä¸€ä¸ªViewå’ŒViewRootImplï¼ŒWindowå’ŒViewé€šè¿‡ViewRootImplå»ºç«‹è”ç³»ã€‚æ‰€ä»¥åœ¨å®žé™…ä½¿ç”¨ä¸­å…¶å®žæˆ‘ä»¬å¹¶ä¸èƒ½è®¿é—®åˆ°çœŸæ­£çš„Windowï¼Œè€Œåªèƒ½é€šè¿‡WindowManagerã€‚1ï¼‰ å‡ ä¸ªé‡è¦çš„windowç±»çš„å…³ç³»ï¼ˆå‘çŽ°ä¸»å¸­ä¸å¤§çˆ±ç”»UMLï¼Œæˆ‘å°±ä»£å·¥äº†ï¼‰2ï¼‰ Windowçš„æ·»åŠ è¿‡ç¨‹ WindowManagerGlobalä¸­çš„addViewï¼š æ£€æŸ¥å‚æ•°æ˜¯å¦åˆæ³•ï¼› å¦‚æžœå­Windowè¿˜éœ€è¦è°ƒèŠ‚å¸ƒå±€å‚æ•°ï¼› åˆ›å»ºViewRootImplå¹¶å°†Viewæ·»åŠ åˆ°åˆ—è¡¨ä¸­ï¼› é€šè¿‡ViewRootImplçš„setViewæ¥æ›´æ–°ç•Œé¢å¹¶å®ŒæˆWindowçš„æ·»åŠ è¿‡ç¨‹ï¼šrequestLayoutä¸­çš„scheduleTraversalsæ˜¯Viewç»˜åˆ¶çš„å…¥å£ï¼Œæœ€ç»ˆé€šè¿‡WindowSessionæ¥å®ŒæˆWindowçš„æ·»åŠ è¿‡ç¨‹ï¼Œæ³¨æ„å…¶å®žè¿™é‡Œæ˜¯ä¸ªIPCè¿‡ç¨‹ï¼Œæœ€ç»ˆä¼šé€šè¿‡WindowManagerServiceçš„addWindowæ–¹æ³•æ¥å®žçŽ°Windowçš„æ·»åŠ ã€‚ 3ï¼‰ Windowçš„åˆ é™¤è¿‡ç¨‹ WinodwManagerGlobalä¸­çš„removeViewï¼› findViewLockedæ¥æŸ¥æ‰¾å¾…åˆ é™¤å¾…Viewçš„ç´¢å¼•ï¼Œå†è°ƒç”¨removeViewLockedæ¥åšè¿›ä¸€æ­¥åˆ é™¤ï¼› removeViewLockedé€šè¿‡ViewRootImplçš„dieæ–¹æ³•æ¥å®Œæˆåˆ é™¤æ“ä½œï¼ŒåŒ…æ‹¬åŒæ­¥å’Œå¼‚æ­¥ä¸¤ç§æ–¹å¼ï¼ŒåŒæ­¥æ–¹å¼å¯èƒ½ä¼šå¯¼è‡´æ„å¤–çš„é”™è¯¯ï¼Œä¸æŽ¨èï¼Œä¸€èˆ¬ä½¿ç”¨å¼‚æ­¥çš„æ–¹å¼ï¼Œå…¶å®žå°±æ˜¯é€šè¿‡handlerå‘é€äº†ä¸€ä¸ªåˆ é™¤è¯·æ±‚ï¼Œå°†Viewæ·»åŠ åˆ°mDyingViewsä¸­ï¼› dieæ–¹æ³•æœ¬è´¨è°ƒç”¨äº†doDieæ–¹æ³•ï¼ŒçœŸæ­£åˆ é™¤Viewçš„é€»è¾‘åœ¨è¯¥æ–¹æ³•çš„dispatchDetachedFromWindowæ–¹æ³•ä¸­ï¼Œä¸»è¦åšäº†å››ä»¶äº‹ï¼šåžƒåœ¾å›žæ”¶ï¼Œé€šè¿‡Sessionçš„removeæ–¹æ³•åˆ é™¤Windowï¼Œè°ƒç”¨Viewçš„dispatchDetachedFromWindowæ–¹æ³•åŒæ—¶ä¼šå›žè°ƒViewçš„onDetachedFromWindowä»¥åŠonDetachedFromWindowInternalï¼Œè°ƒç”¨WindowManagerGlobalçš„doRemoveViewåˆ·æ–°æ•°æ®ã€‚ 4ï¼‰ Windowçš„æ›´æ–°è¿‡ç¨‹WindowManagerGlobalçš„updateViewLayoutï¼›æ›´æ–°Viewçš„LayoutParamsï¼›æ›´æ–°ViewImpleçš„LayoutParamsï¼Œå®žçŽ°å¯¹Viewçš„é‡æ–°æµ‹é‡ï¼Œå¸ƒå±€ï¼Œé‡ç»˜ï¼›é€šè¿‡WindowSessionæ›´æ–°Windowçš„è§†å›¾ï¼ŒWindowManagerService.relayoutWindow()ã€‚ Windowçš„åˆ›å»ºè¿‡ç¨‹1ï¼‰ Activity Activityçš„attachæ–¹æ³•ä¸­ï¼Œç³»ç»Ÿä¼šåˆ›å»ºActivityæ‰€å±žçš„Windowå¹¶ä¸ºå…¶è®¾ç½®å›žè°ƒï¼› Windowå¯¹è±¡çš„åˆ›å»ºé€šè¿‡PolicyManagerçš„makeNewWindowæ–¹æ³•ï¼› Windowçš„å…·ä½“å®žçŽ°æ˜¯PhoneWindowç±»ï¼› Windowåˆ›å»ºå¥½ä¹‹åŽï¼Œé€šè¿‡PhoneWindowçš„setContentViewå°†Activityä¸ŽWindowè¿›è¡Œå…³è”ï¼Œè¿™ä¸ªæ–¹æ³•å¤§è‡´æ­¥éª¤ï¼š a. å¦‚æžœæ²¡æœ‰DecorViewå°±åˆ›å»ºï¼Œidæ˜¯android.R.id.contentï¼›b. å°†Activityè®¾ç½®çš„ContentViewè®¾ç½®åˆ°DecorViewçš„mContentParentä¸­ï¼›c. å›žè°ƒActivityçš„onContentChangedæ–¹æ³•é€šçŸ¥Activityè§†å›¾å·²ç»å‘ç”Ÿæ”¹å˜ï¼›d. Activity onResumeçš„æ—¶å€™ä¼šè°ƒç”¨Activityçš„makeVisibleæ–¹æ³•çœŸæ­£å®ŒæˆDecorViewçš„æ·»åŠ å’Œæ˜¾ç¤ºã€‚ 2ï¼‰ Dialog a. é€šè¿‡PolicyManagerçš„makeNewWindowæ–¹æ³•åˆ›å»ºWindowï¼› b. åˆå§‹åŒ–DecorViewï¼Œå’ŒActivityç±»ä¼¼ï¼› c. Dialogçš„showæ–¹æ³•ä¸­ï¼Œé€šè¿‡WindowManagerå°†DecorViewæ·»åŠ åˆ°Windowä¸­ï¼› d. Dialogå…³é—­æ—¶ï¼Œä¼šé€šè¿‡WindowManageræ¥ç§»é™¤DecorViewï¼Œæ–¹æ³•ä¸ºremoveViewImmediate(mDecor)ï¼› e. æƒ³è¦åˆ›å»ºä¸€ä¸ªä½¿ç”¨application contextçš„Dialogå¯æŒ‰ç…§æœ¬ç« 2-2çš„æ–¹æ³•è®¾ç½®ï¼Œdialog.getWindow.setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)ï¼Œè®°å¾—åœ¨manifestä¸­è®¾ç½®æƒé™ã€‚ â€‹ 3ï¼‰ Toast a. Toastå†…éƒ¨æœ‰ä¸¤ç±»IPCï¼šToastè®¿é—®NotificationManagerServiceï¼›NotificationManagerServiceï¼ˆä¸‹æ–‡ç®€ç§°NMSï¼‰è®¿é—®Toastçš„TNæŽ¥å£ï¼› b. Toastå±žäºŽç³»ç»ŸWindowï¼Œå†…éƒ¨è§†å›¾mNextViewä¸€ç§ä¸ºç³»ç»Ÿé»˜è®¤æ ·å¼ï¼Œå¦ä¸€ç§é€šè¿‡setViewæ–¹æ³•æ¥æŒ‡å®šä¸€ä¸ªè‡ªå®šä¹‰Viewã€‚ c. TNæ˜¯ä¸€ä¸ªBinderç±»ï¼ŒNMSå¤„ç†Toastçš„æ˜¾ç¤ºéšè—è¯·æ±‚æ—¶ä¼šè·¨è¿›ç¨‹å›žè°ƒTNä¸­çš„æ–¹æ³•ï¼Œæ‰€ä»¥TNè¿è¡Œåœ¨Binderçº¿ç¨‹æ± ä¸­ï¼Œæ‰€ä»¥éœ€è¦handleråˆ‡æ¢åˆ°å½“å‰å‘é€Toastè¯·æ±‚çš„çº¿ç¨‹ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´æ²¡æœ‰Looperçš„çº¿ç¨‹æ˜¯æ— æ³•å¼¹å‡ºToastçš„ã€‚ d. Toastçš„showæ–¹æ³•è°ƒç”¨äº†NMSçš„enqueueToastæ–¹æ³•ï¼Œè¯¥æ–¹æ³•å…ˆå°†Toastè¯·æ±‚å°è£…æˆToastRecordå¹¶ä¸¢å…¥mToastQueueé˜Ÿåˆ—ä¸­ï¼ˆéžç³»ç»Ÿåº”ç”¨æœ€å¤šå¡ž50ä¸ªï¼‰ã€‚ e. NMSé€šè¿‡showNextToastLockedæ–¹æ³•æ¥æ˜¾ç¤ºå½“å‰Viewï¼ŒToastæ˜¾ç¤ºç”±ToastRecordçš„callbackæ–¹æ³•ä¸­çš„showæ–¹æ³•å®Œæˆï¼Œcallbackå…¶å®žå°±æ˜¯TNå¯¹è±¡çš„è¿œç¨‹Binderï¼Œæ‰€ä»¥æœ€ç»ˆè°ƒç”¨çš„æ˜¯TNä¸­çš„æ–¹æ³•ï¼Œå¹¶è¿è¡Œåœ¨å‘èµ·Toastè¯·æ±‚åº”ç”¨çš„Binderçº¿ç¨‹æ± ä¸­ã€‚ f. æ˜¾ç¤ºä»¥åŽï¼ŒNMSé€šè¿‡scheduleTimeoutLockedæ–¹æ³•å‘é€å»¶æ—¶æ¶ˆæ¯ï¼Œå»¶æ—¶åŽNMSé€šè¿‡cancelToastLockedæ–¹æ³•æ¥éšè—Toastå¹¶ä»Žé˜Ÿåˆ—ä¸­ç§»é™¤ï¼Œéšè—ä¾ç„¶é€šè¿‡ToastRecordçš„callbackä¸­çš„hideæ–¹æ³•å®žçŽ°ã€‚ g. callbackå›žè°ƒTNçš„showå’Œhideæ–¹æ³•åŽï¼Œä¼šé€šè¿‡handlerå‘é€ä¸¤ä¸ªRunnableï¼Œé‡Œé¢çš„handleShowå’ŒhandleHideæ–¹æ³•æ˜¯çœŸæ­£å®Œæˆæ˜¾ç¤ºå’Œéšè—Toastçš„åœ°æ–¹ã€‚handleShowæ–¹æ³•ä¸­å°†Toastçš„è§†å›¾æ·»åŠ åˆ°Windowä¸­ï¼ŒhandleHideæ–¹æ³•å°†Toastè§†å›¾ä»ŽWindowä¸­ç§»é™¤ã€‚]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>å››å¤§ç»„ä»¶UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å››å¤§ç»„ä»¶çš„å·¥ä½œè¿‡ç¨‹]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[å››å¤§ç»„ä»¶çš„è¿è¡ŒçŠ¶æ€å››å¤§ç»„ä»¶ä¸­é™¤äº†BroadcastReceiverä»¥å¤–, å…¶ä½™çš„ä¸‰ç§ç»„ä»¶éƒ½å¿…é¡»åœ¨AndroidManifestä¸­æ³¨å†Œ, å¯¹äºŽBroadcastReceiveræ¥è¯´, æ—¢å¯ä»¥åœ¨æ¸…å•æ–‡ä»¶ä¸­æ³¨å†Œ, ä¹Ÿå¯ä»¥é€šè¿‡ä»£ç æ¥æ³¨å†Œ. åœ¨è°ƒç”¨å½¢å¼ä¸Šé™¤äº†ContentProviderä¸éœ€è¦å€ŸåŠ©Intent. å…¶ä½™çš„ä¸‰å¤§ç»„ä»¶éƒ½éœ€è¦Intent Activityæ˜¯ä¸€ç§å±•ç¤ºåž‹ç»„ä»¶, ç”¨äºŽå‘ç”¨æˆ·ç›´æŽ¥åœ°å±•ç¤ºä¸€ä¸ªç•Œé¢, å¹¶ä¸”å¯ä»¥æŽ¥æ”¶ç”¨æˆ·çš„è¾“å…¥ä¿¡æ¯ä»Žè€Œè¿›è¡Œäº¤äº’. Activityæ˜¯æœ€é‡è¦çš„ä¸€ç§ç»„ä»¶, å¯¹äºŽç”¨æˆ·æ¥è¯´å®ƒå°±æ˜¯åº”ç”¨çš„å…¨éƒ¨, å› ä¸ºå…¶ä»–ä¸‰å¤§ç»„ä»¶å¯¹ç”¨æˆ·æ¥è¯´æ˜¯æ— æ³•æ„ŸçŸ¥çš„. Activityçš„å¯åŠ¨ç”±Intentè§¦å‘, å…¶ä¸­Intentå¯ä»¥åˆ†ä¸ºæ˜¾å¼å’Œéšå¼. æ˜¾å¼Intentå¯ä»¥æ˜Žç¡®çš„æŒ‡å‘ä¸€ä¸ªActivity, è€Œéšå¼Intentåˆ™æŒ‡å‘ä¸€ä¸ªæˆ–è€…å¤šä¸ªActivityç»„ä»¶. æˆ–è€…æ˜¯æ²¡æœ‰Activityç»„ä»¶å¯ä»¥å¤„ç†è¿™ä¸ªéšå¼çš„Intent. ä¸€ä¸ªActivityå…·æœ‰ç‰¹å®šçš„å¯åŠ¨æ¨¡å¼. ä¹Ÿå¯ä»¥é€šè¿‡finishæ¥åœæ­¢. æ€»ç»“æ¥è¯´, Activityç»„ä»¶çš„ä¸»è¦ä½œç”¨æ˜¯å±•ç¤ºä¸€ä¸ªç•Œé¢å¹¶å’Œç”¨æˆ·äº¤äº’, å®ƒæ‰®æ¼”çš„æ˜¯ä¸€ç§å‰å°ç•Œé¢çš„è§’è‰². Serviceæ˜¯ä¸€ç§è®¡ç®—åž‹ç»„ä»¶, ç”¨äºŽåŽå°æ‰§è¡Œä¸€ç³»åˆ—è®¡ç®—ä»»åŠ¡. è¿è¡Œåœ¨åŽå°,ç”¨æˆ·æ˜¯æ— æ³•æ„ŸçŸ¥çš„. Serviceå’ŒActivityçš„ä¸åŒ: Activityç»„ä»¶åªæœ‰ä¸€ç§è¿è¡Œæ¨¡å¼,å³Activityå¤„äºŽå¯åŠ¨çŠ¶æ€, ä½†æ˜¯Serviceç»„ä»¶æœ‰ä¸¤ç§çŠ¶æ€: å¯åŠ¨çŠ¶æ€å’Œç»‘å®šçŠ¶æ€. å½“Serviceå¤„äºŽå¯åŠ¨çŠ¶æ€æ—¶, è¿™ä¸ªæ—¶å€™Serviceå†…éƒ¨å¯ä»¥åšä¸€äº›åŽå°è®¡ç®—. å°½ç®¡Serviceç»„ä»¶æ˜¯ç”¨äºŽæ‰§è¡ŒåŽå°è®¡ç®—çš„, ä½†æ˜¯å®ƒæœ¬èº«æ˜¯è¿è¡Œåœ¨ä¸»çº¿ç¨‹çš„. å› æ­¤å•ç‹¬çš„è€—æ—¶æ“ä½œä»ç„¶éœ€è¦å•ç‹¬çš„çº¿ç¨‹åŽ»æ‰§è¡Œ. å½“Serviceå¤„äºŽç»‘å®šçŠ¶æ€æ—¶, å†…éƒ¨åŒæ ·å¯ä»¥è¿›è¡ŒåŽå°è®¡ç®—, ä½†æ˜¯å¤„äºŽè¿™ç§çŠ¶æ€æ—¶, å¤–ç•Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„å’ŒServiceç»„ä»¶è¿›è¡Œé€šä¿¡. Serviceå¯ä»¥åœæ­¢, éœ€è¦çµæ´»é‡‡ç”¨stopServiceå’ŒunBindService BroadcastReceiveræ˜¯ä¸€ç§æ¶ˆæ¯åž‹ç»„ä»¶, ç”¨äºŽåœ¨ä¸åŒçš„ç»„ä»¶ä¹ƒè‡³ä¸åŒçš„åº”ç”¨ä¹‹é—´ä¼ é€’æ¶ˆæ¯. åŒæ ·æ— æ³•è¢«ç”¨æˆ·æ„ŸçŸ¥, å› ä¸ºæ˜¯è¿è¡Œåœ¨ç³»ç»Ÿå†…éƒ¨, å¹¿æ’­çš„æ³¨å†Œæ–¹å¼æœ‰ä¸¤ç§:é™æ€æ³¨å†Œå’ŒåŠ¨æ€æ³¨å†Œ é™æ€æ³¨å†Œ: åœ¨æ¸…å•æ–‡ä»¶ä¸­è¿›è¡Œæ³¨å†Œå¹¿æ’­, è¿™ç§å¹¿æ’­åœ¨åº”ç”¨å®‰è£…æ—¶ä¼šè¢«ç³»ç»Ÿè§£æž, æ­¤ç§å½¢å¼çš„å¹¿æ’­ä¸éœ€è¦åº”ç”¨å¯åŠ¨å°±å¯ä»¥æŽ¥æ”¶åˆ°ç›¸åº”çš„å¹¿æ’­. åŠ¨æ€æ³¨å†Œ: éœ€è¦é€šè¿‡Context.registerReceiver()æ¥å®žçŽ°, å¹¶åœ¨ä¸éœ€è¦çš„æ—¶å€™é€šè¿‡Context.unRegisterReceiver()æ¥è§£é™¤å¹¿æ’­. æ­¤ç§å½¢æ€çš„å¹¿æ’­è¦åº”ç”¨å¯åŠ¨æ‰èƒ½æ³¨å†Œå’ŒæŽ¥æ”¶å¹¿æ’­. åœ¨å®žé™…å¼€å‘ä¸­é€šè¿‡Contextçš„ä¸€ç³»åˆ—çš„sendæ–¹æ³•æ¥å‘é€å¹¿æ’­, è¢«å‘é€çš„å¹¿æ’­ä¼šè¢«ç³»ç»Ÿå‘é€ç»™æ„Ÿå…´è¶£çš„å¹¿æ’­æŽ¥æ”¶è€…, å‘é€å’ŒæŽ¥æ”¶çš„è¿‡ç¨‹çš„åŒ¹é…æ˜¯é€šè¿‡å¹¿æ’­æŽ¥æ”¶è€…çš„&lt;intent-filter&gt;æ¥æè¿°çš„. å¯ä»¥å®žçŽ°ä½Žè€¦åˆçš„è§‚å¯Ÿè€…æ¨¡å¼, è§‚å¯Ÿè€…å’Œè¢«è§‚å¯Ÿè€…ä¹‹é—´å¯ä»¥æ²¡æœ‰ä»»ä½•è€¦åˆ. ä½†å¹¿æ’­ä¸é€‚åˆæ¥åšè€—æ—¶æ“ä½œ. ContentProvideræ˜¯ä¸€ç§æ•°æ®å…±äº«ç»„ä»¶, ç”¨äºŽå‘å…¶ä»–ç»„ä»¶ä¹ƒè‡³å…¶ä»–åº”ç”¨å…±äº«æ•°æ®. æ— æ³•è¢«ç”¨æˆ·æ„ŸçŸ¥. å¯¹äºŽå†…å®¹æä¾›è€…æ¥è¯´, å®ƒåªéœ€è¦å®žçŽ°å¢žåˆ æ”¹æŸ¥å››ç§åŸºæœ¬æ“ä½œ, åœ¨å®ƒå†…éƒ¨ç»´æŒç€ä¸€ä»½æ•°æ®é›†åˆ, è¿™ä¸ªæ•°æ®é›†åˆæ—¢å¯ä»¥é€šè¿‡æ•°æ®åº“æ¥å®žçŽ°, ä¹Ÿå¯ä»¥é‡‡ç”¨å…¶ä»–ä»»ä½•ç±»åž‹æ¥å®žçŽ°, ä¾‹å¦‚listæˆ–è€…map. ContentProviderå¯¹æ•°æ®é›†åˆçš„å…·ä½“å®žçŽ°å¹¶æ²¡æœ‰ä»»ä½•è¦æ±‚. è¦æ³¨æ„å¤„ç†å¥½å†…éƒ¨çš„insert, delete, update, queryæ–¹æ³•çš„çº¿ç¨‹åŒæ­¥, å› ä¸ºè¿™å‡ ä¸ªæ–¹æ³•æ˜¯åœ¨Binderçº¿ç¨‹æ± è¢«è°ƒç”¨. Activityçš„å·¥ä½œè¿‡ç¨‹è™½ç„¶è¦æ‰“å¼€ä¸€ä¸ªActivityå¾ˆç®€å•, ä½†æ˜¯ä¸åº”è¯¥åªæ˜¯å±€é™äºŽè¡¨é¢. äº†è§£å…¶å†…éƒ¨èµ°å‘æž„æˆ.æ‰€ä»¥ä¸€åˆ‡ä»ŽstartActivity(intent)è¿™ä¸ªæ–¹æ³•å¼€å§‹. startActivity()æœ‰å¥½å‡ ç§é‡è½½æ–¹å¼ä½†æ˜¯æœ€ç»ˆéƒ½æ˜¯è°ƒç”¨startActivityForResult()æ–¹æ³•. æ³¨æ„è¿™é‡Œåˆ†æžçš„æ˜¯5.0ç‰ˆæœ¬çš„æºç , å’Œ6.0æºç å®žçŽ°ç¨å¾®ä¸åŒ é¦–å…ˆçœ‹startActivityForResult() 123456789101112131415161718192021222324252627282930313233public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; final View decor = mWindow != null ? mWindow.peekDecorView() : null; if (decor != null) &#123; decor.cancelPendingInputEvents(); &#125; // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; if (options != null &amp;&amp; !isTopOfTask()) &#123; mActivityTransitionState.startExitOutTransition(this, options); &#125;&#125; å…³æ³¨mParent==nullçš„åˆ†æ”¯. mParentä»£è¡¨çš„æ˜¯ViewGroup, ActivityGroupæœ€å¼€å§‹è¢«ç”¨æ¥åœ¨ä¸€ä¸ªç•Œé¢ä¸­åµŒå…¥å¤šä¸ªå­Activity, åœ¨API13å·²ç»è¢«åºŸå¼ƒ. ç³»ç»ŸæŽ¨èä½¿ç”¨Fragmentä»£æ›¿ActivityGroup. æ³¨æ„mMainThread.getApplicationThread()è¿™ä¸ªå‚æ•°, å®ƒçš„å‚æ•°ç±»åž‹æ˜¯ApplicationThread, ApplicationThreadæ˜¯ActivityThreadçš„ä¸€ä¸ªå†…éƒ¨ç±». çœ‹ä¸€ä¸‹Instrumentation#execStartActivity()è¿™ä¸ªæ–¹æ³• 12345678910111213141516171819202122232425262728293031323334public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); // å¯åŠ¨Activityçš„çœŸæ­£å®žçŽ° int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null;&#125; ä»£ç ä¸­çœŸæ­£å¯åŠ¨Activityçš„çœŸæ­£å®žçŽ°æ˜¯ç”±ActivityManagerNative.getDefault().startActivity()æ–¹æ³•å®Œæˆçš„. åŽé¢å¯¹ActivityManagerServiceç®€ç§°AMS. AMSç»§æ‰¿è‡ªActivityManagerNative, è€ŒActivityManagerNativeç»§æ‰¿è‡ªBinderå¹¶å®žçŽ°äº†IActivityManagerè¿™ä¸ªBinderæŽ¥å£, å› æ­¤AMSä¹Ÿæ˜¯ä¸€ä¸ªBinder, å®ƒæ˜¯IActivityManagerçš„å…·ä½“å®žçŽ°. ç”±äºŽActivityManagerNative.getDefault()æœ¬è´¨æ˜¯ä¸€ä¸ªIActivityManagerç±»åž‹çš„Binderå¯¹è±¡, å› æ­¤å…·ä½“å®žçŽ°æ˜¯AMS. åœ¨ActivityManagerNativeä¸­, AMSè¿™ä¸ªBinderå¯¹è±¡é‡‡ç”¨å•ä¾‹æ¨¡å¼å¯¹å¤–æä¾›, Singletonæ˜¯ä¸€ä¸ªå•ä¾‹å°è£…ç±». ç¬¬ä¸€æ¬¡è°ƒç”¨å®ƒçš„get()æ–¹æ³•æ—¶ä¼šé€šè¿‡createæ–¹æ³•æ¥åˆå§‹åŒ–AMSè¿™ä¸ªBinderå¯¹è±¡, åœ¨åŽç»­è°ƒç”¨ä¸­ä¼šè¿”å›žè¿™ä¸ªå¯¹è±¡. å…·ä½“å®žçŽ°å¦‚ä¸‹ä»£ç . 1234567891011121314151617static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService("activity"); if (false) &#123; Log.v("ActivityManager", "default service binder = " + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v("ActivityManager", "default service = " + am); &#125; return am; &#125;&#125;; ç”±ä¸Šå¯ä»¥çœ‹åˆ°å…³äºŽActivityçš„å¯åŠ¨æ˜¯ç”±ActivityManagerNative.getDefault()æ¥å¯åŠ¨çš„, è€ŒActivityManagerNative.getDefault()å®žé™…ä¸Šæ˜¯AMS, æ‰€ä»¥Activityçš„å¯åŠ¨è¿‡ç¨‹åˆè¢«è½¬ç§»åˆ°äº†AMSä¸­, æŽ¥ä¸‹æ¥æŸ¥çœ‹AMSä¸­çš„startActivity()æ–¹æ³•. åœ¨åˆ†æžAMS#startActivity()ä¹‹å‰, æ˜¯å¦åœ¨å¼€å§‹æ—¶å€™ç¢°åˆ°è¿‡Activityæ²¡æœ‰åœ¨æ¸…å•æ–‡ä»¶ä¸­å£°æ˜Žç„¶åŽå´©æºƒçš„çŽ°è±¡? è¿™ä¸ªæ­¥éª¤æ˜¯åœ¨Instrumentation#execStartActivity()åˆšæ‰åˆ†æžActivityManagerNative.getDefault().startActivity()çš„ä¸‹ä¸€æ­¥. æœ‰ä¸€ä¸ªcheckStartActivityResult(),çœ‹åå­—åº”è¯¥æ˜¯æ£€æŸ¥çš„ç±», çœ‹ä¸€ä¸‹å®žçŽ°. 1234567891011121314151617181920212223242526272829303132public static void checkStartActivityResult(int res, Object intent) &#123; if (res &gt;= ActivityManager.START_SUCCESS) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( "Unable to find explicit activity class " + ((Intent)intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?"); throw new ActivityNotFoundException( "No Activity found to handle " + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException("Not allowed to start activity " + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( "FORWARD_RESULT_FLAG used while also requesting a result"); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( "PendingIntent is not an activity"); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( "Starting under voice control not allowed for: " + intent); default: throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent); &#125;&#125; çœ‹å‡ºè¿™ä¸ªæ–¹æ³•æ˜¯ä¸€è¨€ä¸åˆå°±æŠ›å¼‚å¸¸. çœ‹ActivityManager.START_CLASS_NOT_FOUNDè¿™ä¸ªåˆ¤æ–­åˆ†æ”¯æŠ›å‡ºçš„å¼‚å¸¸æ˜¯ä¸æ˜¯å¾ˆçœ¼ç†Ÿ? å¯¹å°±æ˜¯æ²¡æœ‰åœ¨æ¸…å•æ–‡ä»¶ä¸­æ³¨å†Œå°±åœ¨è¿™é‡ŒæŠ›å‡º. æ‰€ä»¥è¿™ä¸ªæ–¹æ³•å°±æ˜¯æ£€æŸ¥å¯åŠ¨Activityçš„ç»“æžœ. å›žåˆ°AMSçš„startActivity() 123456789101112131415161718192021public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; // ç›´æŽ¥è°ƒç”¨ä¸‹é¢æ–¹æ³• return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, userId, null, null);&#125; Activityå¯åŠ¨è¿‡ç¨‹ç»è¿‡ä¸¤æ¬¡è½¬ç§», æœ€åŽåˆè½¬ç§»åˆ°äº†mStackSupervisor.startActivityMayWait()è¿™ä¸ªæ–¹æ³•, æ‰€å±žç±»ä¸ºActivityStackSupervisor. åœ¨startActivityMayWait()å†…éƒ¨åˆè°ƒç”¨äº†startActivityLocked()è¿™é‡Œä¼šè¿”å›žç»“æžœç å°±æ˜¯ä¹‹å‰checkStartActivityResult()ç”¨åˆ°çš„. ç»§ç»­è·Ÿè¿›æ–¹æ³•æœ€åŽä¼šè°ƒç”¨startActivityUncheckedLocked(), ç„¶åŽåˆè°ƒç”¨äº†ActivityStack#resumeTopActivityLocked(). è¿™ä¸ªæ—¶å€™å¯åŠ¨è¿‡ç¨‹å·²ç»ä»ŽActivityStackSupervisorè½¬ç§»åˆ°äº†ActivityStackç±»ä¸­. çœ‹ActivityStackçš„resumeTopActivityLocked()æ–¹æ³•å®žçŽ° 1234567891011121314151617181920final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; ä»Žä¸Šå¯ä»¥çœ‹åˆ°resultæ˜¯æ ¹æ®è°ƒç”¨çš„resumeTopActivityInnerLocked()è¿”å›ž, è€ŒresumeTopActivityInnerLocked()åˆè°ƒç”¨äº†ActivityStackSupervisor#startSpecificActivityLocked()æ–¹æ³•. çœ‹ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•: 123456789101112131415161718192021222324252627282930void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !"android".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; // ç»§ç»­è¿›å…¥!!! realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true);&#125; è¿™ä¸ªæ–¹æ³•åˆè¿›å…¥äº†realStartActivityLocked(). åœ¨è¿™ä¸ªæ–¹æ³•ä¸­æœ‰å¦‚ä¸‹ä¸€æ®µä»£ç : 12345app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, r.launchedFromPackage, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); å…ˆæ•´ç†ä¸€ä¸‹åˆšæ‰çš„è°ƒç”¨è¿‡ç¨‹, æˆ‘å·²ç»ç…§ç€ä¹¦ä¸Šè·Ÿçš„ä¸çŸ¥æ‰€ä»¥ç„¶äº†â€¦. Activityçš„å¯åŠ¨è¿‡ç¨‹åœ¨ActivityStackSupervisorå’ŒActivityStackä¹‹é—´çš„ä¼ é€’é¡ºåºå¯ä»¥æ¦‚æ‹¬ä¸ºä¸‹å›¾ï¼š ç»§ç»­çœ‹åˆšæ‰app.thread.scheduleLaunchActivity()è¿™ä¸ªæ–¹æ³•. å…¶ä¸­app.threadç±»åž‹ä¸ºIApplicationThread, è¿™ä¸ªçŽ©æ„ç»§æ‰¿äº†IInterfaceæŽ¥å£, æ‰€ä»¥ä»–ä¹Ÿæ˜¯ä¸€ä¸ªBinderç±»åž‹çš„æŽ¥å£. ä»ŽIApplicationThreadå£°æ˜Žçš„æŽ¥å£æ–¹æ³•å¯ä»¥çœ‹å‡º, å…¶å†…éƒ¨åŒ…å«äº†å¤§é‡å¯åŠ¨å’Œåœæ­¢Activityä»¥åŠServiceçš„æŽ¥å£. é‚£IApplicationThreadçš„å®žçŽ°è€…æ˜¯å“ªä¸ªç±»? åœ¨ActivityThreadä¸­çš„å†…éƒ¨ç±»æœ‰ä¸€ä¸ªApplicationThread,çœ‹çœ‹å®šä¹‰ 1234private class ApplicationThread extends ApplicationThreadNativepublic abstract class ApplicationThreadNative extends Binder implements IApplicationThread å¯ä»¥çœ‹åˆ°ApplicationThreadçš„ç»§æ‰¿å…³ç³», è€ŒæŸ¥çœ‹ApplicationThreadNativeçš„ä½œç”¨å…¶å®žå’Œç³»ç»ŸAIDLæ–‡ä»¶ç”Ÿæˆçš„ç±»æ˜¯ä¸€æ ·çš„. åœ¨ApplicationThreadNativeçš„å†…éƒ¨, è¿˜æœ‰ä¸€ä¸ªApplicationThreadProxyç±», çœ¼ç†Ÿå§åœ¨ç¬¬äºŒç« è®²è§£çš„æ—¶å€™aidlç”Ÿæˆçš„javaæ–‡ä»¶ä¸­ä¹Ÿæœ‰ä¸€ä¸ªå†…éƒ¨çš„ä»£ç†ç±». æ‰€ä»¥ApplicationThreadNativeå°±æ˜¯IApplicationThreadçš„å®žçŽ°è€…, ç”±äºŽApplicationThreadNativeè¢«ç³»ç»Ÿå®šä¹‰ä¸ºæŠ½è±¡ç±», æ‰€ä»¥ApplicationThreadå°±æˆäº†IApplicationThreadçš„å®žçŽ°è€…ã€‚ ç»•äº†ä¸€å¤§åœˆ, Activityå¯åŠ¨è¿‡ç¨‹æœ€ç»ˆå›žåˆ°äº†ApplicationThreadä¸­, ApplicationThreadé€šè¿‡scheduleLaunchActivity()æ¥å¯åŠ¨Activity. 12345678910111213141516171819202122232425262728public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; è¿™æ®µä»£ç åšçš„å°±æ˜¯å°è£…ä¸€ä¸ªActivityçš„è®°å½•ä¿¡æ¯äº¤ç»™åå­—å«Hçš„ä¸€ä¸ªHandlerå¯¹è±¡åŽ»å¤„ç†, ç»§ç»­è·Ÿè¿›çœ‹çœ‹é‡Œé¢çš„å®žçŽ° 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, "SCHEDULE " + what + " " + mH.codeToString(what) + ": " + arg1 + " / " + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; é¢, æ²¡å•¥å¥½çž…çš„å°±æ˜¯å°è£…ä¸€ä¸ªmessageå‘é€äº†ä¸€ä¸ªæ¶ˆæ¯. å¥½å§ é‚£çœ‹çœ‹HandleræŽ¥æ”¶çš„æ—¶å€™æ˜¯å¦‚ä½•å¤„ç†çš„å§. è¿™ä¸ªç±»é‡Œé¢å¯¹Handlerè¿›è¡Œäº†åŒ…è£…, åŒ…è£…çš„ç±»å°±æ˜¯ä¸€ä¸ªHçš„å†…éƒ¨ç±». 1234567891011121314151617181920212223242526272829303132333435363738private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; //è¿™é‡Œçœç•¥ä¸€å †å¸¸é‡å£°æ˜Ž //åœ¨çœç•¥ä¸€å †switchåˆ†æ”¯, ç›´æŽ¥çœ‹å…·ä½“çš„æ¶ˆæ¯å¤„ç† public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case PAUSE_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityPause"); handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;2) != 0); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityPause"); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; //è¿™é‡ŒåˆçœåŽ»äº†ä¸€å¤§å¨çš„caseåˆ†æ”¯ &#125; if (DEBUG_MESSAGES) Slog.v(TAG, "&lt;&lt;&lt; done: " + codeToString(msg.what)); &#125; æˆ‘ä»¬ç›®å‰åªå…³å¿ƒLAUNCH_ACTIVITYè¿™ä¸ªæ ‡è®°ï¼ŒActivityçš„å¯åŠ¨è¿‡ç¨‹ç”±ActivityThreadçš„handleLaunchActivity()æ–¹æ³•æ¥å®žçŽ°ã€‚è¿™ä¸ªæ–¹æ³•å†…éƒ¨é€šè¿‡performLaunchActivity()æ–¹æ³•æœ€ç»ˆå®Œæˆäº†Activityå¯¹è±¡çš„åˆ›å»ºå’Œå¯åŠ¨è¿‡ç¨‹. å¹¶ä¸”ActivityThreadé€šè¿‡handleResumeActivity()æ–¹æ³•æ¥è°ƒç”¨è¢«å¯åŠ¨çš„onResume()è¿™ä¸€ç”Ÿå‘½å‘¨æœŸæ–¹æ³•. performLaunchActivity(ActivityClientRecord r, Intent customIntent)ä¸»è¦å®Œæˆå¦‚ä¸‹çš„å‡ ä»¶äº‹ï¼š 1. ä»ŽActivityClientRecordä¸­èŽ·å–å¾…å¯åŠ¨çš„Activityä¿¡æ¯ 1234567891011121314151617ActivityInfo aInfo = r.activityInfo;if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);&#125;ComponentName component = r.intent.getComponent();if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component);&#125;if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity);&#125; 2.é€šè¿‡Instrumentationçš„newActivityæ–¹æ³•ä½¿ç”¨ç±»åŠ è½½å™¨åˆ›å»ºActivityå¯¹è±¡ 123456789java.lang.ClassLoader cl = r.packageInfo.getClassLoader();activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);StrictMode.incrementExpectedActivityCount(activity.getClass());r.intent.setExtrasClassLoader(cl);r.intent.prepareToEnterProcess();if (r.state != null) &#123; r.state.setClassLoader(cl);&#125; è‡³äºŽInstrumentationçš„newActivityå®žçŽ°å°±æ˜¯é€šè¿‡ç±»åŠ è½½å™¨åˆ›å»ºäº†ä¸€ä¸ªActivityå¯¹è±¡ï¼š 123public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newIntance();&#125; 3.é€šè¿‡LoadedApkçš„makeApplication()æ–¹æ³•æ¥å°è¯•åˆ›å»ºApplicationå¯¹è±¡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123;//å·²ç»æœ‰Applicaitonç›´æŽ¥è¿”å›ž return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = "android.app.Application"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals("android")) &#123; initializeJavaContextClassLoader(); &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); //é€šè¿‡Instrumentationåˆ›å»ºApplication app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; if (!mActivityThread.mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( "Unable to instantiate application " + appClass + ": " + e.toString(), e); &#125; &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; try &#123; //å›žè°ƒonCreate()æ–¹æ³• instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!instrumentation.onException(app, e)) &#123; throw new RuntimeException( "Unable to create application " + app.getClass().getName() + ": " + e.toString(), e); &#125; &#125; &#125; // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); &#125; return app;&#125; ä»Žè¿™ä¸ªæ–¹æ³•ä¸­å¯ä»¥çœ‹åˆ°, å¦‚æžœApplicationè¿™ä¸ªå¯¹è±¡å·²ç»è¢«åˆ›å»ºè¿‡, é‚£ä¹ˆå°±ä¸ä¼šå†é‡å¤åˆ›å»ºäº†, è¿™ä¹Ÿå°±æ„å‘³ç€ä¸€ä¸ªåº”ç”¨åªæœ‰ä¸€ä¸ªApplicationå¯¹è±¡çš„åŽŸå› . Applicationå¯¹è±¡çš„åˆ›å»ºä¹Ÿæ˜¯é€šè¿‡Instrumentationç±»æ¥å®Œæˆ, è¿™ä¸ªè¿‡ç¨‹å’ŒActivityå¯¹è±¡çš„åˆ›å»ºæ˜¯ä¸€è‡´çš„, éƒ½æ˜¯é€šè¿‡ç±»åŠ è½½å™¨æ¥å®žçŽ°. Applicationåˆ›å»ºå®Œæ¯•åŽ, ç³»ç»Ÿä¼šé€šè¿‡Instrumentationçš„callApplicationOnCreate()æ–¹æ³•æ¥è°ƒç”¨Application#onCreate()æ–¹æ³•. 4. åˆ›å»ºContextImplå¯¹è±¡å¹¶é€šè¿‡Activityçš„attachæ–¹æ³•æ¥å®Œæˆé‡è¦æ•°æ®çš„åˆå§‹åŒ– 123456789Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ContextImplæ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„æ•°æ®ç»“æž„, å®ƒæ˜¯Contextçš„å…·ä½“å®žçŽ°, Contextä¸­çš„å¤§éƒ¨åˆ†é€»è¾‘éƒ½æ˜¯ç”±ContentImplæ¥å®Œæˆçš„. ContextImplæ˜¯é€šè¿‡Activityçš„attach()æ–¹æ³•æ¥å’ŒActivityå»ºç«‹å…³è”çš„,é™¤æ­¤ä¹‹å¤–, åœ¨attach()ä¸­Activityè¿˜ä¼šå®ŒæˆWindowçš„åˆ›å»ºå¹¶å»ºç«‹è‡ªå·±å’ŒWindowçš„å…³è”, è¿™æ ·å½“WindowæŽ¥æ”¶åˆ°å¤–éƒ¨è¾“å…¥äº‹ä»¶æ”¶å°±å¯ä»¥å°†äº‹ä»¶ä¼ é€’ç»™Activity. 5. è°ƒç”¨Activityçš„onCreate()æ–¹æ³• mInstrumentation.callActivityOnCreate(activity, r.state);, ç”±äºŽActivityçš„onCreate()å·²ç»è¢«è°ƒç”¨, è¿™ä¹Ÿæ„å‘³ç€Activityå·²ç»å®Œæˆæ•´ä¸ªå¯åŠ¨è¿‡ç¨‹. Serviceçš„å·¥ä½œæµç¨‹Serviceçš„å¯åŠ¨è¿‡ç¨‹åŒæ ·ä»ŽContextImpl#startService()è¿™ä¸ªæ–¹æ³•ä½œä¸ºå…¥å£. è¿™ä¸ªæ–¹æ³•ä¼šè°ƒç”¨startServiceCommon()å¹¶è¿”å›ž. è¿™ä¸ªæ–¹æ³•å†…éƒ¨é€šè¿‡ActivityManagerNative.getDefault()èŽ·å¾—ä¸€ä¸ªAMSå¹¶è°ƒç”¨startService()å¼€å¯ä¸€ä¸ªæœåŠ¡. åœ¨è¿™é‡Œé€šè¿‡AMSæ¥å¯åŠ¨ä¸€ä¸ªæœåŠ¡çš„è¡Œä¸ºæ˜¯å±žäºŽè¿œç¨‹è°ƒç”¨çš„è¿‡ç¨‹. çœ‹ä¸€ä¸‹AMSçš„startService() 1234567891011121314151617181920public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; enforceNotIsolatedCaller("startService"); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; if (DEBUG_SERVICE) Slog.v(TAG, "startService: " + service + " type=" + resolvedType); synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; è¿™æ®µä¸»è¦å°±æ˜¯AMSé€šè¿‡mServicesè¿™ä¸ªå¯¹è±¡æ¥å®ŒæˆServiceåŽç»­çš„å¯åŠ¨è¿‡ç¨‹. è¿™é‡ŒmServiceçš„å¯¹è±¡ç±»åž‹æ˜¯ActiveServices(è¿™æ˜¯ä¸€ä¸ªè¾…åŠ©AMSè¿›è¡ŒServiceç®¡ç†çš„ç±», åŒ…æ‹¬Serviceçš„å¯åŠ¨,ç»‘å®šå’Œåœæ­¢ç­‰). è¿™é‡Œè°ƒç”¨äº†mServices.startServiceLocked()ç„¶åŽè¿™ä¸ªæ–¹æ³•æœ€åŽåˆè°ƒç”¨äº†startServiceInnerLocked(), å®žçŽ°å¦‚ä¸‹. 1234567891011121314151617181920212223242526272829303132333435ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) &#123; ProcessStats.ServiceState stracker = r.getTracker(); if (stracker != null) &#123; stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity); &#125; r.callStart = false; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startRunningLocked(); &#125; String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false); if (error != null) &#123; return new ComponentName("!!", error); &#125; if (r.startRequested &amp;&amp; addToStarting) &#123; boolean first = smap.mStartingBackground.size() == 0; smap.mStartingBackground.add(r); r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT; if (DEBUG_DELAYED_SERVICE) &#123; RuntimeException here = new RuntimeException("here"); here.fillInStackTrace(); Slog.v(TAG, "Starting background (first=" + first + "): " + r, here); &#125; else if (DEBUG_DELAYED_STARTS) &#123; Slog.v(TAG, "Starting background (first=" + first + "): " + r); &#125; if (first) &#123; smap.rescheduleDelayedStarts(); &#125; &#125; else if (callerFg) &#123; smap.ensureNotStartingBackground(r); &#125; return r.name; &#125; ServiceRecordæè¿°çš„æ˜¯ä¸€ä¸ªServiceè®°å½•, ServiceRecordä¸€ç›´è´¯ç©¿ç€æ•´ä¸ªServiceçš„å¯åŠ¨è¿‡ç¨‹. startServiceInnerLocked()æ–¹æ³•å¹¶æ²¡æœ‰å®Œæˆå…·ä½“çš„å¯åŠ¨å·¥ä½œ, è€Œæ˜¯æŠŠåŽç»­çš„å·¥ä½œäº¤ç»™äº†bringUpServiceLocked(),åœ¨bringUpServiceLocked()åˆè°ƒç”¨äº†realStartServiceLocked()æ–¹æ³•. è¿™ä¸ªæ–¹æ³•ç®—æ˜¯çœŸæ­£çš„å¯åŠ¨ä¸€ä¸ªService. realStartServiceLocked()é¦–å…ˆé€šè¿‡app.thread.scheduleCreateService()æ–¹æ³•æ¥åˆ›å»ºServiceå¯¹è±¡å¹¶è°ƒç”¨å…¶onCreate(), æŽ¥ç€å†é€šè¿‡sendServiceArgsLoceked()æ–¹æ³•æ¥è°ƒç”¨Serviceçš„å…¶ä»–æ–¹æ³•, æ¯”å¦‚onStartCommondè¿™ä¸¤ä¸ªè¿‡ç¨‹å‡æ˜¯è¿›ç¨‹é—´é€šä¿¡. app.threadå¯¹è±¡æ˜¯IApplicationThreadç±»åž‹ï¼Œå®žé™…ä¸Šæ˜¯ä¸€ä¸ªBinderï¼Œä»–çš„å…·ä½“å®žçŽ°æ˜¯ApplicationThread. åœ¨Activityå¯åŠ¨æµç¨‹çš„æ—¶å€™å·²ç»è§£é‡Šè¿‡äº†. æ‰€ä»¥åªæŸ¥çœ‹Applicationå¯¹Serviceçš„å¯åŠ¨è¿‡ç¨‹çš„å¤„ç†å³å¯. è¿™å¯¹åº”ç€å®ƒçš„scheduleCreateService(). 12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125; è¿™ä¸ªè¿‡ç¨‹å’ŒActivityç±»ä¼¼, éƒ½æ˜¯é€šè¿‡Hæ¥å®Œæˆã€‚Hä¼šæŽ¥æ”¶è¿™ä¸ªCREATE_SERVICEæ¶ˆæ¯å¹¶é€šè¿‡ActivityThreadçš„handleCreateServiceæ–¹æ³•å®ŒæˆServiceçš„æœ€ç»ˆå¯åŠ¨. 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void handleCreateService(CreateServiceData data) &#123; unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( "Unable to instantiate service " + data.info.name + ": " + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, "Creating service " + data.info.name); ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); //---------------- service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); service.onCreate(); //--------------- mServices.put(data.token, service); try &#123; ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; // nothing to do. &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( "Unable to create service " + data.info.name + ": " + e.toString(), e); &#125; &#125;&#125; handleCreateServiceåšäº†å¦‚ä¸‹äº‹æƒ… é€šè¿‡ç±»åŠ è½½å™¨åˆ›å»ºServiceçš„å®žä¾‹ åˆ›å»ºApplicationå¯¹è±¡å¹¶è°ƒç”¨å…¶onCreate(), æ³¨æ„âš ï¸Applicationåˆ›å»ºè¿‡ç¨‹åªä¼šæœ‰ä¸€æ¬¡. æŽ¥ç€åˆ›å»ºContextImplå¯¹è±¡å¹¶é€šè¿‡Serviceçš„attachæ–¹æ³•å»ºç«‹äºŒè€…ä¹‹é—´çš„å…³ç³», è¿™ä¸ªè¿‡ç¨‹å’ŒActivityå®žé™…ä¸Šæ˜¯ç±»ä¼¼çš„. è°ƒç”¨onCreate()å¹¶å°†Serviceå¯¹è±¡å­˜å‚¨åˆ°ActivityThreadä¸­çš„ä¸€ä¸ªåˆ—è¡¨. å°±æ˜¯final ArrayMap&lt;IBinder, Service&gt; mServices = new ArrayMap&lt;IBinder, Service&gt;(); onCreate()æ–¹æ³•è¢«æ‰§è¡Œäº†ä¹Ÿå°±æ„å‘³ç€Serviceå·²ç»å¯åŠ¨äº†. é™¤æ­¤ä¹‹å¤–, ActivityThreadä¸­è¿˜ä¼šé€šè¿‡handleServiceArgs()æ–¹æ³•è°ƒç”¨Serviceçš„onStartCommand()æ–¹æ³•. Serviceçš„ç»‘å®šè¿‡ç¨‹å’Œå¯åŠ¨è¿‡ç¨‹ä¸€æ ·, ç»‘å®šè¿‡ç¨‹åŒæ ·æ˜¯ä»ŽContextImplå¼€å§‹çš„. å…ˆæŸ¥çœ‹bindServiceCommon(). 12345678910111213141516171819202122232425262728293031323334private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, UserHandle user) &#123; IServiceConnection sd; if (conn == null) &#123; throw new IllegalArgumentException("connection is null"); &#125; if (mPackageInfo != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags); &#125; else &#123; throw new RuntimeException("Not supported in system context"); &#125; validateServiceIntent(service); try &#123; IBinder token = getActivityToken(); if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(); int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( "Not allowed to bind to service " + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; return false; &#125;&#125; è¿™æ®µä»£ç é¦–å…ˆå°†å®¢æˆ·ç«¯çš„ServiceConnectionå¯¹è±¡è½¬åŒ–æˆä¸ºServiceDispatcher.InnerConnectionå¯¹è±¡. ä¸èƒ½ç›´æŽ¥ä½¿ç”¨ServiceConnectionå¯¹è±¡å¿…é¡»å€ŸåŠ©äºŽBinderæ‰èƒ½è®©è¿œç¨‹æœåŠ¡å›žè°ƒè‡ªå·±çš„æ–¹æ³•. è€ŒServiceDispatcherçš„å†…éƒ¨ç±»InnerConnectionåˆšå¥½å……å½“äº†Binderè¿™ä¸ªè§’è‰². ServiceDispatcherçš„ä½œç”¨å°±æ˜¯è¿žæŽ¥ServiceConnectionå’ŒInnerConnectionçš„ä½œç”¨. è¿™ä¸ªè¿‡ç¨‹ç”±LoadedApkçš„getServiceDispatcher()æ–¹æ³•å®Œæˆ. å®žçŽ°å¦‚ä¸‹: 123456789101112131415161718192021public final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) &#123; synchronized (mServices) &#123; LoadedApk.ServiceDispatcher sd = null; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); if (map != null) &#123; sd = map.get(c); &#125; if (sd == null) &#123; sd = new ServiceDispatcher(c, context, handler, flags); if (map == null) &#123; map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;(); mServices.put(context, map); &#125; map.put(c, sd); &#125; else &#123; sd.validate(context, handler); &#125; return sd.getIServiceConnection(); &#125;&#125; mServiceæ˜¯ä¸€ä¸ªArrayMap, å®ƒå­˜å‚¨äº†ä¸€ä¸ªåº”ç”¨å½“å‰æ´»åŠ¨çš„ServiceConnectionå’ŒServiceDispatcherçš„æ˜ å°„å…³ç³». ç³»ç»Ÿé¦–å…ˆä¼šæŸ¥æ‰¾æ˜¯å¦å­˜åœ¨ç›¸åŒçš„ServiceConnection, å¦‚æžœä¸å­˜åœ¨å°±ä¼šé‡æ–°åˆ›å»ºä¸€ä¸ªServiceDispatchå¯¹è±¡å¹¶å°†å…¶å­˜å‚¨åœ¨mServiceä¸­, å…¶ä¸­çš„keyæ˜¯ServiceConnection,valueæ˜¯ServiceDispatcher, åœ¨ServiceDispatcherçš„å†…éƒ¨åˆä¿å­˜äº†ServiceConnectionå’ŒInnerConnectionå¯¹è±¡. å½“Serviceå’Œå®¢æˆ·ç«¯å»ºç«‹è¿žæŽ¥åŽ, ç³»ç»Ÿä¼šé€šè¿‡InnerConnectionæ¥è°ƒç”¨ServiceConnectionä¸­çš„onServiceConnected()æ–¹æ³•. è¿™ä¸ªè¿‡ç¨‹æ˜¯è·¨è¿›ç¨‹çš„. å½“ServiceDispatcheråˆ›å»ºå¥½äº†ä»¥åŽ, getServiceDispatcherä¼šè¿”å›žå…¶ä¿å­˜çš„InnerConnectionå¯¹è±¡. æŽ¥ç€bindServiceCommonæ–¹æ³•ä¼šé€šè¿‡AMSå®ŒæˆServiceçš„å…·ä½“ç»‘å®š, è¿™å¯¹åº”ç€AMS#bindService()æ–¹æ³•. 123456789101112131415public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, int userId) &#123; enforceNotIsolatedCaller("bindService"); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, userId); &#125;&#125; ç„¶åŽAMSä¼šè°ƒç”¨ActivityService#bindServiceLocked()æ–¹æ³•. ç„¶åŽè°ƒç”¨bringUpServiceLocked(), ç»§ç»­è°ƒç”¨. å‘çŽ°è°ƒåˆ°äº†realStartServiceLocked. âš ï¸è¿™é‡Œé¢çš„é€»è¾‘å’Œå¯åŠ¨è¿‡ç¨‹ç±»ä¼¼. æœ€ç»ˆéƒ½æ˜¯é€šè¿‡ApplicationThreadæ¥å®ŒæˆServiceå®žä¾‹çš„åˆ›å»ºå¹¶æ‰§è¡Œå…¶onCreate()æ–¹æ³•. è¿™é‡Œä¸å†é‡å¤è¯´æ˜Ž. ä¸ŽServiceå¯åŠ¨ç¨å¾®ä¸åŒçš„æ˜¯:ðŸ˜­ ç»‘å®šè¿‡ç¨‹: ä¼šè°ƒç”¨åˆ°app.thread(ActivityThread)çš„scheduleBindService()æ–¹æ³•. è€Œè¿™ä¸ªè¿‡ç¨‹çš„å®žçŽ°æ˜¯åœ¨ActiveService#requestServiceBindingLocked()æ–¹æ³•. 123456789101112131415161718192021222324private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) &#123; if (r.app == null || r.app.thread == null) &#123; // If service is not currently running, can't yet bind. return false; &#125; if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; try &#123; bumpServiceExecutingLocked(r, execInFg, "bind"); r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); if (!rebind) &#123; i.requested = true; &#125; i.hasBound = true; i.doRebind = false; &#125; catch (RemoteException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG, "Crashed while binding " + r); return false; &#125; &#125; return true;&#125; app.threadå®žé™…ä¸Šå°±æ˜¯ApplicationThread. ApplicationThreadçš„ä¸€ç³»åˆ—ä»¥scheduleå¼€å¤´çš„æ–¹æ³•, å…¶å†…éƒ¨éƒ½æ˜¯é€šè¿‡Handler Hæ¥ä¸­è½¬çš„. Hçš„å†…éƒ¨ æŽ¥æ”¶åˆ°BIND_SERVICEæ¶ˆæ¯éœ€è¦å¤„ç†æ—¶, ä¼šäº¤ç»™ActivityThread#handleBindService(). åœ¨handlerBindServiceä¸­, é¦–å…ˆæ ¹æ®Serviceçš„tokenå–å‡ºServiceå¯¹è±¡. ç„¶åŽè°ƒç”¨Service#onBind()æ–¹æ³•, Serviceçš„onBinderæ–¹æ³•è¿”å›žä¸€ä¸ªBinderå¯¹è±¡ç»™å®¢æˆ·ç«¯ä½¿ç”¨. åŽŸåˆ™ä¸Šæ¥è¯´, Service#onBind()æ–¹æ³•è¢«è°ƒç”¨åŽ, Serviceå°±å¤„äºŽç»‘å®šçŠ¶æ€, ä½†æ˜¯onBindæ–¹æ³•æ˜¯Serviceçš„æ–¹æ³•, è¿™ä¸ªæ—¶å€™å®¢æˆ·ç«¯å¹¶ä¸çŸ¥é“å·²ç»æˆåŠŸè¿žæŽ¥Service, æ‰€ä»¥è¿˜å¿…é¡»è°ƒç”¨å®¢æˆ·ç«¯çš„ServiceConnectionä¸­çš„onServiceConnected(), è¿™ä¸ªè¿‡ç¨‹ç”±æ˜¯ActivityManagerNative.getDefault()ä¹Ÿå°±æ˜¯AMSçš„publishSevice()æ¥å®Œæˆã€‚ handleBindService()å®žçŽ°å¦‚ä¸‹: 1234567891011121314151617181920212223242526272829303132//ActivityThread.javaprivate void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token); if (DEBUG_SERVICE) Slog.v(TAG, "handleBindService s=" + s + " rebind=" + data.rebind); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try &#123; if (!data.rebind) &#123; IBinder binder = s.onBind(data.intent); // çœ‹æˆ‘çœ‹æˆ‘ ActivityManagerNative.getDefault().publishService( data.token, data.intent, binder); &#125; else &#123; s.onRebind(data.intent); ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; ensureJitEnabled(); &#125; catch (RemoteException ex) &#123; &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( "Unable to bind to service " + s + " with " + data.intent + ": " + e.toString(), e); &#125; &#125; &#125;&#125; è¿˜è®°å¾—å¤šæ¬¡ç»‘å®šä¼šæœ‰ä»€ä¹ˆæ•ˆæžœä¹ˆ? Service#onBind()æ–¹æ³•åªä¼šæ‰§è¡Œä¸€æ¬¡, é™¤éžServiceè¢«ç»ˆæ­¢äº†. å½“Serviceçš„onBind()æ‰§è¡Œä¹‹åŽ, ç³»ç»Ÿè¿˜éœ€è¦å‘ŠçŸ¥å®¢æˆ·ç«¯å·²ç»æˆåŠŸè¿žæŽ¥Serviceäº†. è¿™äº›è¿‡ç¨‹æ˜¯åœ¨AMS#publishService()å®žçŽ°. 12345678910111213public void publishService(IBinder token, Intent intent, IBinder service) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; throw new IllegalArgumentException("Invalid service token"); &#125; mServices.publishServiceLocked((ServiceRecord)token, intent, service); &#125;&#125; å¯ä»¥çœ‹åˆ°è¿™é‡Œå°†å…·ä½“çš„å·¥ä½œäº¤ç»™äº†mServices.publishServiceLocked()å®ƒæ˜¯ä¸€ä¸ªActiveServiceç±»åž‹. å…¶æ ¸å¿ƒä»£ç å°±æ˜¯: 1234c.conn.connected(r.name, service);//cçš„ç±»åž‹æ˜¯ConnectionRecord//c.connçš„ç±»åž‹æ˜¯ServiceDispatcher.InnerConnection//serviceå‚æ•°å°±æ˜¯Serviceçš„onBindè¿”å›žçš„Binderå¯¹è±¡ 123456789101112131415//çœ‹ä¸€ä¸‹ServiceDispatcher.InnerConnectionçš„å®šä¹‰private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service) &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if(sd != null) &#123; sd.connected(name, service); &#125; &#125;&#125; è€ŒInnerConnection#connected()æ–¹æ³•å†…åˆè°ƒç”¨ServiceDispatcherçš„connected(),åœ¨å†…éƒ¨å°±æ˜¯åˆ›å»ºä¸€ä¸ªRunConnection()å‘é€åˆ°mActivityThreadçš„æ¶ˆæ¯ä¸­. 12345678//ServiceDispatch classpublic void connected(Conponment name, IBinder service) &#123; if(mActivityThread != null) &#123; mActiivtyThread.post(new RunConnection(name, service, 0)); &#125; else &#123; doConnect(name, service); &#125;&#125; å¯¹äºŽServiceçš„ç»‘å®šè¿‡ç¨‹æ¥è¯´, ServiceDispatcherçš„mActivityThreadæ˜¯ä¸€ä¸ªHandler, ä¹Ÿå°±æ˜¯ActivityThread#H, ä»Žå‰é¢çš„ServiceDispatcherçš„åˆ›å»ºè¿‡ç¨‹æ¥è¯´, mActivityThreadä¸ä¼šä¸ºnull, æ‰€ä»¥RunConnectionå°±å¯ä»¥ç»ç”±Hçš„postæ–¹æ³•ä»Žè€Œè¿è¡Œåœ¨ä¸»çº¿ç¨‹. å› æ­¤å®¢æˆ·ç«¯çš„ServiceConnectionä¸­çš„æ–¹æ³•æ˜¯åœ¨ä¸»çº¿ç¨‹è¢«å›žè°ƒçš„. RunConnectionæ˜¯ä¸€ä¸ªRunnableæŽ¥å£, run()æ–¹æ³•ä¹Ÿæ˜¯ç®€å•è°ƒç”¨ServiceDispatcher#doConnectedæ–¹æ³•, ç”±äºŽServiceDispatcherå†…éƒ¨ä¿å­˜äº†å®¢æˆ·ç«¯çš„ServiceConnectionå¯¹è±¡, å› æ­¤ä»–å¯ä»¥å¾ˆæ–¹ä¾¿è°ƒç”¨ServiceConnectionå¯¹è±¡çš„onServiceConnected() è§£ç»‘å’Œåœæ­¢è¿‡ç¨‹, åŸºæœ¬ç±»ä¼¼â€¦ ðŸ˜„. BroadcastReceiverçš„å·¥ä½œæµç¨‹ç®€å•å›žé¡¾ä¸€ä¸‹å¹¿æ’­çš„ä½¿ç”¨æ–¹æ³•, é¦–å…ˆå®šä¹‰å¹¿æ’­æŽ¥æ”¶è€…, åªéœ€è¦ç»§æ‰¿BroadcastReceiverå¹¶é‡å†™onReceive()æ–¹æ³•å³å¯. å®šä¹‰å¥½äº†å¹¿æ’­æŽ¥æ”¶è€…, è¿˜éœ€è¦æ³¨å†Œå¹¿æ’­æŽ¥æ”¶è€…, åˆ†ä¸ºä¸¤ç§é™æ€æ³¨å†Œæˆ–è€…åŠ¨æ€æ³¨å†Œ. æ³¨å†Œå®Œæˆä¹‹åŽå°±å¯ä»¥å‘é€å¹¿æ’­äº†. å¹¿æ’­çš„æ³¨å†Œè¿‡ç¨‹å¹¿æ’­çš„æ³¨å†Œæœ‰ä¸¤ç§é™æ€æ³¨å†Œ, åŠ¨æ€æ³¨å†Œ. å…¶ä¸­é™æ€æ³¨å†Œçš„å¹¿æ’­åœ¨åº”ç”¨å®‰è£…æ—¶ç”±ç³»ç»Ÿè‡ªåŠ¨å®Œæˆæ³¨å†Œ, å…·ä½“æ¥è¯´æ˜¯æœ‰PMS(PackageManagerService)æ¥å®Œæˆæ•´ä¸ªæ³¨å†Œè¿‡ç¨‹çš„. é™¤äº†å¹¿æ’­å¤–, å…¶ä»–ä¸‰å¤§ç»„ä»¶ä¹Ÿéƒ½æ˜¯åœ¨åº”ç”¨å®‰è£…æ—¶ç”±PMSè§£æžå¹¶æ³¨å†Œçš„. åŠ¨æ€æ³¨å†Œçš„è¿‡ç¨‹æ˜¯ä»ŽContextWrapper#registerReceiver()å¼€å§‹çš„. å’ŒActivityæˆ–è€…Serviceä¸€æ ·. ContextWrapperå¹¶æ²¡æœ‰åšå®žé™…çš„å·¥ä½œ, è€Œæ˜¯å°†æ³¨å†Œçš„è¿‡ç¨‹ç›´æŽ¥äº¤ç»™äº†ContextImplæ¥å®Œæˆ. ContextImpl#registerReceiver()æ–¹æ³•è°ƒç”¨äº†æœ¬ç±»çš„registerReceiverInternal()æ–¹æ³•. 12345678910111213141516171819202122232425262728private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; return ActivityManagerNative.getDefault().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); &#125; catch (RemoteException e) &#123; return null; &#125;&#125; ä¸Šè¿°ä»£ç ä¸­, ç³»ç»Ÿé¦–å…ˆä»ŽmPackageInfoèŽ·å–åˆ°IIntentReceiverå¯¹è±¡, ç„¶åŽå†é‡‡ç”¨è·¨è¿›ç¨‹çš„æ–¹å¼å‘AMSå‘é€å¹¿æ’­æ³¨å†Œçš„è¯·æ±‚. ä¹‹æ‰€ä»¥é‡‡ç”¨IIntentReceiverè€Œä¸æ˜¯ç›´æŽ¥é‡‡ç”¨BroadcastReceiver, è¿™æ˜¯å› ä¸ºä¸Šè¿°æ³¨å†Œè¿‡ç¨‹ä¸­æ˜¯ä¸€ä¸ªè¿›ç¨‹é—´é€šä¿¡çš„è¿‡ç¨‹. è€ŒBroadcastReceiverä½œä¸ºAndroidä¸­çš„ä¸€ä¸ªç»„ä»¶æ˜¯ä¸èƒ½ç›´æŽ¥è·¨è¿›ç¨‹ä¼ é€’çš„. æ‰€æœ‰éœ€è¦é€šè¿‡IIntentReceiveræ¥ä¸­è½¬ä¸€ä¸‹. IIntentReceiverä½œä¸ºä¸€ä¸ªBinderæŽ¥å£, å®ƒçš„å…·ä½“å®žçŽ°æ˜¯LoadedApk.ReceiverDispatcher.InnerReceiver, ReceiverDispatcherçš„å†…éƒ¨åŒæ—¶ä¿å­˜äº†BroadcastReceiverå’ŒInnerReceiver, è¿™æ ·å½“æŽ¥æ”¶åˆ°å¹¿æ’­çš„æ—¶å€™, ReceiverDispatcherå¯ä»¥å¾ˆæ–¹ä¾¿çš„è°ƒç”¨BroadcastReceiver#onReceive()æ–¹æ³•. è¿™é‡Œå’ŒÂ·Serviceçš„åŽŸç†å¾ˆåƒ, Serviceæœ‰ä¸ªServiceDispatcherç±»ï¼Œå¹¶ä¸”å…¶å†…éƒ¨ç±»InnerConnectionåŒæ ·ä¹Ÿæ˜¯ä¸€ä¸ªBinderæŽ¥å£. çœ‹ä¸€ä¸‹LoadedApk.ReceiverDispatcher#getIIntentReceiver()çš„å®žçŽ°, å¾ˆæ˜¾ç„¶getReceiverDispatcher()é‡æ–°åˆ›å»ºäº†ä¸€ä¸ªReceiverDispatcherå¯¹è±¡å¹¶å°†å…¶ä¿å­˜çš„InnerReceiverå¯¹è±¡ä½œä¸ºè¿”å›žå€¼è¿”å›ž, å…¶ä¸­InnerReceiverå¯¹è±¡å’ŒBroadcastReceiveréƒ½æ˜¯åœ¨ReceiverDispatcherçš„æž„é€ æ–¹æ³•ä¸­è¢«ä¿å­˜èµ·æ¥çš„. 1234567891011121314151617181920212223242526272829public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) &#123; synchronized (mReceivers) &#123; LoadedApk.ReceiverDispatcher rd = null; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null; if (registered) &#123; map = mReceivers.get(context); if (map != null) &#123; rd = map.get(r); &#125; &#125; if (rd == null) &#123; rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); if (registered) &#123; if (map == null) &#123; map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mReceivers.put(context, map); &#125; map.put(r, rd); &#125; &#125; else &#123; rd.validate(context, handler); &#125; rd.mForgotten = false; return rd.getIIntentReceiver(); &#125;&#125; ç”±äºŽæ³¨å†Œå¹¿æ’­çœŸæ­£å®žçŽ°è¿‡ç¨‹æ˜¯åœ¨AMSä¸­, å› æ­¤è·Ÿè¿›AMSä¸­, é¦–å…ˆçœ‹registerReceiver()æ–¹æ³•, è¿™é‡Œåªå…³å¿ƒé‡Œé¢çš„æ ¸å¿ƒéƒ¨åˆ†. è¿™æ®µä»£ç æœ€ç»ˆä¼šæŠŠè¿œç¨‹çš„InnerReceiverå¯¹è±¡ä»¥åŠIntentFilterå¯¹è±¡å­˜å‚¨èµ·æ¥, è¿™æ ·æ•´ä¸ªå¹¿æ’­çš„æ³¨å†Œå°±å®Œæˆäº†. 123456789public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123; //... mRegisteredReceivers.put(receiver.asBinder(), rl); BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId); rl.add(bf); mReceiverResolver.addFilter(bf); &#125; å¹¿æ’­çš„å‘é€å’ŒæŽ¥æ”¶è¿‡ç¨‹å½“é€šè¿‡send()å‘é€å¹¿æ’­æ—¶, AMSä¼šæŸ¥æ‰¾å‡ºåŒ¹é…çš„å¹¿æ’­æŽ¥æ”¶è€…å¹¶å°†å¹¿æ’­å‘é€ç»™ä»–ä»¬å¤„ç†. å¹¿æ’­çš„å‘é€ç§ç±»æœ‰: æ™®é€šå¹¿æ’­, æœ‰åºå¹¿æ’­, ç²˜æ€§å¹¿æ’­. è¿™é‡Œåˆ†æžæ™®é€šå¹¿æ’­. å¹¿æ’­çš„å‘é€å’ŒæŽ¥æ”¶, æœ¬è´¨å°±æ˜¯ä¸€ä¸ªè¿‡ç¨‹çš„ä¸¤ä¸ªé˜¶æ®µ. å¹¿æ’­çš„å‘é€ä»ç„¶å¼€å§‹äºŽContextImpl#sendBroadcase()æ–¹æ³•, ä¹‹æ‰€ä»¥ä¸æ˜¯Context, é‚£æ˜¯å› ä¸ºContext#sendBroad()æ˜¯ä¸€ä¸ªæŠ½è±¡æ–¹æ³•. å’Œå¹¿æ’­çš„æ³¨å†Œè¿‡ç¨‹ä¸€æ ·, ContextWrapper#sendBroadcast()ä»ç„¶ä»€ä¹ˆéƒ½ä¸åš, åªæ˜¯æŠŠäº‹æƒ…äº¤ç»™äº†ContextImplåŽ»å¤„ç†, ContextImpl#sendBroadcast()æºç å¦‚ä¸‹ 1234567891011@Overridepublic void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); intent.prepareToLeaveProcess(); ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());&#125; çœ‹åˆ°ContextImplé‡Œé¢ä¹Ÿå‡ ä¹Žä»€ä¹ˆéƒ½æ²¡æœ‰åš, å†…éƒ¨ç›´æŽ¥å‘AMSå‘èµ·äº†ä¸€ä¸ªå¼‚æ­¥è¯·æ±‚ç”¨äºŽå‘é€å¹¿æ’­. æŽ¥ä¸‹æ¥çœ‹AMS#broadcastIntent()æ–¹æ³•. 12345678910111213141516171819202122public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller("broadcastIntent"); synchronized(this) &#123; intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, null, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; çœ‹åˆ°è¿™é‡Œ, åˆç»§ç»­è°ƒç”¨broadcastIntentLocked()æ–¹æ³•, è¿™ä¸ªæ–¹æ³•æœ‰ç‚¹é•¿. åœ¨ä»£ç å¼€å§‹å¤„ 12// By default broadcasts do not go to stopped apps.intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); è¿™ä¸ªè¡¨ç¤ºé»˜è®¤æƒ…å†µä¸‹å¹¿æ’­ä¸ä¼šå‘é€ç»™å·²ç»åœæ­¢çš„åº”ç”¨, android5.0ä¸­. è€Œandroid 3.1å¼€å§‹å°±å¢žæ·»äº†ä¸¤ä¸ªæ ‡è®°ä¸º. åˆ†åˆ«æ˜¯FLAG_INCLUDE_STOPPED_PACKAGES, FLAG_EXCLUDE_STOPPED_PACKAGES. ç”¨æ¥æŽ§åˆ¶å¹¿æ’­æ˜¯å¦è¦å¯¹å¤„äºŽåœæ­¢çš„åº”ç”¨èµ·ä½œç”¨. FLAG_INCLUDE_STOPPED_PACKAGES: åŒ…å«åœæ­¢åº”ç”¨, å¹¿æ’­ä¼šå‘é€ç»™å·²åœæ­¢çš„åº”ç”¨. FLAG_EXCLUDE_STOPPED_PACKAGES: ä¸åŒ…å«å·²åœæ­¢åº”ç”¨, å¹¿æ’­ä¸ä¼šå‘é€ç»™å·²åœæ­¢çš„åº”ç”¨ åœ¨android 3.1å¼€å§‹, ç³»ç»Ÿå°±ä¸ºæ‰€æœ‰å¹¿æ’­é»˜è®¤æ·»åŠ äº†FLAG_EXCLUDE_STOPPED_PACKAGESæ ‡è¯†, ä¸ºäº†é˜²æ­¢å¹¿æ’­æ— æ„é—´æˆ–è€…ä¸å¿…è¦çš„æ—¶å€™è°ƒèµ·å·²ç»åœæ­¢è¿è¡Œçš„åº”ç”¨. å½“è¿™ä¸¤ä¸ªæ ‡è®°å…±å­˜çš„æ—¶å€™ä»¥FLAG_INCLUDE_STOPPED_PACKAGES(éžé»˜è®¤é¡¹ä¸ºä¸»). åº”ç”¨å¤„äºŽåœæ­¢åˆ†ä¸ºä¸¤ç§ åº”ç”¨å®‰è£…åŽæœªè¿è¡Œ è¢«æ‰‹åŠ¨æˆ–è€…å…¶ä»–åº”ç”¨å¼ºåœ å¼€æœºå¹¿æ’­åŒæ ·å—åˆ°äº†è¿™ä¸ªæ ‡å¿—ä½çš„å½±å“. ä»ŽAndroid 3.1å¼€å§‹å¤„äºŽåœæ­¢çŠ¶æ€çš„åº”ç”¨åŒæ ·æ— æ³•æŽ¥å—åˆ°å¼€æœºå¹¿æ’­, è€Œåœ¨android 3.1ä¹‹å‰å¤„äºŽåœæ­¢çš„çŠ¶æ€ä¹Ÿæ˜¯å¯ä»¥æŽ¥æ”¶åˆ°çš„å¼€æœºå¹¿æ’­çš„. åœ¨broadcastIntentLocked()å†…éƒ¨, ä¼šæ ¹æ®intent-filteræŸ¥æ‰¾å‡ºåŒ¹é…çš„å¹¿æ’­æŽ¥æ”¶è€…å¹¶ç»è¿‡ä¸€ç³»åˆ—çš„æ¡ä»¶è¿‡æ»¤. æœ€ç»ˆä¼šå°†æ»¡è¶³æ¡ä»¶çš„å¹¿æ’­æŽ¥æ”¶è€…æ·»åŠ åˆ°BroadcastQueueä¸­, æŽ¥ç€BroadcastQueueå°±ä¼šå°†å¹¿æ’­å‘é€ç»™ç›¸åº”å¹¿æ’­æŽ¥æ”¶è€…. 12345678910111213141516171819if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size()); if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction()); boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125;&#125; è·Ÿè¿›BroadcastQueue#scheduleBroadcastsLocked() 1234567891011public void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Schedule broadcasts [" + mQueueName + "]: current=" + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125; æ–¹æ³•å†…å¹¶æ²¡æœ‰ç«‹å³å‘é€å¹¿æ’­, è€Œæ˜¯å‘é€äº†ä¸€ä¸ªBROADCAST_INTENT_MSGç±»åž‹çš„æ¶ˆæ¯, BroadcastQueueæ”¶åˆ°æ¶ˆæ¯åŽä¼šè°ƒç”¨processNextBroadcast()æ–¹æ³•. è¿™ä¸ªæ–¹æ³•å¯¹æ™®é€šå¹¿æ’­çš„å¤„ç†å¦‚ä¸‹: 12345678910111213141516171819// First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() &gt; 0) &#123; r = mParallelBroadcasts.remove(0);//å–å‡ºå¹¿æ’­ r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int N = r.receivers.size(); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, "Processing parallel broadcast [" + mQueueName + "] " + r); for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i);//èŽ·å–æ‰€æœ‰å¹¿æ’­æŽ¥å—è€… if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Delivering non-ordered on [" + mQueueName + "] to registered " + target + ": " + r); deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, "Done with parallel broadcast [" + mQueueName + "] " + r); &#125; æ— åºå¹¿æ’­å­˜å‚¨åœ¨mParallelBroadcastsä¸­, ç³»ç»Ÿä¼šéåŽ†è¿™ä¸ªé›†åˆå¹¶å°†å…¶ä¸­çš„å¹¿æ’­å‘é€ç»™ä»–ä»¬æ‰€æœ‰çš„æŽ¥æ”¶è€…, å…·ä½“çš„å‘é€è¿‡ç¨‹æ˜¯é€šè¿‡deliverToRegisteredReceiverLocked()æ–¹æ³•å®žçŽ°. deliverToRegisteredReceiverLocked()è´Ÿè´£å°†ä¸€ä¸ªå¹¿æ’­å‘é€ç»™ä¸€ä¸ªç‰¹å®šçš„æŽ¥æ”¶è€…, å®ƒçš„å†…éƒ¨è°ƒç”¨äº†performReceiverLockedæ–¹æ³•æ¥å®Œæˆå…·ä½“å‘é€è¿‡ç¨‹. performReceiverLocked()æ–¹æ³•å®žçŽ°å¦‚ä¸‹, ç”±äºŽæŽ¥æ”¶å¹¿æ’­ä¼šè°ƒèµ·åº”ç”¨ç¨‹åº, å› ä¸ºapp.threadä¸ä¸ºnull, æ ¹æ®å‰é¢çš„æ€»ç»“app.threadä»ç„¶æŒ‡ApplicationThread. 12345678910111213141516171819private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null) &#123; if (app.thread != null) &#123; // If we have an app thread, do the call through that so it is // correctly ordered with other one-way calls. app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); &#125; else &#123; // Application has died. Receiver doesn't exist. throw new RemoteException("app.thread must not be null"); &#125; &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; &#125; è€Œè°ƒç”¨çš„ApplicationThread#scheduleRegisteredReceiver()å®žçŽ°æ¯”è¾ƒç®€å•, å®ƒé€šè¿‡InnerReceiveræ¥å®žçŽ°å¹¿æ’­çš„æŽ¥æ”¶ 1234567public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser);&#125; ä¸Šé¢çš„receiver.performReceive()ä¸­çš„receiverå¯¹åº”ç€IIntentReceiverç±»åž‹çš„æŽ¥å£. è€Œå…·ä½“çš„å®žçŽ°å°±æ˜¯ReceiverDispatcher$InnerReceiverï¼Œçœ‹ä¸€ä¸‹ä»–çš„performReceiver()æ–¹æ³•ï¼š 1234567891011121314151617181920212223242526272829public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; LoadedApk.ReceiverDispatcher rd = mDispatcher.get(); if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra("seq", -1); Slog.i(ActivityThread.TAG, "Receiving broadcast " + intent.getAction() + " seq=" + seq + " to " + (rd != null ? rd.mReceiver : null)); &#125; if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; else &#123; // The activity manager dispatched a broadcast to a registered // receiver in this process, but before it could be delivered the // receiver was unregistered. Acknowledge the broadcast on its // behalf so that the system's broadcast sequence can continue. if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, "Finishing broadcast to unregistered receiver"); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags()); &#125; catch (RemoteException e) &#123; Slog.w(ActivityThread.TAG, "Couldn't finish broadcast to unregistered receiver"); &#125; &#125;&#125; ä¸Šé¢åˆè°ƒç”¨äº†LoadedApk$ReceiverDispatcher#performReceive()çš„æ–¹æ³•. 123456789101112131415161718public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra("seq", -1); Slog.i(ActivityThread.TAG, "Enqueueing broadcast " + intent.getAction() + " seq=" + seq + " to " + mReceiver); &#125; Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); if (!mActivityThread.post(args)) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, "Finishing sync broadcast to " + mReceiver); args.sendFinished(mgr); &#125; &#125; &#125; åœ¨performReceiver()è¿™ä¸ªæ–¹æ³•ä¸­, ä¼šåˆ›å»ºä¸€ä¸ªArgså¯¹è±¡å¹¶é€šè¿‡mActivityThreadçš„postæ–¹æ³•æ‰§è¡Œargsä¸­çš„é€»è¾‘. è€Œè¿™äº›ç±»çš„æœ¬è´¨å…³ç³»å°±æ˜¯: Args: å®žçŽ°äº†RunnableæŽ¥å£ mActivityThread: æ˜¯ä¸€ä¸ªHandler, å°±æ˜¯ActivityThreadä¸­çš„mH. mHå°±æ˜¯ActivityThread$H. è¿™ä¸ªå†…éƒ¨ç±»Hä»¥å‰è¯´è¿‡. è€ŒArgsä¸­æœ‰çš„run()æ–¹æ³•æœ‰å¦‚ä¸‹ä»£ç : 12345ClassLoader cl = mReceiver.getClass().getClassLoader();intent.setExtrasClassLoader(cl);setExtrasClassLoader(cl);receiver.setPendingResult(this);receiver.onReceive(mContext, intent); è¿™ä¸ªæ—¶å€™BroadcastReceiver#onReceive()æ–¹æ³•è¢«æ‰§è¡Œäº†, ä¹Ÿå°±æ˜¯è¯´åº”ç”¨å·²ç»æŽ¥æ”¶åˆ°äº†å¹¿æ’­, åŒæ—¶onReceive()æ–¹æ³•æ˜¯åœ¨å¹¿æ’­æŽ¥æ”¶è€…çš„ä¸»çº¿ç¨‹ä¸­è¢«è°ƒç”¨çš„. ContentProviderçš„å·¥ä½œæœºåˆ¶ContentProvideræ˜¯ä¸€ç§å†…å®¹å…±äº«åž‹ç»„ä»¶, å®ƒé€šè¿‡Binderå‘å…¶ä»–ç»„ä»¶ä¹ƒè‡³å…¶ä»–åº”ç”¨æä¾›æ•°æ®. å½“ContentProvideræ‰€åœ¨çš„è¿›ç¨‹å¯åŠ¨æ—¶, ContentProviderä¼šåŒæ—¶å¯åŠ¨å¹¶å‘å¸ƒåˆ°AMSä¸­. è¦æ³¨æ„:è¿™ä¸ªæ—¶å€™ContentProviderçš„onCreate()æ–¹æ³•æ˜¯å…ˆäºŽApplicationçš„onCreate()æ‰§è¡Œçš„è¿™ä¸€ç‚¹åœ¨å››å¤§ç»„ä»¶æ˜¯å°‘æœ‰çš„çŽ°è±¡. å½“ä¸€ä¸ªåº”ç”¨å¯åŠ¨çš„æ—¶å€™, å…¥å£çš„æ–¹æ³•ä¸ºActivityThread#main()æ–¹æ³•, mainæ–¹æ³•ä¸ºä¸€ä¸ªé™æ€æ–¹æ³•, åœ¨mainæ–¹æ³•ä¸­ä¼šåˆ›å»ºActivityThreadçš„å®žä¾‹, å¹¶åˆ›å»ºä¸»çº¿ç¨‹çš„æ¶ˆæ¯é˜Ÿåˆ—, ç„¶åŽåœ¨ActivityThread#attach()æ–¹æ³•ä¸­ä¼šè¿œç¨‹è°ƒç”¨AMS#attachApplication()å¹¶å°†ApplicationThreadå¯¹è±¡æä¾›ç»™AMS. ApplicationThreadæ˜¯ä¸€ä¸ªBinderå¯¹è±¡, å®ƒçš„BinderæŽ¥å£æ˜¯IApplicationThread, ä¸»è¦ç”¨äºŽActivityThreadå’ŒAMSä¹‹é—´çš„é€šä¿¡, è¿™ä¸€ç‚¹åœ¨å‰é¢å¤šæ¬¡æåˆ°. åœ¨AMSçš„attachApplication()ä¸­, ä¼šè°ƒç”¨ApplicationThread#bindApplication(). è¿™ä¸ªè¿‡ç¨‹åŒæ ·æ˜¯è·¨è¿›ç¨‹çš„. bindApplication()ä¸­ä¼šç»è¿‡ ActivityThreadä¸­çš„mh(Handler) åˆ‡æ¢åˆ°ActivityThreadä¸­åŽ»æ‰§è¡Œ, å…·ä½“çš„æ–¹å¼æ˜¯handleBindApplication(). åœ¨handleBindApplication()æ–¹æ³•ä¸­, ActivityThreadä¼šåˆ›å»ºApplicationå¯¹è±¡å¹¶åŠ è½½ContentProvider. éœ€è¦æ³¨æ„çš„æ˜¯, ActivityThreadä¼šå…ˆåŠ è½½ContentProvider, ç„¶åŽåœ¨è°ƒç”¨Application#onCreate()æ–¹æ³• ä»¥ä¸Šå°±æ˜¯ContentProviderçš„å¯åŠ¨è¿‡ç¨‹, ContentProviderå¯åŠ¨åŽ, å¤–ç•Œå°±å¯ä»¥é€šè¿‡å®ƒæ‰€æä¾›çš„å¢žåˆ æ”¹æŸ¥è¿™å››ä¸ªæŽ¥å£æ¥æ“ä½œContentProviderä¸­çš„æ•°æ®æº, è¿™å››ä¸ªæ–¹æ³•éƒ½æ˜¯é€šè¿‡Binderæ¥è°ƒç”¨çš„, å¤–ç•Œæ— æ³•ç›´æŽ¥è®¿é—®ContentProvider, å®ƒåªèƒ½é€šè¿‡AMSæ ¹æ®URIæ¥èŽ·å–åˆ°å¯¹åº”çš„ContentProviderçš„BinderæŽ¥å£IContentProvider, ç„¶åŽå†é€šè¿‡IContentProvideræ¥è®¿é—®ContentProviderä¸­çš„æ•°æ®æº. ContentProvideræ˜¯å¦å±žäºŽå•å®žä¾‹? å…·ä½“ContentProvideræ˜¯å¦æ˜¯å•å®žä¾‹å–å†³äºŽandroid:multiprocesså±žæ€§æ¥å†³å®šçš„, å½“å…¶å€¼ä¸ºfalseçš„æ—¶å€™, å°±æ˜¯å•å®žä¾‹ä¹Ÿæ˜¯é»˜è®¤å€¼. å¦‚æžœä¸ºtrueé‚£å°±ä¸ºå¤šå®žä¾‹. è¿™ä¸ªæ—¶å€™åœ¨æ¯ä¸€ä¸ªè°ƒç”¨è€…çš„è¿›ç¨‹ä¸­éƒ½ä¼šå­˜åœ¨ä¸€ä¸ªContentProviderå¯¹è±¡. é€šè¿‡å•å®žä¾‹çš„ContentProvideræ¥åˆ†æžä¸€ä¸‹å¯åŠ¨è¿‡ç¨‹ é¦–å…ˆè®¿é—®ContentProvideréœ€è¦é€šè¿‡ContentResolver, ContentResolveræ˜¯ä¸€ä¸ªæŠ½è±¡ç±», é€šè¿‡Content#getContentResolver()æ–¹æ³•èŽ·å–çš„å®žé™…ä¸Šæ˜¯ApplicationContentResolverå¯¹è±¡, è€Œè¿™ä¸ªç±»ç»§æ‰¿äº†ContentProviderå¹¶å®žçŽ°äº†å…¶æŠ½è±¡æ–¹æ³•. å½“ContentProvideræ‰€åœ¨çš„è¿›ç¨‹æœªå¯åŠ¨æ—¶, ç¬¬ä¸€æ¬¡è®¿é—®å®ƒçš„æ—¶å€™å°±ä¼šè§¦å‘ContentProviderçš„åˆ›å»º, å½“ç„¶è¿™ä¹Ÿä¼´éšç€ContentProvideræ‰€åœ¨çš„è¿›ç¨‹çš„å¯åŠ¨. é€šè¿‡å››ä¸ªå¯¹æ•°æ®çš„æ“ä½œæ–¹æ³•ä¸­çš„ä»»ä½•ä¸€ä¸ª, éƒ½å¯ä»¥è§¦å‘ContentProviderçš„å¯åŠ¨è¿‡ç¨‹. å››ç§æ“ä½œè¿‡ç¨‹å·®ä¸å¤š, é‚£ä¹ˆè¿™é‡Œä»¥queryæ–¹æ³•ä¸ºä¾‹ é¦–å…ˆä¼šèŽ·å–IContentProviderå¯¹è±¡, ä¸ç®¡æ˜¯é€šè¿‡acquireUnstableProvider()æ–¹æ³•è¿˜æ˜¯ç›´æŽ¥é€šè¿‡acquireProvider()æ–¹æ³•, ä»–ä»¬çš„æœ¬è´¨éƒ½æ˜¯ä¸€æ ·çš„, æœ€ç»ˆéƒ½æ˜¯é€šè¿‡acquireProvideræ–¹æ³•æ¥èŽ·å–ContentProvider. ApplicationContentResolver#acquireProvider()æ–¹æ³•å¹¶æ²¡æœ‰å¤„ç†ä»»ä½•é€»è¾‘, å®ƒç›´æŽ¥è°ƒç”¨äº†ActivityThread#acquireProvider(), è¿™ä¸ªæ–¹æ³•å¦‚ä¸‹: 123456789101112131415161718192021222324public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; IActivityManager.ContentProviderHolder holder = null; try &#123; holder = ActivityManagerNative.getDefault().getContentProvider( getApplicationThread(), auth, userId, stable); &#125; catch (RemoteException ex) &#123; &#125; if (holder == null) &#123; Slog.e(TAG, "Failed to find provider info for " + auth); return null; &#125; // Install provider will increment the reference count for us, and break // any ties in the race. holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider;&#125; è¿™æ®µä»£ç ä¸»è¦ä»ŽActivityThreadä¸­æŸ¥æ‰¾æ˜¯å¦å·²ç»å­˜åœ¨äº†ContentProvideräº†, å¦‚æžœå­˜åœ¨é‚£ä¹ˆå°±ç›´æŽ¥è¿”å›ž. ActivityThreadä¸­é€šè¿‡mProviderMapæ¥å­˜å‚¨å·²ç»å¯åŠ¨çš„ContentProviderå¯¹è±¡, è¿™ä¸ªé›†åˆçš„å­˜å‚¨ç±»åž‹ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap. å¦‚æžœç›®å‰ContentProvideræ²¡æœ‰å¯åŠ¨, é‚£ä¹ˆå°±å‘é€ä¸€ä¸ªè¿›ç¨‹é—´è¯·æ±‚ç»™AMSè®©å…¶å¯åŠ¨é¡¹ç›®ç›®æ ‡ContentProvider, æœ€åŽå†é€šè¿‡installProvider()æ–¹æ³•æ¥ä¿®æ”¹å¼•ç”¨è®¡æ•°. é‚£ä¹ˆAMSæ˜¯å¦‚ä½•å¯åŠ¨ContentProviderçš„å‘¢? å…³äºŽContentProviderè¢«å¯åŠ¨çš„æ—¶å€™ä¼šä¼´éšç€è¿›ç¨‹çš„å¯åŠ¨, åœ¨AMSä¸­, é¦–å…ˆä¼šå¯åŠ¨ContentProvideræ‰€åœ¨çš„è¿›ç¨‹, ç„¶åŽå†å¯åŠ¨ContentProvider. å¯åŠ¨è¿›ç¨‹æ˜¯ç”±AMS#startProcessLocked()æ–¹æ³•æ¥å®Œæˆ, å…¶å†…éƒ¨ä¸»è¦æ˜¯é€šè¿‡Process#start()æ–¹æ³•æ¥å®Œæˆä¸€ä¸ªæ–°è¿›ç¨‹çš„å¯åŠ¨, æ–°è¿›ç¨‹å¯åŠ¨åŽå…¶å…¥å£æ–¹æ³•ä¸ºActivityThread#main()æ–¹æ³•. å¦‚ä¸‹: 123456789101112131415161718192021222324252627282930313233343536373839404142 public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; ActivityThread#main()æ˜¯ä¸€ä¸ªé™æ€æ–¹æ³•, åœ¨å®ƒçš„å†…éƒ¨é¦–å…ˆä¼šåˆ›å»ºActivityThreadå®žä¾‹å¹¶è°ƒç”¨attach()æ–¹æ³•æ¥è¿›è¡Œä¸€ç³»åˆ—åˆå§‹åŒ–, æŽ¥ç€å°±å¼€å§‹è¿›è¡Œæ¶ˆæ¯å¾ªçŽ¯. ActivityThread#attach()æ–¹æ³•ä¼šå°†ApplicationThreadå¯¹è±¡é€šè¿‡AMS#attachApplicationæ–¹æ³•è·¨è¿›ç¨‹ä¼ é€’ç»™AMS, æœ€ç»ˆAMSä¼šå®ŒæˆContentProviderçš„åˆ›å»ºè¿‡ç¨‹. ActivityThread#attach()éƒ¨åˆ†ä»£ç : 12345try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; AMS#attachApplication()æ–¹æ³•è°ƒç”¨äº†attachApplication(), ç„¶åŽåˆè°ƒç”¨äº†ApplicationThread#bindApplication(), è¿™ä¸ªè¿‡ç¨‹ä¹Ÿå±žäºŽè¿›ç¨‹é€šä¿¡. è€Œä¸Šé¢çš„bindApplication()æ–¹æ³•ä¼šå‘é€ä¸€ä¸ªBIND_APPLICATIONç±»åž‹çš„æ¶ˆæ¯ç»™mH, è¿™æ˜¯ä¸€ä¸ªHandler, å®ƒæ”¶åˆ°æ¶ˆæ¯åŽä¼šè°ƒç”¨ActivityThread#handleBindApplication()æ–¹æ³•. bindApplication()å‘é€æºç å¦‚ä¸‹: 12345678910111213141516AppBindData data = new AppBindData();data.processName = processName;data.appInfo = appInfo;data.providers = providers;data.instrumentationName = instrumentationName;data.instrumentationArgs = instrumentationArgs;data.instrumentationWatcher = instrumentationWatcher;data.instrumentationUiAutomationConnection = instrumentationUiConnection;data.debugMode = debugMode;data.enableOpenGlTrace = enableOpenGlTrace;data.restrictedBackupMode = isRestrictedBackupMode;data.persistent = persistent;data.config = config;data.compatInfo = compatInfo;data.initProfilerInfo = profilerInfo;sendMessage(H.BIND_APPLICATION, data); ActivityThread#handlerBindApplication()åˆ™å®Œæˆäº†Applicationä»¥åŠContentProvider çš„åˆ›å»ºï¼Œå¯ä»¥åˆ†ä¸ºå¦‚ä¸‹å››ä¸ªæ­¥éª¤: åˆ›å»ºContentProviderå’ŒInstrumentation åˆ›å»ºApplicationå¯¹è±¡ å¯åŠ¨å½“å‰è¿›ç¨‹çš„ContentProviderå¹¶è°ƒç”¨onCreate()æ–¹æ³•. ä¸»è¦å†…éƒ¨å®žçŽ°æ˜¯installContentProvider()å®Œæˆäº†ContentProviderçš„å¯åŠ¨å·¥ä½œ, é¦–å…ˆä¼šéåŽ†å½“å‰è¿›ç¨‹çš„ProviderInfoçš„åˆ—è¡¨å¹¶ä¸€ä¸€è°ƒç”¨installProvider()æ–¹æ³•æ¥å¯åŠ¨ä»–ä»¬, æŽ¥ç€å°†å·²ç»å¯åŠ¨çš„ContentProviderå‘å¸ƒåˆ°AMSä¸­, AMSä¼šæŠŠä»–ä»¬å­˜å‚¨åœ¨ProviderMapä¸­, è¿™æ ·ä¸€æ¥å¤–éƒ¨è°ƒç”¨è€…å°±å¯ä»¥ç›´æŽ¥ä»ŽAMSä¸­èŽ·å–åˆ°ContentProvider. installProvider()å†…éƒ¨é€šè¿‡ç±»åŠ è½½å™¨åˆ›å»ºçš„ContentProviderå®žä¾‹å¹¶åœ¨æ–¹æ³•ä¸­è°ƒç”¨äº†attachInfo(), åœ¨è¿™å†…éƒ¨è°ƒç”¨äº†ContentProvider#onCreate() è°ƒç”¨Application#onCreate() ç»è¿‡äº†ä¸Šè¿°çš„å››ä¸ªæ­¥éª¤, ContentProviderå·²ç»å¯åŠ¨æˆåŠŸ, å¹¶ä¸”å…¶æ‰€åœ¨çš„è¿›ç¨‹çš„Applicationä¹Ÿå·²ç»æˆåŠŸ, è¿™æ„å‘³ç€ContentProvideræ‰€åœ¨çš„è¿›ç¨‹å·²ç»å®Œæˆäº†æ•´ä¸ªçš„å¯åŠ¨è¿‡ç¨‹, ç„¶åŽå…¶ä»–åº”ç”¨å°±å¯ä»¥é€šè¿‡AMSæ¥è®¿é—®è¿™ä¸ªContentProvideräº†. å½“æ‹¿åˆ°äº†ContentProviderä»¥åŽ, å°±å¯ä»¥é€šè¿‡å®ƒæ‰€æä¾›çš„æŽ¥å£æ–¹æ³•æ¥è®¿é—®å®ƒ. è¿™é‡Œè¦æ³¨æ„: è¿™é‡Œçš„ContentProviderå¹¶ä¸æ˜¯åŽŸå§‹çš„ContentProvider. è€Œæ˜¯ContentProviderçš„Binderç±»åž‹å¯¹è±¡IContentProvider, è€ŒIContentProviderçš„å…·ä½“å®žçŽ°æ˜¯ContentProviderNativeå’ŒContentProvider.Transport. åŽè€…ç»§æ‰¿äº†å‰è€…. å¦‚æžœè¿˜ç”¨queryæ–¹æ³•æ¥è§£é‡Šæµç¨‹: é‚£ä¹ˆæœ€å¼€å§‹å…¶ä»–åº”ç”¨é€šè¿‡AMSèŽ·å–åˆ°ContentProviderçš„Binderå¯¹è±¡å°±æ˜¯IContentProvider. è€ŒIContentProviderçš„å®žé™…å®žçŽ°è€…æ˜¯ContentProvider.Transport. å› æ­¤å®žé™…ä¸Šå¤–éƒ¨åº”ç”¨è°ƒç”¨çš„æ—¶å€™æœ¬è´¨ä¸Šä¼šä»¥è¿›ç¨‹é—´é€šä¿¡çš„æ–¹å¼è°ƒç”¨ContentProvider.Transportçš„query()æ–¹æ³•,ç„¶åŽä»–çš„å†…éƒ¨åˆè°ƒç”¨äº†ContentProviderçš„queryæ–¹æ³•ï¼Œqueryæ–¹æ³•çš„æ‰§è¡Œç»“æžœå†é€šè¿‡Binderè¿”å›žç»™è°ƒç”¨è€…ã€‚]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>å››å¤§ç»„ä»¶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava æºç åˆ†æž]]></title>
    <url>%2F2018%2F03%2F08%2FRxJava%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[åŸºäºŽ RxJava 2.1.2 ç»™å®šä¸‹é¢çš„ä¸€æ®µä»£ç ï¼Œä»Žæºç çš„è§’åº¦åˆ†æž RxJava çš„å®žçŽ°åŽŸç†ï¼š 12345678910111213141516171819202122232425262728293031323334353637ObservableOnSubscribe&lt;Integer&gt; oos = new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(max); &#125; e.onComplete(); &#125;&#125;;Observer&lt;Integer&gt; o = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;;Observable.create(oos) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.computation()) .subscribe(o); åˆ†æžæºç ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆå®šä¹‰ä¸€ä¸‹åè¯ï¼ŒRxJava æ˜¯åŸºäºŽè§‚å¯Ÿè€…æ¨¡å¼çš„ï¼Œè¿™é‡Œå°†è¢«è§‚å¯Ÿè€…å«åšä¸»é¢˜ï¼ˆSourceï¼‰ï¼Œè§‚å¯Ÿè€…å«åšè§‚å¯Ÿè€…ï¼ˆObserverï¼‰ã€‚ ä¸Šé¢çš„ä»£ç é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ªä¸»é¢˜å¯¹è±¡ï¼Œç„¶åŽåˆåˆ›å»ºäº†ä¸€ä¸ªè§‚å¯Ÿè€…å¯¹è±¡ï¼Œæœ€åŽå°†ä¸¤è€…å…³è”èµ·æ¥ï¼Œå¹¶ä¸”æœ€é‡è¦çš„ä¸€ç‚¹ï¼ŒæŒ‡å®šäº†ä¸»é¢˜å¯¹è±¡å’Œè§‚å¯Ÿè€…å¯¹è±¡æ‰§è¡Œçš„çº¿ç¨‹ã€‚ Observable.create(oos)é¦–å…ˆåˆ†æžè¿™è¡Œä»£ç åšäº†ä»€ä¹ˆäº‹æƒ…ï¼š 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ObjectHelper åªæ˜¯ç”¨æ¥åšéžç©ºåˆ¤æ–­ï¼Œè¿™é‡Œå°±ä¸ç”¨ç®¡å®ƒäº†ã€‚çœ‹çœ‹ RxJavaPlugins åšäº†ä»€ä¹ˆï¼š 123456789101112131415/** * Calls the associated hook function. * @param &lt;T&gt; the value type * @param source the hook's input value * @return the value returned by the hook */@SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;)@NonNullpublic static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; æ³¨é‡Šä¸Šéƒ½è¯´äº†ï¼Œè¿™æ˜¯ä¸€ä¸ªé’©å­å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´å¦‚æžœ onObservableAssembly çš„å€¼ä¸ä¸ºç©ºï¼Œé‚£ä¹ˆå°±è°ƒç”¨è¿™ä¸ªé’©å­å‡½æ•°ï¼ŒonObservableAssembly æ˜¯ä¸€ä¸ªé™æ€å˜é‡ï¼Œéœ€è¦æˆ‘ä»¬ä¸»åŠ¨çš„åŽ»è®¾ç½®æ‰ä¼šèµ‹å€¼ï¼Œè¿™é‡Œå½“åšç©ºæ¥è€ƒè™‘ï¼Œå¦‚æžœ onObservableAssembly ä¸ºç©ºçš„è¯ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªæ–¹æ³•å•¥éƒ½æ²¡åšï¼Œç›´æŽ¥è¿”å›ž source å‚æ•°ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„ ObservableCreate å¯¹è±¡ã€‚ æ€»ç»“ä¸€ä¸‹ï¼ŒObservable.create(oos) åªæ˜¯åˆ›å»ºäº†ä¸€ä¸ª ObservableCreate å¯¹è±¡ã€‚è¿™ä¸ªæ–¹æ³•å°±æš‚æ—¶å…ˆåˆ†æžåˆ°è¿™é‡Œï¼Œè‡³äºŽè¿™ä¸ªå¯¹è±¡å†…éƒ¨æœ‰ä»€ä¹ˆä¸œè¥¿ï¼Œæˆ‘ä»¬åŽé¢ä¼šè¯´åˆ°ã€‚ observeOn(AndroidSchedulers.mainThread())æ—¢ç„¶ä¹‹å‰çš„ create æ–¹æ³•åˆ›å»ºäº†ä¸€ä¸ª ObservableCreate å¯¹è±¡å¹¶è¿”å›žï¼Œä¹Ÿå°±æ˜¯è¯´ observeOn(Schedulers.computation()) è¿™ä¸ªæ–¹æ³•æ˜¯è°ƒç”¨çš„ ObservableCreate è¿™ä¸ªå¯¹è±¡ä¸Šçš„æ–¹æ³•ã€‚ 1public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; ObservableCreate æ˜¯ç»§æ‰¿è‡³ Observable çš„ã€‚ 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; Observable çš„ observeOn æ˜¯ final çš„ï¼Œæ‰€ä»¥èµ°çš„çˆ¶ç±»çš„æ–¹æ³•ã€‚ç»§ç»­è·Ÿè¸ª observeOn è°ƒç”¨çš„åŒåæ–¹æ³•ï¼š 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; ObjectHelper è·³è¿‡ã€‚è¿™é‡Œåˆæ˜¯ä¸€ä¸ª onAssembly æ–¹æ³•çš„è°ƒç”¨ï¼Œæˆ‘å¾ˆå¥½å¥‡è¿™ä¸ªå•è¯æ˜¯ä»€ä¹ˆæ„æ€ã€‚ç‚¹è¿›åŽ»çœ‹ä¸€ä¸‹ï¼š 1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; åŒæ ·æ˜¯ä¸€ä¸ªé’©å­æ–¹æ³•ï¼ŒçŽ°åœ¨ä¹Ÿæ˜¯æœ‰ç»éªŒçš„äººå‘¢ï¼Œå†çœ‹åˆ°è¿™ä¸ªæ–¹æ³•ï¼Œå°±ç›´æŽ¥è·³è¿‡ï¼Œåªå…³å¿ƒå®ƒä¼ é€’çš„å‚æ•°å’Œè¿”å›žå€¼å°±è¡Œäº†ã€‚å®ƒçš„è¿”å›žå€¼é»˜è®¤å°±æ˜¯ä¼ é€’è¿›æ¥çš„å‚æ•°ã€‚ æ‰€ä»¥ï¼ŒobserveOn æ–¹æ³•å°±æ˜¯åˆ›å»ºå¹¶è¿”å›žäº†ä¸€ä¸ª ObservableObserveOn å¯¹è±¡ï¼ˆå¤§ç¥žæ•™ä½ èµ·ç±»åç³»åˆ—äºŒï¼‰ï¼Œè¿™é‡Œé¢„è­¦ä¸€ä¸‹ï¼Œä¹‹åŽåƒè¿™æ ·ç±»ä¼¼çš„ç±»åå·®ä¸å¤šè¿˜æœ‰3ä¸ªã€‚ subscribeOn(Schedulers.computation())ç”±äºŽ observeOn åˆ›å»ºå¹¶è¿”å›žäº†ä¸€ä¸ª ObservableObserveOn å¯¹è±¡ï¼Œæ‰€ä»¥è¿™é‡Œè°ƒç”¨çš„æ˜¯ ObservableObserveOn å¯¹è±¡ä¸Šçš„æ–¹æ³•ã€‚ 1public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; ä¹Ÿæ˜¯ç»§æ‰¿è‡³ Observable ã€‚ 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; ä¸å‡ºæ„æ–™ï¼Œä¹Ÿæ˜¯ final çš„ï¼Œåˆ›å»ºäº†ä¸€ä¸ª ObservableSubscribeOn å¯¹è±¡ï¼ˆå¤§ç¥žæ•™ä½ èµ·ç±»åç³»åˆ—ä¸‰ï¼‰å¹¶è¿”å›žã€‚ subscribe(o)å‰é¢ subscribeOn åˆ›å»ºäº†ä¸€ä¸ª ObservableSubscribeOn å¯¹è±¡å¹¶è¿”å›žï¼Œæ‰€ä»¥è¿™é‡Œè°ƒç”¨çš„æ˜¯ ObservableSubscribeOn è¿™ä¸ªå¯¹è±¡ä¸Šé¢çš„æ–¹æ³•ã€‚ 1public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; ç»§æ‰¿è‡³ Observable ç±»ã€‚ 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; è¿™ä¸ªæ–¹æ³•ä¹Ÿæ˜¯ final çš„ï¼Œæ‰€ä»¥æ˜¯è°ƒç”¨çš„è¿™ä¸ªæ–¹æ³•ã€‚ public final void subscribe(Observer&lt;? super T&gt; observer) { â€¦ } è¿™ä¸ªæ–¹æ³•æ˜¯æˆ‘ä»¬éœ€è¦åˆ†æžçš„é‡ç‚¹ï¼Œçœ‹çœ‹å†…éƒ¨å…·ä½“çš„ä»£ç å§å…ˆï¼š 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; è¿™é‡Œå¿½ç•¥ ObjectHelper å’Œå¼‚å¸¸å¤„ç†çš„ä»£ç åªæœ‰ä¸¤è¡Œä»£ç æ˜¯å…³é”®ã€‚ å…ˆçœ‹ observer = RxJavaPlugins.onSubscribe(this, observer); 1234567public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) &#123; BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe; if (f != null) &#123; return apply(f, source, observer); &#125; return observer;&#125; æ²¡æƒ³åˆ°å•Šæ²¡æƒ³åˆ°ï¼Œä½ è¿™æµ“çœ‰å¤§çœ¼çš„å®¶ä¼™ä¹Ÿæ˜¯ä¸€ä¸ªé’©å­æ–¹æ³•ã€‚æ‰€ä»¥è¿™è¡Œä»£ç ç›¸å½“äºŽ obsever = observer; æŽ¥ç€çœ‹ï¼ŒsubscribeActual(observer); 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); è¿™æ˜¯ä¸€ä¸ªæŠ½è±¡æ–¹æ³•ï¼Œæ²¡å•¥å¥½åˆ†æžçš„ã€‚ æŽ¥ä¸‹æ¥æˆ‘ä»¬è¦è¿›å…¥æ­£é¢˜äº†ï¼Œæ ¹æ®æˆ‘ä»¬ç¼–å†™çš„ä»£ç ï¼Œæ˜¯ ObservableSubscribeOn è¿™ä¸ªå¯¹è±¡è°ƒç”¨äº† subscribe æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªç±»çš„ subscribeActual æ–¹æ³•ã€‚ 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ s è¿™ä¸ªå‚æ•°ï¼ŒåŽé¢ä¼šæœ‰å¾ˆå¤šåœ°æ–¹çœ‹åˆ°è¿™ä¸ªå‚æ•°ï¼Œä¸€å®šè¦æžæ¸…æ¥šè¿™ä¸ªå‚æ•°æ˜¯è°ä¼ é€’è¿‡æ¥çš„ã€‚æ¯”å¦‚è¯´ï¼š 12A.subscribe(B)é‚£ä¹ˆï¼Œå‚æ•° s å°±æ˜¯ Bã€‚ åœ¨æˆ‘ä»¬çš„ä»£ç ä¸­æ˜¯ ObservableSubscribeOn.subscribe(o); ç†è§£äº†è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬è¯¦ç»†åˆ†æžä»£ç é‡Œé¢çš„å†…å®¹ï¼šé¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ª SubscribeOnObserver ï¼ˆå¤§ç¥žæ•™ä½ èµ·ç±»åç³»åˆ—å››ï¼‰ã€‚ç„¶åŽè°ƒç”¨äº†æˆ‘ä»¬åˆ›å»ºçš„å¯¹è±¡ o çš„ onSubscribe æ–¹æ³•ï¼š 1234@Overridepublic void onSubscribe(Disposable d) &#123;&#125; æˆ‘ä»¬çš„ onSubscribe æ–¹æ³•é‡Œé¢å•¥éƒ½æ²¡åšã€‚ä¸è¿‡ä¸€èˆ¬æ¥è¯´ï¼Œä½ åº”è¯¥è°ƒç”¨ä¸€ä¸‹ onStart æ–¹æ³•ã€‚ æŽ¥ä¸‹æ¥æ˜¯è°ƒç”¨ parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); setDisposable çš„æ–¹æ³•ä¸å½±å“æµç¨‹åˆ†æžï¼Œè¿™é‡Œå°±å…ˆè·³è¿‡äº†ï¼Œæœ‰å…´è¶£çš„å¯ä»¥ç‚¹è¿›åŽ»çœ‹ä¸€ä¸‹ã€‚ç„¶åŽå°±æ˜¯ scheduler å˜é‡ï¼Œè¿™ä¸ªå˜é‡å°±æ˜¯æˆ‘ä»¬ä½¿ç”¨ subscribeOn ä¼ é€’çš„å‚æ•°ï¼š 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; è¿™ä¸ª scheduler å°±æ˜¯ Schedulers.computation()ã€‚ç„¶åŽè°ƒç”¨äº†å®ƒçš„ scheduleDirect æ–¹æ³•ï¼š 123public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125; 1234567891011public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); w.schedule(task, delay, unit); return task;&#125; è¿™ä¸¤ä¸ªæ–¹æ³•æ˜¯çˆ¶ç±»çš„ï¼ŒSchedulers.computation() è¿”å›žçš„æ˜¯ä¸€ä¸ª ComputationScheduler å¯¹è±¡ï¼Œè¿™é‡Œæ‰¾å…·ä½“çš„å®žçŽ°ç±»ç”±äºŽè°ƒç”¨é“¾æ¯”è¾ƒé•¿ï¼Œå°±ä¸ç»™å‡ºäº†ï¼Œè‡ªå·±ç‚¹ç€ç‚¹ç€å°±èƒ½æ‰¾åˆ°äº†ã€‚çœ‹çœ‹ ComputationScheduler æœ‰æ²¡æœ‰å¤å†™è¿™ä¸¤ä¸ªæ–¹æ³•ï¼š 123456@NonNull@Overridepublic Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) &#123; PoolWorker w = pool.get().getEventLoop(); return w.scheduleDirect(run, delay, unit);&#125; å®ƒè¦†ç›–äº†çˆ¶ç±»çš„ç¬¬2ä¸ª scheduleDirect æ–¹æ³•ã€‚è¿™é‡Œå°±ä¸æ·±å…¥åˆ†æžé‡Œé¢çš„æ± äº†ã€‚çœ‹ w.scheduleDirect(run, delay, unit);ï¼š 12345678910111213141516public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; ç†Ÿæ‚‰çš„çº¿ç¨‹æ± ä½¿ç”¨ä»£ç ã€‚å¸Œæœ›çœ‹åˆ°è¿™é‡Œä½ è¿˜æ²¡æœ‰å¿˜è®°æˆ‘ä»¬è¦åˆ†æžçš„æ˜¯ä»€ä¹ˆã€‚ç®€å•çš„å½’çº³ä¸€ä¸‹ï¼Œå…¶å®žå°±æ˜¯å‘æˆ‘ä»¬åˆ›å»ºçš„ scheduler é‡Œé¢æäº¤äº†ä¸€ä¸ª runnableã€‚æœ€ç»ˆè¿™ä¸ª Runnable è‚¯å®šä¼šæ‰§è¡Œï¼Œé‚£ä¹ˆçœ‹çœ‹è¿™ä¸ª Runnable é‡Œé¢æœ‰ä»€ä¹ˆä»£ç ï¼š 1parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); 123456789101112final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; run æ–¹æ³•é‡Œé¢å°±åªæœ‰ä¸€å¥ä»£ç ï¼Œä½†æ˜¯æˆ‘ä»¬éœ€è¦æžæ¸…æ¥šè¿™é‡Œçš„ source å’Œ parent åˆ†åˆ«æ˜¯å“ªä¸ªå¯¹è±¡ã€‚ parent å¯ä»¥ç›´æŽ¥çœ‹åˆ°æ˜¯ SubscribeOnObserver å¯¹è±¡ã€‚ source æ˜¯ä½¿ç”¨çš„å¤–éƒ¨ç±»çš„å˜é‡ã€‚ 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; è¿™é‡Œè°ƒç”¨äº† super æ–¹æ³•ï¼Œæ‰€ä»¥æž„é€ å‡½æ•°é‡Œä¼ é€’çš„å˜é‡å°±æ˜¯ sourceã€‚ 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; è¿™é‡Œæ˜¯æˆ‘ä»¬ä¹‹å‰åˆ†æžè¿‡çš„åˆ›å»º ObservableSubscribeOn çš„ä»£ç ï¼Œè¿™é‡Œçš„ this æŒ‡çš„æ˜¯ observeOn åˆ›å»ºçš„ ObservableObserveOn å¯¹è±¡ã€‚å¸Œæœ›çœ‹åˆ°è¿™é‡Œä½ æ²¡æœ‰æžæ™•ï¼Œå¦‚æžœä½ æ˜¯ä½¿ç”¨æ‰‹æœºçœ‹çš„ï¼Œå¹¶ä¸”çœ‹æ‡‚äº†ï¼Œæˆ‘æ˜¯çœŸçš„ä½©æœã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œrun é‡Œé¢çš„ä»£ç å°±æ˜¯è°ƒç”¨äº† ObservableObserveOn å¯¹è±¡çš„ subscribe æ–¹æ³•ã€‚ä¹‹å‰æˆ‘ä»¬åˆ†æžè¿‡äº†ï¼Œsubscribe æ–¹æ³•å®žé™…ä¸Šæ²¡æœ‰åšä»€ä¹ˆï¼Œåªæ˜¯è°ƒç”¨äº† subscribeActual æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬è¿›å…¥è¿™ä¸ªç±»å†…éƒ¨çœ‹çœ‹ï¼š 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; æˆ‘ä»¬åœ¨ observeOn ä¼ é€’çš„ scheduler ä¸æ˜¯ TrampolineScheduler ç±»åž‹çš„ï¼Œæ‰€ä»¥åªéœ€è¦çœ‹ else çš„ä»£ç ã€‚è¿™é‡Œæ˜¯å…ˆåˆ›å»ºäº†ä¸€ä¸ªå·¥ä½œçº¿ç¨‹ï¼ˆç”±äºŽæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯ AndroidSchedulerï¼Œæ‰€ä»¥è¿™é‡Œæ˜¯æŒ‡çš„ä¸»çº¿ç¨‹ï¼‰ï¼Œç„¶åŽè°ƒç”¨äº† source çš„ subscribe æ–¹æ³•ã€‚éœ€è¦æ³¨æ„çš„æ˜¯è¿™é‡Œæœ€åŽåˆ›å»ºäº†ä¸€ä¸ª ObserveOnObserver å¯¹è±¡ï¼ˆå¤§ç¥žæ•™ä½ èµ·ç±»åç³»åˆ—äº”ï¼‰ã€‚ å…ˆçœ‹çœ‹ createWorkï¼Œåœ¨ HandlerScheduler ä¸­ï¼š 1234@Overridepublic Worker createWorker() &#123; return new HandlerWorker(handler);&#125; è¿”å›žäº†ä¸€ä¸ª HandlerWorker å¯¹è±¡ã€‚ å†çœ‹ source.subscribe()ï¼Œé¦–å…ˆè¿™é‡Œçš„ source æŒ‡çš„æ˜¯ create æ–¹æ³•åˆ›å»ºçš„ ObservableCreate å¯¹è±¡ï¼Œè°ƒç”¨ subscribe ä¼ é€’çš„æ˜¯ ObserveOnObserverã€‚çœ‹çœ‹è¿™ä¸ªå¯¹è±¡çš„ subscribeActual æ–¹æ³•ï¼š 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; è¿™é‡Œçš„å‚æ•° observer æ˜¯ ObserveOnObserverï¼Œsource æ˜¯æˆ‘ä»¬ä»£ç ä¸­åˆ›å»ºçš„ oos å¯¹è±¡ã€‚ é¦–å…ˆåˆ›å»ºäº†ä¸€ä¸ª CreateEmitter å¯¹è±¡ã€‚ æŽ¥ç€çœ‹ ObserveOnObserver çš„ onSubscribe æ–¹æ³•åšäº†å•¥ï¼š 12345678910111213141516171819202122232425262728293031@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.validate(this.s, s)) &#123; this.s = s; if (s instanceof QueueDisposable) &#123; @SuppressWarnings("unchecked") QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) &#123; sourceMode = m; queue = qd; done = true; actual.onSubscribe(this); schedule(); return; &#125; if (m == QueueDisposable.ASYNC) &#123; sourceMode = m; queue = qd; actual.onSubscribe(this); return; &#125; &#125; queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); actual.onSubscribe(this); &#125;&#125; è¿™é‡Œä»£ç æ¯”è¾ƒé•¿ï¼Œåªåˆ†æžé‡è¦çš„ä»£ç ï¼Œå°±æ˜¯ actual.onSubscribe è¿™å¥ã€‚actual æ˜¯æž„é€ å‡½æ•°ä¸­èµ‹å€¼çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å›žåˆ°åˆ›å»º ObserveOnObserver çš„åœ°æ–¹ï¼Œactual æŒ‡çš„æ˜¯ SubscribeOnObserver å¯¹è±¡ã€‚æ‰€ä»¥å®ƒè°ƒç”¨äº† SubscribeOnObserver çš„ onSubscribe æ–¹æ³•ã€‚æŽ¥ä¸‹æ¥åˆ†æžä¸€ä¸‹å®ƒçš„ onSubscribe æ–¹æ³•åšäº†ä»€ä¹ˆï¼Œè¿™é‡Œä¸çœ‹ä¹Ÿä¸ä¼šå½±å“æµç¨‹ã€‚ 123456789SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; this.s = new AtomicReference&lt;Disposable&gt;();&#125;@Overridepublic void onSubscribe(Disposable s) &#123; DisposableHelper.setOnce(this.s, s);&#125; è¿™ä¸ªæ–¹æ³•è°ƒç”¨äº† setOnce æ–¹æ³•ï¼š 1234567891011public static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; ObjectHelper.requireNonNull(d, "d is null"); if (!field.compareAndSet(null, d)) &#123; d.dispose(); if (field.get() != DISPOSED) &#123; reportDisposableSet(); &#125; return false; &#125; return true;&#125; è¿™é‡Œæ¶‰åŠåˆ°äº†ä¹è§‚é”ç­‰çŽ©æ„ï¼Œç®€å•æ¥è¯´å°±æ˜¯å…ˆåˆ¤æ–­ field çš„å€¼æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æžœä¸ºç©ºåˆ™è®¾ç½®ä¸º dï¼Œä¸ä¸ºç©ºåˆ™å°† d disposeã€‚ç„¶åŽåˆ¤æ–­ field çš„å€¼ï¼Œç”±äºŽ field çš„å€¼åªèƒ½è®¾å®šä¸€æ¬¡éž DISPOSED å€¼ï¼Œæ‰€ä»¥å¦‚æžœä¸ä¸º DISPOSEDï¼Œè¯´æ˜Žå·²ç»è¢«è®¾ç½®è¿‡äº†ï¼Œå†æŠ¥å‡ºå¼‚å¸¸ï¼Œå¦‚æžœä¸º DISPOSED æ˜¯å¯ä»¥å†æ¬¡è®¾ç½®çš„ã€‚æŒ‰ç…§æ­£å¸¸çš„æµç¨‹ï¼Œè¿™é‡Œåªæ˜¯å°† field çš„å€¼è®¾ç½®ä¸º dï¼Œç„¶åŽè¿”å›žtrueã€‚è¿™ä¸ªæ–¹æ³•å¯ä»¥å…ˆä¸ç”¨ç®¡ã€‚ å›žåˆ°ä¸»çº¿æµç¨‹ä¸Šï¼Œsource.subscribe(parent); è¿™æ˜¯æœ€é‡è¦çš„ä¸€å¥ä»£ç ã€‚source æ˜¯åœ¨æž„é€ å‡½æ•°èµ‹å€¼çš„ï¼Œçœ‹çœ‹æž„é€ æ–¹æ³•ï¼š 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ä¹Ÿå°±æ˜¯è¯´è¿™é‡Œçš„ source æ˜¯æˆ‘ä»¬ä»£ç ä¸­åˆ›å»ºçš„ oos å¯¹è±¡ã€‚parent æ˜¯æ–°åˆ›å»ºçš„ CreateEmitter å¯¹è±¡ã€‚çœ‹çœ‹æˆ‘ä»¬ oos çš„ subscribe æ–¹æ³•ï¼š 123456789@Overridepublic void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e("aprz", Thread.currentThread().getName()); final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(i); &#125; e.onComplete();&#125; è¿™é‡Œå°±æ˜¯äº‹ä»¶å¼€å§‹çš„èµ·ç‚¹ã€‚æ‰€æœ‰çš„äº‹ä»¶éƒ½ç”± ObservableEmitter å¼€å§‹å‘é€ï¼Œçœ‹çœ‹å®ƒçš„ä»£ç ï¼Œå®ƒæ˜¯ä¸€ä¸ªæŽ¥å£ï¼Œåœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼Œå®ƒçš„å®žçŽ°ç±»æ˜¯ CreateEmitterï¼Œæ‰€æœ‰æˆ‘ä»¬åˆ†æžè¿™ä¸ªç±»çš„ onNext æ–¹æ³•ï¼š 12345678910@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; isDisposed æ–¹æ³•è¿”å›ž false æ‰ä¼šåŽ»è°ƒç”¨ observer çš„ onNext æ–¹æ³•ï¼Œè¿™ä¸ª observer æ˜¯è°å‘¢? çœ‹åˆ°è¿™é‡Œæˆ‘ä»¬å°±è¦ä»ŽåŽå¾€å‰æŽ¨ä¸€éä¹‹å‰çš„ä»£ç äº†ï¼Œä¸ç®¡ä½ ç»ä¸ç»æœ›ï¼Œåæ­£æˆ‘æ˜¯å¾ˆç»æœ›ã€‚è¿™çš„ observer æ˜¯ ObserveOnObserver å¯¹è±¡ã€‚ æŽ¥ä¸‹æ¥æˆ‘ä»¬å°±è¿›å…¥ ObserveOnObserver é‡Œé¢ï¼Œçœ‹çœ‹å®ƒæŽ¥å—äº‹ä»¶ä¹‹åŽåšäº†ä»€ä¹ˆï¼Œä¸Šé¢çš„å‚æ•° e å°±æ˜¯ï¼š 1234567891011@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125; è°ƒç”¨äº† schedule æ–¹æ³•ï¼š 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; å‘ work ä¸­æäº¤äº†ä¸€ä¸ª Runnableï¼Œè¿™é‡Œä¼ é€’çš„æ˜¯ thisã€‚è¯´æ˜Žå®ƒè‡ªå·±è‚¯å®šå®žçŽ°äº†è¿™ä¸ªæŽ¥å£ï¼Œæˆ‘ä»¬çœ‹çœ‹å®ƒçš„ run æ–¹æ³•åšäº†å•¥ï¼š 12345678@Overridepublic void run() &#123; if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125; è¿™é‡Œä¸€èˆ¬æ˜¯èµ° drainNormal å§ï¼Œæˆ‘çŒœçš„ï¼Œæˆ‘ä»¬åˆ†æžè¿™ä¸ªæ–¹æ³•å§ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; ä»£ç å¾ˆé•¿ï¼Œå…·ä½“åšäº†å•¥æˆ‘ä»¬æš‚æ—¶ä¸ç”¨å…³å¿ƒï¼Œåªéœ€è¦æ³¨æ„åˆ° a.onNexe(v) è¿™è¡Œä»£ç ï¼Œè¿™ä¸ª a æ˜¯ actual å˜é‡ï¼Œactual åˆæ˜¯ SubscribeOnObserver å¯¹è±¡ï¼Œæˆ‘ä»¬çœ‹çœ‹å®ƒçš„ onNext æ–¹æ³•ï¼š 1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; å¾ˆç®€å•ï¼Œè¿™é‡Œçš„ actual å°±æ˜¯æˆ‘ä»¬åˆ›å»ºçš„ o äº†ï¼Œæ‰€ä»¥æœ€ç»ˆè°ƒç”¨åˆ°äº†æˆ‘ä»¬çš„ä»£ç é‡Œé¢ã€‚ å¥½äº†ï¼Œåˆ°è¿™é‡Œä¸€ä¸ªå®Œæ•´çš„æµç¨‹å°±æ•´ç†å‡ºæ¥äº†ï¼Œä½†æ˜¯è¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ²¡æœ‰è§£å†³ï¼Œå°±æ˜¯çº¿ç¨‹åˆ‡æ¢æ˜¯å‘ç”Ÿåœ¨å“ªé‡Œã€‚å› ä¸ºä¸ºäº†ä¸å½±å“æ•´ä½“æµç¨‹çš„åˆ†æžï¼Œæ‰€ä»¥ä¸Šé¢å¹¶æ²¡æœ‰åŽ»åˆ†æžçº¿ç¨‹åˆ‡æ¢çš„ä¸œè¥¿ï¼Œä¸‹é¢å¼€å§‹åˆ†æžã€‚ ç›´æŽ¥ä»Ž subscribeOn å¼€å§‹ï¼Œçœ‹ ObservableSubscribeOn çš„ä»£ç  12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; ä»Žè¿™é‡Œå¼€å§‹å°±è¿›è¡Œäº†çº¿ç¨‹çš„åˆ‡æ¢ï¼Œæ ¹æ®ä¸Šé¢çš„åˆ†æžæˆ‘ä»¬çŸ¥é“è¿™é‡Œæ˜¯å°† SubscribeTask ä½œä¸ºä¸€ä¸ª Runnable å¯¹è±¡ç»™æäº¤è¿›äº†æˆ‘ä»¬æŒ‡å®šçš„ scheduler ï¼ˆsubscribeOn ä¼ é€’çš„ï¼‰ä¸­ã€‚æ‰€ä»¥åŽé¢çš„æµç¨‹éƒ½æ˜¯åœ¨ scheduler æ‰€åœ¨çš„çº¿ç¨‹åœ¨è¿è¡Œã€‚ å†çœ‹ observeOnï¼Œçœ‹ ObservableObserveOn çš„ä»£ç ã€‚ 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; è¿™é‡Œçš„çº¿ç¨‹åˆ‡æ¢æ˜¯å‘ç”Ÿåœ¨ ObserveOnObserver è¿™ä¸ªå¯¹è±¡çš„é‡Œé¢ã€‚ 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; schedule çš„æµç¨‹ï¼Œæˆ‘ä»¬ä¸Šé¢åˆ†æžè¿‡ï¼Œworker.schedule(this) è¿™è¡Œä»£ç å°±å‘ç”Ÿäº†çº¿ç¨‹åˆ‡æ¢ï¼Œæ˜¯å°† this ä½œä¸º Runnable å¯¹è±¡æäº¤åˆ°äº†æˆ‘ä»¬æŒ‡å®šçš„ï¼ˆobserverOn ä¼ é€’çš„ï¼‰scheduler ä¸­ã€‚å…·ä½“åˆ†æžï¼Œç”±äºŽä¹‹å‰çš„æµç¨‹æ˜¯åœ¨åˆ«çš„çº¿ç¨‹ä¸­ï¼Œæ‰€ä»¥æƒ³è¦è¿›è¡Œçº¿ç¨‹åˆ‡æ¢ï¼Œæœ€å…ˆæƒ³åˆ°çš„è‚¯å®šæ˜¯ Handlerã€‚ç”±äºŽæˆ‘ä»¬ä¼ é€’çš„æ˜¯ AndroidSchedulers.mainThread()ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±åˆ†æžè¿™ä¸ªå§ã€‚ AndroidSchedulers.mainThread() çš„å®žçŽ°æ˜¯ HandlerSchedulerã€‚çœ‹çœ‹å®ƒçš„ schedule æ–¹æ³•ï¼š 1234567891011121314151617181920212223242526@Overridepublic Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; if (run == null) throw new NullPointerException("run == null"); if (unit == null) throw new NullPointerException("unit == null"); if (disposed) &#123; return Disposables.disposed(); &#125; run = RxJavaPlugins.onSchedule(run); ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker's runnables. handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) &#123; handler.removeCallbacks(scheduled); return Disposables.disposed(); &#125; return scheduled;&#125; post äº†ä¸€ä¸ª msgï¼Œè¿™æ ·å°±å®Œæˆäº†çº¿ç¨‹çš„åˆ‡æ¢ã€‚ ä¸‹é¢ä¸Šä¸€å¼ å›¾ï¼Œæœ‰åŠ©äºŽç†è§£å’Œè®°å¿†ï¼š å›¾ä¸­ç®­å¤´çš„æ–¹å‘ä¸ºäº‹ä»¶ä¼ æ’­çš„æ–¹å‘ï¼Œå¦‚æžœå®šä¹‰æ–¹æ³•è°ƒç”¨çš„æ–¹å‘ä¸ºé¡ºåºï¼Œé‚£ä¹ˆå½“è°ƒç”¨observable.subscribe(observer)çš„æ—¶å€™ï¼Œâš ï¸è®¢é˜…subscribeé¡ºåºæ˜¯ä»Žä¸‹æ¸¸å›žæº¯åˆ°ä¸Šæ¸¸ï¼Œç„¶åŽä¸Šæ¸¸äº§ç”Ÿäº‹ä»¶å¹¶å‘é€ï¼Œäº‹ä»¶å†ä¼ è¾“åˆ°ä¸‹æ¸¸ã€‚ æ¯æ¬¡æ‰§è¡Œ observerOn å’Œ subscribeOn çš„æ—¶å€™ï¼Œå†…éƒ¨éƒ½ä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ Observable å’Œ Observerå¯¹è±¡ã€‚ ä¸‹æ¸¸çš„observable ä¼šå¼•ç”¨ä¸Šæ¸¸çš„ observableï¼Œå³ source å˜é‡ã€‚ ä¸Šæ¸¸çš„observer ä¼šå¼•ç”¨ä¸‹æ¸¸çš„ observerï¼Œå³ actual å˜é‡ã€‚ å¤šæ¬¡æŒ‡å®šä¸Šæ¸¸çš„çº¿ç¨‹åªæœ‰ç¬¬ä¸€æ¬¡æŒ‡å®šçš„æœ‰æ•ˆ, ä¹Ÿå°±æ˜¯è¯´å¤šæ¬¡è°ƒç”¨subscribeOn() åªæœ‰ç¬¬ä¸€æ¬¡çš„æœ‰æ•ˆ, å…¶ä½™çš„ä¼šè¢«å¿½ç•¥ã€‚å› ä¸ºè¢«è§‚å¯Ÿè€…å‘é€äº‹ä»¶åœ¨æ‰€æœ‰ä¸Šæ¸¸çº¿ç¨‹åˆ‡æ¢å®Œæˆä¹‹åŽæ‰æ‰§è¡Œã€‚ å¤šæ¬¡æŒ‡å®šä¸‹æ¸¸çš„çº¿ç¨‹æ˜¯å¯ä»¥çš„, ä¹Ÿå°±æ˜¯è¯´æ¯è°ƒç”¨ä¸€æ¬¡observeOn() , ä¸‹æ¸¸çš„çº¿ç¨‹å°±ä¼šåˆ‡æ¢ä¸€æ¬¡ã€‚å› ä¸ºæŽ¥å—äº‹ä»¶åœ¨æ¯ä¸ªObserveOnObserverå¯¹è±¡çš„onNextä¸­éƒ½ä¼šåˆ‡æ¢ä¸€æ¬¡ã€‚ æœ€åŽæˆ‘ä»¬ subscribe çš„æ—¶å€™ï¼Œæ˜¯è°ƒç”¨çš„æœ€åŽåˆ›å»ºçš„ observable çš„æ–¹æ³•ã€‚è€Œæ¯ä¸ª observable å†…éƒ¨åˆè°ƒç”¨äº† source çš„ subscribe æ–¹æ³•ï¼Œè¿™æ ·å°±å½¢æˆäº†ä¸€å±‚ä¸€å±‚å¾€ä¸Šä¼ é€’çš„è°ƒç”¨é“¾ã€‚å½“è°ƒç”¨åˆ°æœ€å‰é¢çš„ä¸€ä¸ª observable çš„æ—¶å€™ï¼Œå°±æ˜¯æˆ‘ä»¬è‡ªå·±åˆ›å»ºçš„ source Observableï¼Œåœ¨è¿™é‡Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨è§¦å‘è¯¥ä¸Žè¯¥ observable å¯¹åº”çš„ observer å¯¹è±¡çš„ onNext æ–¹æ³•ã€‚è€Œ observer çš„ onNext æ–¹æ³•çš„å†…éƒ¨åˆè°ƒç”¨äº† actual çš„ onNext æ–¹æ³•ï¼Œè¿™æ ·å°±å½¢æˆäº†ä¸€å±‚ä¸€å±‚å¾€åŽä¼ é€’çš„è°ƒç”¨é“¾ã€‚ è™½ç„¶åœ¨æˆ‘ä»¬çš„ä¾‹å­ä¸­ï¼ŒCreateEmitter å¹¶ä¸æ˜¯ä¸€ä¸ª observer ï¼Œä½†æ˜¯å®ƒä¹Ÿæœ‰ onNext ç­‰æ–¹æ³•ï¼Œå¯ä»¥æŠŠå®ƒçœ‹åšä¸€ä¸ª observerã€‚ å¦‚æ­¤ï¼ŒRxJava çš„ä¸€ä¸ªæµç¨‹å°±ç†æ¸…æ¥šäº†ã€‚è¿™è´§çš„æµç¨‹å’Œ OkHttp æ€Žä¹ˆæœ‰ç‚¹åƒï¼Œåªæ˜¯ç¨å¾®æœ‰ç‚¹ä¸ä¸€æ ·ã€‚ è¡¥å……ä¸€ä¸‹å…³äºŽèƒŒåŽ‹çš„çŸ¥è¯†ï¼šåœ¨å¼‚æ­¥è®¢é˜…çš„æ—¶å€™ï¼Œä½¿ç”¨ Observableï¼Œé»˜è®¤çš„ç¼“å†²å¤§å°æ˜¯ 128ï¼Œè¶…è¿‡ è¿™ä¸ªæ•°é‡ä¹‹åŽä¼š resizeï¼Œä¹Ÿå°±æ˜¯è¯´ä¼šç¼“å†²æ‰€æœ‰çš„äº‹ä»¶ï¼Œè¿™æ ·å°±ä¼šå¯¼è‡´å†…å­˜å ç”¨ä¸€ç›´å¢žåŠ ã€‚]]></content>
      <categories>
        <category>æ‹†è½®å­</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç†è§£Windowå’ŒWindowManager]]></title>
    <url>%2F2018%2F03%2F06%2F%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager%2F</url>
    <content type="text"><![CDATA[Windowè¡¨ç¤ºä¸€ä¸ªçª—å£çš„æ¦‚å¿µ, å¦‚æœ‰éœ€è¦åœ¨æ¡Œé¢ä¸Šæ˜¾ç¤ºä¸€ä¸ªç±»ä¼¼æ‚¬æµ®çª—çš„ä¸œè¥¿, é‚£ä¹ˆè¿™ç§æ•ˆæžœå°±éœ€è¦Windowæ¥å®žçŽ°. Windowæ˜¯ä¸€ä¸ªæŠ½è±¡ç±», å…·ä½“å®žçŽ°æ˜¯PhoneWindow. å¦‚æžœæƒ³è¦åˆ›å»ºä¸€ä¸ªWindowåªéœ€è¦é€šè¿‡WindowManagerå³å¯å®Œæˆ. WindowManageræ˜¯å¤–ç•Œè®¿é—®Windowçš„å…¥å£, Windowå…·ä½“å®žçŽ°ä½äºŽWindowManagerServiceä¸­, WMå’ŒWMSçš„äº¤äº’æ˜¯ä¸€ä¸ªIPCè¿‡ç¨‹. Androidä¸­æ‰€æœ‰çš„è§†å›¾éƒ½æ˜¯é€šè¿‡Windowæ¥å‘ˆçŽ°çš„, ä¸ç®¡æ˜¯Activity, Dialog, Toastä»–ä»¬çš„è§†å›¾å®žé™…ä¸Šéƒ½æ˜¯é™„åŠ åœ¨Windowä¸Šçš„. Windowå’ŒWindowManagerå…ˆæ¼”ç¤ºä½¿ç”¨WindowMangeræ·»åŠ ä¸€ä¸ªWindow. 1234567891011121314151617public void addWindow()&#123; Button button = new Button(this); button.setText("åŠ¨æ€æ·»åŠ "); WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT); layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED; layoutParams.gravity = Gravity.LEFT | Gravity.TOP; layoutParams.x = 100; layoutParams.y = 300; getWindowManager().addView(button, layoutParams); &#125; â€‹ Flagå‚æ•°è¡¨ç¤ºWindowçš„å±žæ€§,è¿™äº›å±žæ€§å¯ä»¥æŽ§åˆ¶Windowçš„æ˜¾ç¤ºç‰¹æ€§. ä¸‹é¢æ˜¯å¸¸ç”¨çš„å±žæ€§: FLAG_NOT_FOCUSABLE: è¡¨ç¤ºWindowä¸éœ€è¦èŽ·å–ç„¦ç‚¹, è€Œä¸éœ€è¦æŽ¥æ”¶å„ç§è¾“å…¥äº‹ä»¶, æ­¤æ ‡è®°ä¼šåŒæ—¶å¯åŠ¨FLAG_NOT_TOUCH_MODAL, æœ€ç»ˆäº‹ä»¶ä¼šç›´æŽ¥ä¼ é€’ç»™ä¸‹å±‚çš„å…·æœ‰ç„¦ç‚¹çš„Window. FLAG_NOT_TOUCH_MODAL: è¿™ç§æ¨¡å¼ä¸‹, ç³»ç»Ÿä¼šå°†å½“å‰WindowåŒºåŸŸä»¥å¤–çš„ç‚¹å‡»äº‹ä»¶ä¼ é€’ç»™åº•å±‚çš„Window, å½“å‰WindowåŒºåŸŸä»¥å†…çš„å•å‡»äº‹ä»¶åˆ™è‡ªå·±å¤„ç†. è¿™ä¸ªæ ‡è®°å¾ˆé‡è¦, ä¸€èˆ¬æ¥è¯´éƒ½éœ€è¦å¼€å¯æ­¤æ ‡è®°, å¦åˆ™å…¶ä»–Windowå°†æ— æ³•æŽ¥æ”¶åˆ°å•å‡»äº‹ä»¶. FLAG_SHOW_WHEN_LOCKED: å¼€å¯æ­¤æ¨¡å¼å¯ä»¥è®©Windowæ˜¾ç¤ºåœ¨é”å±çš„ç•Œé¢ä¸Š. Typeå‚æ•°è¡¨ç¤ºWindowçš„ç±»åž‹ Windowå…±æœ‰ä¸‰ç§ç±»åž‹, åˆ†åˆ«æ˜¯åº”ç”¨Window, å­Window, ç³»ç»ŸWindow. åº”ç”¨ç±»Windowå¯¹åº”ç€ä¸€ä¸ªActivity. å­Windowä¸èƒ½å•ç‹¬å­˜åœ¨, ä»–éœ€è¦é™„å±žåœ¨ç‰¹å®šçš„çˆ¶Windowä¸­,æ¯”å¦‚å¸¸è§çš„Dialogå°±æ˜¯ä¸€ä¸ªå­Window. ç³»ç»ŸWindowæ˜¯éœ€è¦å£°æ˜Žæƒé™æ‰èƒ½åˆ›å»ºçš„Window, æ¯”å¦‚Toastå’Œç³»ç»ŸçŠ¶æ€æ éƒ½æ˜¯ç³»ç»Ÿçš„Window. Windowæ˜¯åˆ†å±‚çš„, æ¯ä¸ªWindowéƒ½æœ‰å¯¹åº”çš„z-ordered, å±‚çº§å¤§çš„ä¼šè¦†ç›–åœ¨å±‚çº§å°çš„Windowçš„ä¸Šé¢, è¿™å’ŒHTMLä¸­çš„z-indexçš„æ¦‚å¿µä¸€æ ·. åº”ç”¨Windowçš„å±‚çº§èŒƒå›´æ˜¯1~99, å­Windowçš„å±‚çº§èŒƒå›´æ˜¯1000~1999, ç³»ç»ŸWindowçš„å±‚çº§èŒƒå›´æ˜¯2000~2999. å¦‚æžœæƒ³è¦åœ¨æœ€é¡¶å±‚æ˜¾ç¤º, å¯ä»¥é€‰æ‹©ä½¿ç”¨TYPE_SYSTEM_OVERLAY, TYPE_SYSTEM_ERROR. å¦‚æžœé‡‡ç”¨äº†TYPE_SYSTEM_ERRORåŒæ—¶è¦å£°æ˜Žæƒé™: 1&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; å¦‚æžœä¸å£°æ˜Žé‚£ä¹ˆåœ¨åˆ›å»ºçš„æ—¶å€™å°±ä¼šæŠ¥é”™. WindowManagerå¸¸ç”¨çš„åŠŸèƒ½ åœ¨ViewManageræŽ¥å£ä¸­å®šä¹‰äº†ä¸‰ä¸ªæ–¹æ³•. å°±æ˜¯æˆ‘ä»¬å¸¸ç”¨çš„æ–¹æ³•æ·»åŠ View,åˆ é™¤View,ä¿®æ”¹View. WMç»§æ‰¿äº†è¿™ä¸ªæŽ¥å£. 12345public interface ViewManager &#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; Windowçš„å†…éƒ¨æœºåˆ¶Windowæ˜¯ä¸€ä¸ªæŠ½è±¡çš„æ¦‚å¿µ, æ¯ä¸€Windowéƒ½å¯¹åº”ç€ä¸€ä¸ªViewå’Œä¸€ä¸ªViewRootImpl, Windowå’ŒViewé€šè¿‡ViewRootImplæ¥å»ºç«‹è”ç³», å› æ­¤Windowå¹¶ä¸æ˜¯å®žé™…å­˜åœ¨çš„, ä»–æ˜¯ä»¥Viewçš„å½¢å¼å­˜åœ¨. é€šè¿‡WindowManagerçš„å®šä¹‰å’Œæä¾›çš„ä¸‰ä¸ªæŽ¥å£æ–¹æ³•çœ‹å‡ºéƒ½æ˜¯é’ˆå¯¹Viewçš„. è¯´æ˜ŽViewæ‰æ˜¯Windowå­˜åœ¨çš„å®žä½“. è€Œåœ¨å®žé™…çš„ä½¿ç”¨ä¸­æ— æ³•ç›´æŽ¥è®¿é—®Window, å¯¹Windowçš„è®¿é—®éƒ½æ˜¯å¿…é¡»é€šè¿‡WM. Windowçš„æ·»åŠ è¿‡ç¨‹Windowçš„æ·»åŠ è¿‡ç¨‹éœ€è¦é€šè¿‡WindowManagerçš„addView()æ¥å®žçŽ°, è€ŒWindowManageræ˜¯ä¸€ä¸ªæŽ¥å£, å®ƒçš„çœŸæ­£å®žçŽ°æ˜¯WindowManagerImplç±», åœ¨WindowManagerImplä¸­Windowçš„ä¸‰å¤§æ“ä½œå¦‚ä¸‹. 1234567891011121314151617@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow);&#125;@Overridepublic void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params);&#125; @Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; WindowManagerImplå¹¶æ²¡æœ‰ç›´æŽ¥å®žçŽ°Windowçš„ä¸‰å¤§æ“ä½œ, è€Œæ˜¯å…¨éƒ¨äº¤ç»™äº†WindowManagerGlobalæ¥å¤„ç†. WindowManagerGlobalä»¥å·¥åŽ‚çš„å½¢å¼å‘å¤–æä¾›è‡ªå·±çš„å®žä¾‹. è€ŒWindowManagerImplè¿™ç§å·¥ä½œæ¨¡å¼å°±å…¸åž‹çš„æ¡¥æŽ¥æ¨¡å¼, å°†æ‰€æœ‰çš„æ“ä½œå…¨éƒ¨å§”æ‰˜ç»™WindowManagerGlobalæ¥å®žçŽ°. WindowManagerGlobalçš„addView()ä¸»è¦åˆ†ä¸º æ£€æŸ¥æ‰€æœ‰å‚æ•°æ˜¯å¦åˆæ³•, å¦‚æžœæ˜¯å­Windowé‚£ä¹ˆè¿˜éœ€è¦è°ƒæ•´ä¸€äº›å¸ƒå±€å‚æ•°. åˆ›å»ºViewRootImplå¹¶å°†Viewæ·»åŠ åˆ°åˆ—è¡¨ä¸­. é€šè¿‡ViewRootImplæ¥æ›´æ–°ç•Œé¢å¹¶å®ŒæˆWindowçš„æ·»åŠ è¿‡ç¨‹. è¿™ä¸ªè¿‡ç¨‹æ˜¯é€šè¿‡ViewRootImpl#setView()æ¥å®Œæˆçš„. Viewçš„ç»˜åˆ¶è¿‡ç¨‹æ˜¯ç”±ViewRootImplæ¥å®Œæˆçš„, åœ¨å†…éƒ¨ä¼šè°ƒç”¨requestLayout()æ¥å®Œæˆå¼‚æ­¥åˆ·æ–°è¯·æ±‚. è€ŒscheduleTraversals()å®žé™…ä¸Šæ˜¯Viewç»˜åˆ¶çš„å…¥å£. æŽ¥ç€ä¼šé€šè¿‡WindowSession(ä¸€ä¸ªBinderå¯¹è±¡ï¼Œå®žçŽ°ç±»æ˜¯Session)å®ŒæˆWindowçš„æ·»åŠ è¿‡ç¨‹(Windowçš„æ·»åŠ è¿‡ç¨‹æ˜¯ä¸€æ¬¡IPCè°ƒç”¨). æœ€ç»ˆä¼šé€šè¿‡WindowManagerServiceæ¥å®žçŽ°Windowçš„æ·»åŠ . WindowManagerServiceå†…éƒ¨ä¼šä¸ºæ¯ä¸€ä¸ªåº”ç”¨ä¿ç•™ä¸€ä¸ªå•ç‹¬çš„Session. Windowçš„åˆ é™¤è¿‡ç¨‹Window çš„åˆ é™¤è¿‡ç¨‹å’Œæ·»åŠ è¿‡ç¨‹ä¸€æ ·, éƒ½æ˜¯å…ˆé€šè¿‡WindowManagerImplåŽ, åœ¨è¿›ä¸€æ­¥é€šè¿‡WindowManagerGlobalçš„removeView()æ¥å®žçŽ°çš„. 123456789101112public void removeView(View view, boolean immediate) &#123; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException("Calling with view " + view + " but the ViewAncestor is attached to " + curView); &#125;&#125; æ–¹æ³•å†…é¦–å…ˆé€šè¿‡findViewLockedæ¥æŸ¥æ‰¾å¾…åˆ é™¤çš„Viewçš„ç´¢å¼•, è¿™ä¸ªè¿‡ç¨‹å°±æ˜¯å»ºç«‹æ•°ç»„éåŽ†, ç„¶åŽè°ƒç”¨removeViewLockedæ¥åšè¿›ä¸€æ­¥çš„åˆ é™¤. 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125;&#125; è¿™é‡Œé€šè¿‡ViewRootImplçš„die()å®Œæˆæ¥å®Œæˆåˆ é™¤æ“ä½œ. die()æ–¹æ³•åªæ˜¯å‘é€äº†è¯·æ±‚åˆ é™¤çš„æ¶ˆæ¯åŽå°±ç«‹åˆ»è¿”å›žäº†, è¿™ä¸ªæ—¶å€™Viewå¹¶æ²¡æœ‰å®Œæˆåˆ é™¤æ“ä½œ, æ‰€ä»¥æœ€åŽä¼šå°†å…¶æ·»åŠ åˆ°mDyingViewsä¸­, mDyingViewsè¡¨ç¤ºå¾…åˆ é™¤çš„Viewçš„åˆ—è¡¨. 1234567891011121314151617boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(TAG, "Attempting to destroy the window while drawing!\n" + " window=" + this + ", title=" + mWindowAttributes.getTitle()); &#125; mHandler.sendEmptyMessage(MSG_DIE); return true;&#125; dieæ–¹æ³•ä¸­åªæ˜¯åšäº†ç®€å•çš„åˆ¤æ–­, å¦‚æžœæ˜¯å¼‚æ­¥åˆ é™¤é‚£ä¹ˆå°±å‘é€ä¸€ä¸ªMSG_DIEçš„æ¶ˆæ¯, ViewRootImplä¸­çš„Handlerä¼šå¤„ç†æ­¤æ¶ˆæ¯å¹¶è°ƒç”¨doDie(); å¦‚æžœæ˜¯åŒæ­¥åˆ é™¤, é‚£ä¹ˆå°±ä¸å‘é€æ¶ˆæ¯ç›´æŽ¥è°ƒç”¨doDie()æ–¹æ³•. åœ¨doDie()æ–¹æ³•ä¸­ä¼šè°ƒç”¨dispatchDetachedFromWindow()æ–¹æ³•, çœŸæ­£åˆ é™¤Viewçš„é€»è¾‘åœ¨è¿™ä¸ªæ–¹æ³•å†…éƒ¨å®žçŽ°. å…¶ä¸­ä¸»è¦åšäº†å››ä»¶äº‹: åžƒåœ¾å›žæ”¶çš„ç›¸å…³å·¥ä½œ, æ¯”å¦‚æ¸…é™¤æ•°æ®å’Œæ¶ˆæ¯,ç§»é™¤å›žè°ƒ. é€šè¿‡Sessionçš„removeæ–¹æ³•åˆ é™¤Window: mWindowSession.remove(mWindow), è¿™åŒæ ·æ˜¯ä¸€ä¸ªIPCè¿‡ç¨‹, æœ€ç»ˆä¼šè°ƒç”¨WMSçš„removeWindow()æ–¹æ³•. è°ƒç”¨Viewçš„dispatchDetachedFromWindow()æ–¹æ³•, å†…éƒ¨ä¼šè°ƒç”¨Viewçš„onDetachedFromWindow()ä»¥åŠonDetachedFromWindowInternal(). è€Œå¯¹äºŽonDetachedFromWindow()å°±æ˜¯åœ¨Viewä»ŽWindowä¸­ç§»é™¤æ—¶, è¿™ä¸ªæ–¹æ³•å°±ä¼šè¢«è°ƒç”¨, å¯ä»¥åœ¨è¿™ä¸ªæ–¹æ³•å†…éƒ¨åšä¸€äº›èµ„æºå›žæ”¶çš„å·¥ä½œ. æ¯”å¦‚åœæ­¢åŠ¨ç”»,åœæ­¢çº¿ç¨‹ã€‚ è°ƒç”¨WindowManagerGlobal#doRemoveViewæ–¹æ³•åˆ·æ–°æ•°æ®, åŒ…æ‹¬mRoots, mParams, mDyingViews, éœ€è¦å°†å½“å‰Windowæ‰€å…³è”çš„è¿™ä¸‰ç±»å¯¹è±¡ä»Žåˆ—è¡¨ä¸­åˆ é™¤ã€‚ Windowçš„æ›´æ–°è¿‡ç¨‹WindowManagerGlobal#updateViewLayout()æ–¹æ³•åšçš„æ¯”è¾ƒç®€å•, å®ƒéœ€è¦æ›´æ–°Viewçš„LayoutParamså¹¶æ›¿æ¢æŽ‰è€çš„LayoutParams, æŽ¥ç€æ›´æ–°ViewRootImplä¸­çš„LayoutParams. è¿™ä¸€æ­¥ä¸»è¦æ˜¯é€šè¿‡setLayoutParams()æ–¹æ³•å®žçŽ°. 12345678910111213141516171819public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if(view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if(!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized(mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); root.setLayoutParams(wparams, false); &#125;&#125; åœ¨ViewRootImplä¸­ä¼šé€šè¿‡scheduleTraversals()æ¥å¯¹Viewé‡æ–°å¸ƒå±€, åŒ…æ‹¬æµ‹é‡,å¸ƒå±€,é‡ç»˜. é™¤äº†Viewæœ¬èº«çš„é‡ç»˜ä»¥å¤–, ViewRootImplè¿˜ä¼šé€šè¿‡WindowSessionæ¥æ›´æ–°Windowçš„è§†å›¾, è¿™ä¸ªè¿‡ç¨‹æœ€åŽç”±WMSçš„relayoutWindow()å®žçŽ°ï¼ŒåŒæ ·æ˜¯ä¸€ä¸ªIPCè¿‡ç¨‹. Windowçš„åˆ›å»ºè¿‡ç¨‹Viewæ˜¯Androidä¸­è§†å›¾çš„å‘ˆçŽ°æ–¹å¼, ä½†æ˜¯Viewä¸èƒ½å•ç‹¬å­˜åœ¨, å®ƒå¿…é¡»ä¾é™„åœ¨Windowè¿™ä¸ªæŠ½è±¡çš„æ¦‚å¿µä¸Šé¢, æœ‰è§†å›¾çš„åœ°æ–¹å°±æœ‰Window,å› æ­¤Activityã€Dialogã€Toastç­‰è§†å›¾éƒ½å¯¹åº”ç€ä¸€ä¸ªWindowã€‚ Activityçš„Windowåˆ›å»ºè¿‡ç¨‹Activityçš„å¤§ä½“å¯åŠ¨æµç¨‹: æœ€ç»ˆä¼šç”±ActivityThreadä¸­çš„PerformLaunchActivity()æ¥å®Œæˆæ•´ä¸ªå¯åŠ¨è¿‡ç¨‹, è¿™ä¸ªæ–¹æ³•å†…éƒ¨ä¼šé€šè¿‡ç±»åŠ è½½å™¨åˆ›å»ºActivityçš„å®žä¾‹å¯¹è±¡, å¹¶è°ƒç”¨å…¶attach()æ–¹æ³•ä¸ºå…¶å…³è”è¿è¡Œè¿‡ç¨‹ä¸­æ‰€ä¾èµ–çš„ä¸€ç³»åˆ—ä¸Šä¸‹æ–‡çŽ¯å¢ƒå˜é‡. ä»£ç å¦‚ä¸‹: 1234567891011121314151617181920private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity activity = null; //èŽ·å¾—ç±»åŠ è½½å™¨ java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); ... Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); return activity;&#125; åœ¨attach()æ–¹æ³•é‡Œ, ç³»ç»Ÿä¼šåˆ›å»ºActivityæ‰€å±žçš„Windowå¯¹è±¡å¹¶ä¸ºå…¶è®¾ç½®å›žè°ƒæŽ¥å£, Windowå¯¹è±¡çš„åˆ›å»ºæ˜¯é€šè¿‡PolicyManager#makeNewWindow()æ–¹æ³•å®žçŽ°. ç”±äºŽActivityå®žçŽ°äº†Windowçš„CallBackæŽ¥å£, å› æ­¤å½“WindowæŽ¥æ”¶åˆ°å¤–ç•Œçš„çŠ¶æ€æ”¹å˜çš„æ—¶å€™å°±ä¼šå›žè°ƒActivityæ–¹æ³•. æ¯”å¦‚è¯´æˆ‘ä»¬ç†Ÿæ‚‰çš„onAttachedToWindow(), onDetachedFromWindow(), dispatchTouchEvent()ç­‰ç­‰.ä»£ç å¦‚ä¸‹ 1234567891011mWindow = new PhoneWindow(this);mWindow.setCallback(this);mWindow.setOnWindowDismissedCallback(this);mWindow.getLayoutInflater().setPrivateFactory(this);if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode);&#125;if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions);&#125;mUiThread = Thread.currentThread(); é‚£ä¹ˆActivityè§†å›¾æ˜¯æ€Žä¹ˆé™„å±žåœ¨Windowä¸Šçš„å‘¢? æŸ¥çœ‹ç»å¸¸ä½¿ç”¨çš„setContentView()æ–¹æ³•å¹²äº†ä»€ä¹ˆ 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; Activityå°†å…·ä½“å®žçŽ°äº¤ç»™äº†Windowå¤„ç†, è€ŒWindowçš„å…·ä½“å®žçŽ°å°±æ˜¯PhoneWindow, æ‰€ä»¥åªéœ€è¦çœ‹PhoneWindowçš„ç›¸å…³é€»è¾‘åˆ†ä¸ºä»¥ä¸‹å‡ æ­¥: å¦‚æžœæ²¡æœ‰DecorView, é‚£ä¹ˆå°±åˆ›å»ºå®ƒ. ç”±installDecor()--&gt;generateDecor()è§¦å‘ å°†Viewæ·»åŠ åˆ°DecorViewçš„mContentParentä¸­ 12//å°†Activityçš„å¸ƒå±€æ–‡ä»¶åŠ è½½åˆ°DecorViewçš„mContentParentä¸­mLayoutInflater.inflate(layoutResID, mContentParent); å›žè°ƒActivityçš„onContentChanged()é€šçŸ¥activityè§†å›¾å·²ç»å‘ç”Ÿæ”¹å˜ è¿™ä¸ªæ—¶å€™DecorViewå·²ç»è¢«åˆ›å»ºå¹¶åˆå§‹åŒ–å®Œæ¯•, Activityçš„å¸ƒå±€æ–‡ä»¶ä¹Ÿå·²ç»æ·»åŠ æˆåŠŸåˆ°DecorViewçš„mContentParentä¸­. ä½†æ˜¯è¿™ä¸ªæ—¶å€™DecorViewè¿˜æ²¡æœ‰è¢«WindowManageræ­£å¼æ·»åŠ åˆ°Windowä¸­. è™½ç„¶æ—©åœ¨Activityçš„attachæ–¹æ³•ä¸­windowå°±å·²ç»è¢«åˆ›å»ºäº†, ä½†æ˜¯è¿™ä¸ªæ—¶å€™ç”±äºŽDecorViewå¹¶æ²¡æœ‰è¢«WindowManagerè¯†åˆ«, æ‰€ä»¥è¿™ä¸ªæ—¶å€™çš„Windowæ— æ³•æä¾›å…·ä½“åŠŸèƒ½, å› ä¸ºä»–è¿˜æ— æ³•æŽ¥æ”¶å¤–ç•Œçš„è¾“å…¥ä¿¡æ¯. åœ¨ActivityThread#handleResumeActivity()æ–¹æ³•ä¸­, é¦–å…ˆä¼šè°ƒç”¨Activity#onResume(), æŽ¥ç€ä¼šè°ƒç”¨Activity#makeVisible(), æ­£æ˜¯åœ¨makeVisibleæ–¹æ³•ä¸­, DecorViewçœŸæ­£çš„å®Œæˆäº†æ·»åŠ å’Œæ˜¾ç¤ºè¿™ä¸¤ä¸ªè¿‡ç¨‹. å¦‚ä¸‹: 12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; Dialogçš„Windowåˆ›å»ºè¿‡ç¨‹Dialogçš„Windowçš„åˆ›å»ºè¿‡ç¨‹å’ŒActivityç±»ä¼¼, æœ‰å¦‚ä¸‹å‡ æ­¥ 1. åˆ›å»ºWindow Dialogä¸­çš„WindowåŒæ ·æ˜¯é€šè¿‡PolicyManageråˆ›å»ºçš„makeNewWindowåˆ›å»ºçš„ï¼Œå®žé™…ä¸Šå°±æ˜¯PhoneWindow, è¿™ä¸ªè¿‡ç¨‹å’ŒActivityçš„Windowåˆ›å»ºè¿‡ç¨‹ä¸€è‡´. 2. åˆå§‹åŒ–DecorViewå¹¶å°†Dialogçš„è§†å›¾æ·»åŠ åˆ°DecorViewä¸­ 123public void setContentView(int layoutResID) &#123; mWindow.setContentView(layoutResID);&#125; è¿™ä¸ªè¿‡ç¨‹ä¹Ÿç±»ä¼¼, éƒ½æ˜¯é€šè¿‡WindowåŽ»æ·»åŠ æŒ‡å®šçš„å¸ƒå±€æ–‡ä»¶. 3. å°†DecorViewæ·»åŠ åˆ°Windowä¸­å¹¶æ˜¾ç¤º åœ¨Dialogçš„showæ–¹æ³•ä¸­, ä¼šé€šè¿‡WindowManagerå°†DecorViewæ·»åŠ Windowä¸­. 123mWindowManager.addView(mDecor, l);mShowing = true; sendShowMessage(); æ™®é€šçš„Dialogæœ‰ä¸€ä¸ªç‰¹æ®Šä¹‹å¤„, é‚£å°±æ˜¯å¿…é¡»é‡‡ç”¨Activityçš„Content, å¦‚æžœé‡‡ç”¨Applicationçš„Content, é‚£ä¹ˆå°±ä¼šæŠ¥é”™. æŠ¥çš„é”™æ˜¯æ²¡æœ‰åº”ç”¨tokenæ‰€å¯¼è‡´çš„, è€Œåº”ç”¨tokenä¸€èˆ¬åªæœ‰Activityæ‰æ‹¥æœ‰. è¿˜æœ‰ä¸€ç§æ–¹æ³•. ç³»ç»ŸWindowæ¯”è¾ƒç‰¹æ®Š, ä»–å¯ä»¥ä¸éœ€è¦token, å› æ­¤åªéœ€è¦æŒ‡å®šå¯¹è¯æ¡†çš„Windowä¸ºç³»ç»Ÿç±»åž‹å°±å¯ä»¥æ­£å¸¸å¼¹å‡ºå¯¹è¯æ¡†. 12345//JAVA ç»™Dialogçš„Windowæ”¹å˜ä¸ºç³»ç»Ÿçº§çš„Windowdialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);//XML å£°æ˜Žæƒé™&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; Toastçš„Windowåˆ›å»ºè¿‡ç¨‹Toastå’ŒDialogä¸åŒ, å®ƒçš„å·¥ä½œè¿‡ç¨‹å°±ç¨æ˜¾å¤æ‚. é¦–å…ˆToastä¹Ÿæ˜¯åŸºäºŽWindowæ¥å®žçŽ°çš„. ä½†æ˜¯ç”±äºŽToastå…·æœ‰å®šæ—¶å–æ¶ˆçš„åŠŸèƒ½, æ‰€ä»¥ç³»ç»Ÿé‡‡ç”¨äº†Handler. åœ¨Toastçš„å†…éƒ¨æœ‰ä¸¤ç±»IPCè¿‡ç¨‹, ç¬¬ä¸€ç±»æ˜¯Toastè®¿é—®NotificationManagerServiceåŽé¢ç®€ç§°NMS. ç¬¬äºŒç±»æ˜¯NotificationManagerServiceå›žè°ƒToasté‡Œçš„TNæŽ¥å£ã€‚ Toastå±žäºŽç³»ç»ŸWindow, å®ƒå†…éƒ¨çš„è§†å›¾æœ‰ä¸¤ç§æ–¹å¼æŒ‡å®š, ä¸€ç§æ˜¯ç³»ç»Ÿé»˜è®¤çš„æ ·å¼, å¦ä¸€ç§æ˜¯é€šè¿‡setViewæ–¹æ³•æ¥æŒ‡å®šä¸€ä¸ªè‡ªå®šä¹‰View. ä¸ç®¡å¦‚ä½•, ä»–ä»¬éƒ½å¯¹åº”Toastçš„ä¸€ä¸ªViewç±»åž‹çš„å†…éƒ¨æˆå‘˜mNextView. Toastå†…éƒ¨æä¾›äº†cancelå’Œshowä¸¤ä¸ªæ–¹æ³•. åˆ†åˆ«ç”¨äºŽæ˜¾ç¤ºå’Œéšè—Toast. ä»–ä»¬å†…éƒ¨æ˜¯ä¸€ä¸ªIPCè¿‡ç¨‹ï¼Œä»£ç å¦‚ä¸‹ï¼š 1234567891011121314151617181920212223242526public void show() &#123; if (mNextView == null) &#123; throw new RuntimeException("setView must have been called"); &#125; INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125;public void cancel() &#123; mTN.hide(); try &#123; getService().cancelToast(mContext.getPackageName(), mTN); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; æ˜¾ç¤ºå’Œéšè—Toastéƒ½æ˜¯éœ€è¦é€šè¿‡NMSæ¥å®žçŽ°çš„. ç”±äºŽNMSè¿è¡Œåœ¨ç³»ç»Ÿçš„è¿›ç¨‹ä¸­, æ‰€ä»¥åªèƒ½é€šè¿‡è¿œç¨‹è°ƒç”¨çš„æ–¹å¼æ¥æ˜¾ç¤ºå’Œéšè—Toast. è€ŒTNè¿™ä¸ªç±»æ˜¯ä¸€ä¸ªBinderç±». åœ¨Toastå’ŒNMSè¿›è¡ŒIPCçš„è¿‡ç¨‹ä¸­, å½“NMSå¤„ç†Toastçš„æ˜¾ç¤ºæˆ–éšè—è¯·æ±‚æ—¶ä¼šè·¨è¿›ç¨‹å›žè°ƒTNçš„æ–¹æ³•. è¿™ä¸ªæ—¶å€™ç”±äºŽTNè¿è¡Œåœ¨Binderçº¿ç¨‹æ± ä¸­, æ‰€ä»¥éœ€è¦é€šè¿‡Handlerå°†å…¶åˆ‡æ¢åˆ°å½“å‰ä¸»çº¿ç¨‹. æ‰€ä»¥ç”±å…¶å¯çŸ¥, Toastæ— æ³•åœ¨æ²¡æœ‰Looperçš„çº¿ç¨‹ä¸­å¼¹å‡ºï¼Œå› ä¸ºHandleréœ€è¦ä½¿ç”¨Looperæ‰èƒ½å®Œæˆåˆ‡æ¢çº¿ç¨‹çš„åŠŸèƒ½ã€‚ 12345678910111213141516 if (!isSystemToast) &#123; int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) &#123; final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) &#123; count++; // MAX_PACKAGE_NOTIFICATIONS == 50 if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123; Slog.e(TAG, "Package has already posted " + count + " toasts. Not showing more. Package=" + pkg); return; &#125; &#125; &#125;&#125; å¯¹äºŽéžç³»ç»Ÿåº”ç”¨æ¥è¯´, æœ€å¤šèƒ½åŒæ—¶å­˜åœ¨å¯¹Toastå°è£…çš„ToastRecordä¸Šé™ä¸º50ä¸ª. è¿™æ ·åšæ˜¯ä¸ºäº†é˜²æ­¢DOS(Denial of Service). å¦‚æžœä¸è¿™æ ·, å½“é€šè¿‡å¤§é‡å¾ªçŽ¯åŽ»è¿žç»­çš„å¼¹å‡ºToast, è¿™å°†ä¼šå¯¼è‡´å…¶ä»–åº”ç”¨æ²¡æœ‰æœºä¼šå¼¹å‡ºToast, é‚£ä¹ˆå¯¹äºŽå…¶ä»–åº”ç”¨çš„Toastè¯·æ±‚, ç³»ç»Ÿçš„è¡Œä¸ºå°±æ˜¯æ‹’ç»æœåŠ¡, è¿™å°±æ˜¯æ‹’ç»æœåŠ¡æ”»å‡»çš„å«ä¹‰. åœ¨ToastRecordè¢«æ·»åŠ åˆ°mToastQueue()ä¸­åŽ, NMSå°±ä¼šé€šè¿‡showNextToastLocked()æ–¹æ³•æ¥æ˜¾ç¤ºå½“å‰çš„Toastã€‚Toastçš„æ˜¾ç¤ºæ˜¯ç”±ToastRecordçš„callbackæ¥å®Œæˆçš„. è¿™ä¸ªcallbackå®žé™…ä¸Šå°±æ˜¯Toastä¸­çš„TNå¯¹è±¡çš„è¿œç¨‹Binder. é€šè¿‡callbackæ¥è®¿é—®TNä¸­çš„æ–¹æ³•æ˜¯éœ€è¦è·¨è¿›ç¨‹çš„. æœ€ç»ˆè¢«è°ƒç”¨çš„TNä¸­çš„æ–¹æ³•ä¼šè¿è¡Œåœ¨å‘èµ·Toastè¯·æ±‚çš„åº”ç”¨çš„Binderçº¿ç¨‹æ± . 123456789101112131415161718void showNextToastLocked ()&#123; ToastRecord record = mToastQueue.get(0); while(record != null)&#123; if(DBG) Slog.d(TAG,"show pkg=" + record.pkg + "callback=" + record.callback); try&#123; record.callback.show(); scheduleTimeoutLocked(record); return; &#125;&#125;private void scheduleTimeoutLocked(ToastRecord r)&#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay);&#125; è¿™ä¸ª callback å°±æ˜¯ Toast ä¸­çš„ TN å¯¹è±¡çš„è¿œç¨‹ Binderï¼Œæœ€ç»ˆè¢«è°ƒç”¨çš„ TN ä¸­çš„æ–¹æ³•ä¼šè¿è¡Œåœ¨å‘èµ· Toast è¯·æ±‚çš„åº”ç”¨çš„ Binder çº¿ç¨‹æ± ä¸­ã€‚ ä»Žå¦‚ä¸Šä»£ç æ‰€ç¤ºåœ¨Toastæ˜¾ç¤ºä»¥åŽ, NMSé€šè¿‡è¿™ä¸ªæ–¹æ³•æ¥å‘é€ä¸€ä¸ªå»¶æ—¶æ¶ˆæ¯, å…·ä½“å–å†³Toastçš„æ—¶é•¿. LONG_DELAY, SHORT_DELAYåˆ†åˆ«å¯¹åº”ç€3.5ç§’å’Œ2ç§’. å½“å»¶æ—¶æ—¶é—´è¾¾åˆ°çš„æ—¶å€™. NMSä¼šé€šè¿‡cancelToastLocked()æ–¹æ³•æ¥éšè—Toastå¹¶å°†å…¶ä»ŽmToastQueueä¸­ç§»é™¤, è¿™ä¸ªæ—¶å€™å¦‚æžœmToastQueueä¸­è¿˜æœ‰å…¶ä½™Toasté‚£ä¹ˆNMSå°±ç»§ç»­æ˜¾ç¤ºå…¶ä»–. Toastçš„éšè—ä¹Ÿä¼šé€šè¿‡ToastRecordçš„callbackå®Œæˆçš„.åŒæ ·æ˜¯ä¸€æ¬¡IPCè¿‡ç¨‹. æ–¹å¼å’ŒToastæ˜¾ç¤ºç±»ä¼¼. 12345678910111213void cancelToastLocked(int index) &#123;ToastRecord record = mToastQueue.get(index);try &#123; record.callback.hide();&#125; catch (RemoteException e) &#123; Slog.w(TAG, "Object died trying to hide notification " + record.callback + " in package " + record.pkg); // don't worry about this, we're about to remove it from // the list anyway&#125;mToastQueue.remove(index);...&#125; ä»¥ä¸ŠåŸºæœ¬è¯´æ˜ŽToastçš„æ˜¾ç¤ºå’Œå½±å“è¿‡ç¨‹å®žé™…ä¸Šæ˜¯é€šè¿‡Toastä¸­çš„TNè¿™ä¸ªç±»æ¥å®žçŽ°çš„. ä»–æœ‰ä¸¤ä¸ªæ–¹æ³•show(), hide(). åˆ†åˆ«å¯¹åº”ç€Toastçš„æ˜¾ç¤ºå’Œéšè—. ç”±äºŽè¿™ä¸¤ä¸ªæ–¹æ³•æ˜¯è¢«NMSä»¥è·¨è¿›ç¨‹çš„æ–¹å¼è°ƒç”¨çš„, å› æ­¤ä»–ä»¬è¿è¡Œåœ¨Binderçº¿ç¨‹æ± ä¸­. ä¸ºäº†å°†æ‰§è¡ŒçŽ¯å¢ƒåˆ‡æ¢åˆ°Toastè¯·æ±‚æ‰€åœ¨çº¿ç¨‹ä¸­, åœ¨ä»–ä»¬å†…éƒ¨ä½¿ç”¨äº†handler,å¦‚ä¸‹ 1234567891011121314@Overridepublic void show() &#123; if (localLOGV) Log.v(TAG, "SHOW: " + this); mHandler.post(mShow);&#125;/*** schedule handleHide into the right thread*/@Overridepublic void hide() &#123; if (localLOGV) Log.v(TAG, "HIDE: " + this); mHandler.post(mHide);&#125; ä¸Šé¢ä»£ç ä¸­, mShow, mHideæ˜¯ä¸¤ä¸ªRunnable, ä»–ä»¬å†…éƒ¨åˆ†åˆ«è°ƒç”¨äº†handleShowå’ŒhandleHideæ–¹æ³•. æ‰€ä»¥è¿™ä¸¤ä¸ªæ–¹æ³•æ‰æ˜¯çœŸæ­£å®Œæˆéšè—å’Œæ˜¾ç¤ºToastçš„åœ°æ–¹. TNçš„handleShowä¸­ä¼šå°†Toastçš„è§†å›¾æ·»åŠ åˆ°Windowä¸­. TNçš„handleHideä¸­ä¼šå°†Toastçš„è§†å›¾ä»ŽWindowä¸­ç§»é™¤. å…·ä½“å®žçŽ°ä»£ç å¦‚ä¸‹: 123456789101112//handleShow() mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); mWM.addView(mView, mParams); //handleHide()if (mView != null) &#123; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; mView = null;&#125; å…³äºŽToastæµç¨‹å·²ç»å®Œäº‹. é™¤äº†è¯´åˆ°çš„Activity, Dialog, Toast. è¿˜æœ‰PopupWindowèœå•æ , çŠ¶æ€æ éƒ½æ˜¯é€šè¿‡Windowæ¥å®žçŽ°çš„.]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>Window</tag>
        <tag>WindowManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidåŠ¨ç”»æ·±å…¥åˆ†æž]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ViewåŠ¨ç”»ViewåŠ¨ç”»ä½œç”¨çš„å¯¹è±¡æ˜¯View, å®ƒæ”¯æŒå››ç§åŠ¨ç”»æ•ˆæžœå¹³ç§», ç¼©æ”¾, æ—‹è½¬, é€æ˜Ž. é™¤äº†è¿™å››ç§å…¸åž‹çš„å˜åŒ–æ•ˆæžœ. å¸§åŠ¨ç”»ä¹Ÿå±žäºŽViewåŠ¨ç”». ViewåŠ¨ç”»çš„ç§ç±»ViewåŠ¨ç”»çš„å››ç§å˜æ¢æ•ˆæžœå¯¹åº”ç€Animationçš„å››ä¸ªå­ç±»:TranslateAnimation, ScaleAnimation, RotateAnimationå’ŒAlphaAnimation. å¯¹äºŽViewåŠ¨ç”»å»ºè®®é‡‡ç”¨XMLæ¥å®šä¹‰åŠ¨ç”» åç§° æ ‡ç­¾ å­ç±» æ•ˆæžœ å¹³ç§»åŠ¨ç”» &lt;translate&gt; TranslateAnimation ç§»åŠ¨View ç¼©æ”¾åŠ¨ç”» &lt;scale&gt; ScaleAnimation æ”¾å¤§æˆ–è€…ç¼©å°View æ—‹è½¬åŠ¨ç”» &lt;rotate&gt; RotateAnimation æ—‹è½¬View é€æ˜Žåº¦åŠ¨ç”» &lt;alpha&gt; AlphaAnimation æ”¹å˜Viewçš„é€æ˜Žåº¦ åˆ›å»ºçš„åŠ¨ç”»çš„xmlæ–‡ä»¶. æ˜¯æ”¾åœ¨res/animè¿™ä¸ªæ–‡ä»¶å¤¹ä¸‹çš„. ViewåŠ¨ç”»æè¿°æ–‡ä»¶çš„å›ºæœ‰è¯­æ³•å¦‚ä¸‹ 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:shareInterpolator="true" android:interpolator="@android:anim/decelerate_interpolator" android:fillAfter="true"&gt; &lt;alpha android:fromAlpha="float" android:toAlpha="float"/&gt; &lt;scale android:fromXScale="float" android:toXScale="float" android:fromYScale="float" android:toYScale="float" android:pivotX="float" android:pivotY="float"/&gt; &lt;translate android:fromXDelta="float" android:toXDelta="float" android:fromYDelta="float" android:toYDelta="float"/&gt; &lt;rotate android:fromDegrees="float" android:toDegrees="float" android:pivotY="float" android:pivotX="float"/&gt;&lt;/set&gt; å…³äºŽåŠ¨ç”»æˆ‘ä»¬å¯ä»¥åªè®¾ç½®ä¸€ç§ä¹Ÿå¯ä»¥è®¾ç½®å¤šç§çš„ç»„åˆ. setæ ‡ç­¾å¯¹åº”ç€AnimationSetç±», æ ‡ç­¾ä¸­çš„å±žæ€§çš„æ„ä¹‰: shareInterpolator è¡¨ç¤ºé›†åˆä¸­çš„åŠ¨ç”»æ˜¯å¦å’Œé›†åˆå…±äº«ä¸€ä¸ªæ’å€¼å™¨. å¦‚æžœé›†åˆä¸æŒ‡å®šæ’å€¼å™¨, é‚£ä¹ˆå­åŠ¨ç”»å°±éœ€è¦å•ç‹¬åˆ¶å®šæ‰€éœ€çš„æ’å€¼å™¨æˆ–è€…ä½¿ç”¨é»˜è®¤å€¼ fillAfter æ˜¯å¦ä¿ç•™åŠ¨ç”»ç»“æŸä¹‹åŽçš„çŠ¶æ€ translateæ ‡ç­¾è¡¨ç¤ºå¹³ç§»åŠ¨ç”», å¯¹åº”ç€TranslateAnimationç±» å±žæ€§å€¼çš„æ„ä¹‰å°±æ˜¯fromå¼€å¤´çš„ä¸ºå¼€å§‹èµ·ç‚¹, toå¼€å¤´çš„ç»“æŸç‚¹ scaleæ ‡ç­¾è¡¨ç¤ºç¼©æ”¾åŠ¨ç”», å¯¹åº”ç€ScaleAnimationç±» å±žæ€§å€¼çš„æ„æ€fromå¼€å¤´çš„è¡¨ç¤ºå¼€å§‹æ—¶åŽŸå›¾ç¼©æ”¾çš„ç™¾åˆ†æ¯”. ç”¨æµ®ç‚¹æ•°è¡¨ç¤º1è¡¨ç¤º100%(æ— å˜åŒ–),0.5è¡¨ç¤º50%(åŽŸæ¥çš„ä¸€èˆ¬), 2è¡¨ç¤º200%(åŽŸæ¥çš„ä¸¤å€). toå¼€å¤´çš„è¡¨ç¤ºç»“æŸæ—¶çš„ç™¾åˆ†æ¯”. pivotè¡¨ç¤ºç¼©æ”¾çš„è½´ç‚¹. rotateæ ‡ç­¾è¡¨ç¤ºæ—‹è½¬åŠ¨ç”», å¯¹åº”ç€RotateAnimationç±» fromDegreesæ—‹è½¬çš„å¼€å§‹è§’åº¦, toDegreesæ—‹è½¬çš„ç»“æŸè§’åº¦. pivotæ—‹è½¬çš„è½´ç‚¹ alphaæ ‡ç­¾è¡¨ç¤ºé€æ˜Žåº¦åŠ¨ç”», å¯¹åº”AlphaAnimationç±» fromAlphaè¡¨ç¤ºé€æ˜Žåº¦çš„èµ·å§‹å€¼, toAlphaè¡¨ç¤ºé€æ˜Žåº¦çš„ç»“æŸå€¼. ä¸Šé¢è¿™äº›æ ‡ç­¾è¿˜æœ‰ä¸€äº›é€šç”¨çš„å±žæ€§å€¼. ä¾‹å¦‚durationæ‰§è¡Œæ—¶é—´. xmlå¦‚æžœå£°æ˜Žäº†ä¹‹åŽé‚£ä¹ˆæˆ‘ä»¬å°±è¯¥åœ¨ä»£ç ä¸­åº”ç”¨äº†. å¦‚ä¸‹: 123View btn_main = findViewById(R.id.parent);Animation animation = AnimationUtils.loadAnimation(this, R.anim.temp);btn_main.startAnimation(animation); åŒæ ·ä¹Ÿå¯ä»¥ä¸éœ€è¦xmlç›´æŽ¥åœ¨ä»£ç ä¸­ç”ŸæˆåŠ¨ç”»å¯¹è±¡. 123AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0);alphaAnimation.setDuration(1000);btn_main.startAnimation(alphaAnimation); åœ¨å¼€å§‹åŠ¨ç”»ä¹‹å‰å¯ä»¥ç»™åŠ¨ç”»æ·»åŠ ä¸€ä¸ªç›‘å¬setAnimationListener()è¿™æ ·åœ¨åŠ¨ç”»å¼€å§‹ç»“æŸå’Œæ¯ä¸€æ¬¡å¾ªçŽ¯ä¸‹ä¸€æ¬¡çš„æ—¶å€™éƒ½å¯ä»¥åœ¨å›žè°ƒæ–¹æ³•ä¸­ç›‘å¬åˆ°. 12345public static interface AnimationListener &#123; void onAnimationStart(Animation animation); void onAnimationEnd(Animation animation); void onAnimationRepeat(Animation animation);&#125; è‡ªå®šä¹‰ViewåŠ¨ç”»å¦‚æžœéœ€è¦è‡ªå®šä¹‰ViewåŠ¨ç”», é¦–å…ˆåº”è¯¥ç»§æ‰¿Animationè¿™ä¸ªæŠ½è±¡ç±»æ¥æ´¾ç”Ÿå‡ºä¸€ç§æ–°åŠ¨ç”». ç„¶åŽé‡å†™initialize()å’ŒapplyTransformation()æ–¹æ³•. åœ¨initializeä¸­åšä¸€äº›åˆå§‹åŒ–åŠ¨ä½œ, åœ¨applyTransformation()ä¸­è¿›è¡Œç›¸åº”çŸ©é˜µå˜æ¢, å¾ˆå¤šæ—¶å€™éœ€è¦é‡‡ç”¨Cameraæ¥ç®€åŒ–çŸ©é˜µå˜æ¢çš„è¿‡ç¨‹. è€ŒViewåŠ¨ç”»å˜åŒ–ä¸»è¦å°±æ˜¯çŸ©é˜µçš„å˜æ¢è¿‡ç¨‹. è¿™é‡Œä¸¾ä¸€ä¸ªAndroidä¸­ApiDemoçš„ä¸€ä¸ªè‡ªå®šä¹‰ViewåŠ¨ç”». å¤§æ¦‚æ•ˆæžœå°±æ˜¯è¿™æ ·å¯ä»¥å‚ç…§å®˜ç½‘çš„apiä¹Ÿå¯åœ¨åŒ…ä¸­çš„MyRotateAnimation å¸§åŠ¨ç”»å¸§åŠ¨ç”»æ˜¯é¡ºåºæ’­æ”¾ä¸€ç»„é¢„å…ˆå®šä¹‰å¥½çš„å›¾ç‰‡, ç±»ä¼¼äºŽç”µå½±. ç³»ç»Ÿæä¾›äº†AnimationDrawableæ¥ä½¿ç”¨å¸§åŠ¨ç”». åŒæ ·åœ¨xmlä¸­å£°æ˜Ž, åœ¨res/drawable/åŒ…ä¸‹åˆ›å»ºæ–‡ä»¶, å¹¶æ›¿æ¢æ¯ä¸ªdrawableå›¾ç‰‡å³å¯ 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/xx1" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx2" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx3" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx4" android:duration="500"/&gt;&lt;/animation-list&gt; å°†ä¸Šè¿°çš„Drawableä½œä¸ºViewçš„èƒŒæ™¯å¹¶é€šè¿‡Drawableæ¥æ’­æ”¾åŠ¨ç”». 12AnimationDrawable background = (AnimationDrawable) iv_main.getBackground();background.start(); å¸§åŠ¨ç”»æ¯”è¾ƒå®¹æ˜“å¼•èµ·OOMï¼Œåº”è¯¥å°½é‡é¿å…ä½¿ç”¨ã€‚ ViewåŠ¨ç”»çš„ç‰¹æ®Šä½¿ç”¨åœºæ™¯å‰é¢ä»‹ç»çš„ViewåŠ¨ç”»éƒ½æ˜¯ä½œç”¨åœ¨æŸä¸€ä¸ªViewå¯¹è±¡ä¸Šçš„. è¿˜å¯ä»¥é’ˆå¯¹ViewGroupæŽ§åˆ¶å…¶å­å…ƒç´ . æˆ–è€…é’ˆå¯¹Activityåˆ‡æ¢çš„åŠ¨ç”». LayoutAnimationLayoutAnimationä½œç”¨äºŽViewGroupä¸Šçš„. ä¸ºViewGroupæŒ‡å®šä¸€ä¸ªåŠ¨ç”», è¿™æ ·å½“å®ƒçš„å­å…ƒç´ å‡ºåœºæ—¶éƒ½ä¼šå…·æœ‰è¿™ç§åŠ¨ç”»æ•ˆæžœ. å¸¸ç”¨çš„ä½¿ç”¨åœºæ™¯æ˜¯åœ¨ListViewå’ŒGridView. ä½¿ç”¨å¾ˆç®€å•æ­¥éª¤å¦‚ä¸‹. åœ¨res/anim/anim_itemæ–‡ä»¶å¤¹ä¸‹åˆ›å»ºxmlæ–‡ä»¶. 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="0.5" android:animationOrder="random" android:animation="@anim/layout"&gt; &lt;/layoutAnimation&gt; delay: å­å…ƒç´ å¼€å§‹åŠ¨ç”»çš„å»¶è¿Ÿæ—¶é—´, ä¼ å…¥å€¼æ˜¯æµ®ç‚¹å€¼. 1ä¸º100%. ä¾‹å¦‚å¦‚æžœæ˜¯0.5 å…¥åœºåŠ¨ç”»å‘¨æœŸä¸º300ms(ä¸‹é¢å…³è”åŠ¨ç”»çš„durationæ—¶é—´), é‚£ä¹ˆæ¯ä¸ªå­å…ƒç´ éƒ½éœ€è¦å»¶è¿Ÿ150msæ‰èƒ½æ’­æ”¾å…¥åœºåŠ¨ç”». è€Œä¸”è¿™ä¸ªæ—¶é—´ä¼šæ ¹æ®itemçš„é€’å¢žè€Œå¢žåŠ . æ¯”æ–¹è¯´ç¬¬ä¸€ä¸ªä¸ºå»¶è¿Ÿ150ms, ç¬¬äºŒä¸ªå°±æ˜¯300msä¾æ¬¡ç±»æŽ¨. animationOrder: å­å…ƒç´ åŠ¨ç”»çš„é¡ºåº, æœ‰ä¸‰ç§é€‰æ‹©normal,reverse,random. reverseè¡¨ç¤ºæŽ’åœ¨åŽé¢çš„å…ƒç´ å…ˆæ‰§è¡Œå…¥åœºåŠ¨ç”». randoméšæœºå­å…ƒç´ æ‰§è¡ŒåŠ¨ç”». animation: ä¸ºå­å…ƒç´ æŒ‡å®šå…·ä½“çš„å…¥åœºåŠ¨ç”». é‡Œé¢æ”¾çš„å°±æ˜¯é’ˆå¯¹Viewçš„animationåŠ¨ç”»çš„xml layoutAnimationå£°æ˜Žå®Œæˆä¹‹åŽ, åœ¨è¦ä½œç”¨çš„ViewGroupæ ‡ç­¾ä¸­å¢žåŠ android:layoutAnimation:&quot;@anim/xxx&quot;è¿›è¡Œå…³è”å³å¯. åŒæ ·ä¹Ÿå¯ä»¥é€šè¿‡Javaä»£ç åŠ¨æ€åˆ›å»ºLayoutAnimationç±»æ¥å®žçŽ°. 12345678910//èŽ·å¾—å­å…ƒç´ éœ€è¦æ‰§è¡Œçš„ViewåŠ¨ç”»Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_item); //åˆ›å»ºä¸€ä¸ªLayoutAnimationåŠ¨ç”»å¯¹è±¡LayoutAnimationController controller = new LayoutAnimationController(animation);controller.setDelay(0.5f);controller.setOrder(LayoutAnimationController.ORDER_RANDOM); //å¯¹ViewGropè¿›è¡Œç»‘å®šlistView.setLayoutAnimation(controller); Activityçš„åˆ‡æ¢æ•ˆæžœActivityé»˜è®¤æ˜¯æœ‰ä¸€ç§åˆ‡æ¢æ•ˆæžœçš„. å¦‚æžœéœ€è¦è‡ªå®šä¹‰åˆ‡æ¢æ•ˆæžœ, ä¸»è¦ç”¨åˆ°overridePendingTransition()è¿™ä¸ªæ–¹æ³•, è¿™ä¸ªæ–¹æ³•å¿…é¡»åœ¨startActivity()æˆ–è€…finish()ä¹‹åŽè°ƒç”¨æ‰ä¼šç”Ÿæ•ˆ éœ€è¦çš„å½¢å‚æœ‰ä¸¤ä¸ª, ç¬¬ä¸€ä¸ªæ˜¯è¢«æ‰“å¼€æ—¶å€™æ‰€éœ€çš„åŠ¨ç”»èµ„æºid, ç¬¬äºŒä¸ªæ˜¯è¢«æš‚åœæ—¶,æ‰€éœ€çš„åŠ¨ç”»èµ„æºid. å±žæ€§åŠ¨ç”»å±žæ€§åŠ¨ç”»æ˜¯APIæ–°åŠ å…¥çš„ç‰¹æ€§, å’ŒViewåŠ¨ç”»ä¸åŒ, å®ƒå¯¹ä½œç”¨å¯¹è±¡è¿›è¡Œäº†æ‰©å±•, å±žæ€§åŠ¨ç”»å¯ä»¥å¯¹ä»»ä½•å¯¹è±¡åšåŠ¨ç”». å±žæ€§åŠ¨ç”»ä¸å†åƒViewåŠ¨ç”»é‚£æ ·åªèƒ½æ”¯æŒå››ç§ç®€å•çš„äº¤æ¢ . å±žæ€§åŠ¨ç”»ä¸­æœ‰valueAnimator. ObjectAnimator, AnimatorSetç­‰æ¦‚å¿µ ä½¿ç”¨å±žæ€§åŠ¨ç”»å±žæ€§åŠ¨ç”»å¯ä»¥å¯¹ä»»ä½•å¯¹è±¡çš„å±žæ€§è¿›è¡ŒåŠ¨ç”»è€Œä¸ä»…ä»…æ˜¯View, åŠ¨ç”»é»˜è®¤æ—¶é—´é—´éš”ä¸º300ms, é»˜è®¤å¸§çŽ‡10ms/å¸§. å¯ä»¥è¾¾åˆ°çš„æ•ˆæžœä¸º: åœ¨ä¸€æ®µæ—¶é—´é—´éš”å†…å®Œæˆå¯¹è±¡ä»Žä¸€ä¸ªå±žæ€§å€¼åˆ°å¦ä¸€ä¸ªå±žæ€§å€¼çš„æ”¹å˜. å±žæ€§åŠ¨ç”»æ˜¯ä»ŽAPI11å¢žåŠ çš„. å¦‚: æ”¹å˜ä¸€ä¸ªå¯¹è±¡çš„èƒŒæ™¯è‰²å±žæ€§, å…¸åž‹çš„æ”¹å˜Viewçš„èƒŒæ™¯è‰², ä¸‹é¢çš„åŠ¨ç”»å¯ä»¥è®©èƒŒæ™¯é¢œè‰²çš„æ¸å˜, åŠ¨ç”»ä¼šæ— é™å¾ªçŽ¯è€Œä¸”ä¼šæœ‰åè½¬æ•ˆæžœ. 123456ObjectAnimator colorAnim = ObjectAnimator.ofInt(activity_main, "backgroundColor", 0xffffa000, 0xffffa0ff); colorAnim.setDuration(5000); colorAnim.setEvaluator(new ArgbEvaluator()); colorAnim.setRepeatCount(ValueAnimator.INFINITE); colorAnim.setRepeatMode(ValueAnimator.REVERSE); colorAnim.start(); åŠ¨ç”»é›†åˆ,5ç§’å†…å¯¹Viewæ—‹è½¬å¹³ç§»ç¼©æ”¾é€æ˜Ž 12345678910111213AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether( ObjectAnimator.ofFloat(iv_main, "rotationX", 0,360), ObjectAnimator.ofFloat(iv_main, "rotationY", 0,360), ObjectAnimator.ofFloat(iv_main, "rotation", 0,360), ObjectAnimator.ofFloat(iv_main, "translationX", 0,200), ObjectAnimator.ofFloat(iv_main, "translationY", 0,200), ObjectAnimator.ofFloat(iv_main, "scaleX", 1,1.5f), ObjectAnimator.ofFloat(iv_main, "scaleY", 1,1.5f), ObjectAnimator.ofFloat(iv_main, "alpha", 1, 0.25f, 1) ); animatorSet.setDuration(5*1000).start(); ä¹Ÿå¯ä»¥ä½¿ç”¨xmlçš„å½¢å¼å½¢å¼æ¥å£°æ˜Ž 1234567891011121314151617181920212223242526&lt;set android:ordering=["together" | "sequentially"]&gt; &lt;objectAnimator android:propertyName="string" android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"]/&gt; &lt;animator android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"]/&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; ä»£ç ä¸­ä½¿ç”¨ï¼š 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator);set.setTarget(mButton);set.start(); ç†è§£æ’å€¼å™¨å’Œä¼°å€¼å™¨TimeInterpolatoræ—¶é—´æ’å€¼å™¨, ä½œç”¨æ˜¯æ ¹æ®æ—¶é—´æµé€çš„ç™¾åˆ†æ¯”æ¥è®¡ç®—å½“å‰å±žæ€§å€¼æ”¹å˜çš„ç™¾åˆ†æ¯”. ç³»ç»Ÿé¢„ç½®çš„æœ‰ LinearInterpolator(çº¿æ€§æ’å€¼å™¨:åŒ€é€ŸåŠ¨ç”») AccelerateDecelerateInterpolator(åŠ é€Ÿå‡é€Ÿæ’å€¼å™¨:åŠ¨ç”»ä¸¤å¤´æ…¢ä¸­é—´å¿«) DecelerateInterpolator(å‡é€Ÿæ’å€¼å™¨:åŠ¨ç”»è¶Šæ¥è¶Šæ…¢) TypeEvaluator ç±»åž‹ä¼°å€¼ç®—æ³•, ä¹Ÿå«ä¼°å€¼å™¨. ä½œç”¨æ˜¯æ ¹æ®å½“å‰å±žæ€§æ”¹å˜çš„ç™¾åˆ†æ¯”æ¥è®¡ç®—æ”¹å˜åŽçš„å±žæ€§å€¼. ç³»ç»Ÿé¢„ç½®çš„ä¼°å€¼å™¨æœ‰ IntEvaluator æ•´å½¢ä¼°å€¼å™¨ FloatEvaluator æµ®ç‚¹åž‹ä¼°å€¼å™¨ ArgbEvaluator Colorå±žæ€§ä¼°å€¼å™¨ å±žæ€§åŠ¨ç”»ä¸­çš„æ’å€¼å™¨å’Œä¼°å€¼å™¨éƒ½å¾ˆé‡è¦, ä»–ä»¬æ˜¯å®žçŽ°éžåŒ€é€ŸåŠ¨ç”»çš„é‡è¦æ‰‹æ®µ å±žæ€§åŠ¨ç”»è¦æ±‚å¯¹è±¡çš„è¯¥å±žæ€§æœ‰set``getæ–¹æ³•. æ’å€¼å™¨å’Œä¼°å€¼å™¨ç®—æ³•é™¤äº†ç³»ç»Ÿæä¾›çš„å¤–. ä¹Ÿå¯ä»¥è‡ªå®šä¹‰. å®žçŽ°æ–¹å¼ä¹Ÿå¾ˆç®€å•, å› ä¸ºæ’å€¼å™¨å’Œä¼°å€¼ç®—æ³•éƒ½æ˜¯ä¸€ä¸ªæŽ¥å£, ä¸”å†…éƒ¨éƒ½åªæœ‰ä¸€ä¸ªæ–¹æ³•, æˆ‘ä»¬åªè¦æ´¾ç”Ÿä¸€ä¸ªç±»å®žçŽ°æŽ¥å£æŽ¥å¯ä»¥. å…·ä½“å°±æ˜¯: è‡ªå®šä¹‰æ’å€¼å™¨éœ€è¦å®žçŽ°Interpolatoræˆ–è€…TimeInterpolator. è‡ªå®šä¹‰ä¼°å€¼ç®—æ³•éœ€è¦å®žçŽ°TypeEvaluator å±žæ€§åŠ¨ç”»çš„ç›‘å¬å™¨å±žæ€§åŠ¨ç”»æä¾›äº†ç›‘å¬å™¨ç”¨äºŽç›‘å¬åŠ¨ç”»çš„æ’­æ”¾è¿‡ç¨‹ ä¸»è¦æœ‰ä¸¤ä¸ªæŽ¥å£AnimatorUpdateListenerå’ŒAnimatorListeneræŽ¥å£. AnimatorListener é€šè¿‡æŽ¥å£çš„å®šä¹‰å¯ä»¥çœ‹å‡º, ç›‘å¬äº†åŠ¨ç”»çš„å¼€å§‹,ç»“æŸ,å–æ¶ˆ,ä»¥åŠé‡å¤æ’­æ”¾. ç³»ç»Ÿä¸ºäº†æ–¹ä¾¿å¼€å‘æä¾›äº†AnimatorListenerAdapterç±». ä»–æ˜¯AnimatorListenerçš„é€‚é…å™¨. è¿™æ ·å°±ä¸éœ€è¦éžå¾—å®žçŽ°å››ä¸ªæŠ½è±¡æ–¹æ³•è€Œæ˜¯æŒ‰ç…§æˆ‘ä»¬çš„éœ€è¦é€‰æ‹©å¤å†™. AnimatorUpdateListener æ¯”è¾ƒç‰¹æ®Š, ä»–ä¼šç›‘å¬æ•´ä¸ªåŠ¨ç”»è¿‡ç¨‹, åŠ¨ç”»æ˜¯ç”±è®¸å¤šå¸§ç»„æˆçš„. æ¯æ’­æ”¾ä¸€å¸§onAnimationUpdateå°±ä¼šè¢«è°ƒç”¨ä¸€æ¬¡ å¯¹ä»»æ„å±žæ€§åšåŠ¨ç”»é—®é¢˜: å¦‚æžœéœ€è¦æŠŠä¸€ä¸ªbuttonæŽ§ä»¶çš„å®½å¢žåŠ 200px. åº”è¯¥æ€Žä¹ˆåš? ViewåŠ¨ç”»åªæ˜¯æ”¯æŒå››ç§åŸºæœ¬çš„å±žæ€§æ“ä½œ, è€ŒScaleåªæ˜¯ç¼©æ”¾. å¹¶ä¸”è¿˜ä¼šå¯¹å†…å®¹è¿›è¡Œæ‹‰ä¼¸å¹¶ä¸”ä¼´éšç€yè½´çš„å¢žåŠ . æ‰€ä»¥å±žæ€§åŠ¨ç”»åœ¨è¿™é‡Œå°±å¯ä»¥æ´¾ä¸Šç”¨åœº. ä½†æ˜¯å¦‚æžœç›´æŽ¥å¯¹widthå±žæ€§è¿›è¡Œä¿®æ”¹é‚£ä¹ˆä¸ä¼šæœ‰æ•ˆæžœ. åˆ†æžä¸€ä¸‹: å±žæ€§åŠ¨ç”»çš„åŽŸç†: å±žæ€§åŠ¨ç”»è¦æ±‚åŠ¨ç”»ä½œç”¨çš„å¯¹è±¡æä¾›è¯¥å±žæ€§çš„getå’Œsetæ–¹æ³•, å±žæ€§åŠ¨ç”»æ ¹æ®å¤–ç•Œä¼ é€’çš„è¯¥å±žæ€§å€¼çš„åˆå§‹å€¼å’Œæœ€ç»ˆå€¼, ä»¥åŠ¨ç”»çš„æ•ˆæžœå¤šæ¬¡è°ƒç”¨setæ¯æ¬¡setçš„å€¼ä¹Ÿæ˜¯ä¸åŒ. æœ€ç»ˆè¾¾åˆ°ç»ˆç‚¹å€¼. æ‰€ä»¥è¦è®©åŠ¨ç”»ç”Ÿæ•ˆåº”è¯¥æ»¡è¶³ä¸¤ä¸ªæ¡ä»¶: å¿…é¡»æä¾›setXXX()æ–¹æ³•, å¦‚æžœåŠ¨ç”»æ²¡æœ‰ä¼ é€’åˆå§‹å€¼è¿˜è¦æä¾›getXXX()æ–¹æ³•. è¿™æ ·ç³»ç»Ÿåœ¨éœ€è¦åˆå§‹å±žæ€§çš„æ—¶å€™åœ¨å–å€¼æ—¶ä¸ä¼šå› ä¸ºæ²¡æœ‰getXXX()è€Œå‘ç”ŸCrash. setä¿®æ”¹çš„å€¼å¿…é¡»èƒ½æ”¹é€šè¿‡æŸç§å½¢å¼åæ˜ å‡ºæ¥, æ¯”å¦‚ä¼šå¸¦æ¥UIçš„æ”¹å˜. (å¦‚æžœä¸æ»¡è¶³è¿™æ¡,åŠ¨ç”»æ— æ•ˆæžœä½†ä¸ä¼šCrash) é‚£Buttonæœ¬èº«å…·å¤‡setWidth()ä¸ºä»€ä¹ˆä¼šæ— æ•ˆæžœ. è¿™æ˜¯å› ä¸ºè™½ç„¶Buttonæä¾›äº†æ–¹æ³•, ä½†æ˜¯è¿™ä¸ªsetWidth()æ–¹æ³•å¹¶ä¸æ˜¯æ”¹å˜è§†å›¾å¤§å°çš„, ä»–æ˜¯TextViewæ–°æ·»åŠ çš„æ–¹æ³•, Viewå´æ²¡æœ‰è¿™æ ·çš„æ–¹æ³•. è€ŒsetWidth()æ–¹æ³•çš„å†…éƒ¨,ä½œç”¨ä¸æ˜¯è®¾ç½®Viewçš„å¤§å°, è€Œæ˜¯è®¾ç½®TextViewçš„æœ€å¤§å®½åº¦å’Œæœ€å°å®½åº¦, è¿™ä¸ªå’ŒTextViewçš„å®½æ˜¯ä¸¤ä¸ªä¸œè¥¿. è¿™æ ·è¯´æŽ§ä»¶çš„å®½åº¦å¯¹åº”xmlä¸­çš„layout_width, è€ŒsetWidth()å¯¹åº”çš„å°±æ˜¯xmlä¸­çš„widthå±žæ€§. æ‰€ä»¥ç»¼åˆä¸Šè¿°åŽŸå› , æ»¡è¶³æ¡ä»¶ä¸€è€Œä¸æ»¡è¶³æ¡ä»¶äºŒ. å®˜ç½‘æ–‡æ¡£ä¸­ç»™å‡ºäº†ä¸‰ç§è§£å†³æ–¹æ¡ˆ: ç»™ä½ çš„å¯¹è±¡åŠ ä¸Šgetå’Œsetæ–¹æ³•, å¦‚æžœä½ æœ‰æƒé™çš„è¯. ç”¨ä¸€ä¸ªç±»æ¥åŒ…è£…(Wrapper)åŽŸå§‹å¯¹è±¡, é—´æŽ¥ä¸ºå…¶æä¾›getå’Œsetæ–¹æ³•. é‡‡ç”¨valueAnimator, ç›‘å¬åŠ¨ç”»è¿‡ç¨‹,è‡ªå·±å®žçŽ°å±žæ€§çš„æ”¹å˜. æ¯”è¾ƒï¼š è™½ç„¶ç®€å•ä½†æ˜¯æ²¡æœ‰æƒé™åŽ»SDKå†…éƒ¨å®žçŽ°åŽ» å¯ä»¥åˆ›å»ºä¸€ä¸ªå†…éƒ¨åŒ…è£…ç±»åˆ›å»ºset(),get()æ–¹æ³•å¯¹ViewçœŸæ­£çš„å®½åº¦çš„LayoutParams.widthå±žæ€§è¿›è¡Œä¿®æ”¹. é‡‡ç”¨ValueAnimator, ç›‘å¬åŠ¨ç”»è¿‡ç¨‹, è‡ªå·±å®žçŽ°å±žæ€§æ”¹å˜. ValueAnimatoræœ¬èº«ä¸ä½œç”¨äºŽä»»ä½•å¯¹è±¡. ä½†æ˜¯ä»–å¯ä»¥å¯¹ä¸€ä¸ªå€¼åšåŠ¨ç”». ç„¶åŽç›‘å¬å…¶åŠ¨ç”»è¿‡ç¨‹ï¼Œåœ¨åŠ¨ç”»è¿‡ç¨‹ä¸­é…åˆä¼°å€¼å™¨Evaluatorä¿®æ”¹æˆ‘ä»¬çš„å¯¹è±¡å±žæ€§. å±žæ€§åŠ¨ç”»çš„å·¥ä½œåŽŸç†å‰é¢è¯´è¿‡, è¯´å±žæ€§ç”»è¦æ±‚ä½œç”¨çš„å¯¹è±¡æä¾›è¯¥å±žæ€§æ–¹æ³•setæ–¹æ³•, å±žæ€§åŠ¨ç”»æ ¹æ®ä¼ é€’çš„è¯¥å±žæ€§çš„åˆå§‹å€¼å’Œæœ€ç»ˆå€¼, ä»¥åŠ¨ç”»çš„æ•ˆæžœå¤šæ¬¡åŽ»è°ƒç”¨setæ–¹æ³•. æ¯æ¬¡setæ–¹æ³•æ—¶å€™ä¼ é€’çš„å€¼éƒ½æ˜¯ä¸ä¸€æ ·çš„. ä¹Ÿå°±æ˜¯éšç€æ—¶é—´çš„æŽ¨ç§»æ‰€ä¼ é€’çš„å€¼ä¼šè¶Šæ¥è¶ŠæŽ¥è¿‘ç»ˆç‚¹å€¼. æºç åˆ†æž: é’ˆå¯¹ObjectAnimatorçš„start()ä¸ºå…¥å£ 1234567891011121314151617181920212223242526272829303132333435363738394041424344 @Overridepublic void start() &#123; // See if any of the current active/pending animators need to be canceled AnimationHandler handler = sAnimationHandler.get(); if (handler != null) &#123; int numAnims = handler.mAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; numAnims = handler.mPendingAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; numAnims = handler.mDelayedAnims.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; &#125; if (DBG) &#123; Log.d(LOG_TAG, "Anim target, duration: " + getTarget() + ", " + getDuration()); for (int i = 0; i &lt; mValues.length; ++i) &#123; PropertyValuesHolder pvh = mValues[i]; Log.d(LOG_TAG, " Values[" + i + "]: " + pvh.getPropertyName() + ", " + pvh.mKeyframes.getValue(0) + ", " + pvh.mKeyframes.getValue(1)); &#125; &#125; super.start();&#125; è¿™æ®µä»£ç ä¸»è¦å°±æ˜¯å–æ¶ˆå’Œå½“å‰åŠ¨ç”»ç›¸åŒçš„åŠ¨ç”». æœ€å¼€å§‹åˆ¤æ–­äº†å½“å‰åŠ¨ç”»,ç­‰å¾…åŠ¨ç”»,å»¶è¿ŸåŠ¨ç”»æ˜¯å¦æœ‰ä¸€è‡´çš„. å¦‚æžœæœ‰é‚£ä¹ˆå°±ç»™å–æ¶ˆ. æœ€åŽè°ƒç”¨äº†çˆ¶ç±»æ–¹æ³•. å› ä¸ºObjectAnimatorç»§æ‰¿äº†ValueAnimator,æ‰€ä»¥ç»§ç»­çœ‹ä¸€ä¸‹çˆ¶ç±»çš„start() 1234567891011121314151617181920212223242526private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException("Animators may only be run on Looper threads"); &#125; mReversing = playBackwards; mPlayingBackwards = playBackwards; int prevPlayingState = mPlayingState; mPlayingState = STOPPED; mStarted = true; mStartedDelay = false; mPaused = false; updateScaledDuration(); // in case the scale factor has changed since creation time AnimationHandler animationHandler = getOrCreateAnimationHandler(); animationHandler.mPendingAnimations.add(this); if (mStartDelay == 0) &#123; // This sets the initial value of the animation, prior to actually starting it running if (prevPlayingState != SEEKED) &#123; setCurrentPlayTime(0); &#125; mPlayingState = STOPPED; mRunning = true; notifyStartListeners(); &#125; animationHandler.start();&#125; å±žæ€§åŠ¨ç”»éœ€è¦è¿è¡Œåœ¨æœ‰Looperçš„çº¿ç¨‹ä¸­, æœ€ç»ˆä¼šè°ƒç”¨AnimationHandler.start()æ–¹æ³•.AnimationHandlerå¹¶ä¸æ˜¯Handler, ä»–æ˜¯ä¸€ä¸ªRunnable. åŽé¢ä¼šè°ƒåˆ°JNIå±‚, ç„¶åŽJNIå±‚è¿˜ä¼šè°ƒå›ž, ç„¶åŽrunæ–¹æ³•ä¼šè¢«è°ƒç”¨, è¿™ä¸ªRunableæ¶‰åŠå’Œåº•å±‚çš„äº¤äº’. ç•¥è¿‡. çœ‹é‡ç‚¹. ValueAnimatorçš„doAnimationFrame()æ–¹æ³•, å†…éƒ¨æœ€åŽè°ƒç”¨äº†animationFrame()æ–¹æ³•,è€ŒanimationFrame()å†…éƒ¨è°ƒç”¨äº†animateValue()æ–¹æ³• 1234567891011121314void animateValue(float fraction) &#123; fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].calculateValue(fraction); &#125; if (mUpdateListeners != null) &#123; int numListeners = mUpdateListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mUpdateListeners.get(i).onAnimationUpdate(this); &#125; &#125;&#125; çœ‹åˆ°äº†calculateValue()æ–¹æ³•, è¿™ä¸ªå°±æ˜¯è®¡ç®—æ¯å¸§åŠ¨ç”»æ‰€å¯¹åº”çš„å±žæ€§çš„å€¼, ç„¶åŽçœ‹ä¸€ä¸‹set,getæ–¹æ³•. æ¯”å¦‚ä¹‹å‰è¯´çš„å¦‚æžœæ²¡æœ‰åˆå§‹å€¼, åˆ™è°ƒç”¨getæ–¹æ³•ç­‰.. æŸ¥çœ‹PropertyValuesHolderç±»çš„setupValue() 12345678910111213141516private void setupValue(Object target, Keyframe kf) &#123; if (mProperty != null) &#123; Object value = convertBack(mProperty.get(target)); kf.setValue(value); &#125; if (mGetter == null) &#123; Class targetClass = target.getClass(); setupGetter(targetClass); if (mGetter == null) &#123; // Already logged the error - just return to avoid NPE return; &#125; &#125; Object value = convertBack(mGetter.invoke(target)); kf.setValue(value); å½“åŠ¨ç”»çš„ä¸‹ä¸€å¸§åˆ°æ¥çš„æ—¶, setAnimatedValue()æ–¹æ³•ä¼šå°†æ–°çš„å±žæ€§å€¼ç»™å¯¹è±¡, è°ƒç”¨å…¶set()æ–¹æ³•.åŒæ ·setä¹Ÿæ˜¯åå°„è°ƒç”¨ 123456789void setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); &#125; if (mSetter != null) &#123; mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); &#125;&#125; ä½¿ç”¨åŠ¨ç”»çš„æ³¨æ„äº‹é¡¹ OOMé—®é¢˜: åœ¨å¸§åŠ¨ç”»æ—¶å€™å®¹æ˜“å‘ç”Ÿ å†…å­˜æ³„æ¼: å¦‚æžœæœ‰æ— é™å¾ªçŽ¯çš„å±žæ€§åŠ¨ç”», åœ¨ç•Œé¢é€€å‡ºçš„æ—¶å€™ä¸€å®šè¦åœæ­¢åŠ¨ç”» ,å¦åˆ™activityä¼šæ— æ³•é‡Šæ”¾. è€ŒViewåŠ¨ç”»å¹¶ä¸å­˜åœ¨æ­¤é—®é¢˜. å…¼å®¹æ€§é—®é¢˜: ä¸»è¦æ˜¯3.0ä»¥ä¸‹ç³»ç»Ÿ ViewåŠ¨ç”»é—®é¢˜: å› ä¸ºæ˜¯å¯¹åŽŸå§‹Viewåšçš„å½±åƒæ•ˆæžœ. å¹¶æœªçœŸæ­£æ”¹å˜Viewçš„çŠ¶æ€. æ‰€ä»¥åœ¨åŠ¨ç”»å®Œæˆä¹‹åŽï¼Œå›žå¯¼è‡´è®¾ç½®setVisibility(View.GONE)æ— æ•ˆ. è¿™ä¸ªæ—¶å€™è°ƒç”¨view.clearAnimation()æ¸…é™¤Viewæ•ˆæžœå³å¯ã€‚ ä¸è¦ä½¿ç”¨px åŠ¨ç”»äº¤äº’. ç³»ç»Ÿ3.0ä¹‹å‰æ— è®ºæ˜¯å±žæ€§åŠ¨ç”»è¿˜æ˜¯ViewåŠ¨ç”»æ–°çš„ä½ç½®éƒ½æ— æ³•è§¦å‘å•å‡»äº‹ä»¶.éœ€è¦æ³¨æ„ï¼› ä»Ž3.0å¼€å§‹ï¼Œå±žæ€§åŠ¨ç”»çš„ç‚¹å‡»äº‹ä»¶çš„è§¦å‘ä½ç½®ä¸ºç§»åŠ¨åŽä½ç½®ï¼Œä½†æ˜¯ViewåŠ¨ç”»ä»åœ¨åŽŸä½ç½®ã€‚ ç¡¬ä»¶åŠ é€Ÿ,æé«˜åŠ¨ç”»æµç•…åº¦]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>å±žæ€§åŠ¨ç”»</tag>
        <tag>ViewåŠ¨ç”»</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Androidä¸­çš„Drawable]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E7%9A%84Drawable%2F</url>
    <content type="text"><![CDATA[Drawableç®€ä»‹Drawableè¡¨ç¤ºä¸€ç§å›¾åƒçš„æ¦‚å¿µ. ä¼˜ç‚¹:ä½¿ç”¨æ¯”è‡ªå®šä¹‰Viewçš„æˆæœ¬ä½Ž, éžå›¾ç‰‡ç±»åž‹çš„Drawableå ç”¨ç©ºé—´è¾ƒå°. Drawableæœ¬èº«æ˜¯ä¸€ä¸ªæŠ½è±¡ç±». æ˜¯æ‰€æœ‰Drawableå¯¹è±¡çš„åŸºç±», æ¯ä¸ªå…·ä½“çš„Drawableéƒ½æ˜¯å…¶å­ç±». Drawableå†…éƒ¨å®½é«˜é€šè¿‡getIntrinsicWidthå’ŒgetIntrinsicHeightè¿™ä¸¤ä¸ªæ–¹æ³•èŽ·å¾—. éœ€è¦æ³¨æ„è¿™ä¸ªå†…éƒ¨å®½é«˜çš„æ¦‚å¿µé’ˆå¯¹ä¸åŒçš„ç±»åž‹çš„Drawable, å¯¹äºŽå›¾ç‰‡å½¢æˆçš„Drawableå†…éƒ¨å®½é«˜å°±æ˜¯å›¾ç‰‡çš„å®½é«˜. è€Œé¢œè‰²æ‰€å½¢æˆçš„Drawableæ²¡æœ‰å†…éƒ¨å®½é«˜çš„æ¦‚å¿µ. Drawableçš„å†…éƒ¨å®½é«˜ä¸ç­‰äºŽå®ƒçš„å¤§å°. å½“ä½œä¸ºViewçš„èƒŒæ™¯çš„è§†å›¾, Drawableä¼šè¢«æ‹‰ä¼¸è‡³Viewçš„åŒç­‰å¤§å°. Drawableçš„åˆ†ç±»BitmapDrawableè¡¨ç¤ºä¸€å¼ å›¾ç‰‡, åœ¨å¼€å‘ä¸­ç›´æŽ¥å¼•ç”¨åŽŸå§‹å›¾ç‰‡ä¹Ÿå¯, ä¸‹é¢ç»™å‡ºåœ¨XMLä¸­æè¿°ç¨å¾®å®Œæ•´çš„å£°æ˜Ž 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@mipmap/ic_sample" android:antialias="true" android:dither="true" android:filter="true" android:gravity="top" android:mipMap="true" android:tileMode="repeat" &gt;&lt;/bitmap&gt; src: å›¾ç‰‡çš„èµ„æºæ–‡ä»¶id(ASä¸‹å¯èƒ½ä¸ä¼šè‡ªåŠ¨æç¤ºmipmap,ç›´æŽ¥å†™å…¥å³å¯) antialias: å›¾ç‰‡æŠ—é”¯é½¿.å±žæ€§å€¼boolean å¼€å¯å¯ä»¥è®©å›¾ç‰‡å˜å¾—å¹³æ»‘. dither: æŠ–åŠ¨æ•ˆæžœ. å±žæ€§å€¼Boolean. å½“å›¾ç‰‡çš„åƒç´ é…ç½®å’Œæ‰‹æœºå±å¹•çš„åƒç´ é…ç½®ä¸ä¸€è‡´æ—¶,å¼€å¯æ­¤é€‰é¡¹å¯ä»¥è®©é«˜è´¨é‡çš„å›¾ç‰‡åœ¨ä½Žè´¨é‡çš„å±å¹•ä¸Šç»§ç»­ä¿æŒè¾ƒå¥½æ•ˆæžœ. ä¾‹å¦‚å›¾ç‰‡æ¨¡å¼ä¸ºARGB8888,è€Œè®¾å¤‡å±å¹•æ‰€æ”¯æŒä¸ºRGB555. å¼€å¯å¯ä»¥è®©å›¾ç‰‡ä¸ä¼šè¿‡äºŽå¤±çœŸ. filter: è¿‡æ»¤æ•ˆæžœ. å½“å›¾ç‰‡å°ºå¯¸è¢«æ‹‰ä¼¸æˆ–è€…åŽ‹ç¼©,å¯ä»¥ä¿æŒè¾ƒå¥½çš„æ•ˆæžœ. gravity: å¯ä»¥å¯¹å›¾ç‰‡è¿›è¡Œå®šä½. å¯ä»¥ä½¿ç”¨|ç»„åˆå±žæ€§ä½¿ç”¨. å¯ä¾›ä½¿ç”¨çš„å±žæ€§ å¯é€‰é¡¹ å«ä¹‰ top æ”¾åœ¨é¡¶éƒ¨, ä¸æ”¹å˜å›¾ç‰‡å¤§å° bottom æ”¾åœ¨åº•éƒ¨, ä¸æ”¹å˜å›¾ç‰‡å¤§å° left æ”¾åœ¨å·¦ç«¯, ä¸æ”¹å˜å›¾ç‰‡å¤§å° right æ”¾åœ¨å³ç«¯, ä¸æ”¹å˜å›¾ç‰‡å¤§å° center_vertical ä½¿å›¾ç‰‡ç«–ç›´å±…ä¸­, ä¸æ”¹å˜å›¾ç‰‡å¤§å° fill_vertical å›¾ç‰‡ç«–ç›´æ–¹å‘å¡«å……å®¹å™¨ center_horizontal ä½¿å›¾ç‰‡æ°´å¹³å±…ä¸­, ä¸æ”¹å˜å›¾ç‰‡å¤§å° fill_horizontal å›¾ç‰‡æ°´å¹³æ–¹å‘å¡«å……å®¹å™¨ center å›¾ç‰‡åŒæ—¶æ°´å¹³å’Œåž‚ç›´å±…ä¸­, ä¸æ”¹å˜å›¾ç‰‡å¤§å° fill å›¾ç‰‡æ°´å¹³å’Œç«–ç›´æ–¹å‘å‡å¡«å……å®¹å™¨, è¿™æ˜¯é»˜è®¤å€¼ clip_vertical è¡¨ç¤ºç«–ç›´æ–¹å‘çš„è£å‰ª, è¾ƒå°‘ä½¿ç”¨ clip_horizontal è¡¨ç¤ºæ°´å¹³æ–¹å‘çš„è£å‰ª, è¾ƒå°‘ä½¿ç”¨ mipmap: çº¹ç†æ˜ å°„ é»˜è®¤ä¸ºfalse tileMode: å¹³é“ºæ¨¡å¼. æœ‰å››ç§å€¼: disableå…³é—­å¹³é“ºæ¨¡å¼(é»˜è®¤å€¼), repeatæ™®é€šå¹³é“ºå¼€å¯, mirrorå¹³é“ºçš„åŒæ—¶,å¹³é“ºå›¾ç‰‡åšé•œé¢æ•ˆæžœ. clampåœ¨åŽŸå§‹å›¾ç‰‡æœ€å³è¾¹åƒç´ å‘å³å»¶ä¼¸, æœ€ä¸‹è¾¹åƒç´ å‘ä¸‹å»¶ä¼¸.å¦‚å›¾: NinePatchDrawable è¡¨ç¤ºä¸€å¼ .9æ ¼å¼çš„å›¾ç‰‡, .9å›¾ç‰‡å¯ä»¥è‡ªåŠ¨çš„æ ¹æ®æ‰€éœ€è¦çš„å®½é«˜è¿›è¡Œç›¸åº”çš„ç¼©æ”¾å¹¶ä¿è¯ä¸å¤±çœŸ. å’ŒBitmapDrawableä½¿ç”¨ä¸€æ ·ç›´æŽ¥å¼•å…¥å›¾ç‰‡å³å¯. xmlæ–¹å¼å¦‚ä¸‹: 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;nine-patch xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;xxxx&quot; android:dither=&quot;true&quot;/&gt; ShapeDrawableè¿™æ˜¯ä¸€ç§é€šè¿‡é¢œè‰²æ¥æž„æˆçš„å›¾ç‰‡, å®ƒå¯ä»¥ä¸ºçº¯è‰²çš„å›¾å½¢, ä¹Ÿå¯ä»¥å…·æœ‰æ¸å˜çš„å›¾å½¢. ä»¥ä¸‹æ˜¯ä¸€ä¸ªç®€å•ä½¿ç”¨æ–¹æ³• 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;!--åœ†è§’--&gt; &lt;corners android:radius=&quot;50dp&quot;/&gt; &lt;padding android:top=&quot;5dp&quot;/&gt; &lt;!--å¡«å……--&gt; &lt;solid android:color=&quot;@color/colorPrimary&quot;/&gt; &lt;!--gradient å’Œsolid äº’æ–¥å±žæ€§è°æ”¾åœ¨åŽé¢è°æ‰æœ‰æ•ˆ--&gt; &lt;!--æ¸å˜--&gt; &lt;gradient android:angle=&quot;90&quot; android:startColor=&quot;#f00&quot; android:centerColor=&quot;#0f0&quot; android:endColor=&quot;#00f&quot;/&gt; &lt;!--è¾¹æ¡†--&gt; &lt;stroke android:width=&quot;30dp&quot; android:color=&quot;#ff0000&quot; /&gt;&lt;/shape&gt; æ¥è¯´è¯´å…·ä½“çš„å±žæ€§éƒ½æœ‰ä»€ä¹ˆ shape: è¡¨ç¤ºå›¾ç‰‡çš„å½¢çŠ¶, æœ‰å››ä¸ªé€‰é¡¹: rectangle()çŸ©å½¢, oval(æ¤­åœ†), line(æ¨ªçº¿), ring(åœ†çŽ¯). é»˜è®¤å€¼ä¸ºçŸ©å½¢. å¦å¤–lineå’Œringè¿™ä¸¤ä¸ªé€‰é¡¹å¿…é¡»è¦é€šè¿‡&lt;stroke&gt;æ ‡ç­¾æ¥æŒ‡å®šçº¿çš„å®½åº¦å’Œé¢œè‰²ç­‰ä¿¡æ¯, å¦åˆ™æ— æ³•è¾¾åˆ°é¢„æœŸæ•ˆæžœ.å½“ringè¿™ä¸ªå½¢çŠ¶è¿˜éœ€è¦æ·»åŠ å‡ ä¸ªå±žæ€§innerRadiusåœ†çŽ¯å†…åŠå¾„, thicknessåœ†çŽ¯çš„åŽšåº¦,å¤–åŠå¾„å‡åŽ»å†…åŠå¾„çš„è·ç¦». è¿˜æœ‰ä¸¤ä¸ªåŠåˆ†æ¯”çš„å±žæ€§.æ•ˆæžœä¸€æ ·. useLevel:åŸºæœ¬éƒ½æ˜¯ç”¨false, å¦åˆ™å¯èƒ½æ— æ³•åˆ°è¾¾é¢„æœŸçš„æ˜¾ç¤ºæ•ˆæžœ,é™¤éžè¢«å½“åšLevelListDrawable.å¦‚ä¸‹å›¾å¯ä»¥çœ‹çœ‹å‡ ä¸ªæ–¹å¼çš„æ ·å­ &lt;corner&gt; è¡¨ç¤ºshapeçš„å››ä¸ªè§’åº¦. å®ƒåªé€‚ç”¨äºŽçŸ©å½¢shape. æ”¯æŒå±žæ€§æ€»å…±æœ‰äº”ä¸ª,ä¸€ä¸ªRadiuså’Œå››ä¸ªé¡¶è§’å¦‚topLeftRadiusç­‰ç­‰. Radiusçš„ä¼˜å…ˆçº§æœ€ä½Ž, ä¼šè¢«å…¶ä»–å±žæ€§è¦†ç›–. &lt;gradient&gt; å®ƒä¸Ž&lt;solid&gt;æ ‡ç­¾æ˜¯äº’ç›¸äº’æ–¥çš„. å…¶ä¸­solidè¡¨ç¤ºçº¯è‰²å¡«å……, è€Œgradientåˆ™è¡¨ç¤ºæ¸å˜æ•ˆæžœ. æœ‰å¦‚ä¸‹å±žæ€§: android:angle â€“æ¸å˜çš„è§’åº¦, é»˜è®¤ä¸º0, å…¶å€¼å¿…é¡»ä¸º45çš„å€æ•°. 0è¡¨ç¤ºä»Žå·¦åˆ°å³, 90è¡¨ç¤ºä»Žä¸‹åˆ°ä¸Š. android:centerX â€“æ¸å˜çš„ä¸­å¿ƒç‚¹æ¨ªåæ ‡(èŒƒå›´0~1) android:centerY â€“æ¸å˜çš„ä¸­å¿ƒç‚¹çºµåæ ‡(èŒƒå›´0~1) android:startColor â€“æ¸å˜çš„èµ·å§‹è‰² android:centerColor â€“æ¸å˜çš„ä¸­é—´è‰² android:endColor â€“æ¸å˜çš„ç»“æŸè‰² android:gradientRadius â€“æ¸å˜åŠå¾„, ä»…å½“android:type=â€radialâ€æ—¶æœ‰æ•ˆ,å¹¶ä¸”å½“type=â€radialâ€çš„æ—¶å€™å¿…é¡»å£°æ˜Žæ­¤å±žæ€§,å¦åˆ™å´©æºƒ android:useLevel â€“ä¸€èˆ¬ä¸ºfalse.å½“Drawableä½œä¸ºStateListDrawableä½¿ç”¨æ—¶ä¸ºtrue android:type â€“æ¸å˜çš„ç±»åž‹, æœ‰linear(çº¿æ€§æ¸å˜), radial(å¾„å‘æ¸å˜), sweep(æ‰«æçº¿æ¸å˜)ä¸‰ç§, é»˜è®¤ä¸ºçº¿æ€§æ¸å˜ çœ‹çœ‹typeä¸åŒçš„æ ¼å¼ä»€ä¹ˆæ ·å­ &lt;solid&gt;è¡¨ç¤ºçº¯è‰²å¡«å……, é€šè¿‡android:coloræ¥æŒ‡å®šé¢œè‰² &lt;stroke&gt; shapeçš„æè¾¹,æœ‰å››ä¸ªå±žæ€§. widthæè¾¹çš„å®½åº¦, coloræè¾¹çš„é¢œè‰², dashWidthç»„æˆè™šçº¿çš„çº¿æ®µçš„å®½åº¦, dashGapç»„æˆè™šçº¿çš„çº¿æ®µä¹‹é—´çš„é—´éš”. &lt;padding&gt; è¿™ä¸ªè¡¨ç¤ºç©ºç™½, ä½†æ˜¯ä»–è¡¨ç¤ºçš„ä¸æ˜¯shapeçš„ç©ºç™½, è€Œæ˜¯åŒ…å«å®ƒçš„Viewçš„ç©ºç™½, æœ‰ä¸Šä¸‹å·¦å³å››ä¸ªå±žæ€§ &lt;size&gt; Drawableæœ‰ä¸¤ä¸ªæ–¹æ³•èŽ·å¾—å›ºæœ‰é«˜åº¦. getIntrinsicWidth(), getIntrinsicHeight(). å°±æ˜¯å¦‚æžœæ˜¯å›¾ç‰‡Drawableé‚£å°±æ˜¯å›¾ç‰‡çš„å±žæ€§å¤§å°. å¦‚æžœä¸æ˜¯é‚£å°±æ˜¯è¿”å›ž-1. å¦‚æžœsizeæ ‡ç­¾è®¾ç½®äº†å¤§å°. åœ¨æ–¹æ³•è¿”å›žçš„æ—¶å€™å°±ä¸å†æ˜¯-1. ä½†æ˜¯ä½œä¸ºViewçš„èƒŒæ™¯, shapeè¿˜ä¼šè¢«æ‹‰ä¼¸æˆ–è€…ç¼©ä¸ºViewçš„å¤§å°. LayerDrawableå¯¹åº”çš„æ ‡ç­¾æ˜¯&lt;layer-list&gt;, ä»–è¡¨ç¤ºä¸€ä¸ªå±‚æ¬¡åŒ–å¾—Drawableé›†åˆ.é€šè¿‡å°†ä¸åŒçš„Drawableæ”¾ç½®åœ¨ä¸åŒçš„å±‚é¢ä¸Šä»Žè€Œè¾¾åˆ°ä¸€ç§å åŠ çš„æ•ˆæžœ. ä¸€ä¸ªè¿™ç§æ ‡ç­¾å¯ä»¥åŒ…å«å¤šä¸ªitem, æ¯ä¸ªitemè¡¨ç¤ºä¸€ä¸ªDrawable. Itemçš„ç»“æž„æ¯”è¾ƒç®€å•ï¼Œå¸¸è§çš„æœ‰android:topã€android:bottomã€android:leftã€android:rightï¼Œè¡¨ç¤ºDrawableç›¸å¯¹äºŽViewçš„ä¸Šä¸‹å·¦å³åç§»é‡ã€‚å¯ä»¥ç›´æŽ¥é€šè¿‡drawableå±žæ€§å¼•ç”¨ä¸€ä¸ªDrawableä¹Ÿå¯ä»¥åœ¨itemä¸­è‡ªå®šä¹‰ä¸€ä¸ªDrawable. 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#0ac39e" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="60dp"&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="1dp" android:left="1dp" android:right="1dp"&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; StateListDrawableStateListå¯¹åº”&lt;selector&gt;æ ‡ç­¾, ä¹Ÿæ˜¯Drawableé›†åˆ. è¿™ä¸ªæˆ‘ä»¬ç»å¸¸ä½¿ç”¨åœ¨å¼€å‘ä¸­çš„æŒ‰é’®çŠ¶æ€é€‰æ‹©å™¨. 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize="true" android:dither="true" android:variablePadding="false" &gt; &lt;!-- åªæ˜¯åˆ—ä¸¾ä¸€ä¸‹ &lt;item android:state_pressed="true" android:drawable="xxx"/&gt; &lt;item android:state_focused="true" android:drawable="xxx"/&gt; &lt;item android:state_hovered="true" android:drawable="xxx"/&gt; &lt;item android:state_pressed="true" android:drawable="xxx"/&gt; &lt;item android:state_selected="true" android:drawable="xxx"/&gt; &lt;item android:state_checkable="true" android:drawable="xxx"/&gt; &lt;item android:state_checked="true" android:drawable="xxx"/&gt; &lt;item android:state_enabled="true" android:drawable="xxx"/&gt; &lt;item android:state_activated="true" android:drawable="xxx"/&gt; &lt;item android:state_window_focused="true" android:drawable="xxx"/&gt; --&gt;&lt;/selector&gt; selectæ ‡ç­¾å¯¹åº”æœ‰ä¸‰ä¸ªå±žæ€§ constantSize: ç”¨äºŽStateListDrawableçš„å›ºæœ‰å¤§å°æ˜¯å¦ä¸éšç€å…¶çŠ¶æ€æ”¹å˜è€Œæ”¹å˜çš„, å› ä¸ºçŠ¶æ€çš„æ”¹å˜ä¼šåˆ‡æ¢ä¸åŒçš„itemçš„drawable, è€Œä¸åŒçš„drawableå…·æœ‰ä¸åŒçš„å›ºæœ‰å¤§å°. å¦‚æžœä¸ºtrueé‚£å°±æ˜¯æ•´ä¸ªStateListDrawableå›ºæœ‰å¤§å°æ˜¯å†…éƒ¨æ‰€æœ‰Drawableçš„æœ€å¤§å›ºæœ‰å¤§å°çš„å€¼. falseä¼šéšä¹‹å˜åŒ–, é»˜è®¤ä¸ºfalse dither: æ˜¯å¦å¼€å¯æŠ–åŠ¨æ•ˆæžœ, é»˜è®¤ä¸ºtrue variablePadding: è¡¨ç¤ºpaddingæ˜¯å¦éšç€çŠ¶æ€çš„æ”¹å˜è€Œæ”¹å˜, paddingå–å¾—å€¼æ˜¯æ‰€æœ‰Drawableçš„æœ€å¤§å€¼. é»˜è®¤ä¸ºfalse. ä¸ä¼šéšä¹‹æ”¹å˜. &lt;item&gt;æ ‡ç­¾ä¹Ÿæ¯”è¾ƒç®€å•, æŒ‡å®šä¸€ä¸ªdrawable,å¹¶åŠ ä¸€ä¸ªçŠ¶æ€åˆ¤æ–­å€¼. ä¸‹é¢ç»™å‡ºå¸¸è§çš„çŠ¶æ€åˆ¤æ–­ çŠ¶æ€ å«ä¹‰ android:state_pressed è¡¨ç¤ºæŒ‰ä¸‹çŠ¶æ€, æ¯”å¦‚Buttonè¢«æŒ‰ä¸‹åŽæ²¡æœ‰æ¾å¼€æ—¶çš„çŠ¶æ€ android:state_focused è¡¨ç¤ºViewå·²ç»èŽ·å–äº†ç„¦ç‚¹ android:state_selected è¡¨ç¤ºç”¨æˆ·é€‰æ‹©äº†View android:state_checked è¡¨ç¤ºç”¨æˆ·é€‰ä¸­äº†View, ä¸€èˆ¬é€‚ç”¨äºŽCheckBoxè¿™ç±»åœ¨é€‰ä¸­å’Œéžé€‰ä¸­ä¹‹é—´åˆ‡æ¢çš„ android:state_enabled è¡¨ç¤ºViewå½“å‰æ˜¯å¦å¯ç”¨ é»˜è®¤çŠ¶æ€çš„ä¸€å®šè¦æ”¾åœ¨æœ€åŽä¸€æ¡, å› ä¸ºç³»ç»Ÿæ˜¯æŒ‰ç…§ä»Žä¸Šåˆ°ä¸‹çš„é¡ºåºæŸ¥æ‰¾. åªè¦æ‰¾åˆ°ä»»ä½•ä¸€ä¸ªåŒ¹é…çŠ¶æ€çš„é‚£ä¹ˆä¹…ç»“æŸäº†. LevelListDrawableLevelListDrawableå¯¹åº”äºŽ&lt;level-list&gt;æ ‡ç­¾, ä¹Ÿè¡¨ç¤ºä¸€ä¸ªDrawableé›†åˆ, é›†åˆä¸­æ¯ä¸€ä¸ªDrawableéƒ½æœ‰ä¸€ä¸ªç­‰çº§çš„æ¦‚å¿µ, æ ¹æ®ä¸åŒçš„ç­‰çº§LevelListDrawableä¼šåˆ‡æ¢ä¸åŒçš„å¯¹åº”çš„Drawable. 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_sample" android:maxLevel="2" android:minLevel="2"/&gt; &lt;item android:drawable="@mipmap/ic_launcher" android:maxLevel="1" android:minLevel="1" /&gt;&lt;/level-list&gt; è¿™é‡Œå°±ç›¸å½“äºŽç»™æ¯ä¸€ä¸ªDrawableè®¾å®šä¸€ä¸ªæ ‡è¯†. level-listä¼šæ ¹æ®è¿™ä¸ªæ ‡è¯†åŽ»è‡ªå·±çš„itemä¸­æŸ¥æ‰¾. é»˜è®¤ç­‰çº§ä¸º0, Levelçš„å–å€¼åœ¨0~10000. åœ¨ç»™æ¯ä¸ªItemå£°æ˜Žç­‰çº§çš„æ—¶å€™å°½é‡æœ€å¤§å’Œæœ€å°ç­‰çº§ä¿æŒä¸€è‡´. è®©æ¯ä¸ªiteméƒ½å¯ä»¥æœ‰ä¸€ä¸ªå”¯ä¸€æ ‡è¯†ç­‰çº§, è€Œé¿å…æœ‰ä¸€äº›å…¬å…±æ‹¥æœ‰ç­‰çº§çš„Itemå¯¼è‡´å‡ºçŽ°å’Œæˆ‘ä»¬é¢„æœŸçš„ä¸ç¬¦. å¦‚æžœä½œä¸ºäº†èƒŒæ™¯, é‚£ä¹ˆèŽ·å¾—Drawableå¯¹è±¡é€šè¿‡getLevel(), setLevel()æ¥å¾—åˆ°å’Œè®¾ç½®ä¸åŒçš„ç­‰çº§åšåˆ°åˆ‡æ¢å›¾ç‰‡çš„æ•ˆæžœ. å¦‚æžœæ˜¯ImageViewé‚£ä¹ˆé€šè¿‡setImageLevel()å‰æ™¯è®¾ç½®å…¶ç­‰çº§å°±å¯ä»¥,ä¸€å®šåˆ«å¿˜äº†æŠŠDrawableè®¾ç½®å‰æ™¯å†é€šè¿‡è¿™ç§æ–¹å¼å®žçŽ°. TransitionDrawableå¯¹åº”ç€&lt;transition&gt;æ ‡ç­¾, å®ƒç”¨äºŽå®žçŽ°ä¸¤ä¸ªDrawableä¹‹é—´çš„æ·¡å…¥æ·¡å‡ºæ•ˆæžœ. 1234567&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_sample"/&gt; &lt;item android:drawable="@mipmap/ic_launcher"/&gt;&lt;/transition&gt; 12 TransitionDrawable drawable = (TransitionDrawable) iv_main.getBackground();drawable.startTransition(5000); è¿™ä¸ªæ²¡ä»€ä¹ˆå¥½è¯´çš„äº†, å¾ˆç®€å•. æ³¨æ„ä¸€ä¸‹å¦‚æžœæ˜¯ç»™ImageViewè®¾ç½®å‰æ™¯çš„è¯é‚£ä¹ˆä¸è¦ç”¨getBackground()æ¥èŽ·å–äº†,é€šè¿‡getDrawable()æ¥èŽ·å–. InsetDrawableInsetDrawableå¯¹åº”&lt;inset&gt;æ ‡ç­¾, å®ƒå¯ä»¥å°†å…¶ä»–Drawableå†…åµŒåˆ°è‡ªå·±å½“ä¸­, å¹¶å¯ä»¥åœ¨å››å‘¨ç•™å‡ºä¸€å®šçš„è·ç¦». å½“ä¸€ä¸ªViewå¸Œæœ›è‡ªå·±çš„èƒŒæ™¯æ¯”è‡ªå·±çš„å®žé™…åŒºåŸŸå°çš„æ—¶å€™, å¯ä»¥ä½¿ç”¨è¿™ä¸ªæ¥å®žçŽ°.(ç›¸å½“äºŽç»™ä½¿ç”¨çš„Viewå¢žåŠ äº†marginæ•ˆæžœ) LayerDrawableä¹Ÿå¯ä»¥å®žçŽ°æ­¤æ•ˆæžœ 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:insetBottom="20dp" android:insetTop="50dp" android:insetRight="20dp" android:insetLeft="20dp"&gt; &lt;shape &gt; &lt;solid android:color="#ffff00"/&gt; &lt;/shape&gt;&lt;/inset&gt; ScaleDrawableScaleDrawableå¯¹åº”&lt;scale&gt;æ ‡ç­¾, ä»–å¯ä»¥æ ¹æ®è‡ªå·±çš„ç­‰çº§levelå°†åˆ¶å®šçš„Drawableç¼©æ”¾åˆ°ä¸€å®šæ¯”ä¾‹. 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@mipmap/ic_sample" android:scaleHeight="10%" android:scaleWidth="10%" android:scaleGravity="center"&gt;&lt;/scale&gt; å¹¶åœ¨ä»£ç ä¸­è®¾ç½®ç­‰çº§, é»˜è®¤ä¸º0æ˜¯ä¸æ˜¾ç¤ºScaleDrawable 12ScaleDrawable drawable = (ScaleDrawable) findViewById(R.id.activity_main).getBackground();drawable.setLevel(1); å…¶ä¸­scaleHeightå’ŒscaleWidthéœ€è¦çš„æ˜¯ç™¾åˆ†æ¯”å€¼. æœ‰ç‚¹åˆ«æ‰­, å¦‚æžœä½ è®¾ç½®äº†10%, é‚£ä¹ˆå®žé™…çš„æ„ä¹‰å°±æ˜¯ç¼©æ”¾äº†åŽŸå¤§å°çš„10%, ç›¸å½“äºŽåŽ»æŽ‰äº†è®¾ç½®çš„å€¼. æœ€ç»ˆå‘ˆçŽ°å‡ºæ¥çš„æ˜¯1-è®¾å®šçš„ç™¾åˆ†æ¯”. å°±æ˜¯å±•çŽ°äº†90%. è€Œè®¾ç½®çš„ç­‰çº§ä¼šå½±å“æœ€ç»ˆçš„å›¾ç‰‡å¤§å°, ç­‰çº§è¶Šå¤§å›¾ç‰‡è¶Šå¤§. æœ€å¥½ç­‰çº§æŽ§åˆ¶åˆ°0~10000 æœ€åŽ. ClipDrawableClipDrawableå¯¹åº”äºŽ&lt;clip&gt;æ ‡ç­¾, ä»–å¯ä»¥æ ¹æ®è‡ªå·±å½“å‰çš„ç­‰çº§æ¥è£å‰ªDrawable, è£å‰ªçš„æ–¹å‘é€šè¿‡android:clipOrientationå’Œandroid:gravityè¿™ä¸¤ä¸ªå±žæ€§æ¥å…±åŒæŽ§åˆ¶. 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;clip xmlns:android="http://schemas.android.com/apk/res/android" android:clipOrientation="horizontal" android:drawable="@mipmap/ic_sample" android:gravity="center"&gt;&lt;/clip&gt; é¦–å…ˆandroid:clipOrientation å¦‚æžœå‚æ•°æ·»åŠ æ°´å¹³ horizontal. å®žé™…ä¸Šæ˜¯ç«–ç›´åˆ‡å‰², ä¿ç•™åž‚ç›´æ–¹å‘çš„å®Œæ•´. å¦‚æžœæ˜¯Verticalåä¹‹. çœ‹å›¾å§. è€Œgravityæœ‰çš„å±žæ€§å’ŒBitmapDrawableä¸­çš„gravityä¸€æ ·. è¿™é‡ŒçŽ°åœ¨æ˜¯android:clipOrientation=&quot;horizontal&quot;å®ƒæ˜¯ä»¥æ°´å¹³æ–¹å‘åšçš„åž‚ç›´åˆ‡å‰². é‚£ä¹ˆé€šè¿‡ç»™gravityè®¾ç½®å·¦ ä¸­ å³å°±æ˜¯left, center, rightå¯ä»¥è¾¾åˆ°ä¸åŒçš„æ•ˆæžœ. å¦‚å›¾ é‡è¦çš„ä¸€ç‚¹è¿˜æœ‰åŠ¨æ€ä»£ç è®¾ç½®ç­‰çº§, è¦æ˜¯ä¸è®¾ç½®ç­‰çº§å°±æ˜¯é»˜è®¤çš„0, 0å°±æ˜¯åˆ‡å‰²æŽ‰100%çš„éƒ¨åˆ†,æ‰€ä»¥å‰©ä¸‹çš„éƒ¨ä½ä¸º0ä¹Ÿå°±æ˜¯ç©ºçš„ 12ClipDrawable drawable = (ClipDrawable) findViewById(R.id.activity_main).getBackground();drawable.setLevel(5000); è¿™ä¸ªç­‰çº§çš„æ•°è¿˜æ˜¯1~10000. ç­‰çº§ä¸º0é‚£ä¹ˆæ„å‘³ç€è£å‰ªDrawableçš„100%éƒ¨åˆ†. ä»€ä¹ˆä¸œè¥¿æ²¡æœ‰.ç©ºçš„ ç­‰çº§ä¸º5000é‚£ä¹ˆæ„å‘³ç€è£å‰ªDrawableçš„50%éƒ¨åˆ†, æˆ‘ä¸Šé¢çš„æ¼”ç¤ºçš„å›¾ç‰‡éƒ½æ˜¯ä»¥ç­‰çº§ä¸º5000ä¸ºæ ‡å‡†æµ‹è¯•çš„ ç­‰çº§ä¸º10000é‚£ä¹ˆå°±æ„å‘³çš„è£å‰ªéƒ¨åˆ†ä¸ºDrawableçš„100%éƒ¨åˆ†, ä¹Ÿå°±æ˜¯å®Œå…¨æ˜¾ç¤ºäº†. å¯ä»¥çœ‹å‡ºæ¥äº†, ç»¼åˆä¸Šé¢çš„çœ‹å‡º, ä¸Šé¢çš„gravityçš„æ–¹å‘å¯ä»¥è®¤ä¸ºæ˜¯ä»Žé‚£è¾¹å¼€å§‹è¿›è¡Œè£å‰ªä¿ç•™. è‡ªå®šä¹‰Drawableä¸€èˆ¬Drawableéƒ½æ˜¯ä½œä¸ºViewçš„èƒŒæ™¯å›¾, æˆ–è€…ImageViewçš„æ˜¾ç¤ºå›¾ç‰‡. å…¶å·¥ä½œåŽŸç†æ ¸å¿ƒå°±æ˜¯draw()æ–¹æ³•. è€Œç³»ç»Ÿä¼šè°ƒç”¨Drawableçš„draw()æ¥ç»˜åˆ¶Viewçš„èƒŒæ™¯, æ‰€ä»¥æˆ‘ä»¬é€šè¿‡é‡å†™draw()æ¥å®žçŽ°è‡ªå®šä¹‰Drawable. ä¸€èˆ¬draw(), setAlpha(), setColorFilter(), å’ŒgetOpacity()éƒ½æ˜¯è¦å®žçŽ°çš„ , draw()é‡Œé¢çš„å…·ä½“å®žçŽ°å’Œæˆ‘ä»¬Viewçš„onDraw()å¾ˆç›¸ä¼¼. å¯ä»¥å‚è€ƒShapeDrawableå’ŒBitmapDrawableçš„æºç åŽ»ä»¿é€ å®žçŽ°. åœ¨è‡ªå®šä¹‰çš„æ—¶å€™æ³¨æ„: å¦‚æžœè¦å®šä¹‰çš„Drawableæœ‰å›ºæœ‰çš„å¤§å°å€¼, é‚£ä¹ˆæœ€å¥½é‡å†™getIntrinsicWidth()å’ŒgetIntrinsicHeight()è¿™ä¸¤ä¸ªæ–¹æ³•. å› ä¸ºå®ƒä¼šå½±å“åˆ°Viewçš„wrap_contentå¸ƒå±€. æœ€åŽå†…éƒ¨å¤§å°ä¸ä¸€å®šç­‰äºŽDrawableçš„å®žé™…å¤§å°, Drawableå®žé™…å¤§å°å¯ä»¥é€šè¿‡getBound()æ¥èŽ·å–.]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>Drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç†è§£RemoteViews]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%90%86%E8%A7%A3RemoteViews%2F</url>
    <content type="text"><![CDATA[RemoteViewçš„åº”ç”¨ç®€ä»‹:åœ¨å¼€å‘ä¸­, é€šçŸ¥æ éƒ½çŸ¥é“æ˜¯é€šè¿‡NotificationManagerçš„notifyæ–¹æ³•å®žçŽ°. æ¡Œé¢å°éƒ¨ä»¶åˆ™æ˜¯é€šè¿‡AppWidgetProviderå®žçŽ°. åŽè€…æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªå¹¿æ’­.æ›´æ–°ä»–ä»¬æ— æ³•åƒä»¥å‰é‚£æ ·.è¿™æ˜¯å› ä¸ºä¸æ˜¯ä¸€ä¸ªè¿›ç¨‹,å°éƒ¨ä»¶æ˜¯SystemServerè¿›ç¨‹. ä¸ºäº†è·¨è¿›ç¨‹æ›´æ–°ç•Œé¢,RemoteViewsæä¾›äº†ä¸€ç³»åˆ—çš„setæ–¹æ³•â€¦ RemoteViewsé€šçŸ¥æ çš„åº”ç”¨å…ˆä½¿ç”¨ç³»ç»Ÿé»˜è®¤çš„æ ·å¼. â€“! å…ˆä¸è®°å½•notificationäº†. å‘çŽ°ä¹¦ä¸Šçš„æ–¹æ³•åœ¨ç¼–è¯‘çŽ¯å¢ƒ23ç‰ˆæœ¬ä»¥ä¸Šæ— æ•ˆ. 23ä»¥ä¸‹æ˜¯æ²¡æœ‰é—®é¢˜çš„.notification.setLatestEventInfo()æ­¤æ–¹æ³•å·²ç»è¢«åˆ é™¤äº†. è´´å‡ºè‡ªå®šä¹‰å¸ƒå±€é€šçŸ¥æ ä»£ç åˆ©ç”¨remoteViews 123456789101112131415161718192021222324252627/** * æ‰“å¼€è‡ªå®šä¹‰å¸ƒå±€çš„é€šçŸ¥æ  */private void displayRemoteViews() &#123; Notification notification = new Notification(); notification.icon = R.mipmap.ic_launcher; notification.tickerText = "æˆ‘æ˜¯å°éƒ¨ä»¶"; notification.when = System.currentTimeMillis(); notification.flags = Notification.FLAG_AUTO_CANCEL; Intent intent = new Intent(getApplicationContext(), MainActivity.class); PendingIntent pedingIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); RemoteViews remoteViews = new RemoteViews(getPackageName(), R.layout.layout_notification); remoteViews.setTextViewText(R.id.tv_msg, "æˆ‘æ˜¯æ–‡å­—ä¿¡æ¯"); remoteViews.setImageViewResource(R.id.iv_icon, R.mipmap.favicon); notification.contentView = remoteViews; notification.contentIntent = pedingIntent; PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, OpenActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); remoteViews.setOnClickPendingIntent(R.id.tv_open, openActivity2PendingIntent); NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); manager.notify(2, notification);&#125; ä¼ å…¥äº†ä¸€ä¸ªè‡ªå®šä¹‰å¸ƒå±€é‡Œé¢æœ‰ä¸€ä¸ªimageViewä¸¤ä¸ªtextView. å¦‚ä¸‹å›¾: RemoteViewåœ¨æ¡Œé¢å°éƒ¨ä»¶ä¸Šçš„åº”ç”¨AppWidgetProvideræ˜¯ç³»ç»Ÿæä¾›çš„ç”¨äºŽå®žçŽ°æ¡Œé¢å°éƒ¨ä»¶çš„ç±», ç»§æ‰¿BroadcaseReceiver.å¯ä»¥å½“æˆå¹¿æ’­ç†è§£. æ¡Œé¢å°éƒ¨ä»¶çš„å¼€å‘æ­¥éª¤ 1.å®šä¹‰å°éƒ¨ä»¶ç•Œé¢ åœ¨åˆ›å»ºä¸€ä¸ªå¸ƒå±€xmlå½“åšè¿™ä¸ªå°éƒ¨ä»¶è¦å±•ç¤ºçš„æ ·å­ 2.å®šä¹‰å°éƒ¨ä»¶é…ç½®ä¿¡æ¯ åœ¨res/xmlæ–‡ä»¶å¤¹ä¸‹æ–°å»ºä¸€ä¸ªxxx_info.xmlçš„æ–‡ä»¶ 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android" android:initialLayout="@layout/layout_widget" android:minHeight="100dp" android:minWidth="100dp" android:updatePeriodMillis="60000" &gt;&lt;/appwidget-provider&gt; initiaLayout: å°å·¥å…·æ‰€è¦ä½¿ç”¨çš„åˆå§‹åŒ–å¸ƒå±€ minHeight``minWidth: æŒ‡å®šå°å·¥å…·çš„å°ºå¯¸ updatePeriodMillis: è‡ªåŠ¨åˆ·æ–°çš„æ—¶é—´, å•ä½æ¯«ç§’ 3.å®šä¹‰å°éƒ¨ä»¶çš„å®žçŽ°ç±» 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Created by suzeyu on 16/8/11. * å®šä¹‰å°éƒ¨ä»¶çš„å®žçŽ°ç±» */public class MyAppWidgetProvider extends AppWidgetProvider &#123; public static final String TAG = MyAppWidgetProvider.class.getName(); public static final String CLICK_ACTION = "com.szysky.note.androiddevseek_05.action.CLICK"; @Override public void onReceive(final Context context, Intent intent) &#123; super.onReceive(context, intent); Log.i(TAG, "onReceive: æŽ¥æ”¶åˆ°å¹¿æ’­--&gt;"+intent.getAction()); //æ˜¯è§¦å‘çš„è‡ªå·±ç‚¹å‡»æ—¶å‘é€çš„actioné‚£ä¹ˆå°±è®©å°éƒ¨ä»¶æ—‹è½¬ if (intent.getAction().equals(CLICK_ACTION))&#123; Toast.makeText(context, "å‡†å¤‡æ—‹è½¬", Toast.LENGTH_SHORT).show(); AsyncTask.execute(new Runnable() &#123; @Override public void run() &#123; Bitmap srcBmp = BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon); AppWidgetManager widgetManager = AppWidgetManager.getInstance(context); for (int i = 0; i &lt; 37; i++) &#123; float degree = (i * 10) % 360; RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, rotateBmp(context, srcBmp, degree)); if (i==36)&#123; Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent peddingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, peddingIntent); &#125; widgetManager.updateAppWidget(new ComponentName(context, MyAppWidgetProvider.class), remoteViews); SystemClock.sleep(50); &#125; &#125; &#125;); &#125; &#125; /** * æ—‹è½¬ä¸€ä¸ªbitmap */ private Bitmap rotateBmp(Context context, Bitmap srcBmp, float degree) &#123; Matrix matrix = new Matrix(); matrix.reset(); matrix.setRotate(degree); return Bitmap.createBitmap(srcBmp, 0, 0, srcBmp.getWidth(), srcBmp.getHeight(), matrix, true); &#125; /** * å½“è‡ªå®šä¹‰çš„å°æ¡Œé¢è¢«æ·»åŠ  è¿™ä¸ªæ–¹æ³•åªæœ‰åœ¨æœ¬å®žä¾‹ä¸­åªæœ‰è¢«æ·»åŠ çš„æ—¶å€™æ‰è°ƒç”¨ */ @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; super.onUpdate(context, appWidgetManager, appWidgetIds); final int counter = appWidgetIds.length; Log.i(TAG, "å°æ¡Œé¢æ›´æ–°äº† counter="+counter); for (int i = 0; i &lt; counter; i++) &#123; int appWidgetID = appWidgetIds[i]; onWidgetUpdate(context, appWidgetManager, appWidgetID); &#125; &#125; /** * æ¡Œé¢å°éƒ¨ä»¶æ›´æ–° è¿™ä¸ªæ–¹æ³•åªæœ‰åœ¨æœ¬å®žä¾‹ä¸­åªæœ‰è¢«æ·»åŠ çš„æ—¶å€™æ‰è°ƒç”¨ */ private void onWidgetUpdate(Context context, AppWidgetManager appWidgetManager, int appWidgetID) &#123; Log.i(TAG, "onWidgetUpdate: id=="+appWidgetID); RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon)); Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, pendingIntent); appWidgetManager.updateAppWidget(appWidgetID, remoteViews); &#125;&#125; ç›´æŽ¥è¯´ç”¨é€”æŠŠ, å°éƒ¨ä»¶è¢«æ·»åŠ åˆ°æ¡Œé¢çš„æ—¶å€™, ä¼šå…ˆèµ°onUpdate()å›žè°ƒ,è¿™ä¸ªæ—¶å€™æ‰§è¡Œæ–¹æ³•é€šè¿‡RemoteViews()æž„å»ºä¸€ä¸ªå¸ƒå±€,å¹¶æ›´æ–°æ¡Œé¢ä¸Šæ–°çš„å¸ƒå±€å’Œè®¾ç½®äº†ç‚¹å‡»äº‹ä»¶,ç„¶åŽèµ°onReceive() . å¦‚æžœå½“æˆ‘ä»¬ç‚¹å‡»çš„å°éƒ¨ä»¶çš„æ—¶å€™, ä¼šè§¦å‘å¹¿æ’­ä¸­çš„onReceive()ç„¶åŽè¿›è¡Œå›¾ç‰‡çš„æ—‹è½¬.è¿™å°±æ˜¯ä¸Šè¿°ä»£ç çš„å¤§ä½“æµç¨‹. 4.æœ€åŽè¦åœ¨æ¸…å•æ–‡ä»¶ä¸­å£°æ˜Žå°éƒ¨ä»¶ 12345678910&lt;receiver android:name=".MyAppWidgetProvider"&gt; &lt;meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_provider_info"/&gt; &lt;intent-filter&gt; &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE"/&gt; &lt;action android:name="com.szysky.note.androiddevseek_05.action.CLICK"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; ç¬¬ä¸€ä¸ªactionåˆ™æ˜¯ä½œä¸ºå°éƒ¨ä»¶çš„è¡¨ç¤ºè€Œå¿…é¡»å­˜åœ¨çš„. ç¬¬äºŒä¸ªactionå°±æ˜¯è¦è¯†åˆ«è®¾å®šçš„å•å‡»è¡Œä¸º. ç„¶åŽå°±å¯ä»¥åœ¨ä¸»å±å¹•ä¸Šé•¿æŒ‰æ·»åŠ å°éƒ¨ä»¶æŸ¥çœ‹æ•ˆæžœäº† å«Œéº»çƒ¦å°±ç›´æŽ¥æ‰£ä»£ç ,è¿™æ˜¯é“¾æŽ¥ AppWidgetProviderè¿™ä¸ªç±»è¿˜æœ‰å…¶ä»–ç”Ÿå‘½å‘¨æœŸçš„å›žè°ƒ, å…¶å®žå°±æ˜¯å½“å¹¿æ’­åˆ°æ¥ä¹‹åŽ, AppWidgetProviderä¼šè‡ªåŠ¨æ ¹æ®å¹¿æ’­çš„Actioné€šè¿‡onReceive()æ¥è‡ªåŠ¨è¿›è¡Œåˆ†å‘å¹¿æ’­. onEnable(): å½“è¯¥çª—å£å°éƒ¨ä»¶ç¬¬ä¸€æ¬¡æ·»åŠ åˆ°æ¡Œé¢æ—¶è°ƒç”¨è¯¥æ–¹æ³•, å¯æ·»åŠ å¤šæ¬¡ä½†åªåœ¨ç¬¬ä¸€æ¬¡è°ƒç”¨. onUpdate(): å°éƒ¨ä»¶è¢«æ·»åŠ æ—¶æˆ–è€…æ¯æ¬¡å°éƒ¨ä»¶æ›´æ–°æ—¶éƒ½ä¼šè°ƒç”¨ä¸€æ¬¡è¯¥æ–¹æ³•, å°éƒ¨ä»¶çš„æ›´æ–°æ—¶æœºç”±updatePeriodMillisæ¥æŒ‡å®š, æ¯ä¸ªå‘¨æœŸå°éƒ¨ä»¶éƒ½ä¼šè‡ªåŠ¨æ›´æ–°ä¸€æ¬¡. onDeleted(): æ¯åˆ é™¤ä¸€æ¬¡å°éƒ¨ä»¶å°±ä¼šè°ƒç”¨ä¸€æ¬¡. onReceive(): è¿™æ˜¯å¹¿æ’­çš„å†…ç½®æ–¹æ³•, ç”¨äºŽåˆ†å‘å…·ä½“çš„äº‹ä»¶ç»™å…¶ä»–æ–¹æ³•. ä¸‹é¢å°±æ˜¯åˆ†æžäº† PendingIntentæ¦‚è¿°PendingIntentå’ŒIntentçš„åŒºåˆ«: PendingIntent: ç­‰å¾…æ„å›¾, æœ‰ä¸€ä¸ªIntentå°†åœ¨æŸä¸ªå¾…å®šçš„æ—¶åˆ»å‘ç”Ÿ. Intent: æ˜¯ç«‹åˆ»å‘ç”Ÿ. ä½¿ç”¨åœºæ™¯ æœ€å…¸åž‹çš„å°±æ˜¯ç»™RemoteViewsæ·»åŠ å•å‡»äº‹ä»¶, å› ä¸ºRemoteViewsè¿è¡Œåœ¨è¿œç¨‹è¿›ç¨‹ä¸­, å› æ­¤RemoteViewsä¸åŒäºŽæ™®é€šçš„View, æ‰€ä»¥æ— æ³•ç›´æŽ¥å‘Viewé‚£æ ·é€šè¿‡setOnClickListener()æ–¹æ³•é‚£æ ·è®¾ç½®å•å‡»äº‹ä»¶. è¦æƒ³ç»™RemoteViewsè®¾ç½®å•å‡»äº‹ä»¶, å°±å¿…é¡»ä½¿ç”¨PendingIntent, PendingIntenté€šè¿‡send()å’Œcancel()æ¥å‘é€å’Œå–æ¶ˆç‰¹å®šçš„å¾…å®šIntent. PendingIntentæ”¯æŒä¸‰ç§å¾…å®šæ„å›¾: å¯åŠ¨Activity, å¯åŠ¨Service, å’Œå‘é€å¹¿æ’­ å¯¹åº”ç€PendingIntentä¸‰ä¸ªé™æ€æ–¹æ³• getActivity(),getService(), getBroadCast(). å½“è¿™ä¸‰ç§æ–¹æ³•è¿”å›žçš„PendingIntentå¾…å®šæ„å›¾å‘ç”Ÿæ—¶å€™, å¯¹åº”çš„æ•ˆæžœå°±æ˜¯æˆ‘ä»¬æ—¥å¸¸å¼€å¯è¿™ä¸‰å¤§ç»„ä»¶çš„æƒ…å½¢. ä¸Šè¿°ä¸‰ä¸ªæ–¹æ³•éƒ½éœ€è¦å››ä¸ªå‚æ•°. éœ€è¦è¯´ä¸€ä¸‹ç¬¬äºŒä¸ªå‚æ•°requestCodeå’Œç¬¬å››ä¸ªå‚æ•°flags. å…¶ä¸­requestCodeè¡¨ç¤ºPendingIntentå‘é€æ–¹çš„è¯·æ±‚ç , å¤šæ•°æƒ…å†µä¸‹è®¾ä¸º0å³å¯, å¦å¤–requestCodeä¼šå½±å“åˆ°flagsçš„æ•ˆæžœ. flags: å¸¸ç”¨çš„ç±»åž‹æœ‰: FLAG_ONE_SHOT, FLAG_UPDATE_CURRENT, FLAG_NO_CREATE, FLAG_CANCEL_CURRENT. åœ¨æ­¤ä¹‹å‰é¦–å…ˆè¦æ˜Žç¡®ä¸€ä¸ªæ¦‚å¿µ, PendingIntentçš„åŒ¹é…è§„åˆ™, åœ¨ä»€ä¹ˆæƒ…å†µä¸‹ä¸¤ä¸ªPendingIntentæ˜¯ç›¸åŒçš„. PendingIntentåŒ¹é…è§„åˆ™: å¦‚æžœä¸¤ä¸ªPendingIntentçš„å†…éƒ¨Intentç›¸åŒå¹¶ä¸”requestCodeä¹Ÿç›¸åŒé‚£ä¹ˆè¿™ä¸¤ä¸ªPendingIntentå°±æ˜¯æƒ³åŒçš„. requestCodeæ˜¯intå€¼ä¸éœ€è¦è§£é‡Š. è€ŒIntentåŒ¹é…è§„åˆ™æ˜¯: å¦‚æžœä¸¤ä¸ªIntentçš„ComponentNameå’Œintent-filteréƒ½ç›¸åŒ, é‚£ä¹ˆè¿™ä¸¤ä¸ªIntentå°±æ˜¯ç›¸åŒçš„. Extrasæ˜¯ä¸å‚ä¸ŽIntentçš„åŒ¹é…è§„åˆ™. FLAG_ONE_SHOT: å½“å‰æè¿°çš„PendingIntentåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡, ç„¶åŽå®ƒå°±ä¼šè¢«è‡ªåŠ¨cancle, å¦‚æžœåŽç»­è¿˜æœ‰ç›¸åŒçš„PendingIntent, é‚£ä¹ˆå®ƒä»¬çš„sendæ–¹æ³•å°±ä¼šè°ƒç”¨å¤±è´¥. å¯¹äºŽé€šçŸ¥æ æ¶ˆæ¯æ¥è¯´, å¦‚æžœé‡‡ç”¨æ­¤æ ‡è®°, é‚£ä¹ˆåŒç±»çš„é€šçŸ¥åªèƒ½ä½¿ç”¨ä¸€æ¬¡, åŽç»­çš„é€šçŸ¥å•å‡»åŽå°†æ— æ³•æ‰“å¼€. FLAG_NO_CREATE: å½“å‰æè¿°çš„PendingIntentä¸ä¼šä¸»åŠ¨åˆ›å»º, å¦‚æžœå½“å‰PendingIntentä¹‹å‰ä¸å­˜åœ¨, é‚£ä¹ˆgetActivity, getService, getBroadcastæ–¹æ³•ä¼šç›´æŽ¥è¿”å›žnull, å³èŽ·å–PendingIntentå¤±è´¥. è¿™ä¸ªæ ‡è®°å¾ˆå°‘è§, å®ƒæ— æ³•å•ç‹¬ä½¿ç”¨,å› æ­¤æ—¥å¸¸ä¸­æ²¡æœ‰å¤ªå¤šæ„ä¹‰. FLAG_CANCEL_CURRENT: å½“å‰æè¿°çš„PendingIntentå¦‚æžœå·²ç»å­˜åœ¨, é‚£ä¹ˆä»–ä»¬éƒ½ä¼šè¢«cancel, ç„¶åŽç³»ç»Ÿä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„PendingIntent. å¯¹äºŽé€šçŸ¥æ æ¶ˆæ¯æ¥è¯´, é‚£äº›è¢«cancelçš„æ¶ˆæ¯å•å‡»åŽå°†æ— æ³•æ‰“å¼€. FLAG_UPDATE_CURRENT: å½“å‰æè¿°çš„PendingIntentå¦‚æžœå·²ç»å­˜åœ¨, é‚£ä¹ˆä»–ä»¬éƒ½ä¼šè‡ªåŠ¨è¢«æ›´æ–°, å³å®ƒä»¬çš„Intentä¸­çš„Extraä¼šè¢«æ¢æˆæ–°çš„. è§„åˆ™è¯´äº†æŽ¥ä¸‹æ¥ç»“åˆå®žé™…ä½¿ç”¨è¯´æ˜Ž: å¦‚æžœmanager.notify(1, notification),å¦‚æžœå‚æ•°1çš„idæ˜¯å¸¸é‡,é‚£ä¹ˆå¤šæ¬¡è°ƒç”¨notify()åªèƒ½å¼¹å‡ºä¸€ä¸ªé€šçŸ¥, åŽç»­çš„é€šçŸ¥ä¼šæŠŠå‰é¢çš„é€šçŸ¥å…¨éƒ¨æ›¿ä»£, å¦‚æžœæ¯æ¬¡idéƒ½æ˜¯ä¸ä¸€æ ·çš„, é‚£ä¹ˆå¤šæ¬¡è°ƒç”¨notify()å°±ä¼šå¼¹å‡ºå¤šä¸ªé€šçŸ¥. æ‰€ä»¥å¦‚æžœnotify()æ˜¯å¸¸é‡, é‚£ä¹ˆä¸ç®¡PendingIntentæ˜¯å¦åŒ¹é…, åŽé¢çš„é€šçŸ¥éƒ½ä¼šç›´æŽ¥æ›¿æ¢å‰é¢çš„é€šçŸ¥. å¦‚æžœnotify()æ¯æ¬¡ä¸åŒ, é‚£ä¹ˆå½“pendingIntentä¸åŒ¹é…æ—¶(è¿™é‡ŒæŒ‡çš„åŒ¹é…å°±æ˜¯ä¸Šé¢ä»‹ç»çš„Intentå’ŒrequestCodeæ˜¯å¦åŒæ—¶ç›¸åŒ), ä¸ç®¡é‡‡ç”¨ä½•ç§æ ‡è®°, è¿™äº›é€šçŸ¥ä¹‹é—´éƒ½ä¸ä¼šäº’ç›¸å¹²æ‰°. ä½†æ˜¯å¦‚æžœPendingIntentåŒ¹é…æ—¶å°±è¦ç”¨åˆ°åŽ»æŒ‰ç…§ä¹‹å‰è¯´çš„æ ‡è®°åŒºåˆ«æ¥åˆ’åˆ† FLAG_ONE_SHOTâ€“&gt; é‚£ä¹ˆåŽç»­é€šçŸ¥ä¸­çš„PendingIntentä¼šå’Œç¬¬ä¸€æ¡é€šçŸ¥ä¿æŒä¸€è‡´, åŒ…æ‹¬Extras, å•å‡»ä»»ä½•ä¸€æ¡é€šçŸ¥åŽ, å‰©ä¸‹çš„é€šçŸ¥å‡æ— æ³•å†æ‰“å¼€, å½“æ‰€æœ‰çš„é€šçŸ¥éƒ½è¢«æ¸…é™¤åŽ, ä¼šå†æ¬¡é‡å¤è¿™ä¸ªè¿‡ç¨‹. FLAG_CANCEL_CURRENTâ€“&gt; é‚£ä¹ˆåªæœ‰æœ€æ–°çš„é€šçŸ¥å¯ä»¥æ‰“å¼€, ä¹‹å‰å¼¹å‡ºçš„æ‰€æœ‰é€šçŸ¥å‡æ— æ³•æ‰“å¼€ FLAG_UPDATE_CURRENTâ€“&gt; é‚£ä¹ˆä¹‹å‰å¼¹å‡ºçš„é€šçŸ¥ä¸­çš„PendingIntentä¼šè¢«æ›´æ–°, æœ€ç»ˆä»–ä»¬å’Œæœ€æ–°çš„ä¸€æ¡é€šçŸ¥ä¿æŒå®Œå…¨çš„ä¸€è‡´, åŒ…æ‹¬å…¶ä¸­çš„Extras,å¹¶ä¸”è¿™äº›é€šçŸ¥éƒ½æ˜¯å¯ä»¥æ‰“å¼€çš„. â€‹ RemoteViewsçš„å†…éƒ¨æœºåˆ¶RemoteViewsçš„ä½œç”¨æ˜¯åœ¨å…¶ä»–è¿›ç¨‹ä¸­æ˜¾ç¤ºå¹¶æ›´æ–°Viewç•Œé¢. æœ€å¸¸ç”¨çš„æž„é€ å‡½æ•°å°±æ˜¯public RemoteViews(String packageName, int layoutId), æ³¨æ„RemoteViewsç›®å‰å¹¶ä¸èƒ½æ”¯æŒæ‰€æœ‰çš„Viewç±»åž‹, ç›®å‰æ”¯æŒå¦‚ä¸‹(ä¸åŒ…æ‹¬å…¶å­ç±»): Layout FrameLayout, LinearLayout, RelativeLayout, GridLayout View TextView, ImageView, ImageButton, Button, AnalogClock, Chronometer, ProgressBar, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub RemoteViewsæ²¡æœ‰æä¾›findviewById()æ–¹æ³•, åªæœ‰ä¸€ç³»åˆ—çš„set()æ–¹æ³•. æ–¹æ³•å ä½œç”¨ setTextViewText() è®¾ç½®TextViewçš„æ–‡æœ¬ setTextViewSize() è®¾ç½®TextViewçš„å­—ä½“å¤§å° setTextColor() è®¾ç½®TextViewçš„å­—ä½“é¢œè‰² setImageViewResource() è®¾ç½®imageViewçš„å›¾ç‰‡èµ„æº setImageViewBitmap() è®¾ç½®imageViewçš„å›¾ç‰‡ setInt() åå°„è°ƒç”¨Viewå¯¹è±¡çš„å‚æ•°ç±»åž‹ä¸ºintçš„æ–¹æ³• setLong() åå°„è°ƒç”¨Viewå¯¹è±¡çš„å‚æ•°ç±»åž‹ä¸ºlongçš„æ–¹æ³• setBoolean() åå°„è°ƒç”¨Viewå¯¹è±¡çš„å‚æ•°ç±»åž‹ä¸ºbooleançš„æ–¹æ³• setOnClickPendingIntent() ä¸ºViewæ·»åŠ å•å‡»äº‹ä»¶, äº‹ä»¶ç±»åž‹åªèƒ½PendingIntent RemoteViewsçš„å·¥ä½œæµç¨‹ é€šçŸ¥æ å’Œæ¡Œé¢å°éƒ¨ä»¶åˆ†åˆ«ç”±NotificationManagerå’ŒAppWidgetManagerç®¡ç†, è€Œè¿™ä¸¤ä¸ªç®¡ç†è€…éƒ½æ˜¯é€šè¿‡Binderåˆ†åˆ«å’ŒSystemServerè¿›ç¨‹ä¸­çš„NotificationManagerServiceä»¥åŠAppWidgetServiceè¿›è¡Œé€šä¿¡. ç”±æ­¤å¯è§,é€šçŸ¥æ å’Œæ¡Œé¢å°éƒ¨ä»¶ä¸­çš„å¸ƒå±€æ–‡ä»¶å®žé™…ä¸Šæ˜¯åœ¨NotificationManagerServiceä»¥åŠAppWidgetServiceä¸­è¢«åŠ è½½çš„, è€Œä»–ä»¬è¿è¡Œåœ¨ç³»ç»Ÿçš„SystemServerä¸­, è¿™å°±å’Œæˆ‘ä»¬çš„è¿›ç¨‹æž„æˆäº†è¿›ç¨‹é—´é€šä¿¡. æœ€å¼€å§‹RemoteViewsä¼šé€šè¿‡Binderä¼ é€’åˆ°SystemServerè¿›ç¨‹, RemoteViewså®žçŽ°äº†ParcelableæŽ¥å£. ç³»ç»Ÿæ ¹æ®RemoteViewsä¸­çš„åŒ…åç­‰ä¿¡æ¯åŽ»å¾—åˆ°è¯¥åº”ç”¨çš„èµ„æº, ç„¶åŽé€šè¿‡LayoutInflateåŽ»åŠ è½½RemoteViewsä¸­çš„å¸ƒå±€æ–‡ä»¶. åœ¨SystemServerè¿›ç¨‹ä¸­åŠ è½½åŽçš„å¸ƒå±€æ–‡ä»¶æ˜¯ä¸€ä¸ªæ™®é€šçš„View, åªä¸è¿‡ç›¸å¯¹äºŽæˆ‘ä»¬çš„è¿›ç¨‹ä»–æ˜¯ä¸€ä¸ªRemoteViewsè€Œå·². æŽ¥ç€ç³»ç»Ÿä¼šå¯¹Viewæ‰§è¡Œä¸€ç³»åˆ—ç•Œé¢æ›´æ–°ä»»åŠ¡, è¿™äº›ä»»åŠ¡å°±æ˜¯ä¹‹å‰çš„è®¾ç½®çš„set(). setæ–¹æ³•å¯¹Viewæ‰€åšçš„æ›´æ–°ä¸æ˜¯ç«‹å³æ‰§è¡Œ, åœ¨RemoteViewså†…éƒ¨ä¼šè®°å½•æ‰€æœ‰çš„æ›´æ–°æ“ä½œ, å…·ä½“çš„æ‰§è¡Œæ—¶æœºè¦ç­‰åˆ°RemoteViewsè¢«åŠ è½½ä»¥åŽæ‰èƒ½æ‰§è¡Œ, è¿™æ ·RemoteViewså°±å¯ä»¥åœ¨SystemServerè¿›ç¨‹ä¸­æ˜¾ç¤º, è¿™å°±æ˜¯æˆ‘ä»¬çœ‹åˆ°çš„é€šçŸ¥æ æˆ–è€…æ¡Œé¢å°éƒ¨ä»¶. å½“éœ€è¦æ›´æ–°RemoteViewsæ—¶, æˆ‘ä»¬éœ€è¦è°ƒç”¨setæ–¹æ³•å¹¶é€šè¿‡NotificationManagerå’ŒAppWidgetManageræ¥æäº¤æ›´æ–°ä»»åŠ¡, å…·ä½“çš„æ›´æ–°æ“ä½œä¹Ÿæ˜¯åœ¨SystemServerè¿›ç¨‹ä¸­å®Œæˆçš„. ä¸ºä»€ä¹ˆä¸æ”¯æŒæ‰€æœ‰çš„Viewå’Œå…¶æ“ä½œ? å› ä¸ºä»£ä»·å¤ªå¤§, Viewçš„æ–¹æ³•å¤ªå¤š, å¦å¤–å°±æ˜¯å¤§é‡çš„IPCæ“ä½œä¼šå½±å“æ•ˆçŽ‡. ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜, ç³»ç»Ÿå¹¶æ²¡æœ‰é€šè¿‡Binderç›´æŽ¥æ”¯æŒViewçš„è·¨è¿›ç¨‹è®¿é—®, è€Œæ˜¯æä¾›äº†ä¸€ä¸ªActionçš„æ¦‚å¿µ, Actionä»£è¡¨ä¸€ä¸ªViewæ“ä½œ, ActionåŒæ ·å®žçŽ°äº†ParcelableæŽ¥å£. ç³»ç»Ÿé¦–å…ˆå°†Viewæ“ä½œå°è£…åˆ°Actionå¯¹è±¡å¹¶å°†è¿™äº›å¯¹è±¡è·¨è¿›ç¨‹ä¼ è¾“åˆ°è¿œç¨‹è¿›ç¨‹, æŽ¥ç€åœ¨è¿œç¨‹è¿›ç¨‹ä¸­æ‰§è¡ŒActionå¯¹è±¡ä¸­çš„å…·ä½“æ“ä½œ. åœ¨æˆ‘ä»¬çš„åº”ç”¨ä¸­æ¯è°ƒç”¨ä¸€æ¬¡set(), RemoteViewsä¸­å°±ä¼šæ·»åŠ ä¸€ä¸ªå¯¹åº”çš„Actionå¯¹è±¡, å½“æˆ‘ä»¬é€šè¿‡NotificationManagerå’ŒAppWidgetManageræ¥æäº¤æˆ‘ä»¬çš„æ›´æ–°æ—¶, è¿™äº›Actionå¯¹è±¡å°±ä¼šä¼ è¾“åˆ°è¿œç¨‹è¿›ç¨‹å¹¶åœ¨è¿œç¨‹è¿›ç¨‹ä¸­ä¸€æ¬¡æ‰§è¡Œ. å¦‚å›¾: è¿œç¨‹è¿›ç¨‹é€šè¿‡RemoteViewsçš„applyæ–¹æ³•æ¥è¿›è¡ŒViewçš„æ›´æ–°æ“ä½œ, RemoteViewsçš„applyæ–¹æ³•å†…éƒ¨åˆ™ä¼šåŽ»éåŽ†æ‰€æœ‰çš„Actionå¯¹è±¡å¹¶è°ƒç”¨ä»–ä»¬çš„applyæ–¹æ³•, å…·ä½“çš„Viewæ›´æ–°æ“ä½œæ˜¯ç”±Actionå¯¹è±¡çš„applyæ–¹æ³•æ¥å®Œæˆçš„. ä¸Šè¿°åšæ³•çš„å¥½å¤„æ˜¯æ˜¾è€Œæ˜“è§çš„, é¦–å…ˆä¸éœ€è¦å®šä¹‰å¤§é‡çš„BinderæŽ¥å£, å…¶æ¬¡é€šè¿‡è¿œç¨‹è¿›ç¨‹ä¸­æ‰¹é‡æ‰§è¡ŒRemoteViewsçš„ä¿®æ”¹æ“ä½œä»Žè€Œé¿å…äº†å¤§é‡çš„IPCæ“ä½œ, è¿™å°±æé«˜äº†ç¨‹åºçš„æ€§èƒ½. æŽ¥ä¸‹æ¥ä»Žæºç è§’åº¦åˆ†æž. é¦–å…ˆæœ€é•¿ç”¨åˆ°çš„setTextViewText(),æºç å¦‚ä¸‹ 123public void setTextViewText(int viewId, CharSequence text) &#123; setCharSequence(viewId, "setText", text);&#125; æŽ¥æ”¶çš„å‚æ•°æ¯”è¾ƒç®€å•,ç»§ç»­è·Ÿè¿›setCharSequence()æ–¹æ³•. 123public void setCharSequence(int viewId, String methodName, CharSequence value) &#123; addAction(new ReflectionAction(viewId, methodName, ReflectionAction.CHAR_SEQUENCE, value));&#125; ä»Žè¿™é‡Œå®žçŽ°çœ‹åˆ°, å†…éƒ¨å¹¶æ²¡æœ‰å¯¹Viewè¿›ç¨‹ç›´æŽ¥çš„æ“ä½œ, è€Œæ˜¯æ·»åŠ ä¸€ä¸ªReflectionAction()ä¸€ä¸ªçœ‹åå­—ç±»ä¼¼åå°„ç±»åž‹çš„å¯¹è±¡. æŽ¥ä¸‹çœ‹addAction() 12345678910private void addAction(Action a) &#123; //çœç•¥éƒ¨åˆ†ä»£ç ... if (mActions == null) &#123; mActions = new ArrayList&lt;Action&gt;(); &#125; mActions.add(a); // update the memory usage stats a.updateMemoryUsageEstimate(mMemoryUsageCounter);&#125; è¿™é‡Œçœ‹åˆ°, åœ¨RemoteViewså†…éƒ¨æœ‰ä¸€ä¸ªmActionsæˆå‘˜, å®ƒæ˜¯ä¸€ä¸ªArrayList, å¤–ç•Œæ¯è°ƒç”¨ä¸€æ¬¡set(), RemoteViewså°±ä¼šä¸ºå…¶åˆ›å»ºä¸€ä¸ªActionå¯¹è±¡å¹¶åŠ å…¥åˆ°è¿™ä¸ªé›†åˆä¸­, è¿™é‡Œä»…ä»…å°†Actionå¯¹è±¡ä¿å­˜äº†èµ·æ¥, å¹¶æœªå¯¹Viewè¿›è¡Œå®žé™…çš„æ“ä½œ, è¿™ä¸€ç‚¹åœ¨ä¸Šé¢çš„ç†è®ºåˆ†æžä¸­å·²ç»æåˆ°è¿‡. æŽ¥ä¸‹æ¥å†çœ‹ReflectionActionçš„å®žçŽ°ä¹‹å‰, å…ˆçœ‹ä¸€ä¸‹RemoteViewsçš„apply()æ–¹æ³•ä»¥åŠActionç±»çš„å®žçŽ°. 12345678910111213141516171819202122232425262728293031323334public View apply(Context context, ViewGroup parent, OnClickHandler handler) &#123; RemoteViews rvToApply = getRemoteViewsToApply(context); View result; final Context contextForResources = getContextForResources(context); Context inflationContext = new ContextWrapper(context) &#123; @Override public Resources getResources() &#123; return contextForResources.getResources(); &#125; @Override public Resources.Theme getTheme() &#123; return contextForResources.getTheme(); &#125; @Override public String getPackageName() &#123; return contextForResources.getPackageName(); &#125; &#125;; LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); // Clone inflater so we load resources from correct context and // we don't add a filter to the static version returned by getSystemService. inflater = inflater.cloneInContext(inflationContext); inflater.setFilter(this); result = inflater.inflate(rvToApply.getLayoutId(), parent, false); rvToApply.performApply(result, parent, handler); return result; &#125; è¿™æ®µä»£ç é¦–å…ˆé€šè¿‡LayoutInflateåŽ»åŠ è½½RemoteViewsä¸­çš„å¸ƒå±€æ–‡ä»¶, RemoteViewsä¸­çš„å¸ƒå±€æ–‡ä»¶å¯ä»¥é€šè¿‡getLayoutId()è¿™ä¸ªæ–¹æ³•èŽ·å¾—, åŠ è½½å®Œå¸ƒå±€æ–‡ä»¶åŽä¼šé€šè¿‡performApply()åŽ»æ‰§è¡Œä¸€äº›æ›´æ–°æ“ä½œ,å¦‚ä¸‹: 12345678910private void performApply(View v, ViewGroup parent, OnClickHandler handler) &#123; if (mActions != null) &#123; handler = handler == null ? DEFAULT_ON_CLICK_HANDLER : handler; final int count = mActions.size(); for (int i = 0; i &lt; count; i++) &#123; Action a = mActions.get(i); a.apply(v, parent, handler); &#125; &#125; &#125; è¿™ä¸ªå®žçŽ°å°±æ˜¯éåŽ†mActionså¹¶æ‰§è¡Œæ¯ä¸ªActionå¯¹è±¡çš„apply()æ–¹æ³•, è¿™é‡ŒçŒœæƒ³Actionå¯¹è±¡çš„applyæ–¹æ³•å°±æ˜¯çœŸæ­£æ“ä½œViewçš„åœ°æ–¹. RemoteViewsåœ¨é€šçŸ¥æ å’Œæ¡Œé¢å°éƒ¨ä»¶ä¸­çš„å·¥ä½œè¿‡ç¨‹å’Œä¸Šé¢æè¿°çš„è¿‡ç¨‹æ˜¯ä¸€è‡´çš„. å½“è°ƒç”¨äº†RemoteViewsçš„setæ–¹æ³•æ—¶, å¹¶ä¸ä¼šç«‹åˆ»æ›´æ–°ä»–ä»¬çš„ç•Œé¢, è€Œå¿…é¡»è¦é€šè¿‡NotificationManagerçš„notifyæ–¹æ³•ä»¥åŠAppWidgetManagerçš„updateAppWidgetæ‰èƒ½æ›´æ–°ä»–ä»¬çš„ç•Œé¢. å®žé™…ä¸Šåœ¨AppWidgetManagerçš„updateAppWidgetå†…éƒ¨å®žçŽ°ä¸­, ä»–ä»¬å°±æ˜¯é€šè¿‡RemoteViewsçš„applyä»¥åŠreapplyæ–¹æ³•æ¥åŠ è½½æˆ–è€…æ›´æ–°å¸ƒå±€çš„. applyå’ŒreApplyçš„åŒºåˆ«åœ¨äºŽ:å‰è€…ä¼šåŠ è½½å¸ƒå±€å¹¶æ›´æ–°ç•Œé¢, è€ŒåŽè€…åªä¼šæ›´æ–°ç•Œé¢. é€šçŸ¥æ å’Œæ¡Œé¢å°éƒ¨ä»¶åœ¨åˆå§‹åŒ–ç•Œé¢çš„æ—¶å€™å›žè°ƒç”¨apply()æ–¹æ³•, è€Œåœ¨åŽç»­çš„æ›´æ–°ç•Œé¢æ—¶åˆ™ä¼šè°ƒç”¨reapply()æ–¹æ³•. äº†è§£äº†apply()ä»¥åŠreapply()çš„ä½œç”¨åŽ, æŽ¥ç€çœ‹Actionçš„å­ç±»å…·ä½“å®žçŽ°, å…ˆçœ‹ReflectionActionçš„å…·ä½“å®žçŽ°. 12345678910111213141516171819202122232425262728293031323334private final class ReflectionAction extends Action &#123; //çœç•¥éƒ¨åˆ†ä»£ç  ... String methodName; int type; Object value; ReflectionAction(int viewId, String methodName, int type, Object value) &#123; this.viewId = viewId; this.methodName = methodName; this.type = type; this.value = value; &#125; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final View view = root.findViewById(viewId); if (view == null) return; Class&lt;?&gt; param = getParameterType(); if (param == null) &#123; throw new ActionException("bad type: " + this.type); &#125; try &#123; getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value)); &#125; catch (ActionException e) &#123; throw e; &#125; catch (Exception ex) &#123; throw new ActionException(ex); &#125; &#125; // ...&#125; ReflectionActionè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªåå°„åŠ¨ä½œ, é€šè¿‡å®ƒå¯¹Viewçš„æ“ä½œä¼šä»¥åå°„çš„æ–¹å¼æ¥è°ƒç”¨, å…¶ä¸­getMethodå°±æ˜¯æ ¹æ®æ–¹æ³•åæ¥å¾—åˆ°åå°„æ‰€éœ€è¦çš„Methodå¯¹è±¡. é™¤äº†ReflectionAction, è¿˜æœ‰å…¶ä»–çš„Action. ä¾‹å¦‚: TextViewSizeAction, ViewPaddingAction, SetOnClickPendingIntentç­‰. çœ‹ä¸€ä¸‹TextViewSizeAction 1234567891011121314151617181920212223private class TextViewSizeAction extends Action &#123; public TextViewSizeAction(int viewId, int units, float size) &#123; this.viewId = viewId; this.units = units; this.size = size; &#125; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final TextView target = (TextView) root.findViewById(viewId); if (target == null) return; target.setTextSize(units, size); &#125; public String getActionName() &#123; return "TextViewSizeAction"; &#125; int units; float size; public final static int TAG = 13;&#125; è¿™ä¸ªç±»æ²¡æœ‰ä½¿ç”¨åå°„, å› ä¸ºsetTextSizeçš„æ–¹æ³•æœ‰ä¸¤ä¸ªå‚æ•°,å› æ­¤æ— æ³•å¤ç”¨ReflectionAction, å› ä¸ºè¿™ä¸ªåå°„è°ƒç”¨åªèƒ½æœ‰ä¸€ä¸ªå‚æ•°. å…³äºŽå•å‡»äº‹ä»¶, RemoteViewsåªæ”¯æŒå‘èµ·PendingIntent,ä¸æ”¯æŒonClickListener()è¿™ç§æ¨¡å¼. setOnClickPendingIntent,setPendingIntentTemplate,setOnClickFillIntentè¿™ä¸‰ä¸ªçš„åŒºåˆ«. setOnClickPendingIntent: åªæ”¯æŒæ™®é€šViewè®¾ç½®ç‚¹å‡»äº‹ä»¶, ä¸èƒ½ç»™é›†åˆ(ListView,StackView)ä¸­çš„Viewè®¾ç½®ç‚¹å‡»äº‹ä»¶,å¦‚item. å› ä¸ºå¼€é”€æ¯”è¾ƒå¤§, ç³»ç»Ÿç¦æ­¢äº†è¿™ç§æ–¹å¼. å¦‚æžœè¦ç»™é›†åˆä¸­çš„itemæ·»åŠ ç‚¹å‡»äº‹ä»¶,åˆ™å¿…é¡»ä½¿ç”¨åŽä¸¤ç§ç»„åˆä½¿ç”¨æ‰å¯ä»¥. RemoteViewsçš„æ„ä¹‰å¯ä»¥æ¨¡æ‹Ÿä¸€ä¸ªé€šçŸ¥æ æ•ˆæžœå¹¶å®žçŽ°è·¨è¿›ç¨‹çš„UIæ›´æ–°. ä¸€ä¸ªåº”ç”¨éœ€è¦èƒ½å¤Ÿæ›´æ–°å¦ä¸€ä¸ªåº”ç”¨ä¸­çš„æŸä¸ªç•Œé¢ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬å½“ç„¶å¯ä»¥é€‰æ‹©AIDLåŽ»å®žçŽ°ï¼Œä½†æ˜¯å¦‚æžœå¯¹ç•Œé¢çš„æ›´æ–°æ¯”è¾ƒé¢‘ç¹ï¼Œè¿™ä¸ªæ—¶å€™å°±ä¼šæœ‰æ•ˆçŽ‡é—®é¢˜ï¼ŒåŒæ—¶AIDLæŽ¥å£å°±æœ‰å¯èƒ½ä¼šå˜å¾—å¾ˆå¤æ‚ è¿™ä¸ªæ—¶å€™å¦‚æžœé‡‡ç”¨RemoteViewsæ¥å®žçŽ°å°±æ²¡æœ‰è¿™ä¸ªé—®é¢˜äº†ï¼Œå½“ç„¶RemoteViewsä¹Ÿä¼šæœ‰ç‚¹ç¼ºç‚¹ï¼Œé‚£å°±æ˜¯ä»–ä»…æ”¯æŒä¸€äº›å¸¸è§çš„View,å¯¹äºŽè‡ªå®šä¹‰VIewä»–æ˜¯ä¸æ”¯æŒçš„]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>RemoteViews</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Viewçš„å·¥ä½œåŽŸç†]]></title>
    <url>%2F2018%2F03%2F01%2FView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRootå’ŒDecorViewè¿™æ˜¯åœ¨Viewä¸‰å¤§æµç¨‹ä¹‹å‰(measure, layout, draw),éœ€è¦äº†è§£çš„æ¦‚å¿µ. ViewRootå¯¹åº”äºŽViewRootImplç±», å®ƒæ˜¯è¿žæŽ¥WindowManagerå’ŒDecorViewçš„çº½å¸¦. Viewçš„ä¸‰å¤§æµç¨‹éƒ½æ˜¯é€šè¿‡ViewRootæ¥å®Œæˆçš„. å½“ä¸€ä¸ªActivityå¯¹è±¡åœ¨ActivityThreadè¢«åˆ›å»ºåŽ. ä¼šå°†DecorViewæ·»åŠ åˆ°Windowä¸­, åŒæ—¶ä¼šåˆ›å»ºViewRootImpå¯¹è±¡, å¹¶å°†ViewRootImplå¯¹è±¡å’ŒDecorViewå»ºç«‹å…³è”ï¼š 12root = new ViewRootImpl(view.getContext(), display);root.setView(view, wparams, panelParentView); Viewç»˜åˆ¶æµç¨‹æ˜¯ä»ŽViewRootçš„PerformTraversals()å¼€å§‹çš„. ç»è¿‡ä¸‰å¤§æµç¨‹æ‰èƒ½å°†ä¸€ä¸ªViewç»˜åˆ¶å‡ºæ¥. PerformTraversals()ä¼šä¾æ¬¡è°ƒç”¨performMeasure, performLayout, performDraw. è€Œå‰ä¸¤ç§å†…éƒ¨çš„è°ƒç”¨åŸºæœ¬ä¸€è‡´,éƒ½æ˜¯å…ˆè°ƒç”¨measure()/layout(),ç„¶åŽå†è°ƒç”¨onMeasure()/onLayout()åœ¨è¿™ä¸ªæ–¹æ³•ä¸­ä¼šå¯¹æ‰€æœ‰å­å…ƒç´ è¿›è¡Œæµ‹é‡å’Œç»˜åˆ¶.ä¾æ¬¡å‘å†…éƒ¨ä¼ é€’. performDraw()æœ‰ç‚¹ä¸åŒæ˜¯åœ¨drawè°ƒç”¨çš„dispatchDraw(). PerformTraversalsç»˜åˆ¶æµç¨‹å¦‚ä¸‹å›¾ï¼š measureè¿‡ç¨‹: å†³å®šäº†Viewå®½é«˜, measureåŽå¯ä»¥é€šè¿‡getMeasureWidthå’ŒgetMeasureHeightæ¥èŽ·å–Viewçš„å®½é«˜. ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯æœ€ç»ˆå®½é«˜. layoutè¿‡ç¨‹: å†³å®šäº†Viewçš„é¡¶ç‚¹åæ ‡å’Œå®žé™…Viewçš„å®½é«˜. å®ŒæˆåŽé€šè¿‡getTop, getBottom, getLeft, getRightèŽ·å¾—å››ä¸ªé¡¶ç‚¹, é€šè¿‡getWidth,å’ŒgetHeightèŽ·å¾—å®½é«˜ drawè¿‡ç¨‹: åªæœ‰draw()æ–¹æ³•å®Œæˆä¹‹åŽViewçš„å†…å®¹æ‰ä¼šæ˜¾ç¤ºå‡ºæ¥. 12setContentView(R.layout.activity_inside_intercept);((ViewGroup) getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); ä¸Šé¢ç¬¬ä¸€è¡Œå¯ä»¥è¯´æ— æ—¶æ— åˆ»ä¸å­˜åœ¨. è€Œä¸‹é¢è¿™è¡Œåœ¨ä¸Šä¸€ç« è¯´è¿‡å°±æ˜¯èŽ·å¾—æˆ‘ä»¬è®¾ç½®çš„å¸ƒå±€.é‚£DecorViewå¸ƒå±€ç©¶ç«Ÿæ˜¯æ€Žä¹ˆæ ·çš„, ä¸‹å›¾. DecorViewå°±æ˜¯ä¸€ä¸ªFrameLayout. è€Œä¸€èˆ¬æƒ…å†µä¸‹å®ƒçš„å¸ƒå±€å°±å¦‚ä¸Šé¢å›¾é‚£æ ·(å…·ä½“å’Œä¸»é¢˜æœ‰å…³ç³»). è€Œæˆ‘ä»¬ç»å¸¸setContentView(xxx). å°±æ˜¯æŠŠæˆ‘ä»¬ç¼–å†™çš„xmlçš„å¸ƒå±€æ·»åŠ åˆ°äº†DecorViewçš„android.R.id.contentçš„æŽ§ä»¶å¸ƒå±€ä¸­. æ‰€ä»¥ä¹Ÿå°±èƒ½è¯´é€šä¸ºä»€ä¹ˆgetChildAt(0)ä¼šèŽ·å¾—æˆ‘ä»¬çš„çš„å¸ƒå±€.å¹¶ä¸”ä¸ºä»€ä¹ˆæˆ‘ä»¬ç”¨çš„å…³è”å¸ƒå±€çš„æ–¹æ³•æ˜¯setContentâ€¦ MeasureSpec å¾ˆå¤§ç¨‹åº¦ä¸Šå†³å®šä¸€ä¸ªViewçš„å°ºå¯¸è§„æ ¼, ä¹‹æ‰€ä»¥ä¸æ˜¯ç»å¯¹, æ˜¯å› ä¸ºè¿™ä¸ªè¿‡ç¨‹è¿˜å—çˆ¶å®¹å™¨çš„å½±å“. ç†è§£MeasureSpecMeasureSpecæœ¬èº«æ˜¯ä¸€ä¸ª32ä½çš„intå€¼, ä½†æ˜¯å´è¡¨ç¤ºäº†ä¸¤ç§ä¿¡æ¯. é«˜2ä½: ä»£è¡¨äº†SpecMode, æµ‹é‡æ¨¡å¼ ä½Ž30ä½: ä»£è¡¨äº†SpecSize, åœ¨ä¸Šè¿°æµ‹é‡æ¨¡å¼ä¸­çš„å¤§å° 1234567891011121314151617181920212223242526272829303132public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; .....&#125; æ˜¯ä¸æ˜¯æŒºæœ‰æ„æ€. ä¸‰ç§ç±»åž‹åˆ†åˆ«é«˜äºŒä½01, 00, 10æ¥ä»£è¡¨. ç›´æŽ¥åˆ©ç”¨ä½è¿ç®—. æ¥å®žçŽ°å¯ä»¥è®©é¢‘ç¹è®¡ç®—çš„ä¸œè¥¿ä½¿ç”¨æœ€æŽ¥è¿‘è®¡ç®—æœºçš„è¿ç®—æ–¹å¼. ä¸éœ€è¦é¢å¤–çš„è½¬æ¢. ä¹Ÿé¿å…äº†è¿‡å¤šçš„å¯¹è±¡å†…å­˜åˆ†é…. è¯´ä¸€ä¸‹SpecModeçš„ä¸‰ç§æ¨¡å¼ UNSPECIFIED: çˆ¶å®¹å™¨ä¸å¯¹Viewæœ‰ä»»ä½•çš„é™åˆ¶,è¦å¤šå¤§å°±ç»™å¤šå¤§, è¿™ç§æƒ…å†µä¸€èˆ¬ç”¨äºŽç³»ç»Ÿå†…éƒ¨,è¡¨ç¤ºä¸€ä¸­æµ‹é‡çŠ¶æ€ EXACTLY: çˆ¶å®¹å™¨å·²ç»æ£€æµ‹å‡ºViewæ‰€éœ€è¦çš„ç²¾ç¡®å¤§å°, è¿™ä¸ªæ—¶å€™Viewçš„æœ€ç»ˆå¤§å°å°±æ˜¯SpecSizeæ‰€æŒ‡å®šçš„å€¼. å¯¹åº”ç€LayoutParamsä¸­çš„match_parentå’Œå…·ä½“çš„æ•°å€¼. AT_MOST: çˆ¶å®¹å™¨åˆ¶å®šäº†ä¸€ä¸ªå¯ç”¨çš„å¤§å°åŠSpecSize, Viewçš„å¤§å°ä¸èƒ½è¶…è¿‡è¿™ä¸ªå€¼, å®ƒå¯¹åº”ä¸ŽLayoutParamsä¸­çš„wrap_content MeasureSpecå’ŒLayoutParamså…³ç³»é€šå¸¸è®¾ç½®çš„LayoutParams,ç³»ç»Ÿä¼šåœ¨çˆ¶å®¹å™¨çš„çš„çº¦æŸä¸‹è½¬æ¢æˆå¯¹åº”çš„MeasureSpec,ç„¶åŽæ ¹æ®è¿™ä¸ªMeasureSpecæ¥ç¡®å®šViewæµ‹é‡åŽçš„å®½é«˜. æ‰€ä»¥Viewè‡ªèº«çš„MeasureSpecæ˜¯éœ€è¦LayoutParamså’Œçˆ¶å®¹å™¨ä¸€èµ·ç»„åˆç”Ÿæˆçš„. ä¸Šé¢è®²è¿°çš„æ˜¯æ™®é€šView, ä½†æ˜¯é¡¶çº§View(DecorView)æœ‰æ‰€ä¸åŒ. DecorViewæ˜¯ç‰©ç†çª—å£å°ºå¯¸å’Œè‡ªèº«çš„LayoutParamså†³å®šçš„. å…·ä½“åœ¨ViewRootImplç±»measureHierarchy()è¿›è¡Œç”Ÿæˆçš„. MeasureSpecä¸€æ—¦ç¡®å®š, onMeasureä¸­å°±å¯ä»¥æµ‹é‡Viewçš„å®½é«˜. å¯¹äºŽæˆ‘ä»¬æ—¥å¸¸æ“ä½œçš„View Viewçš„measureè¿‡ç¨‹æ˜¯ç”±ViewGroupä¼ é€’è€Œæ¥çš„. çœ‹ViewGroup#measureChildWithMargins()æ–¹æ³• 123456789101112131415protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; ä¸Šé¢ä¼šå¯¹å­å…ƒç´ è¿›è¡Œmeasureï¼Œè€Œåœ¨æ­¤ä¹‹å‰ï¼Œä¼šé€šè¿‡getChildMeasureSpec()æ¥å¾—åˆ°å­å…ƒç´ çš„MeasureSpec. é€šè¿‡è°ƒç”¨æ–¹æ³•ä¼ å…¥çš„å‚æ•°çœ‹åˆ°ï¼Œç”ŸæˆViewçš„MeasureSpecå…·ä½“ç”±ä»¥ä¸‹å› ç´ å…±åŒå†³å®šï¼š çˆ¶å®¹å™¨çš„MeasureSpecå’Œpaddingï¼ŒViewè‡ªèº«çš„marginå’ŒLayoutParamsï¼Œå¯¹äºŽå­Viewçš„LayoutParamså¦‚æžœæ˜¯ï¼š dp/px: ä¸ç®¡çˆ¶å®¹å™¨çš„MeasureSpecæ˜¯ä»€ä¹ˆ. Viewéƒ½æ˜¯EXACTLY(ç²¾ç¡®æ¨¡å¼), è€Œå¤§å°éµå¾ªè‡ªèº«LayoutParamsçš„å¤§å°. match_parent: å¦‚æžœçˆ¶å®¹å™¨æ˜¯EXACTLY(ç²¾ç¡®æ¨¡å¼),é‚£ä¹ˆå­Viewä¹Ÿæ˜¯EXACTLY(ç²¾ç¡®æ¨¡å¼)å¹¶ä¸”å¤§å°æ˜¯çˆ¶å®¹å™¨çš„å‰©ä½™ç©ºé—´. å¦‚æžœçˆ¶å®¹å™¨æ˜¯AT_MOST(æœ€å¤§æ¨¡å¼),é‚£ä¹ˆå­Viewä¹Ÿæ˜¯AT_MOST(æœ€å¤§æ¨¡å¼)å¹¶ä¸”å¤§å°ä¸ä¼šè¶…è¿‡çˆ¶å®¹å™¨çš„å‰©ä½™ç©ºé—´. wrap_content: ä¸ç®¡çˆ¶å®¹å™¨æ˜¯ä»€ä¹ˆ. Viewéƒ½æ˜¯AT_MOST(æœ€å¤§æ¨¡å¼), å¹¶ä¸”å¤§å°ä¸èƒ½è¶…è¿‡çˆ¶å®¹å™¨å‰©ä½™ç©ºé—´. ä¸Šè¿°æ²¡æœ‰è¯´æ˜ŽUNSPECIFIEDåœ¨match_parentå’Œwrap_contentä¸­. å› ä¸ºè¿™ä¸ªæ¨¡å¼ä¸»è¦ç”¨äºŽç³»ç»Ÿå¤šæ¬¡Measureçš„æƒ…å½¢,ä¸€èˆ¬æ¥è¯´ä¸éœ€è¦å…³æ³¨. æ™®é€šViewçš„MeasureSpecçš„åˆ›å»ºæµç¨‹,è§„åˆ™å¦‚ä¸‹è¡¨æ‰€ç¤ºï¼š Viewçš„å·¥ä½œæµç¨‹ ä¸»è¦æŒ‡measure, layout, drawä¸‰å¤§æµç¨‹. å³æµ‹é‡,å¸ƒå±€,ç»˜åˆ¶. measureè¿‡ç¨‹è¿™é‡Œé¢å­˜åœ¨ä¸¤ç§åœºæ™¯: View: é€šè¿‡äº†measureæ–¹æ³•å°±å®Œæˆäº†æµ‹é‡è¿‡ç¨‹ ViewGroup: é™¤äº†æµ‹é‡è‡ªå·±,è¿˜ä¼šéåŽ†åŽ»è°ƒç”¨æ‰€æœ‰å­å…ƒç´ çš„measureæ–¹æ³•. å„ä¸ªå­å…ƒç´ åœ¨é€’å½’åŽ»æ‰§è¡Œè¿™ä¸ªæµç¨‹ Viewçš„measureè¿‡ç¨‹ Viewçš„measureè¿‡ç¨‹ç”±å…¶measure()æ–¹æ³•æ¥å®Œæˆ, measure()æ–¹æ³•æ˜¯ä¸€ä¸ªfinalç±»åž‹, è€Œåœ¨å†…éƒ¨è°ƒç”¨äº†onMeasure()è¿™ä¸ªå¯ä¸æ˜¯final, æ‰€ä»¥ä¹Ÿå¯ä»¥è‡ªå®šä¹‰çš„æ—¶å€™å¤å†™. çœ‹ä¸€ä¸‹å†…éƒ¨. 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; setMeasureDimension()ä¼šè®¾ç½®Viewå®½é«˜çš„æµ‹é‡å€¼. è¿™é‡Œéœ€è¦çœ‹ä¸€ä¸‹getDefaultSize()è¿™ä¸ªæ–¹æ³•. 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; çœ‹åˆ°å¦‚æžœè¿™ä¸ªviewæ˜¯EXACTLY(ç²¾å‡†æ¨¡å¼), é‚£ä¹ˆè¿”å›žçš„å¤§å°å°±æ˜¯SpecSizeã€‚ UNSPECIFIEDä¸€èˆ¬ç”¨äºŽç³»ç»Ÿæµ‹é‡å…ˆä¸è¯´. è€ŒAT_MOST(æœ€å¤§æ¨¡å¼)çš„æ—¶å€™. è™½ç„¶æ˜¯ä¸åŒæ¨¡å¼ä½†æ˜¯é»˜è®¤æƒ…å†µä¸‹å’Œç²¾ç¡®æ¨¡å¼æ˜¯ä¸€æ ·çš„ç»“æžœ. getSuggestedMinimumWidth()å’ŒgetSuggestedMinimumHeight(). çœ‹ä¸€ä¸‹å®žçŽ°. 1234567protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; é¦–å…ˆä¼šçœ‹æ˜¯å¦è®¾ç½®äº†èƒŒæ™¯. æ— èƒŒæ™¯: é‚£ä¹ˆå®½åº¦ä¸ºmMinWidth,è¿™ä¸ªå€¼å¯¹åº”å¸ƒå±€ä¸­çš„android:minWidthå±žæ€§,é»˜è®¤ä¸º0. æœ‰èƒŒæ™¯: é‚£ä¹ˆå–mMinWidthå’ŒmBackground.getMinimumWidth()æœ€å¤§å€¼. æˆ‘ä»¬çœ‹ä¸€ä¸‹:getMinimumHeight() 1234public int getMinimumHeight() &#123; final int intrinsicHeight = getIntrinsicHeight(); return intrinsicHeight &gt; 0 ? intrinsicHeight : 0;&#125; åŽŸæ¥getMinimumHeight()è¿”å›žçš„å°±æ˜¯Drawableçš„åŽŸå§‹é«˜åº¦ã€‚ å¦‚æžœæ²¡æœ‰å°±è¿”å›ž0. å…³äºŽåŽŸå§‹é«˜åº¦ä¸¾ä¸ªä¾‹å­ShapeDrawableæ— åŽŸå§‹å®½é«˜ï¼Œ BitmapDrawbleæœ‰åŽŸå§‹å®½é«˜å°±æ˜¯å›¾ç‰‡çš„å°ºå¯¸ã€‚ å†æ€»ç»“ä¸‹getDefaultSize()çš„é»˜è®¤è¡Œä¸ºï¼Œè™½ç„¶æˆ‘ä»¬åœ¨xmlå¸ƒå±€ä¸­ä½¿ç”¨äº†wrap_contentï¼Œä½†å®žé™…æ•ˆæžœä¸ºï¼šViewè‡ªèº«çš„MeasureSpecç­‰äºŽçˆ¶å®¹å™¨è‡ªèº«çš„å‰©ä½™å¤§å°ï¼Œå¹¶æ²¡æœ‰åŽ»é€‚é…Viewæœ¬èº«çš„å¤§å°ã€‚å› æ­¤ï¼š å¯¹äºŽç›´æŽ¥ç»§æ‰¿Viewçš„è‡ªå®šä¹‰æŽ§ä»¶ï¼Œéœ€è¦é‡å†™onMeasure()æ–¹æ³•å¹¶è®¾ç½®wrap_contentæ—¶çš„è‡ªèº«å¤§å°ã€‚ è‡ªå®šä¹‰Viewçš„æ—¶å€™å¦‚æžœä¸å¯¹wrap_contentè¿›è¡Œé¢å¤–å¤„ç†ï¼Œé‚£ä¹ˆå°±ä¼šè°ƒç”¨é»˜è®¤setMeasureDimension()æ–¹æ³•. è€Œé»˜è®¤ä¸­æ–¹æ³•çš„å®žå‚ä¼ é€’çš„æ˜¯getDefaultSize()è¿™ä¸ªæ–¹æ³•ä¸­å¯¹AT_MOSTè¿™ç§æ¨¡å¼æ²¡æœ‰å¤„ç†. ç›´æŽ¥æ²¿ç”¨å’Œç²¾ç¡®æ¨¡å¼çš„å¤§å°(ç›¸å½“äºŽè®¾ç½®äº†wrap_contentå´å¾—åˆ°äº†match_parentçš„æ˜¾ç¤ºç»“æžœ) å¯ä»¥é’ˆå¯¹è¿™ä¸ªé—®é¢˜, åšå‡ºå¯¹åº”çš„ç¼–ç è¿›è¡Œè§£å†³: 123456789101112131415161718192021222324@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //é»˜è®¤ä¼šè°ƒç”¨çˆ¶ç±»çš„setMeasuredDimension() super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpaceMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpaceMode = MeasureSpec.getMode(heightMeasureSpec); //è®¾ç½®ä¸¤ä¸ªé»˜è®¤å€¼å®½é«˜ int defaultHeight = 100; int defaultWidth = 100; // é’ˆå¯¹AT_MOSTæ¨¡å¼è¿›è¡Œç‰¹æ®Šå¤„ç† if (widthSpaceMode == MeasureSpec.AT_MOST &amp;&amp; heightSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, defaultHeight); &#125; else if (widthSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, heightSpaceSize); &#125; else if (heightSpaceMode == MeasureSpec.AT_MOST) setMeasuredDimension(widthMeasureSpec, defaultHeight); &#125; &#125; ViewGroupçš„Measure å¯¹äºŽViewGroupä¸å…‰ä¼šæµ‹é‡è‡ªå·±,è¿˜ä¼šéåŽ†è°ƒç”¨æ‰€æœ‰çš„å­å…ƒç´ çš„measure(). å’ŒViewä¸åŒçš„æ˜¯ViewGroupæ˜¯ä¸€ä¸ªæŠ½è±¡ç±»,å®ƒæ²¡æœ‰é‡å†™onMeasure,ä½†æä¾›äº†measureChildren()çš„æ–¹æ³•. è¿™ä¸ªmeasureChildren()æ–¹æ³•å†…éƒ¨æ¯”è¾ƒç®€å•å°±æ˜¯éåŽ†è‡ªå·±çš„å­©å­ç„¶åŽè°ƒç”¨-&gt;measureChild() è¿™ä¸ªmeasureChild()è¿™ä¸ªæ–¹æ³•å‰é¢è´´è¿‡æºç ã€‚å°±æ˜¯å–å‡ºå­å…ƒç´ çš„LayoutParamsï¼Œå¹¶è°ƒç”¨ getChildMeasureSpec()ï¼Œ é€šè¿‡ä¼ å…¥å­å…ƒç´ çš„LayoutParamsé‡Œé¢çš„å®½é«˜å±žæ€§å’Œpaddingï¼Œçˆ¶å…ƒç´ çš„marginå’Œå½“å‰MeasureSpecå±žæ€§æ¥è®¡ç®—å‡ºå­å…ƒç´ çš„MeasureSpecæœ€åŽè°ƒç”¨child.measure()ä¼ å…¥ä¹‹å‰è®¡ç®—çš„æµ‹é‡è§„æ ¼ã€‚ ViewGroupä¸ºä»€ä¹ˆæ²¡æœ‰å®šä¹‰æµ‹é‡çš„å…·ä½“è¿‡ç¨‹? å› ä¸ºå…·ä½“çš„æµ‹é‡è¿‡ç¨‹éœ€è¦äº¤ç»™å­ç±»åŽ»å®žçŽ°çš„. æ¯”å¦‚LinearLayout,RelativeLayout. çœ‹ä¸€ä¸‹LinearLayoutçš„onMeasure()æ˜¯å¦‚ä½•å®šä¹‰çš„. 12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; æ ¹æ®è®¾ç½®çš„æŽ’åˆ—æ–¹å¼è¿™é‡Œåˆ†ä¹‹äº†ä¸¤ç§æµ‹é‡æ–¹æ³•. ç¨å¾®çœ‹ä¸€ä¸‹å¤§æ¦‚è½®å»“ï¼Œé€‰æ‹©measureVertical()ä¸è´´æºç äº†è¿™ä¸ªæ–¹æ³•300è¡Œå‘¢! é¦–å…ˆLinearLayoutçš„è¿™ä¸ªæ–¹æ³•ä¼šéåŽ†æ¯ä¸ªå­å…ƒç´ å¹¶æ‰§è¡ŒmeasureChildBeforeLayout()æ–¹æ³•ã€‚è¿™ä¸ªæ–¹æ³•å†…éƒ¨ä¼šè°ƒç”¨å­å…ƒç´ çš„measure()ï¼Œè¿™æ ·å­å…ƒç´ ä¼šä¾æ¬¡æµ‹é‡ï¼Œå¹¶ä¸”ä¼šé€šè¿‡mTotalLenghtè¿™ä¸ªå˜é‡æ¥å­˜å‚¨LinearLayoutåœ¨ç«–ç›´æ–¹å‘ä¸Šçš„åˆæ­¥é«˜åº¦ï¼Œæ¯æµ‹é‡ä¸€ä¸ªå°±ä¼šå¢žåŠ ã€‚å½“å­å…ƒç´ æµ‹é‡å®Œä¹‹åŽï¼ŒLinearLayoutä¼šæµ‹é‡è‡ªå·±çš„å¤§å°ã€‚ åœ¨å¯¹è‡ªå·±è¿›è¡Œæµ‹é‡çš„æ—¶å€™ï¼Œ å¦‚æžœå¸ƒå±€ä¸­çš„é«˜åº¦é‡‡ç”¨çš„æ˜¯match_parentæˆ–è€…å…·ä½“æ•°å€¼ï¼Œé‚£ä¹ˆå®ƒçš„æµ‹é‡è¿‡ç¨‹å’ŒViewä¸€æ ·ï¼Œå³é«˜åº¦ä¸ºspecSizeã€‚å¦‚æžœå¸ƒå±€ä¸­é‡‡ç”¨wrap_contenté‚£ä¹ˆé«˜åº¦å°±æ˜¯æ‰€æœ‰çš„å­å…ƒç´ æ€»å’Œä½†æ˜¯ä¸èƒ½è¶…è¿‡çˆ¶å…ƒç´ å‰©ä½™ç©ºé—´ï¼Œå…·ä½“å¯å‚è€ƒresolveSizeAndState()çš„å®žçŽ°ã€‚ åˆ°è¿™é‡ŒåŸºæœ¬ä¸Šmeasureæµ‹é‡è¿‡ç¨‹å·²ç»åšäº†æ¯”è¾ƒè¯¦ç»†çš„åˆ†æžï¼Œè¿™ä¸ªè¿‡ç¨‹ä¹Ÿæ˜¯ä¸‰å¤§è¿‡ç¨‹ä¸­æœ€å¤æ‚çš„ä¸€ä¸ªï¼Œåœ¨measureå®Œæˆä¹‹åŽå°±å¯ä»¥é€šè¿‡getMeasuredWidth/Heightæ–¹æ³•èŽ·å–Viewçš„æµ‹é‡å®½é«˜ã€‚ ä½†æ˜¯è¯·æ³¨æ„: æŸäº›æžç«¯æƒ…å†µä¸‹ï¼Œmeasureå¯èƒ½æ‰§è¡Œå¤šæ¬¡ã€‚ æ‰€ä»¥å°½é‡åœ¨onLayout()æ–¹æ³•ä¸­åŽ»èŽ·å¾—æœ€ç»ˆå®½é«˜ã€‚ æ­£ç¡®èŽ·å–å®½é«˜æ–¹æ³•é¦–å…ˆæ˜Žç¡®ä¸€ç‚¹:Viewçš„measureå’ŒActivityçš„ç”Ÿå‘½å‘¨æœŸæ–¹æ³•ä¸æ˜¯åŒæ­¥æ‰§è¡Œ.æ‰€ä»¥æ— æ³•ä¿è¯åœ¨æŸä¸ªç”Ÿå‘½å‘¨æœŸ(onCreate,onStart)èŽ·å–åˆ°æ­£ç¡®çš„æµ‹é‡å®½é«˜ Activity/View#onWindowFocusChanged() view.post(runnable) ViewTreeObserver#onGlobalLayout view.measure() onWindowFocusChanged() Viewå·²ç»åˆå§‹åŒ–å®Œæ¯•ï¼Œå®½é«˜å·²ç»å‡†å¤‡å¥½ã€‚è¿™é‡Œéœ€è¦æ³¨æ„åªè¦Activityçš„ç„¦ç‚¹å‘ç”Ÿå˜åŒ–æ­¤æ–¹æ³•å°±ä¼šè¢«è°ƒç”¨ï¼Œæ‰€ä»¥å¦‚æžœä½ çš„ç•Œé¢åœ¨è¿›è¡ŒonPauseå’ŒonResumeï¼Œé‚£ä¹ˆonWindowFocusChanged()ä¹Ÿä¼šå¾—åˆ°è°ƒç”¨ã€‚ View.post(runnable) é€šè¿‡postå¯ä»¥å°†ä¸€ä¸ªrunnableæŠ•é€’åˆ°æ¶ˆæ¯é˜Ÿåˆ—çš„å°¾éƒ¨ï¼Œç„¶åŽç­‰å¾…Looperè°ƒç”¨åˆ°æ­¤runnableçš„æ—¶å€™ï¼ŒViewå·²ç»åˆå§‹åŒ–å®Œæ¯•ã€‚ ä½¿ç”¨ViewTreeObserver å½“Viewçš„å¯è§æ€§å‘ç”Ÿäº†æ”¹å˜çš„æ—¶å€™ï¼ŒonGlobalLayout()å°†å‘ç”Ÿå›žè°ƒï¼Œæ³¨æ„ä¼´éšç€Viewæ ‘çš„çŠ¶æ€æ”¹å˜ç­‰ï¼Œè¿™ä¸ªå›žè°ƒæ–¹æ³•å¯èƒ½ä¼šè¢«è°ƒç”¨å¤šæ¬¡.ã€‚ä½¿ç”¨ä»£ç å¦‚ä¸‹ 123456789ViewTreeObserver viewTreeObserver = view.getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); int height = view.getMeasuredHeight(); int width = view.getMeasuredWidth(); &#125; &#125;); view.measure(widthMeasureSpec, heightMeasureSpec) ä¹Ÿå¯ä»¥æ‰‹åŠ¨è¿›è¡Œæµ‹é‡ï¼Œä½†æ˜¯éœ€è¦åˆ†æƒ…å†µå¤„ç†MeasureSpec match_parent å½“Viewæ˜¯æ­¤å±žæ€§çš„æ—¶å€™æ— æ³•ä½¿ç”¨measure()ï¼Œé¦–å…ˆä½¿ç”¨è¿™ç§æ–¹æ³•éœ€è¦çš„å‚æ•°ï¼Œæ˜¯é€šè¿‡çˆ¶å®¹å™¨å’Œå­å…ƒç´ ç»„åˆæ¥ç”Ÿæˆçš„å­å…ƒç´ çš„MeasureSpecå±žæ€§ã€‚æ‰€ä»¥åœ¨å¤–éƒ¨æˆ‘ä»¬ä¸çŸ¥é“çˆ¶å…ƒç´ çš„å‚æ•°å€¼å¾—æ—¶å€™åªèƒ½å¤„ç†ä¸éœ€è¦çˆ¶å…ƒç´ æ•°æ®å°±å¯ä»¥ç”Ÿæˆå­å…ƒç´ çš„MeasureSpecçš„æ¨¡å¼ æ‰€ä»¥å¾ˆæ¸…æ¥š, è¿™ä¸ªmatch_patchè¿™ä¸ªæ¨¡å¼ï¼Œåœ¨ç»™å…¶å­å…ƒç´ æž„é€ MeasureSpecçš„æ—¶å€™éœ€è¦å¾—å€¼parentSizeï¼Œæ‰€ä»¥å¾—åˆ°çš„ä¹Ÿæ˜¯æ— æ•ˆã€‚ å…·ä½“æ•°å€¼px/dx å‡è®¾è¿™é‡Œæ˜¯100px, é¦–å…ˆæž„æˆå®½é«˜å¯¹åº”çš„MeasureSpecå±žæ€§ 123int widthSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int heightSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY); view.measure(widthSpec, heightSpec); wrap_content 123int widthSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST);int heightSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST); view.measure(widthSpec, heightSpec); é€šè¿‡(1&lt;&lt;30) - 1 å¯ä»¥æž„æˆä¸€ä¸ªMeasureSpecä½Ž30ä½çš„æœ€å¤§å€¼. ç”¨ç†è®ºä¸ŠViewèƒ½æ”¯æŒçš„æœ€å¤§å€¼åŽ»æž„é€ MeasureSpecã€‚ layoutè¿‡ç¨‹åœ¨ViewGroupä¸­ä¼šå…ˆé€šè¿‡layout()æ–¹æ³•ç¡®å®šæœ¬èº«çš„ä½ç½®. ç„¶åŽè°ƒç”¨onLayout()æ–¹æ³•éåŽ†æ‰€æœ‰çš„å­å…ƒç´ ,å¹¶è°ƒç”¨å­å…ƒç´ çš„layout()æ–¹æ³•ç¡®å®šå­å…ƒç´ çš„ä½ç½®â€¦ä¾æ¬¡å¾ªçŽ¯. æå‡ºViewçš„layoutæ–¹æ³•, è¿™é‡ŒæŠ½å–éƒ¨åˆ†ä»£ç  12345678910111213public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); &#125; &#125; è¿™æ ·æ¥çœ‹,å¤§è‡´æµç¨‹é€šè¿‡setFrame()æ–¹æ³•æ¥è®¾å®šViewçš„å››ä¸ªé¡¶ç‚¹çš„ä½ç½®ï¼Œå³mLeftã€mTopã€mBottomã€mRightè¿™å››ä¸ªé¡¶ç‚¹ä¸€æ—¦ç¡®å®šã€‚å½“å‰Viewçš„ä½ç½®ä¹Ÿå°±ç¡®å®šï¼Œç„¶åŽä¼šè°ƒç”¨onLayout()æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯ç¡®å®šå­å…ƒç´ çš„Viewä½ç½®ã€‚ è¿™é‡Œçš„å’ŒonMeasure()ç±»ä¼¼ï¼Œ onLayout()å…·ä½“å®žçŽ°å’Œå…·ä½“çš„å¸ƒå±€æœ‰å…³, æ‰€ä»¥Viewå’ŒViewGroupå‡æ²¡æœ‰çœŸæ­£å®žçŽ°onLayout()æ–¹æ³•ã€‚ çœ‹ä¸€ä¸‹LinearLayoutçš„onLayout()æºç  12345678@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; å’ŒonMeasure()ä¸€æ ·åˆ†æ”¯,æŽ¥ä¸‹æ¥è·Ÿè¿›layoutVertical()è´´å‡ºä¸»è¦ä»£ç  1234567891011121314151617181920212223242526272829303132void layoutVertical(int left, int top, int right, int bottom) &#123; //çœç•¥ä¸€éƒ¨åˆ†... for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; //çœç•¥ä¸€éƒ¨åˆ†... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; ä¸Šé¢ä»£ç å¤§ä½“é€»è¾‘: é¦–å…ˆéåŽ†æ‰€æœ‰å­©å­å¹¶è°ƒç”¨setChildFrame()æ¥ä¸ºå­å…ƒç´ æŒ‡å®šå¯¹åº”çš„ä½ç½®. å…¶ä¸­childTopä¼šé€æ¸å¢žå¤§, è¿™å°±æ„å‘³ç€åŽé¢çš„å­å…ƒç´ ä¼šè¢«æ”¾ç½®åœ¨é ä¸‹çš„ä½ç½®. è€ŒsetChildFrame()å†…éƒ¨ä»…æœ‰ä¸€è¡Œä»£ç , å°±æ˜¯è°ƒç”¨å­å…ƒç´ çš„layout()å¹¶ä¼ å…¥å®ƒè‡ªèº«åº”è¯¥å­˜æ”¾çš„ä½ç½®. 123private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; è€Œåœ¨setChildFrame()ä¸­ä¼ å…¥çš„å®½é«˜å°±æ˜¯å­å…ƒç´ çš„æµ‹é‡å®½é«˜ã€‚ è€Œåœ¨å­å…ƒç´ çš„layout()ä¸­é€šè¿‡setFrame()æ¥è®¾ç½®å…ƒç´ çš„å››ä¸ªé¡¶ç‚¹ã€‚ Viewçš„æµ‹é‡å®½é«˜getMeasureWidth()/getMeasureHeight() å’Œ layoutåŽç”¨getWidth()/getHeight()èŽ·å¾—çš„æœ€ç»ˆå®½/é«˜æœ‰ä»€ä¹ˆåŒºåˆ«? åœ¨ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œæµ‹é‡measureå’Œlayoutæ—¶å€™çš„å€¼æ˜¯å®Œå…¨ä¸€æ ·çš„ï¼Œå› ä¸ºlayout()ä¸­æŽ¥å—çš„å‚æ•°å°±æ˜¯é€šè¿‡æµ‹é‡çš„ç»“æžœèŽ·å–åˆ°çš„ã€‚ å¹¶ä¸”å†…éƒ¨ç›´æŽ¥é€šè¿‡setFrame()èµ‹å€¼åˆ°è‡ªå·±çš„å››ä¸ªæˆå‘˜å˜é‡ä¸Šã€‚ä½†æ˜¯å¦‚æžœå¯¹layout()è¿›è¡Œäº†å¤å†™ã€‚å¦‚ä¸‹ 1234 @Overrideprotected void layout(int l, int t, int r, int b) &#123; super.layout( l, t+200, r, b+200);&#125; å¦‚æžœè¿›è¡Œäº†è¿™æ ·çš„å¤å†™, é‚£ä¹ˆæœ€ç»ˆå®½é«˜æ°¸è¿œä¼šä¸Žæµ‹é‡çš„å‡ºæ¥çš„å€¼ç›¸å·®200,ä½†æ˜¯è¿™æ ·åšä¼šå¯¼è‡´æ˜¾ç¤ºä¸æ­£å¸¸ï¼Œå¹¶æ²¡æœ‰ä»€ä¹ˆæ„ä¹‰. drawè¿‡ç¨‹è¿™ä¸ªè¿‡ç¨‹åªæ˜¯å°†Viewç»˜åˆ¶åˆ°å±å¹•ä¸Šé¢. ç»˜åˆ¶èƒŒæ™¯background.draw(canvas) ç»˜åˆ¶è‡ªå·±onDraw() ç»˜åˆ¶childrendispatchDraw() ç»˜åˆ¶è£…é¥°onDrawScrollBars() Viewç»˜åˆ¶è¿‡ç¨‹ä¼ é€’æ˜¯é€šè¿‡dispatchDraw()å®žçŽ°çš„. ä¼ é€’äº†è‡ªå·±çš„ç”»å¸ƒ. è¿™ä¸ªæ–¹æ³•ä¼šéåŽ†å­å…ƒç´ å¹¶ä¸”è°ƒç”¨å­å…ƒç´ çš„draw() Viewä¸€ä¸ªç‰¹æœ‰çš„æ–¹æ³•setWillNotDraw()ï¼Œè¿™ä¸ªæ–¹æ³•æ˜¯è®¾ç½®äº†trueé‚£ä¹ˆç³»ç»Ÿä¼šè¿›è¡Œç›¸åº”çš„ä¼˜åŒ–ï¼Œ åœ¨Viewä¸­é»˜è®¤æ˜¯å…³é—­çš„.ï¼Œè€ŒViewGroupé»˜è®¤æ˜¯å¼€å¯çš„ã€‚å¦‚æžœæˆ‘ä»¬ç»§æ‰¿äº†è‡ªå®šä¹‰ViewGroupå¦‚æžœè¿˜éœ€è¦ç»˜åˆ¶è‡ªå·±çš„å†…å®¹é‚£ä¹ˆéœ€è¦æ˜¾ç¤ºçš„å…³é—­æ­¤æ ‡è®°ã€‚ è‡ªå®šä¹‰Viewè‡ªå®šä¹‰Viewçš„åˆ†ç±»1.ç›´æŽ¥ç»§æ‰¿Viewé‡å†™onDrawæ–¹æ³• è¿™ç§æ–¹æ³•ä¸»è¦ç”¨äºŽå®žçŽ°ä¸€äº›ä¸è§„åˆ™çš„æ•ˆæžœ,ï¼Œä¸æ–¹ä¾¿ç»„åˆå¸ƒå±€å®žçŽ°ï¼Œæˆ–è€…åˆæœ‰åŠ¨æ€æ˜¾ç¤ºçš„ä¸€äº›å›¾å½¢ã€‚ éœ€è¦è‡ªå·±ç»˜åˆ¶é‚£ä¹ˆå°±é‡å†™onDraw()æ–¹æ³•ã€‚è¿™ç§æ–¹æ³•éœ€è¦è‡ªå·±æ”¯æŒwrap_contentå’Œpadding 2.ç›´æŽ¥ç»§æ‰¿ViewGroupæ´¾ç”Ÿç‰¹æ®Šçš„Layout è¿™ç§æ–¹å¼ç”¨äºŽå®žçŽ°è‡ªå®šä¹‰å¸ƒå±€ï¼Œè¿™ç§å¸ƒå±€çš„å®žçŽ°ç¨å¾®å¤æ‚ï¼Œéœ€è¦åˆé€‚çš„å¤„ç†ViewGroupçš„æµ‹é‡ï¼Œå¸ƒå±€è¿™ä¸¤ä¸ªè¿‡ç¨‹ï¼Œå¹¶åŒæ—¶å¤„ç†å­å…ƒç´ çš„æµ‹é‡å’Œå¸ƒå±€è¿‡ç¨‹ã€‚ 3.ç»§æ‰¿ç‰¹å®šçš„View(TextView) æ¯”è¾ƒå¸¸è§ï¼Œ ä¸€èˆ¬ç”¨äºŽæ‰©å±•å·²æœ‰çš„Viewçš„åŠŸèƒ½ã€‚è¿™ç§ä¸éœ€è¦è‡ªå·±å¤„ç†wrap_contentå’Œpadding 4.ç»§æ‰¿ç‰¹å®šViewGroup(LinearLayout) å½“æŸç§æ•ˆæžœçœ‹èµ·æ¥åƒå‡ ç§Viewçš„ç»„åˆåœ¨ä¸€èµ·çš„æ—¶å€™ï¼Œå¯ä»¥é‡‡ç”¨è¿™ç§æ–¹å¼ã€‚è¿™ç§æ–¹å¼ä¸éœ€è¦è‡ªå·±å¤„ç†ViewGroupçš„æµ‹é‡å’Œå¸ƒå±€ã€‚ è‡ªå®šä¹‰Viewçš„é¡»çŸ¥ é‡å†™Viewçš„onMeasure()æ”¯æŒwrap_contentå±žæ€§ é‡å†™onMeasure()é’ˆå¯¹AT_MOSTæ¨¡å¼ç‰¹æ®Šå¤„ç†ã€‚å¦‚æžœä¸å¤„ç†ï¼Œè®¾ç½®çš„wrap_contentå±žæ€§ç›¸å½“äºŽmatch_parentçš„æ•ˆæžœï¼Œå‚è€ƒå‰é¢çš„Viewçš„measureè¿‡ç¨‹ã€‚ é‡å†™Viewçš„onDraw()æ”¯æŒpaddingå±žæ€§ å¦‚æžœç›´æŽ¥ç»§æ‰¿Viewï¼Œåœ¨onDraw()ä¸­ä¸å¤„ç†paddingï¼Œé‚£ä¹ˆå±žæ€§æ˜¯æ— æ³•èµ·ä½œç”¨çš„ã€‚è¿˜æœ‰ç»§æ‰¿ViewGroupçš„æŽ§ä»¶éœ€è¦åœ¨onMeasureå’ŒonLayoutä¸­è€ƒè™‘paddingå’Œå­å…ƒç´ çš„marginä¼šé€ æˆçš„å½±å“ã€‚ å°½é‡ä¸è¦åœ¨Viewä¸­new Handlerä½¿ç”¨ å†…éƒ¨å·²ç»æä¾›äº†postç³»åˆ—æ–¹æ³•ï¼ˆå†…éƒ¨å®žçŽ°ä¹Ÿæ˜¯Handlerï¼‰ï¼Œé™¤éžå¾ˆæ˜Žç¡®è¦æ˜¯ç”¨Handlerå‘é€æ¶ˆæ¯ã€‚ Viewä¸­å¦‚æžœæœ‰çº¿ç¨‹æˆ–è€…åŠ¨ç”»ï¼Œéœ€è¦åŠæ—¶çš„åœæ­¢ å½“åŒ…å«æ­¤Viewçš„Activityé€€å‡ºæˆ–è€…æ­¤Viewè¢«removeçš„æ—¶å€™ï¼ŒViewçš„onDetachedFromWindow()ä¼šè¢«è°ƒç”¨ï¼Œå¯ä»¥é€‚å½“å¤„ç†é˜²æ­¢å†…å­˜æ³„æ¼ã€‚ Viewå¸¦æœ‰çš„æ»‘åŠ¨åµŒå¥—æ—¶ï¼Œéœ€è¦å¤„ç†å¥½æ»‘åŠ¨å†²çª è‡ªå®šä¹‰Viewå®žä¾‹1.è‡ªå®šä¹‰Viewæ´¾ç”Ÿç±» é¦–å…ˆæˆ‘ä»¬çœ‹ä¸€ä¸‹è‡ªå®šä¹‰Viewå¯èƒ½æ¶‰åŠçš„å±žæ€§ï¼Œæ¯”å¦‚ä¸€ä¸ªCircleView: 12345678&lt;com.ryg.chapter_4.ui.CircleView android:id="@+id/circleView1" android:layout_width="wrap_content" android:layout_height="100dp" android:layout_margin="20dp" android:background="#000000" android:padding="20dp" app:circle_color="@color/light_green" /&gt; ç¬¬ä¸€æ­¥: é€‚é…wrap_contentå±žæ€§ å¯¹äºŽç›´æŽ¥ç»§æ‰¿Viewçš„ç©ºé—´ï¼Œä¸ç®¡æ˜¯è®¾ç½®match_parentä¹Ÿå¥½ï¼Œwrap_contentä¹Ÿå¥½çˆ¶å®¹å™¨éƒ½ä¼šç»™åˆ†é…è‡ªå·±å‰©ä½™ç©ºé—´çš„å¤§å°ç»™å­å®¹å™¨ä½œä¸ºspecSizeçš„ç©ºé—´å¤§å°ã€‚å¦‚æžœä¸å¯¹wrap_contentå¤„ç†é‚£å°±æ˜¯ç›¸å½“äºŽå’Œmatch_parentå¡«å……çˆ¶å®¹å™¨çš„æ•ˆæžœä¸€æ ·ã€‚ æ‰€ä»¥éœ€è¦å¯¹onMeasure()æ–¹æ³•ä¸­çš„AT_MOSTæ¨¡å¼çš„æŒ‡å®šé»˜è®¤å¤§å°æ¯”å¦‚200pxï¼š 12345678910111213141516protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //é»˜è®¤è°ƒç”¨super.setMeasuredDimension() super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(200, 200); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(200, heightSpecSize); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSpecSize, 200); &#125; &#125; ç¬¬äºŒæ­¥: é€‚é…paddingå±žæ€§ marginæ˜¯äº¤ç»™çˆ¶å®¹å™¨åˆ†é…çš„ï¼Œä½†æ˜¯paddingæ˜¯è¦å­Viewè‡ªå·±è¦å¤„ç†çš„. è¿™æ—¶éœ€è¦é‡å†™onDraw()ä¸­æ¥å¤„ç†. 123456789101112protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); final int paddingLeft = getPaddingLeft(); final int paddingRight = getPaddingRight(); final int paddingTop = getPaddingTop(); final int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingTop - paddingBottom; int radius = Math.min(width, height) / 2; canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, mPaint); &#125; ç¬¬ä¸‰æ­¥:æœ‰æ—¶å€™æˆ‘ä»¬éœ€è¦æä¾›è‡ªå®šä¹‰å±žæ€§ï¼Œ ä¾‹å¦‚android:id=è¿™ç§ï¼ŒæŽ¥ä¸‹æ¥æ·»åŠ è‡ªå®šä¹‰å±žæ€§ï¼š åœ¨valuesç›®å½•ä¸‹åˆ›å»ºè‡ªå®šä¹‰å±žæ€§çš„xml. åå­—éšä¾¿å½“æœ€å¥½attrs.xmlæˆ–è€…attrs_xxx_xxx.xml. 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="CircleView"&gt; &lt;attr name="circle_color" format="color"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; ä¸Šé¢ç›¸å½“äºŽ,å®šä¹‰äº†ä¸€ä¸ªCircleViewçš„å±žæ€§é›†åˆ. åœ¨è¿™ä¸ªé›†åˆé‡Œé¢ä¼šæœ‰è‡ªå®šä¹‰å±žæ€§. è¿™é‡Œçš„formatæ ¼å¼å¯ä»¥æ˜¯æŒ‡å®šå°ºå¯¸çš„dimension, èµ„æºidå¼•ç”¨çš„reference, åŸºæœ¬ç±»åž‹string, integer ,booleanç­‰. å£°æ˜Žå¥½äº†å±žæ€§åœ¨æˆ‘ä»¬è‡ªå®šä¹‰Viewä¸­å°±å¯ä»¥å¼•ç”¨å¤„ç†äº†. å¦‚æž„é€ æ–¹æ³•ä¸­. 1234567891011public CircleView(Context context, AttributeSet attrs) &#123; super(context, attrs, defStyleAttr); //èŽ·å¾—ä¸€ä¸ªè‡ªå®šä¹‰çš„å¯¹åº”å±žæ€§å€¼é›†åˆ TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView); //å–å‡ºå±žæ€§é›†åˆä¸­çš„æŸä¸ªå±žæ€§å€¼ mColor = typedArray.getColor(R.styleable.CircleView_circle_color, Color.GREEN); //é‡Šæ”¾èµ„æº typedArray.recycle(); init(); &#125; åœ¨å¸ƒå±€ä¸­ä½¿ç”¨å³å¯. å…ˆå£°æ˜Žschemas. xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; ,ä½¿ç”¨appæ¥æ›¿ä»£ä¹‹å‰çš„ç±»ä¼¼androidå‰ç¼€çš„å¼•å¯¼. ç»§æ‰¿Viewçš„æ´¾ç”Ÿç±»å°±åˆ°æ­¤ä¸ºæ­¢äº†ï¼šæ•ˆæžœå¦‚ä¸‹ï¼š]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>è‡ªå®šä¹‰View</tag>
        <tag>Viewçš„å·¥ä½œåŽŸç†</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Viewçš„äº‹ä»¶ä½“ç³»]]></title>
    <url>%2F2018%2F02%2F28%2FView%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[View çš„åŸºç¡€çŸ¥è¯† Viewçš„ä½ç½®å‚æ•° Viewç›¸å¯¹äºŽçˆ¶å®¹å™¨çš„åæ ‡topï¼Œleftï¼Œrightï¼Œbottomã€‚ 12width = right - leftheight = bottom - top ä»ŽAndroid 3.0å¼€å§‹å¢žåŠ äº†xã€yã€translationXã€tranlationYï¼›å…¶ä¸­ï¼š Viewä¹Ÿæä¾›äº†ç›¸åº”çš„get/setæ–¹æ³•ï¼Œå…³ç³»æ¢ç®—ï¼š 12x = left + translationXy = top + translationY æ³¨æ„âš ï¸ï¼šViewåœ¨å¹³ç§»çš„è¿‡ç¨‹ä¸­ï¼Œtopå’Œleftçš„å€¼å¹¶ä¸ä¼šæ”¹å˜ï¼Œæ­¤æ—¶å‘ç”Ÿæ”¹å˜çš„æ˜¯xã€yã€translationXå’ŒtranslationYã€‚ MotionEvent å’Œ TouchSlop ACTION_DOWNâ€”â€”æ‰‹æŒ‡åˆšæŽ¥è§¦å±å¹• ACTION_MOVEâ€”â€”æ‰‹æŒ‡åœ¨å±å¹•ä¸Šç§»åŠ¨ ACTION_UPâ€”â€”æ‰‹æŒ‡ä»Žå±å¹•ä¸Šæ¾å¼€çš„ä¸€çž¬é—´ getX/getYè¿”å›žçš„æ˜¯ç›¸å¯¹äºŽå½“å‰Viewçš„å·¦ä¸Šè§’çš„xå’Œyçš„åæ ‡ï¼Œè€ŒgetRawX/getRawYè¿”å›žçš„æ˜¯æ˜¯ç›¸å¯¹äºŽæ‰‹æœºå±å¹•å·¦ä¸Šè§’çš„åæ ‡ã€‚ TouchSlop æ˜¯ç³»ç»Ÿèƒ½è¯†åˆ«å‡ºçš„è¢«è®¤ä¸ºæ˜¯æ»‘åŠ¨çš„æœ€å°è·ç¦»(8dp)ã€‚ ViewConfigrarion.get(getContext()).getScaledTouchSlop() VelocityTrackerã€GestureDetectorå’ŒScroller VelocityTrackerç”¨äºŽè¿½è¸ªæ‰‹æŒ‡åœ¨æ»‘åŠ¨è¿‡ç¨‹ä¸­çš„é€Ÿåº¦ã€‚ GestureDetector æ‰‹åŠ¿æ£€æµ‹ï¼Œç”¨äºŽæ£€æµ‹å•å‡»ã€æ»‘åŠ¨ã€é•¿æŒ‰ã€åŒå‡»ç­‰è¡Œä¸ºã€‚éœ€è¦å®žçŽ°æŽ¥å£onGestureListenerå’ŒonDoubleTapListeneræ¯”è¾ƒå¸¸ç”¨çš„æœ‰ï¼šonSingleTapUpï¼ˆå•å‡»ï¼‰ã€onFlingï¼ˆå¿«é€Ÿæ»‘åŠ¨ï¼‰ã€onScollï¼ˆæ‹–åŠ¨ï¼‰ã€onLongPressï¼ˆé•¿æŒ‰ï¼‰ã€onDoubleTapï¼ˆåŒå‡»ï¼‰ã€‚ Scrollå®žçŽ°å¼¹æ€§æ»‘åŠ¨ã€‚ Viewçš„æ»‘åŠ¨ ä½¿ç”¨scrollTo/srollBy123public void scrollTo (int x, int y);//ç»å¯¹åæ ‡æ»‘åŠ¨public void scrollBy(int x, int y);//ç›¸å¯¹åæ ‡æ»‘åŠ¨ å¦‚æžœä»Žå·¦åˆ°å³æ»‘åŠ¨ï¼Œé‚£ä¹ˆmSrollXä¸ºè´Ÿå€¼ï¼Œåä¹‹ä¸ºæ­£ï¼›å¦‚æžœä»Žä¸Šå¾€ä¸‹æ»‘åŠ¨ï¼Œé‚£ä¹ˆmScrollYä¸ºè´Ÿå€¼ï¼Œåä¹‹ä¸ºæ­£ï¼›ä½¿ç”¨scrollToå’ŒscrollByæ¥å®žçŽ°Viewçš„æ»‘åŠ¨ï¼Œåªèƒ½å°†Viewçš„å†…å®¹è¿›è¡Œç§»åŠ¨ï¼Œä¸å½±å“å†…éƒ¨å…ƒç´ çš„ç‚¹å‡»äº‹ä»¶ï¼Œä½†æ˜¯å¹¶ä¸èƒ½æ”¹å˜Viewçš„åŽŸå§‹å¸ƒå±€ä½ç½®ã€‚ ä½¿ç”¨åŠ¨ç”» ViewåŠ¨ç”»ï¼Œç”¨xmlå®žçŽ° View åŠ¨ç”»æ˜¯å¯¹Viewçš„å½±åƒåšæ“ä½œï¼Œå¹¶ä¸èƒ½çœŸæ­£çš„æ”¹å˜Viewçš„ä½ç½®å‚æ•°å’Œå®½é«˜ï¼›å¹¶ä¸”å¦‚æžœå¸Œæœ›åŠ¨ç”»åŽçš„çŠ¶æ€ä¿ç•™å¿…é¡»è®¾ç½®fillAfterå±žæ€§ä¸ºtrueã€‚é€‚ç”¨äºŽæ²¡æœ‰äº¤äº’æ€§çš„ï¼ˆç‚¹å‡»ï¼‰åœºæ™¯ã€‚ å±žæ€§åŠ¨ç”» 1ObjectAnimator.ofFloat(targetView, "translationX", 0, 100).setDuration(100).start(); å±žæ€§åŠ¨ç”»èƒ½å¤Ÿæ”¹å˜åŽŸå§‹ä½ç½®ï¼Œæ²¡æœ‰ç¼ºç‚¹ï¼Œä¼˜å…ˆæŽ¨èä½¿ç”¨ã€‚ æ”¹å˜å¸ƒå±€å‚æ•°æ”¹å˜Viewçš„å¸ƒå±€å‚æ•°LayoutParamsï¼Œé€‚ç”¨äºŽæœ‰äº¤äº’çš„Viewï¼Œæ“ä½œç¨å¾®å¤æ‚ã€‚ å¼¹æ€§æ»‘åŠ¨ä½¿ç”¨Scroller Scroller æœ¬èº«ä¸èƒ½å®žçŽ° View çš„æ»‘åŠ¨ï¼Œå®ƒéœ€è¦é…åˆ View çš„ computeScroll æ–¹æ³•æ‰èƒ½å®Œæˆå¼¹æ€§æ»‘åŠ¨çš„æ•ˆæžœã€‚é€šè¿‡ä¸æ–­åœ°è®© View é‡ç»˜ï¼Œè€Œæ¯ä¸€æ¬¡é‡ç»˜è·ç¦»æ»‘åŠ¨å…¶å®žèµ·å§‹æ—¶é—´ä¼šæœ‰ä¸€ä¸ªæ—¶é—´é—´éš”ï¼Œé€šè¿‡è¿™ä¸ªæ—¶é—´é—´éš” Scroller å¾—å‡º View å½“å‰çš„æ»‘åŠ¨ä½ç½®ï¼ŒçŸ¥é“äº†æ»‘åŠ¨ä½ç½®å°±å¯ä»¥é€šè¿‡ scrollTo æ–¹æ³•å®Œæˆ View çš„æ»‘åŠ¨ã€‚ View çš„æ¯ä¸€æ¬¡é‡ç»˜éƒ½ä¼šå¯¼è‡´ View çš„å°å¹…åº¦æ»‘åŠ¨ï¼Œè€Œå¤šæ¬¡çš„å°å¹…åº¦æ»‘åŠ¨ç»„æˆäº†å¼¹æ€§æ»‘åŠ¨ï¼Œè¿™å°±æ˜¯ Scroller æ»‘åŠ¨çš„å·¥ä½œæœºåˆ¶ã€‚ 123456789101112131415161718192021Scroller mScroller = new Scroller(mContext);// ç¼“æ…¢æ»šåŠ¨åˆ°æŒ‡å®šçš„ä½ç½® private void smoothScrollTo(int destX, int destY)&#123; int scrollX = getScrollX(); int deltaX = destX - scrollX; // ä»¥ 1000ms å†…æ»‘å‘ destXï¼Œ æ•ˆæžœæ˜¯æ…¢æ…¢æ»‘åŠ¨ mScroller.startScroll(scrollX, destY, deltaX , 0, 1000); // View çš„é‡ç»˜ invalidate();&#125; // é‡å†™ computeScroll æ–¹æ³•ï¼Œå¹¶åœ¨å†…éƒ¨å®Œæˆå¹³æ»‘æ»šåŠ¨çš„é€»è¾‘ @Overridepublic void computeScroll() &#123; //åˆ¤æ–­viewæ˜¯åœ¨æŒ‡å®šæ—¶é—´å†…æ˜¯å¦å®Œæˆæ»‘åŠ¨,å¹¶è®¡ç®—å‡ºå½“å‰æ—¶é—´çš„ mScrolleX å’Œ mScrollY if (mScroller.computeScrollOffset())&#123; //é€šè¿‡mScrollerèŽ·å–å½“å‰ä½ç½®ï¼Œå®žçŽ°æ»‘åŠ¨ scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // å†æ¬¡è¿›è¡Œé‡ç»˜ postInvalidate(); &#125;&#125; é€šè¿‡åŠ¨ç”»å±žæ€§åŠ¨ç”»ï¼š12ObjectAnimator animator = ObjectAnimator.ofFloat(view, "translationX", 0.0f, 100.0f);animator.setDuration(100).start(); æˆ–è€… 1234567891011121314151617181920private void scroller()&#123; //åŠ¨ç”»èµ·å§‹ä½ç½® final int startX = 0; //åŠ¨ç”»è¦æ»‘åŠ¨çš„è·ç¦» final int deltax = 1000; final ValueAnimator animator = ValueAnimator.ofInt(0, 1).setDuration(2000); //åŠ¨ç”»æ·»åŠ ç›‘å¬å™¨ animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //èŽ·å–åŠ¨ç”»å®Œæˆæ¯”ä¾‹å€¼ float fraction = animator.getAnimatedFraction(); //æ ¹æ®æ¯”ä¾‹å€¼å¯¹ç›®æ ‡viewè¿›è¡Œæ»‘åŠ¨ targetView.scrollTo(startX +(int)(deltax * fraction), 0); //add other operation &#125; &#125;); //å¼€å§‹æ‰§è¡Œ animator.start();&#125; ç¬¬äºŒç§æ–¹æ³•æ€æƒ³å’ŒScrollerå¾ˆç±»ä¼¼ï¼Œé€šè¿‡æ—¶é—´æµé€æ¯”ä¾‹æ¥è®¡ç®—æ»‘åŠ¨è·ç¦»ã€‚ ä½¿ç”¨å»¶è¿Ÿç­–ç•¥ ä½¿ç”¨Handleræˆ–è€…Viewçš„postDelayæ–¹æ³•ï¼Œé—´éš”çš„å‘é€æ¶ˆæ¯ï¼Œè®¡ç®—æ»‘åŠ¨è·ç¦»ï¼Œå¹¶ä½¿ç”¨scrollToå®Œæˆæ»‘åŠ¨ã€‚ Viewçš„äº‹ä»¶åˆ†å‘ ç‚¹å‡»äº‹ä»¶çš„ä¼ é€’è§„åˆ™1public boolean dispatchTouchEvent(MotionEvent ev) ç”¨æ¥è¿›è¡Œäº‹ä»¶çš„åˆ†å‘ï¼Œå¦‚æžœäº‹ä»¶èƒ½å¤Ÿä¼ é€’ç»™å½“å‰çš„Viewï¼Œé‚£ä¹ˆæ­¤æ–¹æ³•ä¸€å®šä¼šè¢«è°ƒç”¨ï¼Œè¿”å›žç»“æžœå—å½“å‰Viewçš„onTouchEventå’Œä¸‹çº§çš„Viewçš„dispatchTouchEventæ–¹æ³•çš„å½±å“ï¼Œè¡¨ç¤ºæ˜¯å¦æ¶ˆè€—å½“å‰äº‹ä»¶ã€‚ 1public boolean onInterceptTouchEvent(MotionEvent event) åœ¨dispatchTouchEventå†…éƒ¨è°ƒç”¨ï¼Œç”¨æ¥åˆ¤æ–­æ˜¯å¦æ‹¦æˆªæŸä¸ªäº‹ä»¶ï¼Œå¦‚æžœå½“å‰Viewæ‹¦æˆªäº†æŸä¸ªäº‹ä»¶ï¼Œé‚£ä¹ˆåœ¨åŒä¸€ä¸ªäº‹ä»¶åºåˆ—ä¸­ï¼Œæ­¤æ–¹æ³•ä¸ä¼šè¢«å†æ¬¡è°ƒç”¨ï¼Œè¿”å›žç»“æžœè¡¨ç¤ºæ˜¯å¦æ‹¦æˆªå½“å‰äº‹ä»¶ã€‚ 1public boolean onTouchEvent(MotionEvent event) åœ¨dispatchTouchEventä¸­è°ƒç”¨ï¼Œç”¨æ¥å¤„ç†ç‚¹å‡»äº‹ä»¶ï¼Œè¿”å›žç»“æžœè¡¨ç¤ºæ˜¯å¦æ¶ˆè€—å½“å‰äº‹ä»¶ï¼Œå¦‚æžœä¸æ¶ˆè€—ï¼Œåˆ™åœ¨åŒä¸€äº‹ä»¶åºåˆ—ä¸­ï¼Œå½“å‰Viewæ— æ³•å†æ¬¡æŽ¥æ”¶åˆ°äº‹ä»¶ã€‚ ä¼ªä»£ç è¡¨ç¤ºï¼š 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onIterceptTouchEvent(ev)) &#123; //æ‹¦æˆªäº‹ä»¶ consume = onTouchEvent(ev); //è‡ªå·±å¤„ç†äº‹ä»¶ &#125; else &#123; consume = child.dispatchTouchEvent(ev); //åˆ†å‘ç»™å­Viewå¤„ç†äº‹ä»¶ &#125; return consume;&#125; æ³¨æ„âš ï¸å¦‚æžœä¸€ä¸ªViewè®¾ç½®äº†OnTouchListenerï¼Œé‚£ä¹ˆonTouchæ–¹æ³•å°†ä¼˜å…ˆè¢«è°ƒç”¨ï¼›å¦‚æžœonTouchæ–¹æ³•è¿”å›žtureï¼ŒonTouchEventæ–¹æ³•å°†ä¸ä¼šè¢«è°ƒç”¨ï¼Œè¿”å›žfalseï¼ŒonTouchEventæ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼›åœ¨onTouchEventä¸­ï¼Œå¦‚æžœè®¾ç½®äº†OnClickListenerï¼Œé‚£ä¹ˆå®ƒçš„onClickæ–¹æ³•å°†è¢«è°ƒç”¨ã€‚ä¼˜å…ˆçº§ï¼šonTouchâ€”&gt;onTouchEventâ€”&gt;onClick äº‹ä»¶ä¼ é€’é¡ºåºï¼šActivityâ€”&gt;Windowâ€”&gt;View, å¦‚æžœä¸€ä¸ªViewçš„onTouchEventè¿”å›žfalseï¼Œé‚£ä¹ˆå®ƒçš„çˆ¶å®¹å™¨çš„onTouchEventå°†è¢«è°ƒç”¨ï¼Œä»¥æ­¤ç±»æŽ¨ï¼Œå¦‚æžœæ‰€æœ‰å…ƒç´ éƒ½ä¸å¤„ç†è¿™ä¸ªäº‹ä»¶ï¼Œé‚£ä¹ˆæœ€ç»ˆä¼ é€’ç»™Activityçš„onTouchEventæ¥å¤„ç†ã€‚ ä¸€ä¸ªäº‹ä»¶åºåˆ—ï¼Œä»ŽACTION_DOWNå¼€å§‹ï¼Œä¸­é—´æœ‰æ•°é‡ä¸å®šçš„ACTION_MOVE,æœ€ç»ˆä»¥ACTION_UPç»“æŸã€‚ ä¸€ä¸ªäº‹ä»¶åºåˆ—åªèƒ½è¢«ä¸€ä¸ªViewæ‹¦æˆªä¸”æ¶ˆè€—ï¼Œä¸€æ—¦æŸä¸ªViewå†³å®šæ‹¦æˆªï¼Œé‚£ä¹ˆè¿™ä¸ªäº‹ä»¶åºåˆ—éƒ½åªèƒ½ç”±å®ƒæ¥å¤„ç†ï¼Œå¹¶ä¸”å®ƒçš„onIterceptTouchEventä¸ä¼šå†è¢«è°ƒç”¨ï¼ˆonIterceptTouchEventä»…ä»…è°ƒç”¨ä¸€æ¬¡ï¼‰ã€‚ æŸä¸ªViewä¸€æ—¦å¼€å§‹å¤„ç†äº‹ä»¶ï¼Œå¦‚æžœå®ƒä¸æ¶ˆè€—ACTION_DOWNäº‹ä»¶ï¼ˆonTouchEventè¿”å›žfalseï¼‰ï¼Œé‚£ä¹ˆåŒä¸€äº‹ä»¶åºåˆ—ä¸­çš„å…¶ä»–äº‹ä»¶éƒ½ä¸ä¼šå†äº¤ç»™å®ƒå¤„ç†ï¼Œå¹¶ä¸”äº‹ä»¶å°†é‡æ–°äº¤ç»™å®ƒçš„çˆ¶å…ƒç´ åŽ»å¤„ç†ã€‚ ViewGroupé»˜è®¤ä¸æ‹¦æˆªä»»ä½•äº‹ä»¶ï¼ŒonInterceptEventæ–¹æ³•é»˜è®¤è¿”å›žfalseã€‚ Viewæ²¡æœ‰onInterceptEventæ–¹æ³•ï¼Œä¸€æ—¦æœ‰äº‹ä»¶ä¼ é€’ç»™å®ƒï¼Œé‚£ä¹ˆonTouchEventæ–¹æ³•å°±ä¼šè¢«è°ƒç”¨ã€‚ Viewçš„onTouchEventé»˜è®¤éƒ½ä¼šæ¶ˆè€—äº‹ä»¶ï¼ˆè¿”å›žtrueï¼‰ï¼Œé™¤éžå®ƒæ˜¯ä¸å¯ç‚¹å‡»çš„ï¼ˆclickableå’ŒlongClickableåŒæ—¶ä¸ºfalseï¼‰ã€‚Viewçš„longClickableé»˜è®¤éƒ½ä¸ºfalseã€‚enableå±žæ€§ä¸å½±å“onTouchEventçš„è¿”å›žå€¼ã€‚ onClickå‘ç”Ÿçš„å‰ææ˜¯Viewæ˜¯å¯ç‚¹å‡»çš„ï¼Œå¹¶ä¸”æ”¶åˆ°äº†downå’Œupäº‹ä»¶ã€‚ äº‹ä»¶ä¼ é€’è¿‡ç¨‹æ˜¯ç”±çˆ¶å…ƒç´ åˆ†å‘åˆ°å­å…ƒç´ ï¼Œé€šè¿‡requestDisallowInterceptTouchEventæ–¹æ³•å¯ä»¥åœ¨å­å…ƒç´ ä¸­å¹²é¢„å¤«å…ƒç´ çš„äº‹ä»¶åˆ†å‘è¿‡ç¨‹ï¼ˆACTION_DOWNé™¤å¤–ï¼‰ã€‚ äº‹ä»¶åˆ†å‘æºç è§£æžäº‹ä»¶åˆ†å‘æ€»ä½“å›¾ï¼š Activityå¯¹ç‚¹å‡»äº‹ä»¶çš„åˆ†å‘è¿‡ç¨‹ 1Activiyâ€”&gt;Window(PhoneWindow)â€”&gt;DecorViewâ€”&gt;ContentViewâ€”&gt;é¡¶çº§ViewGroupâ€”&gt;Views ViewGroupå¯¹ç‚¹å‡»äº‹ä»¶çš„åˆ†å‘è¿‡ç¨‹ Viewå¯¹ç‚¹å‡»äº‹ä»¶çš„å¤„ç† â€‹ æ€»ç»“ï¼š å‚è€ƒ: Androidäº‹ä»¶åˆ†å‘æœºåˆ¶è¯¦è§£ Androidäº‹ä»¶åˆ†å‘æœºåˆ¶å®Œå…¨è§£æžï¼Œå¸¦ä½ ä»Žæºç çš„è§’åº¦å½»åº•ç†è§£(ä¸‹) Android Viewçš„äº‹ä»¶åˆ†å‘æœºåˆ¶å’Œæ»‘åŠ¨å†²çªè§£å†³ å›¾è§£ Android äº‹ä»¶åˆ†å‘æœºåˆ¶ View çš„æ»‘åŠ¨å†²çªå¸¸è§çš„æ»‘åŠ¨å†²çªåœºæ™¯ï¼š åœºæ™¯1â€”â€”å¤–éƒ¨æ»‘åŠ¨æ–¹å‘å’Œå†…éƒ¨æ»‘åŠ¨æ–¹å‘ä¸ä¸€è‡´ï¼ˆViewPager + ListViewï¼‰ åœºæ™¯2â€”â€”å¤–éƒ¨æ»‘åŠ¨æ–¹å‘å’Œå†…éƒ¨æ»‘åŠ¨æ–¹å‘ä¸€è‡´ï¼ˆSrcollView + ListViewï¼‰ åœºæ™¯3â€”â€”ä¸Šé¢ä¸¤ç§æƒ…å†µçš„åµŒå¥—ï¼ˆSlideMenu + ScrollView + ListViewï¼‰ æ€Žä¹ˆå¤„ç†ï¼Ÿåˆ©ç”¨äº‹ä»¶åˆ†å‘æœºåˆ¶ï¼Œé’ˆå¯¹æ»‘åŠ¨å†²çªä½¿ç”¨å¤–éƒ¨æ‹¦æˆªæ³•å’Œå†…éƒ¨æ‹¦æˆªæ³• å¤–éƒ¨æ‹¦æˆªæ³• æŒ‡ç‚¹å‡»äº‹ä»¶é€šè¿‡çˆ¶å®¹å™¨çš„æ‹¦æˆªå¤„ç†ï¼Œå¦‚æžœçˆ¶Viewéœ€è¦æ‹¦æˆªå°±æ‹¦æˆªï¼Œå¦åˆ™äº¤ç»™å­Viewå¤„ç†ï¼Œè¿™ç§æ–¹æ³•ç¬¦åˆäº‹ä»¶çš„åˆ†å‘æœºåˆ¶ã€‚éœ€è¦é‡å†™çˆ¶å®¹å™¨çš„onInterceptTouchEventæ–¹æ³•ã€‚ 12345678910111213141516171819202122232425262728public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; //å¿…é¡»è¿”å›žfalse break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (æ»¡è¶³çˆ¶å®¹å™¨çš„æ‹¦æˆªè¦æ±‚) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; //å¿…é¡»è¿”å›žfalse break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; æ ¹æ®ä¸šåŠ¡é€»è¾‘éœ€è¦ï¼Œåœ¨ACTION_MOVEæ–¹æ³•ä¸­è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æžœéœ€è¦çˆ¶Viewå¤„ç†åˆ™è¿”å›žtrueï¼Œå¦åˆ™è¿”å›žfalseï¼Œäº‹ä»¶åˆ†å‘ç»™å­ViewåŽ»å¤„ç†ã€‚ ACTION_DOWN ä¸€å®šè¿”å›žfalseï¼Œä¸è¦æ‹¦æˆªå®ƒï¼Œå¦åˆ™æ ¹æ®Viewäº‹ä»¶åˆ†å‘æœºåˆ¶ï¼ŒåŽç»­ACTION_MOVE ä¸Ž ACTION_UPäº‹ä»¶éƒ½å°†é»˜è®¤äº¤ç»™çˆ¶ViewåŽ»å¤„ç†ï¼ åŽŸåˆ™ä¸ŠACTION_UPä¹Ÿéœ€è¦è¿”å›žfalseï¼Œå¦‚æžœè¿”å›žtrueï¼Œå¹¶ä¸”æ»‘åŠ¨äº‹ä»¶äº¤ç»™å­Viewå¤„ç†ï¼Œé‚£ä¹ˆå­Viewå°†æŽ¥æ”¶ä¸åˆ°ACTION_UPäº‹ä»¶ï¼Œå­Viewçš„onClickäº‹ä»¶ä¹Ÿæ— æ³•è§¦å‘ã€‚è€Œçˆ¶Viewä¸ä¸€æ ·ï¼Œå¦‚æžœçˆ¶Viewåœ¨ACTION_MOVEä¸­å¼€å§‹æ‹¦æˆªäº‹ä»¶ï¼Œé‚£ä¹ˆåŽç»­ACTION_UPä¹Ÿå°†é»˜è®¤äº¤ç»™çˆ¶Viewå¤„ç†ï¼ å†…éƒ¨æ‹¦æˆªæ³• å³çˆ¶Viewä¸æ‹¦æˆªä»»ä½•äº‹ä»¶ï¼Œæ‰€æœ‰äº‹ä»¶éƒ½ä¼ é€’ç»™å­Viewï¼Œå­Viewæ ¹æ®éœ€è¦å†³å®šæ˜¯è‡ªå·±æ¶ˆè´¹äº‹ä»¶è¿˜æ˜¯ç»™çˆ¶Viewå¤„ç†ã€‚è¿™éœ€è¦å­Viewä½¿ç”¨requestDisallowInterceptTouchEventæ–¹æ³•æ‰èƒ½æ­£å¸¸å·¥ä½œã€‚ä¸‹é¢æ˜¯å­Viewçš„dispatchTouchEventæ–¹æ³•çš„ä¼ªä»£ç ï¼š 12345678910111213141516171819202122232425262728public boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; parent.requestDisallowInterceptTouchEvent(true);//çˆ¶å®¹å™¨è®¾ç½®ä¸æ‹¦æˆª break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; if (çˆ¶å®¹å™¨éœ€è¦æ­¤ç±»ç‚¹å‡»äº‹ä»¶) &#123; parent.requestDisallowInterceptTouchEvent(false);//çˆ¶å®¹å™¨è®¾ç½®æ‹¦æˆª &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; çˆ¶Viewéœ€è¦é‡å†™onInterceptTouchEventæ–¹æ³•ï¼š 12345678public boolean onInterceptTouchEvent(MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125; ä½¿ç”¨å†…éƒ¨æ‹¦æˆªæ³•éœ€è¦æ³¨æ„ï¼š å†…éƒ¨æ‹¦æˆªæ³•è¦æ±‚çˆ¶Viewä¸èƒ½æ‹¦æˆªACTION_DOWNäº‹ä»¶ï¼Œç”±äºŽACTION_DOWNä¸å—FLAG_DISALLOW_INTERCEPTæ ‡å¿—ä½æŽ§åˆ¶ï¼Œä¸€æ—¦çˆ¶å®¹å™¨æ‹¦æˆªACTION_DOWNé‚£ä¹ˆæ‰€æœ‰çš„äº‹ä»¶éƒ½ä¸ä¼šä¼ é€’ç»™å­Viewã€‚ æ»‘åŠ¨ç­–ç•¥çš„é€»è¾‘æ”¾åœ¨å­Viewçš„dispatchTouchEventæ–¹æ³•çš„ACTION_MOVEä¸­ï¼Œå¦‚æžœçˆ¶å®¹å™¨éœ€è¦èŽ·å–ç‚¹å‡»äº‹ä»¶åˆ™è°ƒç”¨ parent.requestDisallowInterceptTouchEvent(false)æ–¹æ³•ï¼Œè®©çˆ¶å®¹å™¨åŽ»æ‹¦æˆªäº‹ä»¶ã€‚ å‚è€ƒï¼š ä¸€æ–‡è§£å†³Android Viewæ»‘åŠ¨å†²çª]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>Viewçš„äº‹ä»¶åˆ†å‘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPCæœºåˆ¶]]></title>
    <url>%2F2018%2F02%2F22%2FIPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Androidä¸­çš„å¤šè¿›ç¨‹æ¨¡å¼å¼€å¯å¤šè¿›ç¨‹æ¨¡å¼ åœ¨AndroidMenifestä¸­ä¸ºå››å¤§ç»„ä»¶æŒ‡å®šandroid:processå±žæ€§ é€šè¿‡JNIåœ¨nativeå±‚forkä¸€ä¸ªæ–°çš„è¿›ç¨‹ æŸ¥çœ‹è¿›ç¨‹ä¿¡adb shell ps | grep packagename android:process å±žæ€§æ–¹å¼åŒºåˆ« â€œ:remoteâ€å¼€å¤´ï¼Œè¿›ç¨‹åä¸ºpackagename:remote ,å±žäºŽå½“å‰åº”ç”¨çš„ç§æœ‰è¿›ç¨‹ã€‚ â€œcom.packagename.remoteâ€å®Œæ•´å‘½ååˆ™å±žäºŽå…¨å±€è¿›ç¨‹ï¼Œé€šè¿‡å…·æœ‰ç›¸åŒçš„ShareUIDå’Œç­¾åï¼Œä¸¤ä¸ªä¸åŒåº”ç”¨å¯ä»¥è·‘åœ¨åŒä¸€ä¸ªè¿›ç¨‹ä¸­ã€‚å…·æœ‰ç›¸åŒUIDçš„åº”ç”¨å¯ä»¥å…±äº«æ•°æ®ï¼ˆdataç›®å½•ã€ç»„ä»¶ä¿¡æ¯ç­‰ï¼‰ å¤šè¿›ç¨‹æ¨¡å¼è¿è¡Œæœºåˆ¶ ä¸åŒçš„è¿›ç¨‹çš„ç»„ä»¶ä¼šæ‹¥æœ‰ç‹¬ç«‹çš„è™šæ‹Ÿæœºã€Applicationã€ä»¥åŠå†…å­˜ç©ºé—´ã€‚ å¤šè¿›ç¨‹æ³¨æ„çš„é—®é¢˜ï¼š é™æ€æˆå‘˜å’Œå•åˆ—ä¸èƒ½è·¨è¿›ç¨‹ä½¿ç”¨ çº¿ç¨‹åŒæ­¥å¤±æ•ˆ SharedPreferenceçš„å¯é æ€§ä¸‹é™ Applicationä¼šå¤šæ¬¡åˆ›å»º SharePrefåº•å±‚é€šè¿‡è¯»å†™xmlæ–‡ä»¶å®žçŽ°ï¼Œå¹¶å‘æ‰§è¡Œè¯»å†™æ“ä½œå¯èƒ½ä¼šå¯¼è‡´ä¸€å®šå‡ çŽ‡çš„æ•°æ®ä¸¢å¤± â€‹ IPCåŸºç¡€æ¦‚å¿µä»‹ç»SerializableæŽ¥å£ 123456public class User implements Serializable &#123; private static final long serialVersionUID = 87113688048893844L; public int userId; public String userName; public boolean isMale;&#125; è¿™ä¸ªserialVersionUIDæ˜¯ç”¨æ¥è¾…åŠ©åºåˆ—åŒ–å’Œååºåˆ—åŒ–çš„ï¼Œåºåˆ—åŒ–æ—¶ä¼šå°†è¯¥å­—æ®µå†™å…¥æ–‡ä»¶ä¸­ï¼Œç„¶åŽååºåˆ—åŒ–æ—¶æ£€æµ‹æ–‡ä»¶ä¸­çš„serialVersionUIDæ˜¯å¦ä¸Žå½“å‰ç±»ä¸€è‡´ã€‚å¦‚æžœä¸ä¸€è‡´ï¼Œå°†åºåˆ—åŒ–å¤±è´¥ã€‚ æœ€å¥½èƒ½å¤Ÿæ‰‹åŠ¨æŒ‡å®šserialVersionUIDï¼Œè¿™æ ·ç‰ˆæœ¬æ›´æ–°åŽï¼Œæˆ‘ä»¬å¯èƒ½åˆ é™¤æˆ–æ–°å¢žäº†ä¸€äº›Fieldï¼Œä½†æ˜¯ååºåˆ—åŒ–ä»èƒ½æˆåŠŸã€‚ä¸æŒ‡å®šçš„è¯ç”±äºŽç±»å†…éƒ¨æˆå‘˜å˜åŒ–ï¼Œæ‰€ä»¥è®¡ç®—hashå€¼å˜åŒ–ï¼Œå¯¼è‡´ååºåˆ—å¤±è´¥ã€‚ é™æ€æˆå‘˜ä¸å‚ä¸Žåºåˆ—åŒ– transientå…³é”®å­—æ ‡è®°çš„æˆå‘˜å˜é‡ä¸å‚ä¸Žåºåˆ—åŒ– SerialableæŽ¥å£æ˜¯åºåˆ—åŒ–éœ€è¦å¤§é‡I/Oæ“ä½œï¼Œå¼€é”€å¤§ ParcelableæŽ¥å£ Parcelableä¸»è¦ç”¨åœ¨å†…å­˜åºåˆ—åŒ–ä¸Šï¼Œæ•ˆçŽ‡é«˜ï¼ŒAndroidå¹³å°æŽ¨èç”¨ã€‚ ä½†æ˜¯å¯¹è±¡åºåˆ—åŒ–åŽè¦ç½‘ç»œä¼ è¾“å’ŒæŒä¹…åŒ–å­˜å‚¨æŽ¨èç”¨Serialableã€‚ Binderé©±åŠ¨ Clientå’ŒServeråˆ†åˆ«å±žäºŽä¸åŒçš„è¿›ç¨‹ï¼Œä»–ä»¬ä¹‹é—´çš„å¯¹è±¡ä¸èƒ½ç›´æŽ¥å…±äº«ï¼Œé‚£ä¹ˆæ˜¯æ€Žä¹ˆä¼ é€’çš„å‘¢ï¼Ÿ å…¶å®žå°±æ˜¯é€šè¿‡Binderé©±åŠ¨ã€‚Clientç«¯æ‹¿åˆ°çš„å…¶å®žæ˜¯Serverç«¯Binderå¯¹è±¡çš„Proxyå¯¹è±¡ï¼Œé€šè¿‡è°ƒç”¨è¯¥Proxyå¯¹è±¡çš„æ–¹æ³•ï¼Œå®žé™…æ•ˆæžœç›¸å½“äºŽServerçš„Binderä¸­çš„æ–¹æ³•ã€‚ ä»Žè¿›ç¨‹é—´é€šä¿¡çš„è§’åº¦çœ‹ï¼ŒBinder æ˜¯ä¸€ç§è¿›ç¨‹é—´é€šä¿¡çš„æœºåˆ¶ï¼› ä»Ž Server è¿›ç¨‹çš„è§’åº¦çœ‹ï¼ŒBinder æŒ‡çš„æ˜¯ Server ä¸­çš„ Binder å®žä½“å¯¹è±¡ï¼› ä»Ž Client è¿›ç¨‹çš„è§’åº¦çœ‹ï¼ŒBinder æŒ‡çš„æ˜¯å¯¹ Binder ä»£ç†å¯¹è±¡ï¼Œæ˜¯ Binder å®žä½“å¯¹è±¡çš„ä¸€ä¸ªè¿œç¨‹ä»£ç† ä»Žä¼ è¾“è¿‡ç¨‹çš„è§’åº¦çœ‹ï¼ŒBinder æ˜¯ä¸€ä¸ªå¯ä»¥è·¨è¿›ç¨‹ä¼ è¾“çš„å¯¹è±¡ï¼›Binder é©±åŠ¨ä¼šå¯¹è¿™ä¸ªè·¨è¶Šè¿›ç¨‹è¾¹ç•Œçš„å¯¹è±¡å¯¹ä¸€ç‚¹ç‚¹ç‰¹æ®Šå¤„ç†ï¼Œè‡ªåŠ¨å®Œæˆä»£ç†å¯¹è±¡å’Œæœ¬åœ°å¯¹è±¡ä¹‹é—´çš„è½¬æ¢ã€‚ â€‹ Binder Binderæ˜¯å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯é€šä¿¡çš„åª’ä»‹ï¼Œå½“bindServiceçš„æ—¶å€™ï¼ŒæœåŠ¡ç«¯ä¼šè¿”å›žä¸€ä¸ªåŒ…å«äº†æœåŠ¡ç«¯ä¸šåŠ¡è°ƒç”¨çš„Binderå¯¹è±¡ï¼Œé€šè¿‡è¿™ä¸ªBinderå¯¹è±¡ï¼Œå®¢æˆ·ç«¯å°±å¯ä»¥èŽ·å–æœåŠ¡ç«¯æä¾›çš„æœåŠ¡å’Œæ•°æ®ã€‚aidlç±»æ ¸å¿ƒå®žçŽ°å†…éƒ¨ç±»Stubä»¥åŠStubçš„å†…éƒ¨ä»£ç†ç±»Proxyã€‚ DESCRIPTOR Binderçš„å”¯ä¸€æ ‡ç¤ºï¼Œä¸€èˆ¬ç”¨å½“å‰Binderçš„ç±»å asInterface(android.os.IBinder obj) ç”¨äºŽå°†æœåŠ¡ç«¯çš„Binderå¯¹è±¡è½¬æ¢æˆå®¢æˆ·ç«¯æ‰€éœ€çš„AIDLæŽ¥å£ç±»åž‹å¯¹è±¡ï¼ŒåŒºåˆ†è¿›ç¨‹ï¼Œå¦‚æžœå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä½äºŽåŒä¸€è¿›ç¨‹ï¼Œè¿”å›žæœåŠ¡ç«¯çš„Stubå¯¹è±¡æœ¬èº«ï¼Œå¦åˆ™è¿”å›žStub.proxyå¯¹è±¡ã€‚ asBinder è¿”å›žå½“å‰çš„Binderå¯¹è±¡ onTransact è¿è¡Œåœ¨æœåŠ¡ç«¯çš„Binderçº¿ç¨‹æ± ä¸­ï¼ŒåŽŸåž‹ä¸º 1public Boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flag) codeç¡®å®šç›®æ ‡æ–¹æ³•ï¼Œdataç›®æ ‡å‚æ•°ï¼Œreplyå†™å…¥è¿”å›žå€¼ã€‚ Proxy#getBookList è¿™ä¸ªæ–¹æ³•è¿è¡Œåœ¨å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯è¿œç¨‹è°ƒç”¨è¯¥æ–¹æ³•ï¼Œåˆ›å»ºè¾“å…¥åž‹Parcelå¯¹è±¡dataï¼Œè¾“å‡ºåž‹Parcelå¯¹è±¡_replyå’Œè¿”å›žå€¼å¯¹è±¡Listã€‚æŽ¥ç€è°ƒç”¨transactæ–¹æ³•å‘èµ·RPCï¼ˆè¿œç¨‹è¿‡ç¨‹è°ƒç”¨ï¼‰è¯·æ±‚ï¼ŒåŒæ—¶å½“å‰çº¿ç¨‹æŒ‚èµ·ï¼›ç„¶åŽæœåŠ¡ç«¯çš„onTransactæ–¹æ³•ä¼šè¢«è°ƒç”¨ï¼Œç›´åˆ°RPCè¿”å›žï¼Œå½“å‰çº¿ç¨‹ç»§ç»­æ‰§è¡Œï¼Œå¹¶ä»Ž_replyä¸­è¿”å›žç»“æžœã€‚ é€šè¿‡linkToDeath å’Œ unlinkToDeathç»™Binderè®¾ç½®æ­»äº¡ä»£ç†DeathRecipientï¼Œå½“æœåŠ¡ç«¯è¿›ç¨‹å¼‚å¸¸ç»ˆæ­¢æ—¶ï¼Œå¯ä»¥æ”¶åˆ°é€šçŸ¥ã€‚ Androidä¸­çš„IPCæ–¹å¼ ä½¿ç”¨Bundle ä½¿ç”¨æ–‡ä»¶å…±äº«ï¼ˆè€ƒè™‘å¹¶å‘è¯»å†™çš„é—®é¢˜ï¼Œæ³¨æ„âš ï¸SharedPrefencesä¸æ”¯æŒè·¨è¿›ç¨‹è¯»å†™ï¼‰ ä½¿ç”¨Messenger ä¿¡ä½¿ ä½¿ç”¨AIDL â€‹ ä½¿ç”¨Messager â€‹ Messgenerçš„å·¥ä½œåŽŸç† AIDL æœåŠ¡ç«¯ï¼šåˆ›å»ºä¸€ä¸ªserviceæ¥ç›‘å¬å®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œåˆ›å»ºä¸€ä¸ªAIDLæ–‡ä»¶ï¼Œæš´éœ²å‡ºAIDLæŽ¥å£ä¾›å®¢æˆ·ç«¯è°ƒç”¨ï¼Œæœ€åŽåœ¨serviceä¸­å®žçŽ°è¿™ä¸ªAIDLæŽ¥å£ã€‚ å®¢æˆ·ç«¯ï¼šbindServiceç»‘å®šæœåŠ¡ï¼Œè°ƒç”¨AIDLæŽ¥å£ AIDLæ–‡ä»¶æ”¯æŒç±»åž‹ï¼šåŸºæœ¬æ•°æ®ç±»åž‹ã€Stringã€ArrayListã€HashMapã€Pacelableå¯¹è±¡ã€å…¶ä»–AIDLæŽ¥å£ã€‚ æ³¨æ„âš ï¸è‡ªå®šä¹‰çš„Pacelableå¯¹è±¡å¿…é¡»æ–°å»ºä¸€ä¸ªå’Œå®ƒåŒåçš„AIDLæ–‡ä»¶ï¼Œå¹¶æ˜¾ç¤ºimportè¿›æ¥ã€‚ é™¤äº†åŸºæœ¬æ•°æ®ç±»åž‹ï¼Œå…¶ä»–å‚æ•°å¿…é¡»è¡¨ä¸Šæ–¹å‘ï¼šinã€outã€inout 1234##Book.aidlpackage com.ryg.chapter_2.aidl;parcelable Book; 123456789101112##IBookManager.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;import com.ryg.chapter_2.aidl.IOnNewBookArrivedListener;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookArrivedListener listener);//obsever mode void unregisterListener(IOnNewBookArrivedListener listener);&#125; 12345678##IOnNewBookArrivedListener.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;interface IOnNewBookArrivedListener &#123; void onNewBookArrived(in Book newBook);&#125; AIDLä¸­è§‚å¯Ÿè€…æ¨¡å¼çš„ä½¿ç”¨ï¼Œæä¾›ä¸€ä¸ªAIDLæŽ¥å£ï¼Œå®¢æˆ·ç«¯éœ€è¦å®žçŽ°è¯¥listenerï¼ˆé€šè¿‡ç»§æ‰¿è¯¥Listener.StubæŽ¥å£ï¼‰ï¼Œä¼ é€’ç»™æœåŠ¡ç«¯ï¼ŒæœåŠ¡ç«¯å¤„ç†å®ŒæˆåŽå†å›žè°ƒå›žå®¢æˆ·ç«¯ã€‚ æ³¨å†Œå’Œè§£æ³¨å†Œï¼Œä½¿ç”¨==RemoteCallbackList==ï¼Œä¸“é—¨æä¾›ç”¨äºŽåˆ é™¤è·¨è¿›ç¨‹çš„listeneræŽ¥å£ã€‚ å¦‚æžœæŸä¸ªè¿œç¨‹æ–¹æ³•æ˜¯è€—æ—¶çš„ï¼Œé‚£ä¹ˆè¦é¿å…åœ¨å®¢æˆ·ç«¯UIçº¿ç¨‹ä¸­åŽ»è®¿é—®è¿œç¨‹æ–¹æ³•ï¼Œå¦åˆ™ä¼šå¯¼è‡´å®¢æˆ·ç«¯ANRã€‚å®¢æˆ·ç«¯çš„onServiceConnectedå’ŒonServiceDisconnectedæ–¹æ³•éƒ½è¿è¡Œåœ¨UIçº¿ç¨‹ä¸­ï¼Œæ‰€ä»¥ä¹Ÿä¸èƒ½åœ¨è¿™é‡Œè°ƒç”¨æœåŠ¡ç«¯çš„è€—æ—¶æ–¹æ³•ã€‚è§£å†³çš„åŠžæ³•æ˜¯åœ¨éžUIçº¿ç¨‹ä¸­è°ƒç”¨åŽŸåŽ‚æ–¹æ³•ã€‚ åŒç†ï¼Œå¦‚æžœæœ‰æœåŠ¡ç«¯éœ€è¦è°ƒç”¨å®¢æˆ·ç«¯çš„listeneræ–¹æ³•ï¼Œè¢«è°ƒç”¨çš„æ–¹æ³•å°†è¿è¡Œåœ¨å®¢æˆ·ç«¯çš„Binderçº¿ç¨‹æ± ä¸­ï¼Œå¦‚æžœlistenerä¸­çš„æ–¹æ³•æ¯”è¾ƒè€—æ—¶ï¼Œä¹Ÿè¦æ³¨æ„æœåŠ¡ç«¯çš„ANRé—®é¢˜ã€‚ Binderæ„å¤–æ­»äº¡é‡è¿ž ç»™Binderè®¾ç½®DeathRecipientç›‘å¬ï¼ˆåœ¨å®¢æˆ·ç«¯Binderçº¿ç¨‹ä¸­è¢«å›žè°ƒï¼‰ åœ¨onServiceDisconnectedä¸­é‡è¿žè¿œç¨‹æœåŠ¡ï¼ˆåœ¨å®¢æˆ·ç«¯UIçº¿ç¨‹è¢«å›žè°ƒï¼‰ æƒé™éªŒè¯ AndroidMenifest.xmlå£°æ˜Žæƒé™ 123&lt;permission android:name="com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE" android:protectionLevel="normal" /&gt; åœ¨æœåŠ¡é˜Ÿçš„onBindæˆ–è€…onTransactæ–¹æ³•ä¸­è¿›è¡Œæƒé™éªŒè¯ã€‚ ä½¿ç”¨ContentProviderç»§æ‰¿ContentProviderï¼Œé€šè¿‡ContentResolverçš„queryã€updateã€insertã€deleteæ–¹æ³•å®žçŽ°æ•°æ®åº“SQLiteOpenHelperçš„CRUDæ“ä½œã€‚ ä½¿ç”¨Socketä½¿ç”¨ServerSocketâ€”&gt;TCPè¿žæŽ¥; UDPä¹Ÿæ˜¯è·¨è¿›åŸŽçš„é€šä¿¡æ–¹å¼ã€‚ Binderè¿žæŽ¥æ±  é¢å¯¹å¤šä¸ªæ¨¡å—éœ€è¦ç”¨åˆ°AIDLï¼Œæˆ‘ä»¬ä¸èƒ½é’ˆå¯¹æ¯ä¸€ä¸ªAIDLæŽ¥å£å•ç‹¬åˆ›å»ºå¤šä¸ªServiceã€‚ è¿™ç§æ¨¡å¼ä¸‹ï¼šæ¯ä¸ªä¸šåŠ¡æ¨¡å—åˆ›å»ºè‡ªå·±çš„AIDLæŽ¥å£å¹¶å®žçŽ°æ­¤æŽ¥å£ï¼Œä¸åŒä¸šåŠ¡æ¨¡å—ä¹‹é—´æ²¡æœ‰è€¦åˆï¼Œå¹¶å‘æœåŠ¡ç«¯æä¾›è‡ªå·±çš„å”¯ä¸€æ ‡è¯†å’Œå¯¹åº”çš„Binderå¯¹è±¡ï¼›å¯¹äºŽæœåŠ¡ç«¯æ¥è¯´ï¼Œåªéœ€è¦æä¾›ä¸€ä¸ªServiceï¼Œå¹¶åŒ…å«ä¸€ä¸ªqueryBinderæŽ¥å£ï¼Œè¿™ä¸ªæŽ¥å£èƒ½å¤Ÿæ ¹æ®ä¸šåŠ¡æ¨¡å—çš„ç‰¹å¾æ¥è¿”å›žç›¸åº”çš„Binderå¯¹è±¡ï¼›ä¸åŒä¸šåŠ¡æ¨¡å—æ‹¿åˆ°è‡ªå·±çš„Binderå¯¹è±¡åŽå°±å¯ä»¥è¿›è¡Œè¿œç¨‹æ–¹æ³•è°ƒç”¨äº†ã€‚ Binderè¿žæŽ¥æ± çš„ä½œç”¨å°±æ˜¯å°†æ¯ä¸ªä¸šåŠ¡æ¨¡å—çš„Binderè¯·æ±‚ç»Ÿä¸€è½¬å‘åˆ°è¿œç¨‹çš„Serviceä¸­åŽ»æ‰§è¡Œï¼Œä»Žè€Œé¿å…é‡å¤åˆ›å»ºServiceã€‚ Binderè¿žæŽ¥æ± å·¥ä½œåŽŸç† 123456## Module A package com.ryg.chapter_2.binderpool;interface ISecurityCenter &#123; String encrypt(String content); String decrypt(String password);&#125; 12345## Module Bpackage com.ryg.chapter_2.binderpool;interface ICompute &#123; int add(int a, int b);&#125; 12345678910## BinderPool aidl interfacepackage com.ryg.chapter_2.binderpool;interface IBinderPool &#123; /** * @param binderCode, the unique token of specific Binder&lt;br/&gt; * @return specific Binder who's token is binderCode. */ IBinder queryBinder(int binderCode);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.ryg.chapter_2.binderpool;import java.util.concurrent.CountDownLatch;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;public class BinderPool &#123; private static final String TAG = "BinderPool"; public static final int BINDER_NONE = -1; public static final int BINDER_COMPUTE = 0; public static final int BINDER_SECURITY_CENTER = 1; private Context mContext; private IBinderPool mBinderPool; //BinderPool aidl interface private static volatile BinderPool sInstance; private CountDownLatch mConnectBinderPoolCountDownLatch; private BinderPool(Context context) &#123; mContext = context.getApplicationContext(); connectBinderPoolService(); &#125; // singleton, double check public static BinderPool getInsance(Context context) &#123; if (sInstance == null) &#123; synchronized (BinderPool.class) &#123; if (sInstance == null) &#123; sInstance = new BinderPool(context); &#125; &#125; &#125; return sInstance; &#125; /** ** ç»‘å®šBinderPoolçš„è¿œç¨‹æœåŠ¡ **/ private synchronized void connectBinderPoolService() &#123; mConnectBinderPoolCountDownLatch = new CountDownLatch(1); Intent service = new Intent(mContext, BinderPoolService.class); mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE); try &#123; //å°†bindServiceè¿™å¼‚æ­¥æ“ä½œè½¬ä¸ºåŒæ­¥çš„ï¼Œè€—æ—¶æ“ä½œ mConnectBinderPoolCountDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * query binder by binderCode from binder pool * * @param binderCode * the unique token of binder * @return binder who's token is binderCode&lt;br&gt; * return null when not found or BinderPoolService died. */ public IBinder queryBinder(int binderCode) &#123; IBinder binder = null; try &#123; if (mBinderPool != null) &#123; binder = mBinderPool.queryBinder(binderCode); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; return binder; &#125; private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // ignored. &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinderPool = IBinderPool.Stub.asInterface(service); try &#123; mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient, 0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; mConnectBinderPoolCountDownLatch.countDown(); &#125; &#125;; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; Log.w(TAG, "binder died."); mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, 0); mBinderPool = null; connectBinderPoolService(); &#125; &#125;; /** * å½“Binderè¿žæŽ¥æ± è¿žæŽ¥ä¸Šè¿œç¨‹æœåŠ¡æ—¶ï¼Œä¼šæ ¹æ®ä¸åŒæ¨¡å—çš„æ ‡è¯†bindeCodeè¿”å›žä¸åŒçš„Binderå¯¹è±¡ï¼Œ * é€šè¿‡è¿™ä¸ªå¯¹è±¡æ‰€æ‰§è¡Œçš„æ“ä½œå‘ç”Ÿåœ¨è¿œç¨‹æœåŠ¡å™¨ **/ public static class BinderPoolImpl extends IBinderPool.Stub &#123; public BinderPoolImpl() &#123; super(); &#125; @Override public IBinder queryBinder(int binderCode) throws RemoteException &#123; IBinder binder = null; switch (binderCode) &#123; case BINDER_SECURITY_CENTER: &#123; binder = new SecurityCenterImpl(); break; &#125; case BINDER_COMPUTE: &#123; binder = new ComputeImpl(); break; &#125; default: break; &#125; return binder; &#125; &#125;&#125; æœ‰äº†BinderPoolæœºåˆ¶åŽï¼Œå¦‚æžœæœ‰ä¸€ä¸ªæ–°çš„ä¸šåŠ¡æ¨¡å—éœ€è¦åŠ AIDLï¼Œé‚£ä¹ˆåœ¨å®žçŽ°çš„è‡ªå·±çš„AIDLæŽ¥å£åŽï¼Œåªéœ€è¦ä¿®æ”¹BInderPoolImplä¸­çš„queryBinderæ–¹æ³•ç»™è‡ªå·±æ·»åŠ ä¸€ä¸ªbinderCodeå¹¶è¿”å›žå¯¹åº”çš„Binderå¯¹è±¡å³å¯ï¼Œä¸éœ€è¦åˆ›å»ºæ–°çš„Serviceã€‚ é€‰ç”¨åˆé€‚çš„IPCæ–¹å¼ åç§° ä¼˜ç‚¹ ç¼ºç‚¹ é€‚ç”¨åœºæ™¯ Bundle ç®€å•æ˜“ç”¨ åªèƒ½ä¼ è¾“Bundleæ”¯æŒçš„æ•°æ® å››å¤§ç»„ä»¶é—´çš„è¿›ç¨‹é€šä¿¡ æ–‡ä»¶å…±äº« ç®€å•æ˜“æ‡‚ ä¸é€‚åˆé«˜å¹¶å‘åœºæ™¯ï¼Œå¹¶ä¸”æ— æ³•åšåˆ°è¿›ç¨‹é—´å³æ—¶é€šä¿¡ æ— å¹¶å‘ï¼Œäº¤æ¢ç®€å•çš„æ•°æ®ã€å®žæ—¶æ€§ä¸é«˜çš„åœºæ™¯ AIDL åŠŸèƒ½å¼ºå¤§ï¼Œæ”¯æŒä¸€å¯¹å¤šå¹¶å‘é€šä¿¡ ä½¿ç”¨å¤æ‚ï¼Œéœ€è¦å¤„ç†å¥½çº¿ç¨‹åŒæ­¥ ä¸€å¯¹å¤šé€šä¿¡æœ‰RPCéœ€æ±‚ Messager åŠŸèƒ½ä¸€èˆ¬ï¼Œæ”¯æŒä¸€å¯¹å¤šä¸²è¡Œé€šä¿¡ ä¸èƒ½å¤„ç†å¹¶å‘æƒ…å½¢ï¼Œä¸æ”¯æŒRPCï¼Œæ•°æ®é€šè¿‡Messageä¼ è¾“ï¼Œåªèƒ½æ”¯æŒBundleæ•°æ®ç±»åž‹ ä¸²è¡Œä¸€å¯¹å¤šå³æ—¶é€šä¿¡ï¼Œæ— RPCéœ€æ±‚ï¼Œæˆ–è€…æ— éœ€è¿”å›žç»“æžœRPCéœ€æ±‚ ContentProvider åœ¨æ•°æ®æºè®¿é—®åŠŸèƒ½å¼ºå¤§ï¼Œæ”¯æŒä¸€å¯¹å¤šå¹¶å‘æ•°æ®å…±äº« å¯ä»¥ç†è§£ä¸ºå—çº¦æŸçš„AIDLï¼Œä¸»è¦æä¾›æ•°æ®æºçš„CRUD ä¸€å¯¹å¤šçš„è¿›ç¨‹é—´æ•°æ®å…±äº« Socket åŠŸèƒ½å¼ºå¤§ï¼Œé€šè¿‡ç½‘ç»œä¼ è¾“å­—èŠ‚æµï¼Œæ”¯æŒä¸€å¯¹å¤šçš„å¹¶å‘å®žæ—¶é€šä¿¡ å®žçŽ°ç»†èŠ‚ç¨å¾®ç¹çï¼Œä¸æ”¯æŒç›´æŽ¥çš„RPC ç½‘ç»œæ•°æ®äº¤æ¢]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>AIDL</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é‡æž„]]></title>
    <url>%2F2018%2F01%2F14%2Frefactor%2F</url>
    <content type="text"><![CDATA[#é‡æž„ Extract Method (æç‚¼å‡½æ•°) Move Method (æ¬ç§»å‡½æ•°ï¼‰ Self Encapsulate Field (è‡ªå°è£…å­—æ®µ) Replace Type Code With State/Strategy (ä»¥çŠ¶æ€ï¼ç­–ç•¥æ¨¡å¼å–ä»£çŠ¶æ€ç ) Replace Condition with Polymorphism (ä»¥å¤šæ€å–ä»£æ¡ä»¶è¡¨è¾¾å¼) ###é‡æž„åŽŸåˆ™ ä½•ä¸ºé‡æž„ å¯¹è½¯ä»¶å†…éƒ¨ç»“æž„çš„ä¸€ç§è°ƒæ•´ï¼Œç›®çš„æ˜¯åœ¨ä¸æ”¹å˜è½¯ä»¶å¯è§‚å¯Ÿè¡Œä¸ºçš„å‰æä¸‹ï¼Œæé«˜å…¶å¯ç†è§£æ€§ï¼Œé™ä½Žå…¶ä¿®æ”¹æˆæœ¬ã€‚ ä¸ºä½•é‡æž„ æ”¹è¿›è½¯ä»¶è®¾è®¡ã€æ˜¯è½¯ä»¶æ›´å®¹æ˜“ç†è§£ã€å¸®åŠ©æ‰¾åˆ°bugã€æé«˜ç¼–ç¨‹é€Ÿåº¦ã€‚ ä½•æ—¶é‡æž„ æ·»åŠ åŠŸèƒ½æ—¶é‡æž„ã€ä¿®è¡¥é”™è¯¯æ—¶é‡æž„ã€å¤å®¡ä»£ç æ—¶é‡æž„ é‡æž„ä¸Žé—´æŽ¥å±‚ é—´æŽ¥å±‚ä»·å€¼ï¼š å…è®¸é€»è¾‘å…±äº«ã€åˆ†å¼€è§£é‡Šæ„å›¾å’Œå®žçŽ°ã€éš”ç¦»å˜åŒ–ã€å°è£…æ¡ä»¶é€»è¾‘ï¼ˆå¤šæ€ï¼‰ é‡æž„çš„éš¾é¢˜ æ•°æ®åº“è¿ç§»ã€ä¿®æ”¹å·²å…¬å¸ƒçš„æŽ¥å£ã€éš¾ä»¥é‡æž„çš„å¤æ‚è®¾è®¡ ###ä»£ç çš„åå‘³é“ Duplicated codeï¼ˆé‡å¤ä»£ç ï¼‰ Long Methodï¼ˆè¿‡é•¿å‡½æ•°ï¼‰ Large Classï¼ˆè¿‡å¤§çš„ç±»ï¼‰ Long Parameter List (è¿‡é•¿å‚æ•°åˆ—ï¼‰ Divergent Change ï¼ˆå‘æ•£å¼å˜åŒ–ï¼‰ä¸€ç§ç±»å—å¤šç§å˜åŒ–çš„å½±å“ï¼Œç±»è¿‡å¤§ï¼Œéœ€Extract class Shotgun Surgeryï¼ˆæ•£å¼¹å¼ä¿®æ”¹ï¼‰ä¸€ç§å˜åŒ–å¼•èµ·å¤šä¸ªç±»ä¿®æ”¹ï¼Œéœ€Move Methodç§»åˆ°åŒä¸€ä¸ªç±» Feature Envyï¼ˆä¾æ‹æƒ…ç»“ï¼‰æ€»æ˜¯ä¸€èµ·å˜åŒ–çš„ä¸œè¥¿æ”¾åœ¨ä¸€å— Data Clumps ï¼ˆæ•°æ®æ³¥å›¢ï¼‰å¤šä¸ªç±»ä¸­é‡å¤çš„å­—æ®µã€æ–¹æ³•ã€‚éœ€Extract classåˆ°ä¸€ä¸ªç‹¬ç«‹å¯¹è±¡ Primitive Obsesstion ï¼ˆåŸºæœ¬ç±»åž‹åæ‰§ï¼‰å¿…è¦æ—¶ç”¨å¯¹è±¡ä»£æ›¿åŸºæœ¬æ•°æ® Switch Statementï¼ˆswitchè¯­å¥ï¼‰éœ€è¦æŠ½å‡ºæ–¹æ³•ï¼Œç”¨å­ç±»æˆ–state/strategyæ¨¡å¼æ›¿ä»£ Parallel Inheritance Hierarchies ï¼ˆå¹³è¡Œç»§æ‰¿ä½“ç³»ï¼‰æ•£å¼¹ä¿®æ”¹çš„ä¸€ç§ï¼Œéœ€ç”¨å¼•ç”¨ä»£æ›¿ç»§æ‰¿ Lazy Classï¼ˆå†—ä½™ç±»ï¼‰ Speculative Generalityï¼ˆå¤¸å¤¸å…¶è°ˆæœªæ¥æ€§ï¼‰å¤šä½™çš„æŠ½è±¡ã€å§”æ‰˜ã€å‚æ•°åº”è¯¥åŽ»é™¤ Temporary Field (è¿·æƒ‘çš„æš‚æ—¶å­—æ®µ) å¯ä»¥çš„è¯æç‚¼åˆ°ä¸€ä¸ªç‹¬ç«‹çš„ç±»ä¸­ Message ChainsIï¼ˆè¿‡åº¦è€¦åˆçš„æ¶ˆæ¯é“¾ï¼‰ Middle Manï¼ˆä¸­é—´äººï¼‰è¿‡åº¦ä½¿ç”¨å§”æ‰˜ Inappropriate Intimacy (ç‹Žæ˜µå…³ç³») æ‹†æ•£è¿‡æ¸¡äº²å¯†çš„ç±»ï¼ŒMove Method æˆ– Move Fieldåˆ°åˆé€‚çš„åœ°æ–¹ï¼›æç‚¼å…±æ€§åˆ°æ–°ç±»ï¼›Replace Inheritance with Delegation Alternative Classes With Different Interfaces (å¼‚æ›²åŒå·¥çš„ç±») é‡æ–°å‘½åæˆ–æå–è¶…ç±» Incomplete Library Class (ä¸å®Œç¾Žçš„ç±»åº“) Data Classï¼ˆå­˜ç²¹çš„æ•°æ®ç±»ï¼‰æ³¨æ„å°è£…å’Œè®¿é—®æƒé™ Refused Bequestï¼ˆè¢«æ‹’ç»çš„é¦ˆèµ ï¼‰å­ç±»æœç”¨çš„è¶…ç±»çš„è¡Œä¸ºï¼ˆå®žçŽ°ï¼‰ï¼Œå´ä¸æ„¿æ”¯æŒè¶…ç±»çš„æŽ¥å£ï¼Œéœ€é‡æž„ï¼ˆè¿™é‡Œæ€è€ƒBasessoç±»çš„3ä¸ªabstractæ–¹æ³•æœ‰è¿™ä¸ªé—®é¢˜ï¼Œä¸æ„¿æ”¯æŒè¶…ç±»çš„æŽ¥å£ï¼‰ Commentsï¼ˆè¿‡å¤šæ³¨é‡Šï¼‰ ###é‡æ–°ç»„ç»‡å‡½æ•° Extract Methodï¼ˆæç‚¼å‡½æ•°ï¼‰ å°†ä¸€æ®µä»£ç æ”¾è¿›ä¸€ä¸ªç‹¬ç«‹çš„å‡½æ•°ä¸­ï¼Œå¹¶è®©å‡½æ•°åç§°è§£é‡Šè¯¥å‡½æ•°çš„ç”¨é€”ã€‚ å¦‚æžœæºå‡½æ•°ä¸­å±€éƒ¨å˜é‡æ¯”è¾ƒå¤šï¼Œå…ˆç”¨Replace Temp With Queryå‡å°‘ä¸´æ—¶å˜é‡ï¼Œæºå‡½æ•°ä¸­è¯»å–çš„ä¸´æ—¶å˜é‡å’Œå‚æ•°ï¼Œæç‚¼åˆ°ç›®æ ‡å‡½æ•°ä½œä¸ºå‚æ•°ï¼Œå¹¶è€ƒè™‘æ˜¯å¦éœ€è¦è¿”å›žå€¼ã€‚ Inline Method ï¼ˆå†…è”å‡½æ•°ï¼‰ ä¸€ä¸ªå‡½æ•°å’Œæœ¬ä½“ä¸€æ ·æ¸…æ¥šæ˜“æ‡‚ï¼Œåœ¨å‡½æ•°è°ƒç”¨ç‚¹æ’å…¥å‡½æ•°ä½“ï¼Œç„¶åŽç§»é™¤è¯¥å‡½æ•°ã€‚ Inline Tempï¼ˆå†…è”ä¸´æ—¶å˜é‡ï¼‰ å°†ä¸´æ—¶å˜é‡æ›¿æ¢ä¸ºå¯¹å®ƒèµ‹å€¼çš„è¡¨è¾¾å¼æˆ–å‡½æ•°ã€‚ Replace Temp With Queryï¼ˆä»¥æŸ¥è¯¢å–ä»£ä¸´æ—¶å˜é‡ï¼‰ å°†ä¸´æ—¶å˜é‡çš„è®¡ç®—ä»£ç æç‚¼åˆ°ä¸€ä¸ªç‹¬ç«‹çš„å‡½æ•°ä¸­ï¼Œè¿™æ ·ä¸´æ—¶å˜é‡çš„å¼•ç”¨ç‚¹å°±å¯ä»¥æ›¿æ¢ä¸ºæ–°å‡½æ•°çš„è°ƒç”¨ã€‚ ä»¥æŸ¥è¯¢ä»£æ›¿ä¸´æ—¶å˜é‡å¯ä»¥å‡å°‘ä¸´æ—¶å˜é‡ï¼Œæ˜¯æç‚¼å‡½æ•°çš„é‡è¦æ­¥éª¤ã€‚ Introduce Explaining Variable (å¼•å…¥è§£é‡Šæ€§å˜é‡) å°†è¯¥å¤æ‚è¡¨è¾¾å¼çš„ç»“æžœæ”¾è¿›ä¸€ä¸ªä¸´æ—¶å˜é‡ï¼Œä»¥æ­¤å˜é‡åç§°æ¥è§£é‡Šè¡¨è¾¾å¼çš„ä½œç”¨ã€‚ æˆ–è€…Extract Methodæ¥å¤„ç† Split Temporary Variable (åˆ†è§£ä¸´æ—¶å˜é‡) æŸä¸ªä¸´æ—¶å˜é‡ï¼Œæ—¢ä¸æ˜¯å¾ªçŽ¯å˜é‡ä¹Ÿä¸æ˜¯æ”¶é›†å˜é‡ï¼›é’ˆå¯¹æ¯æ¬¡èµ‹å€¼ï¼Œåˆ›é€ ä¸€ä¸ªç‹¬ç«‹çš„ã€æœ‰åˆç†åç§°çš„ä¸´æ—¶å˜é‡æ¥åˆ†è§£é‡å¤èµ‹å€¼ã€‚ Remove Assignments to Parameters(ç§»é™¤å¯¹å‚æ•°çš„èµ‹å€¼ï¼‰ ä»£ç å¯¹å‚æ•°è¿›è¡Œèµ‹å€¼ï¼Œä»¥ä¸€ä¸ªä¸´æ—¶å˜é‡å–ä»£è¯¥å‚æ•°çš„ä½ç½® Javaæ˜¯æŒ‰å€¼ä¼ é€’çš„ 123void aMethod(Object foo) &#123; foo.modifySomeWay(); //that's OKï¼Œå°†æ”¹å˜fooå¼•ç”¨çš„å¯¹è±¡ foo = anothnerObject; //trouble will follow, å‡½æ•°è¿”å›žåŽå¹¶ä¸ä¼šæ”¹å˜fooã€‚ Replace Method with Method Object(ä»¥å‡½æ•°å¯¹è±¡å–ä»£å‡½æ•°ï¼‰ æœ‰ä¸€ä¸ªå¤§åž‹å‡½æ•°å…¶ä¸­å­˜åœ¨å¤§é‡çš„å±€éƒ¨å˜é‡ï¼Œå¾ˆéš¾Extract Methodæ¥åˆ†è§£è¿™ä¸ªå‡½æ•°ï¼Œé‚£ä¹ˆä½¿ç”¨å‡½æ•°å¯¹è±¡ã€‚ å°†åŽŸå‡½æ•°æ›¿ä»£æˆå‡½æ•°å¯¹è±¡ï¼Œè¯¥å‡½æ•°å¯¹è±¡çš„æž„é€ å‡½æ•°æŽ¥å—æºå¯¹è±¡å’ŒåŽŸå‡½æ•°çš„å‚æ•°ä½œä¸ºå‚æ•°ï¼› é’ˆå¯¹åŽŸå‡½æ•°æ¯ä¸ªä¸´æ—¶å˜é‡å’Œæ¯ä¸ªå‚æ•°ï¼Œåœ¨æ–°çš„å‡½æ•°å¯¹è±¡ä¸­å»ºç«‹ä¸€ä¸ªå¯¹åº”çš„å­—æ®µä¿å­˜ï¼› ç„¶åŽå°±å¯ä»¥åœ¨å‡½æ•°å¯¹è±¡ä¸­Extract Methodæ¥åˆ†è§£åŽŸå‡½æ•°ï¼› Substitute Algorithm (æ›¿æ¢ç®—æ³•) å°†å‡½æ•°æœ¬ä½“æ›¿æ¢ä¸ºæ–°çš„ç®—æ³•ï¼Œå»ºè®®å…ˆè€ƒè™‘åˆ†è§£å‡½æ•°å†åšæ›¿æ¢ã€‚ ###åœ¨å¯¹è±¡ä¹‹é—´æ¬ç§»ç‰¹æ€§ Move Method (æ¬ç§»å‡½æ•°) å‡½æ•°ä¸Žå…¶ä»–ç±»è€¦åˆè¿‡å¤šï¼Œè€ƒè™‘ä½¿ç”¨å§”æ‰˜æˆ–æ¬ç§»åˆ°åˆé€‚çš„ç±»ä¸­ã€‚ æ¬ç§»è¿‡ç¨‹ä¸­ï¼Œå½“ç›®æ ‡ç±»éœ€è¦æºç±»ç‰¹æ€§æ—¶ï¼Œ1ï¼‰å°†è¿™ä¸ªç‰¹æ€§ä¹Ÿæ¬ç§»åˆ°ç›®æ ‡ç±» 2ï¼‰å»ºç«‹ä½¿ç”¨ç›®æ ‡ç±»åˆ°æºç±»çš„ä½¿ç”¨ 3ï¼‰å°†æºå¯¹è±¡æˆ–è¯¥ç‰¹æ€§å˜é‡ä½œä¸ºå‚æ•°ä¼ é€’ç»™ç›®æ ‡ç±» Move Field (æ¬ç§»å­—æ®µ) æŸä¸ªå­—æ®µè¢«æ‰€é©»ç±»ä¹‹å¤–çš„å¦ä¸€ä¸ªç±»æ›´å¤šåœ°ç”¨åˆ°ï¼Œè€ƒè™‘æ¬ç§»è¿™ä¸ªå­—æ®µåˆ°ç›®æ ‡ç±»ã€‚ Self Encapsulateï¼ˆä½¿ç”¨è‡ªæˆ‘å°è£…ï¼‰åœ¨å­—æ®µæ¬ç§»åŽï¼Œå°±åªéœ€è¦ä¿®æ”¹è®¿é—®å‡½æ•°ï¼ˆsetï¼getï¼‰ï¼Œè€Œæ— éœ€ä¿®æ”¹å¼•ç”¨ç‚¹ã€‚ Extract Classï¼ˆæç‚¼ç±»ï¼‰ å»ºç«‹ä¸€ä¸ªæ–°ç±»ï¼Œå°†ç›¸å…³å­—æ®µå’Œå‡½æ•°ä»Žæ—§ç±»æ¬ç§»åˆ°æ–°ç±»ã€‚ å¯èƒ½éœ€è¦åŒå‘è¿žæŽ¥ï¼Œå°½é‡é¿å…å»ºè®®æ–°ç±»åˆ°æ—§ç±»çš„è¿žæŽ¥ï¼›å†³å®šæ˜¯å¦å…¬å¼€æ–°ç±»ï¼› Inline Classï¼ˆå†…è”åŒ–ç±»ï¼‰ å°†è¿™ä¸ªç±»çš„æ‰€æœ‰ç‰¹æ€§æ¬ç§»åˆ°å¦ä¸€ä¸ªç±»ï¼Œç„¶åŽç§»é™¤è¿™ä¸ªç±»ï¼› Hide Delegate (éšè—â€œå§”æ‰˜å…³ç³»â€œ) å®¢æˆ·ç±»é€šè¿‡å§”æ‰˜ç±»æ¥è°ƒç”¨å¦ä¸€ä¸ªå¯¹è±¡ï¼Œåœ¨æœåŠ¡ç±»ä¸Šå»ºç«‹å®¢æˆ·éœ€è¦çš„æ‰€æœ‰å§”æ‰˜å‡½æ•°ï¼Œç”¨äºŽéšè—å§”æ‰˜å…³ç³»ã€‚ â€‹ Remove Middle Manï¼ˆç§»é™¤ä¸­é—´äººï¼‰ æŸä¸ªç±»åšäº†è¿‡å¤šçš„å§”æ‰˜åŠ¨ä½œï¼Œé‚£ä¹ˆå¯ä»¥ç›´æŽ¥è®©å®¢æˆ·ç±»è°ƒç”¨å—æ‰˜ç±»ï¼› æœåŠ¡ç±»ä¸­å»ºç«‹ä¸€ä¸ªå‡½æ•°ï¼Œç›´æŽ¥è¿”å›žå—æ‰˜ç±»ï¼Œå®¢æˆ·ç±»ç›´æŽ¥è°ƒç”¨è¯¥ç±»ï¼› éšè—å§”æ‰˜å…³ç³»ä¸Žç§»é™¤ä¸­é—´äººäº’ä¸ºé€†å‘çš„è¡Œä¸ºã€‚ Introduce foreign Method (å¼•å…¥å¤–åŠ å‡½æ•°) åœºæ™¯ï¼šä½ éœ€è¦ä¸ºæä¾›æœåŠ¡çš„ç±»å¢žåŠ ä¸€ä¸ªå‡½æ•°ï¼Œä½†æ˜¯å´æ— æ³•ä¿®æ”¹è¿™ä¸ªç±» åº”å¯¹ï¼šåœ¨å®¢æˆ·ç±»ä¸­å»ºç«‹ä¸€ä¸ªå‡½æ•°ï¼Œå¹¶ä¼ å…¥ä¸€ä¸ªæœåŠ¡ç±»çš„å®žä¾‹å‚æ•°ï¼› å¦‚æžœéœ€è¦å¤–åŠ å¤šä¸ªå‡½æ•°ï¼Œè€ƒè™‘ä½¿ç”¨å¼•å…¥æœ¬åœ°æ‰©å±•ã€‚ Introduce Local Extension (å¼•å…¥æœ¬åœ°æ‰©å±•) åœºæ™¯ï¼šä½ éœ€è¦ä¸ºæœåŠ¡ç±»æä¾›ä¸€äº›é¢å¤–çš„å‡½æ•°ï¼Œä½†æ˜¯ä½ æ— æ³•ä¿®æ”¹è¿™ä¸ªç±» åº”å¯¹ï¼šå»ºç«‹ä¸€ä¸ªæ–°ç±»ï¼ŒåŒ…å«è¿™äº›é¢å¤–çš„å‡½æ•°ï¼Œè®©è¿™ä¸ªæ‰©å±•å“ç§°ä¸ºæºç±»çš„å­—ç±»ï¼ˆsubclassï¼‰æˆ–åŒ…è£…ç±»ï¼ˆwrapperï¼‰ï¼› ###é‡æ–°ç»„ç»‡æ•°æ® Self Encapsulate Field (è‡ªå°è£…å­—æ®µ) ç›´æŽ¥è®¿é—®å­—æ®µï¼Œäº§ç”Ÿè€¦åˆå…³ç³»ï¼›ä¸ºè¿™äº›å­—æ®µå»ºç«‹get/setå‡½æ•°ï¼Œå¹¶ä»¥è¿™äº›å‡½æ•°è®¿é—®å­—æ®µã€‚ ç›´æŽ¥è®¿é—®å­—æ®µè¿˜æ˜¯é€šè¿‡get/setå‡½æ•°è®¿é—®å“ªä¸ªå¥½æ²¡æœ‰å®šè®ºã€‚ Replace Data Value with Object(ä»¥å¯¹è±¡å–ä»£æ•°æ®å€¼) å¦‚æžœæœ‰ä¸€ä¸ªæ•°æ®é¡¹éœ€è¦ä¸Žå…¶ä»–æ•°æ®æˆ–è€…è¡Œä¸ºä¸€èµ·ä½¿ç”¨æ‰æœ‰æ„ä¹‰ï¼Œé‚£ä¹ˆå°†æ•°æ®å˜æˆå¯¹è±¡ã€‚ æ•°æ®å€¼ â€”&gt; å€¼å¯¹è±¡,å€¼å¯¹è±¡åº”è¯¥æ˜¯ä¸å¯ä¿®æ”¹çš„ åŒºåˆ«ï¼šå¦‚æžœæ•°æ®å¯ä¿®æ”¹ï¼Œä½¿ç”¨å¼•ç”¨å¯¹è±¡ï¼ŒChange value to Reference Change Value into Reference(å°†å€¼å¯¹è±¡æ”¹ä¸ºå¼•ç”¨å¯¹è±¡) ä»Žä¸€ä¸ªç±»è¡ç”Ÿå‡ºå¤šä¸ªç›¸ç­‰çš„å®žä¾‹ï¼Œå¸Œæœ›å®ƒä»¬æ˜¯åŒä¸€ä¸ªå¯¹è±¡ï¼›å°†å€¼å¯¹è±¡å˜æˆå¼•ç”¨å¯¹è±¡ï¼› å¤šä¸ªOrderå…±äº«åŒä¸€ä¸ªCustomerå¯¹è±¡ å¼•ç”¨å¯¹è±¡éƒ½ä»£è¡¨çœŸå®žä¸–ç•Œä¸­çš„ä¸€ä¸ªå®žç‰©ï¼Œå¯ä»¥ç”¨==ç›´æŽ¥æ£€æŸ¥ä¸¤ä¸ªå¯¹è±¡æ˜¯å¦ç›¸ç­‰ï¼›å¦‚â€œå®¢æˆ·â€ã€â€œè´¦æˆ·â€ç­‰.. å€¼å¯¹è±¡ä¸å¯å˜ï¼Œå®Œå…¨ç”±å…¶æ•°æ®å€¼æ¥å®šä¹‰ï¼Œæœ‰å¤šä¸ªå‰¯æœ¬å­˜åœ¨ï¼Œéœ€è¦å¤å†™equals()åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚â€œæ—¥æœŸâ€ã€â€œé’±â€.. Change Reference to Value(å°†å¼•ç”¨å¯¹è±¡æ”¹ä¸ºå€¼å¯¹è±¡) æœ‰ä¸€ä¸ªå¼•ç”¨å¯¹è±¡ï¼Œå¾ˆå°ä¸”ä¸å¯å˜ï¼Œå°†å®ƒæ”¹ä¸ºå€¼å¯¹è±¡ã€‚ â€‹ å€¼å¯¹è±¡æ˜¯â€œä¸å¯å˜â€ï¼ˆimmutableï¼‰çš„ï¼Œè¡¨ç¤ºå¯¹è±¡è‡ªèº«æ˜¯ä¸å¯å˜çš„ã€‚åˆ¤æ–­ç›¸ç­‰ç”¨equals()æ–¹æ³• Replace Array with Object(ä»¥å¯¹è±¡ä»£æ›¿ç»„æ•°) æœ‰ä¸€ä¸ªæ•°ç»„ï¼Œå…¶ä¸­çš„å…ƒç´ å„è‡ªä»£è¡¨ä¸åŒçš„ä¸œè¥¿ ä»¥å¯¹è±¡ä»£æ›¿æ•°ç»„ï¼Œå¯¹äºŽæ•°ç»„ä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ ï¼Œä»¥ä¸€ä¸ªå­—æ®µæ¥è¡¨ç¤º Duplicate Observed Data(å¤åˆ¶â€œè¢«ç›‘è§†çš„æ•°æ®â€) æœ‰ä¸€äº›é¢†åŸŸï¼ˆModelï¼‰æ•°æ®ç½®èº«äºŽGUIæŽ§ä»¶ä¸­ï¼Œè€Œé¢†åŸŸå‡½æ•°éœ€è¦è®¿é—®éœ€è¦è®¿é—®è¿™æ•°æ®ï¼› å°†è¯¥æ•°æ®å¤åˆ¶åˆ°é¢†åŸŸå¯¹è±¡ä¸­ï¼Œå»ºç«‹ä¸€ä¸ªObserveræ¨¡å¼ï¼Œç”¨ä»¥åŒæ­¥é¢†åŸŸå¯¹è±¡å’ŒGUIå¯¹è±¡å†…çš„é‡å¤æ•°æ®ï¼› â€‹ Change Unidirectional Association to Bidirectional(å°†å•å‘å…³è”æ”¹ä¸ºåŒå‘å…³è”) åœºæ™¯ï¼šä¸¤ä¸ªç±»éƒ½éœ€è¦ä½¿ç”¨å¯¹æ–¹çš„ç‰¹æ€§ï¼Œä½†åªæœ‰ä¸€æ¡å•å‘å…³è” å®žçŽ°ï¼šæ·»åŠ ä¸€ä¸ªåå‘æŒ‡é’ˆï¼Œå¹¶ä½¿ä¿®æ”¹å‡½æ•°èƒ½å¤ŸåŒäº‹æ›´æ–°ä¸¤æ¡è¿žæŽ¥ â€‹ å†³å®šå“ªä¸ªç±»æ˜¯æŽ§åˆ¶ç«¯ï¼›æŽ§åˆ¶ç«¯ï¼ˆæä¾›æŽ§åˆ¶å‡½æ•°ï¼Œç»´æŠ¤åå‘æŒ‡é’ˆï¼‰ï¼Œä¿®æ”¹å‡½æ•°è°ƒç”¨æŽ§åˆ¶å‡½æ•°ï¼›è¢«æŽ§åˆ¶ç«¯ï¼ˆæä¾›ä¸€ä¸ªè¾…åŠ©å‡½æ•°æä¾›åå‘æŒ‡é’ˆï¼‰ï¼Œä¿®æ”¹å‡½æ•°è°ƒç”¨æŽ§åˆ¶ç«¯çš„æŽ§åˆ¶å‡½æ•°ã€‚ Change Bidirectional Association to Unidirectionalï¼ˆå°†åŒå‘å…³è”æ”¹ä¸ºå•å‘å…³è”) åœºæ™¯ï¼šä¸¤ä¸ªç±»ä¹‹é—´æœ‰åŒå‘å…³è”ï¼Œä½†å…¶ä¸­ä¸€ä¸ªç±»å¦‚ä»Šä¸å†éœ€è¦å¦ä¸€ä¸ªç±»çš„ç‰¹æ€§ï¼› åŽ»é™¤ä¸å¿…è¦çš„å…³è” Replace Magic Number with Symbolic Constant(ä»¥å­—é¢å¸¸é‡ä»£æ›¿é­”æ³•æ•°) åˆ›å»ºä¸€ä¸ªå¸¸é‡ï¼Œæ ¹æ®å…¶æ„ä¹‰å‘½åï¼Œæ›¿æ¢ä¸Šè¿°é­”æ³•æ•° Encapsulate Field(å°è£…å­—æ®µ) å°†publicå­—æ®µå£°æ˜Žä¸ºprivateï¼Œå¹¶æä¾›ç›¸åº”çš„get/setè®¿é—®å‡½æ•° Encapsulate Collection(å°è£…é›†åˆ) åœºæ™¯ï¼šæœ‰ä¸€ä¸ªå‡½æ•°è¿”å›žä¸€ä¸ªé›†åˆ ä¼˜åŒ–ï¼šè®©è¿™ä¸ªå‡½æ•°è¿”å›žè¯¥é›†åˆçš„ä¸€ä¸ªåªè¯»å‰¯æœ¬ï¼Œå¹¶æä¾›æ·»åŠ ï¼ç§»é™¤è¯¥é›†åˆå…ƒç´ çš„æ–¹æ³• â€‹ Replace Record with Data Class(ä»¥æ•°æ®ç±»å–ä»£è®°å½•) ä¸ºè®°å½•ç»“æž„åž‹æ•°æ®åˆ›å»ºä¸€ä¸ªæ•°æ®å¯¹è±¡ Replace Type Code with Class(ä»¥ç±»å–ä»£ç±»åž‹ç ) åœºæ™¯ï¼šç±»ä¸­åˆä¸€ä¸ªæ•°å€¼ç±»åž‹ç ï¼Œä½†å®ƒå¹¶ä¸å½±å“ç±»çš„è¡Œä¸º ä»¥ä¸€ä¸ªæ–°çš„ç±»æ›¿æ¢è¯¥æ•°å€¼ç±»åž‹ç  â€‹ Replace Type Code with Subclasses(ä»¥å­ç±»å–ä»£ç±»åž‹ç ) åœºæ™¯ï¼šæœ‰ä¸€ä¸ªä¸å¯å˜çš„ç±»åž‹ç ï¼Œå®ƒä¼šå½±å“ç±»çš„è¡Œä¸º é‡æž„ï¼šä»¥å­—ç±»å–ä»£è¿™ä¸ªç±»åž‹ç ï¼Œå€ŸåŠ©å¤šæ€å®žçŽ°å˜åŒ–è¡Œä¸º,å°†å’Œç‰¹å®šå­—ç±»ç›¸å…³çš„å­—æ®µï¼å‡½æ•°push downåˆ°å­—ç±» Replace Type Code with State/Stratege(ä»¥çŠ¶æ€ï¼ç­–ç•¥å–ä»£ç±»åž‹ç ) åœºæ™¯ï¼šå¦‚æžœä¸€ä¸ªç±»åž‹ç çš„å€¼åœ¨å¯¹è±¡ç”Ÿå‘½å‘¨æœŸå‘ç”Ÿå˜åŒ–æˆ–è€…å…¶ä»–åŽŸå› æ˜¯å®¿ä¸»ç±»ä¸èƒ½è¢«ç»§æ‰¿ï¼› é‡æž„ï¼šä»¥çŠ¶æ€å¯¹è±¡æˆ–ç­–ç•¥æ¨¡å¼å–ä»£ç±»åž‹ç  Replace Subclass with Fields(ä»¥å­—æ®µä»£æ›¿å­ç±») åœºæ™¯ï¼šå„ä¸ªå­ç±»çš„å”¯ä¸€å·®åˆ«åªåœ¨â€œè¿”å›žå¸¸é‡æ•°æ®â€çš„å‡½æ•°èº«ä¸Š é‡æž„ï¼šä¿®æ”¹è¿™äº›å‡½æ•°ï¼Œä½¿å®ƒä»¬è¿”å›žè¶…ç±»ä¸­çš„æŸä¸ªï¼ˆæ–°å¢žï¼‰å­—æ®µï¼Œç„¶åŽé”€æ¯å­ç±» ###ç®€åŒ–æ¡ä»¶è¡¨è¾¾å¼ Decompose Conditional(ç®€åŒ–æ¡ä»¶è¡¨è¾¾å¼) åœºæ™¯ï¼šæœ‰ä¸€ä¸ªå¤æ‚çš„æ¡ä»¶if-then-elseè¯­å¥ ä»Žifã€thenã€elseæ®µè½ä¸­åˆ†åˆ«æç‚¼å‡ºç‹¬ç«‹çš„å‡½æ•°ï¼Œå‡½æ•°åå¯ä»¥ç›´è§‚åæ˜ å‡ºå‡½æ•°çš„ç”¨é€” Consolidate Conditional Expression(åˆå¹¶æ¡ä»¶è¡¨è¾¾å¼) åœºæ™¯ï¼šæœ‰ä¸€ç³»åˆ—çš„æ¡ä»¶æµ‹è¯•ï¼Œå‡å¾—åˆ°ç›¸åŒçš„ç»“æžœ é‡æž„ï¼šå°†è¿™äº›æµ‹è¯•åˆå¹¶ä¸ºä¸€ä¸ªæ¡ä»¶è¡¨è¾¾å¼ï¼Œå¹¶å°†è¿™ä¸ªæ¡ä»¶è¡¨è¾¾å¼æç‚¼ä¸ºä¸€ä¸ªç‹¬ç«‹çš„å‡½æ•° ä½¿ç”¨||ã€&amp;&amp;ã€ï¼Ÿï¼šåˆå¹¶æµ‹è¯•æ¡ä»¶ Consolidate Duplicate Conditional Fragments(åˆå¹¶é‡å¤çš„æ¡ä»¶ç‰‡æ®µ) åœºæ™¯ï¼šåœ¨æ¡ä»¶è¡¨è¾¾å¼çš„æ¯ä¸ªåˆ†æ”¯ä¸Šéƒ½æœ‰ç›¸åŒçš„ä¸€æ®µä»£ç  é‡æž„ï¼šå°†è¿™æ®µä»£ç æ¬ç§»åˆ°æ¡ä»¶è¡¨è¾¾å¼å¤–ï¼Œå¹¶æç‚¼å‡ºç‹¬ç«‹å‡½æ•° Remove Control Flag(ç§»é™¤æŽ§åˆ¶æ ‡è®°) åœ¨ä¸€ç³»åˆ—çš„å¸ƒå°”è¡¨è¾¾å¼ä¸­ï¼ŒæŸä¸ªå˜é‡å¸¦æœ‰æŽ§åˆ¶æ ‡è®°ï¼ˆcontrol flagï¼‰çš„ä½œç”¨ ä»¥breakæˆ–è€…returnè¯­å¥å–ä»£è¿™ä¸ªæŽ§åˆ¶æ ‡è®° Replace Nested Conditional with Guard Clauses(ä»¥ä½è¯­å¥å–ä»£åµŒå¥—çš„æ¡ä»¶è¡¨è¾¾å¼) åœºæ™¯ï¼šå‡½æ•°ä¸­æ¡ä»¶é€»è¾‘ä½¿äººè¿·æƒ‘ é‡æž„ï¼šä½¿ç”¨å«è¯­å¥è¡¨çŽ°æ‰€æœ‰ç‰¹æ®Šæƒ…å†µï¼Œç«‹å³è¿”å›žç»“æžœï¼›æœ€åŽå¤„ç†æ­£å¸¸é€»è¾‘ï¼› ä½¿ç”¨å«è¯­å¥æ£€æŸ¥ç‰¹æ®Šæ¡ä»¶ï¼Œç«‹åˆ»è¿”å›žæˆ–æŠ›å‡ºå¼‚å¸¸ï¼› å¯ä»¥å…ˆå°†æ¡ä»¶è¡¨è¾¾å¼åè½¬å®žçŽ°å«è¯­å¥ï¼ˆP253ï¼‰ï¼› â€‹ â€‹ Replace Conditional with Polymorphism(ä»¥å¤šæ€å–ä»£æ¡ä»¶è¡¨è¾¾å¼) åœºæ™¯ï¼šæœ‰ä¸€ä¸ªæ¡ä»¶è¡¨è¾¾å¼ï¼Œæ ¹æ®å¯¹è±¡ç±»åž‹çš„ä¸åŒé€‰æ‹©ä¸åŒçš„è¡Œä¸º é‡æž„ï¼šå°†è¿™ä¸ªæ¡ä»¶è¡¨è¾¾å¼çš„æ¯ä¸ªåˆ†æ”¯æ”¾è¿›ä¸€ä¸ªå­ç±»çš„å¤å†™å‡½æ•°ä¸­ï¼Œç„¶åŽå°†åŽŸå§‹çš„å‡½æ•°å£°æ˜Žä¸ºæŠ½è±¡ â€‹ åœ¨ä½¿ç”¨Replace Coditional with Polymorphismä¹‹å‰,å¿…é¡»å»ºç«‹ä¸€ä¸ªç»§æ‰¿ç»“æž„ï¼šä¼˜å…ˆä½¿ç”¨Repalce Type Code with Subclassï¼Œä½†æ˜¯å¦‚æžœéœ€è¦åœ¨å¯¹è±¡åˆ›å»ºåŽä¿®æ”¹ç±»åž‹ç ï¼Œå°±ä¸èƒ½ç”¨ç»§æ‰¿æ‰‹æ³•ï¼Œé‚£ä¹ˆä½¿ç”¨ Replace Type Code with State/Stratege; Introduce Null Object(å¼•å…¥Nullå¯¹è±¡) åœºæ™¯ï¼šä½ éœ€è¦å†ä¸‰æ£€æŸ¥æŸä¸ªå¯¹è±¡æ˜¯å¦ä¸ºnull é‡æž„ï¼šå»ºç«‹Nullå¯¹è±¡ï¼Œæ›¿æ¢nullå€¼çš„åˆ¤æ–­ â€‹ ç©ºå¯¹è±¡ç»§æ‰¿æºå¯¹è±¡ï¼Œæˆ–è€…å®žçŽ°Null Interfaceï¼›ç©ºå¯¹è±¡ä¸€å®šæ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œå®ƒçš„ä»»ä½•æˆåˆ†éƒ½ä¸ä¼šå˜åŒ–ï¼› Introduce Assertion(å¼•å…¥æ–­è¨€) æŸä¸€æ®µä»£ç éœ€è¦å¯¹ç¨‹åºçŠ¶æ€ä½œå‡ºå‡è®¾ï¼Œä»¥æ–­è¨€æ˜Žç¡®è¡¨ç¤ºè¿™ç§å‡è®¾ ###ç®€åŒ–å‡½æ•°è°ƒç”¨ Rename Method(å‡½æ•°æ”¹å) ç»™æ¯ä¸€ä¸ªå‡½æ•°å–ä¸€ä¸ªå¯ä»¥æ­ç¤ºå‡½æ•°ç”¨é€”çš„ã€ç›´è§‚çš„åå­— Add Parameter(æ·»åŠ å‚æ•°) ä¸ºæ­¤å‡½æ•°æ·»åŠ ä¸€ä¸ªå¯¹è±¡å‚æ•°ï¼Œè®©è¯¥å¯¹è±¡å‚æ•°å¸¦è¿›å‡½æ•°æ‰€éœ€ä¿¡æ¯ Remove Parameter(ç§»é™¤å‚æ•°) ç§»é™¤å¤šä½™çš„å‚æ•° Separate Query from Modifier(å°†æŸ¥è¯¢å‡½æ•°å’Œä¿®æ”¹å‡½æ•°åˆ†ç¦») åœºæ™¯ï¼šæŸä¸ªå‡½æ•°æ—¢è¿”å›žå¯¹è±¡çŠ¶æ€å€¼ï¼Œæœ‰ä¿®æ”¹å¯¹è±¡çŠ¶æ€ é‡æž„ï¼šå»ºç«‹ä¸¤ä¸ªç‹¬ç«‹çš„å‡½æ•°ï¼Œä¸€ä¸ªè´Ÿè´£æŸ¥è¯¢ï¼Œå¦ä¸€ä¸ªè´Ÿè´£ä¿®æ”¹ æ³¨æ„å¹¶å‘ç¼–ç¨‹ä¸­ï¼Œå¯ä¿ç•™æŸ¥è¯¢-ä¿®æ”¹å‡½æ•°ï¼Œè°ƒç”¨å„è‡ªç‹¬ç«‹çš„æŸ¥è¯¢å‡½æ•°å’Œä¿®æ”¹å‡½æ•°ï¼Œå¹¶å£°æ˜Žä¸ºsynchronised Parameterize Method(ä»¤å‡½æ•°æºå¸¦å‚æ•°) è‹¥å¹²å‡½æ•°åšäº†ç±»ä¼¼çš„å·¥ä½œï¼Œä½†å› å°‘æ•°å‡ ä¸ªå€¼è‡´ä½¿è¡Œä¸ºç•¥æœ‰ä¸åŒ å»ºç«‹å•ä¸€å‡½æ•°ï¼Œä»¥å‚æ•°è¡¨è¾¾é‚£äº›ä¸åŒçš„å€¼ â€‹ Replace Parameter with Explicit Method(ä»¥æ˜Žç¡®å‡½æ•°å–ä»£å‚æ•°) æœ‰ä¸€ä¸ªå‡½æ•°å®‰å…¨å–å†³äºŽå‚æ•°å€¼è€Œé‡‡å–ä¸åŒçš„è¡Œä¸º é’ˆå¯¹è¯¥å‚æ•°çš„æ¯ä¸€ä¸ªå¯èƒ½å€¼ï¼Œå»ºç«‹ä¸€ä¸ªç‹¬ç«‹å‡½æ•°ï¼›ç›¸åä¸ŽParameterize Method Preserve Whole Object(ä¿æŒå®Œæ•´å¯¹è±¡) åœºæ™¯ï¼šä½ ä»Žå¯¹è±¡ä¸­å–å‡ºä¸€äº›å€¼ï¼Œå°†å®ƒä»¬ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•° é‡æž„ï¼šæ”¹ä¸ºä¼ é€’æ•´ä¸ªå¯¹è±¡ Replace Parameter with Methods(ä»¥å‡½æ•°å–ä»£å‚æ•°) åœºæ™¯ï¼šå¯¹è±¡è°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œå¹¶å°†æ‰€å¾—çš„ç»“æžœä½œä¸ºå‚æ•°ï¼Œä¼ é€’ç»™å¦ä¸€ä¸ªå‡½æ•° é‡æž„ï¼šè®©å‚æ•°æŽ¥æ”¶è¿™åŽ»å¤„è¯¥é¡¹å‚æ•°ï¼Œå¹¶ç›´æŽ¥è°ƒç”¨å‰ä¸€ä¸ªå‡½æ•° å¦‚æžœå‡½æ•°å¯ä»¥é€šè¿‡å…¶ä»–é€”å¾„èŽ·å–å‚æ•°å€¼ï¼Œé‚£ä¹ˆå°±åº”è¯¥åŽ»é™¤è¯¥å¤šä½™çš„å‚æ•° â€‹ Introduce Parameter Object(å¼•å…¥å‚æ•°å¯¹è±¡) åœºæ™¯ï¼šæŸäº›å‚æ•°æ€»æ˜¯å¾ˆè‡ªç„¶çš„åŒæ—¶å‡ºçŽ° é‡æž„ï¼šä»¥ä¸€ä¸ªå¯¹è±¡å–ä»£è¿™äº›å‚æ•°ï¼Œæ¯”å¦‚Rangeæ¨¡å¼ï¼ŒèŒƒå›´å¯¹è±¡å–ä»£(start,end) Remove Setting Method(ç§»é™¤è®¾å€¼å‡½æ•°) åœºæ™¯ï¼šç±»ä¸­çš„æŸä¸ªå­—æ®µåº”è¯¥åœ¨å¯¹è±¡åˆ›å»ºçš„æ—¶å€™è¢«è®¾å€¼ï¼Œç„¶åŽä¸å†æ”¹å˜ é‡æž„ï¼šåŽ»é™¤è¯¥å­—æ®µæ‰€æœ‰è®¾å€¼å‡½æ•°ï¼ŒåŒæ—¶å£°æ˜Žè¯¥å­—æ®µä¸ºfinal Hide Method(éšè—å‡½æ•°) æœ‰ä¸€ä¸ªå‡½æ•°ä»Žç±»æ²¡æœ‰è¢«å…¶ä»–ä»»ä½•ç±»ç”¨åˆ°è¿‡ å°†è¿™ä¸ªå‡½æ•°ä¿®æ”¹ä¸ºprivate Replace Constructor with Factory Method(ä»¥å·¥åŽ‚å‡½æ•°å–ä»£æž„é€ å‡½æ•°) åœºæ™¯ï¼šåœ¨æ´¾ç”Ÿå­ç±»çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦æ ¹æ®ç±»åž‹ç ï¼Œåˆ›å»ºç›¸åº”çš„å¯¹è±¡ é‡æž„ï¼šä½¿ç”¨å·¥åŽ‚å‡½æ•°å–ä»£æž„é€ å‡½æ•° â€‹ Encapsulate Downcast(å°è£…å‘ä¸‹è½¬åž‹) åœºæ™¯ï¼šæŸä¸ªå‡½æ•°è¿”å›žçš„å¯¹è±¡éœ€è¦ç”±å‡½æ•°çš„è°ƒç”¨è€…æ‰§è¡Œå‘ä¸‹è½¬åž‹ é‡æž„ï¼šå°†å‘ä¸‹è½¬åž‹çš„åŠ¨ä½œç§»åˆ°å‡½æ•°ä¸­ 123Object lastReading() &#123; return reading.lastElement();&#125; æ”¹ä¸ºï¼š 123Reading lastReading() &#123; return (Reading)reading.lastElement();&#125; Replace Error Code with Exception(ä»¥å¼‚å¸¸å–ä»£é”™è¯¯ç ) åœºæ™¯ï¼šæŸä¸ªå‡½æ•°è¿”å›žä¸€ä¸ªç‰¹å®šçš„ä»£ç ï¼Œè¡¨ç¤ºæŸç§é”™è¯¯çš„æƒ…å†µ é‡æž„ï¼šæ”¹ç”¨å¼‚å¸¸ 12345678int withdraw(int amount) &#123; if(amount &gt; _balance) &#123; return -1; &#125; else &#123; _balance -= amount; return 0; &#125;&#125; æ”¹ä¸ºï¼š 1234void withdraw(int amount) throws BalanceException &#123; if(amount &gt; _balance) throw new BalanceExctption(); _balance -= amount;&#125; å†³å®šå‡½æ•°åº”è¯¥æŠ›å‡ºå—æŽ§å¼‚å¸¸ï¼ˆcheckedï¼‰è¿˜æ˜¯éžå—æŽ§å¼‚å¸¸ï¼ˆuncheckedï¼‰ å¦‚æžœå‡½æ•°çš„è°ƒç”¨è€…æœ‰è´£ä»»åœ¨è°ƒç”¨å‰æ£€æŸ¥å¿…è¦çŠ¶æ€ï¼Œå°±æŠ›å‡ºuncheckedå¼‚å¸¸ æŠ›å‡ºcheckedå¼‚å¸¸å¯ä»¥æ–°å»ºä¸€ä¸ªå¼‚å¸¸ç±»ç»§æ‰¿Exceptionï¼Œæˆ–è€…ä½¿ç”¨çŽ°æœ‰çš„checkedå¼‚å¸¸ç±» Replace Exception with Test(ä»¥æµ‹è¯•å–ä»£å¼‚å¸¸) åœºæ™¯ï¼šé¢å¯¹ä¸€ä¸ªè°ƒç”¨è€…å¯ä»¥é¢„å…ˆæ£€æŸ¥çš„æ¡ä»¶ï¼Œä½ æŠ›å‡ºäº†ä¸€ä¸ªå¼‚å¸¸ ä¿®æ”¹è°ƒç”¨è€…ï¼Œä½¿å®ƒåœ¨å‡½æ•°è°ƒç”¨ä¹‹å‰é¢„å…ˆæ£€æŸ¥ 1234567double getValueForPeriod(int periodNumber) &#123; try &#123; return _values[periodNumber]; &#125; catch(ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125; æ”¹ä¸ºï¼š 1234double getValueForPeriod(int periodNumber) &#123; if ( periodNumber &gt;= _values.length ) return 0; return _values[periodNumber];&#125; å¼‚å¸¸åº”è¯¥åªè¢«ç”¨äºŽé‚£äº›äº§ç”Ÿæ„æ–™ä¹‹å¤–çš„é”™è¯¯è¡Œä¸ºï¼Œè€Œä¸åº”è¯¥æˆä¸ºæ¡ä»¶æ£€æŸ¥çš„å·¥å…·ï¼›ä¸è¦ç”¨try-catchè¯­å¥ä½œä¸ºæ¡ä»¶åˆ¤æ–­è¯­å¥ï¼› ###æ¦‚æ‹¬å¤„ç†å…³ç³» Pull Up Field(å­—æ®µä¸Šç§») å¦‚æžœä¸¤ä¸ªå­ç±»æ‹¥æœ‰ç›¸åŒçš„å­—æ®µï¼Œå°†è¯¥å­æ®µç§»åˆ°è¶…ç±» Pull Up Method(å‡½æ•°ä¸Šç§») åœºæ™¯ï¼šæœ‰äº›å‡½æ•°åœ¨å­ç±»ä¸­äº§ç”Ÿå®Œå…¨ç›¸åŒçš„ç»“æžœ é‡æž„ï¼šå°†è¯¥å‡½æ•°ç§»è‡³è¶…ç±» Pull Up Methodè¿‡ç¨‹ä¸­æœ€éº»çƒ¦çš„ä¸€ç‚¹å°±æ˜¯ï¼šè¢«æå‡çš„å‡½æ•°å¯èƒ½ä¼šå¼•ç”¨åªå‡ºçŽ°åœ¨å­ç±»è€Œä¸å‡ºçŽ°åœ¨è¶…ç±»çš„ç‰¹æ€§ã€‚ å¦‚æžœè¢«å¼•ç”¨çš„æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä½ å¯ä»¥å°†è¯¥å‡½æ•°ä¸€åŒæå‡åˆ°è¶…ç±»ï¼›æˆ–è€…åœ¨è¶…ç±»ä¸­å»ºç«‹ä¸€ä¸ªæŠ½è±¡å‡½æ•°ï¼›æˆ–è€…å»ºç«‹ä¸€ä¸ªå§”æ‰˜å‡½æ•° å¦‚æžœè¢«å¼•ç”¨çš„æ˜¯å­ç±»çš„å­—æ®µï¼Œä½ å¯ä»¥å°†è¯¥å­—æ®µä¹Ÿæå‡åˆ°è¶…ç±»ï¼›æˆ–è€…å…ˆåœ¨å­ç±»ä¸­è‡ªå°è£…å­—æ®µï¼Œç„¶åŽåœ¨è¶…ç±»ä¸­æŠŠå–å€¼å‡½æ•°å£°æ˜Žä¸ºæŠ½è±¡ Pull Up Constructor Body(æž„é€ å‡½æ•°æœ¬ä½“ä¸Šç§») åœ¨å­ç±»ä¸­å„æ‹¥æœ‰ä¸€äº›æž„é€ å‡½æ•°ï¼Œå®ƒä»¬çš„æœ¬ä½“å‡ ä¹Žä¸€è‡´ åœ¨è¶…ç±»ä¸­æ–°å»ºä¸€ä¸ªæž„é€ å‡½æ•°ï¼Œå¹¶åœ¨å­ç±»æž„é€ å‡½æ•°ä¸­è°ƒç”¨å®ƒ Pull Down Method(å‡½æ•°ä¸‹ç§») è¶…ç±»ä¸­çš„æŸä¸ªå‡½æ•°åªä¸Žéƒ¨åˆ†ï¼ˆè€Œéžå…¨éƒ¨ï¼‰å­ç±»æœ‰å…³ï¼Œå°†è¿™ä¸ªå‡½æ•°ç§»åˆ°ç›¸å…³çš„é‚£äº›å­ç±»ä¸­åŽ» Pull Down Field(å­—æ®µä¸‹ç§») è¶…ç±»ä¸­çš„æŸä¸ªå­—æ®µåªè¢«éƒ¨åˆ†ï¼ˆè€Œéžå…¨éƒ¨ï¼‰å­ç±»æ‰€ç”¨åˆ°ï¼Œå°†è¿™ä¸ªå­—æ®µç§»åˆ°éœ€è¦å®ƒçš„é‚£ä¸ªå­ç±»ä¸­åŽ» Extract SubClass(æç‚¼å­ç±») åœºæ™¯ï¼šç±»ä¸­çš„æŸäº›ç‰¹æ€§åªè¢«æŸäº›ï¼ˆè€Œéžå…¨éƒ¨ï¼‰å®žä¾‹ç”¨åˆ° é‡æž„ï¼šæ–°å»ºä¸€ä¸ªå­ç±»ï¼Œå°†ä¸Šè¿°ä¸€éƒ¨åˆ†ç‰¹æ€§ç§»åˆ°å­ç±»ä¸­ Extract SuperClass(æç‚¼è¶…ç±») åœºæ™¯ï¼šä¸¤ä¸ªç±»å…·æœ‰ç›¸ä¼¼çš„ç‰¹æ€§ é‡æž„ï¼šä¸ºè¿™ä¸¤ä¸ªç±»å»ºç«‹ä¸€ä¸ªè¶…ç±»ï¼Œå°†è¿™äº›ç›¸åŒçš„ç‰¹æ€§æ¬ç§»åˆ°è¶…ç±» Extract Interface(æç‚¼æŽ¥å£) åœºæ™¯ï¼šè‹¥å¹²å®¢æˆ·ä½¿ç”¨ç±»æŽ¥å£ä¸­çš„åŒä¸€å­é›†ï¼Œæˆ–è€…ä¸¤ä¸ªç±»çš„æŽ¥å£æœ‰ç›¸åŒçš„éƒ¨åˆ† é‡æž„ï¼šå°†ç›¸åŒçš„å­é›†æç‚¼åˆ°ä¸€ä¸ªç‹¬ç«‹çš„æŽ¥å£ä¸­ Collapse Hierarchy(æŠ˜å ç»§æ‰¿ä½“ç³») è¶…ç±»å’Œå­ç±»ä¹‹é—´æ— å¤ªå¤§åŒºåˆ«ï¼Œå°†å®ƒä»¬åˆä¸ºä¸€ä½“ From Template Method(å¡‘é€ æ¨¡ç‰ˆå‡½æ•°) åœºæ™¯ï¼šä½ æœ‰ä¸€äº›å­ç±»ï¼Œå…¶ä¸­ç›¸åº”çš„æŸäº›å‡½æ•°ä»¥ç›¸åŒçš„é¡ºåºæ‰§è¡Œç±»ä¼¼çš„æ“ä½œï¼Œä½†å„ä¸ªæ“ä½œç»†èŠ‚ä¸Šæœ‰æ‰€ä¸åŒ é‡æž„ï¼šå°†è¿™äº›ç»†èŠ‚æ“ä½œåˆ†åˆ«æ”¾è¿›ç‹¬ç«‹çš„å‡½æ•°ä¸­ï¼Œå¹¶ä¿æŒå®ƒä»¬éƒ½æœ‰ç›¸åŒçš„ç­¾åï¼ŒäºŽæ˜¯åŽŸå‡½æ•°ä¹Ÿå˜å¾—ç›¸åŒäº†ï¼›ç„¶åŽå°†åŽŸå‡½æ•°ä¸Šç§»åˆ°è¶…ç±» â€‹ Replace Inheritance with Delegation(ä»¥å§”æ‰˜å–ä»£ç»§æ‰¿) åœºæ™¯ï¼šæŸäº›å­ç±»åªä½¿ç”¨è¶…ç±»æŽ¥å£ä¸­çš„ä¸€éƒ¨åˆ†ï¼Œæˆ–è€…æ ¹æœ¬ä¸éœ€è¦ç»§æ‰¿è€Œæ¥çš„æ•°æ® é‡æž„ï¼šåœ¨å­ç±»ä¸­æ–°å»ºä¸€ä¸ªå­æ®µç”¨ä»¥ä¿å­˜è¶…ç±»ï¼›è°ƒæ•´å­ç±»å‡½æ•°ä»¤å®ƒå§”æ‰˜è¶…ç±»ï¼›ç„¶åŽåŽ»æŽ‰ç»§æ‰¿å…³ç³» Replace Delegation with Inheritance(ä»¥ç»§æ‰¿å–ä»£å§”æ‰˜) åœºæ™¯ï¼šä½ åœ¨ä¸¤ä¸ªç±»ä¹‹é—´ä½¿ç”¨å§”æ‰˜å…³ç³»ï¼Œå¹¶ç»å¸¸ä¸ºæ•´ä¸ªæŽ¥å£ç¼–å†™å¾ˆå¤šåŠå…¶ç®€å•çš„å§”æ‰˜å‡½æ•° é‡æž„ï¼šè®©å§”æ‰˜ç±»ç»§æ‰¿å—æ‰˜ç±» ###å¤§åž‹é‡æž„ Tease Apart Inheritance(æ¢³ç†å¹¶åˆ†è§£ç»§æ‰¿ä½“ç³») åœºæ™¯ï¼šæŸä¸ªç»§æ‰¿ä½“ç³»åŒæ—¶æ‰¿æ‹…ä¸¤é¡¹è´£ä»» é‡æž„ï¼šå»ºç«‹ä¸¤ä¸ªç»§æ‰¿ä½“ç³»ï¼Œå¹¶é€šè¿‡å§”æ‰˜å…³ç³»è®©å…¶ä¸­ä¸€ä¸ªå¯ä»¥è°ƒç”¨å¦ä¸€ä¸ª â€‹ Convert Procedural Design to Objects(å°†è¿‡ç¨‹åŒ–è®¾è®¡è½¬åŒ–ä¸ºå¯¹è±¡è®¾è®¡) åœºæ™¯ï¼šä½ æ‰‹ä¸­æœ‰ä¸€äº›ä¼ ç»Ÿè¿‡ç¨‹åŒ–é£Žæ ¼çš„ä»£ç  é‡æž„ï¼šå°†æ•°æ®è®°å½•å˜ä¸ºå¯¹è±¡ï¼Œå°†å¤§å—è¡Œä¸ºåˆ†ä¸ºå°å—ï¼Œå¹¶å°†è¡Œä¸ºç§»å…¥ç›¸å…³å¯¹è±¡ä¹‹ä¸­ â€‹ Separate Domain from Presentation(å°†é¢†åŸŸå’Œæ˜¾ç¤ºåˆ†ç¦») æŸäº›GUIç±»ä¸­åŒ…å«äº†é¢†åŸŸé€»è¾‘ å°†é¢†åŸŸé€»è¾‘åˆ†ç¦»å‡ºæ¥ï¼Œä¸ºå®ƒä»¬å»ºç«‹ç‹¬ç«‹çš„é¢†åŸŸç±» â€‹ Extract Hierarchy(æç‚¼ç»§æ‰¿ä½“ç³») åœºæ™¯ï¼šä½ æœ‰æŸä¸ªç±»åšäº†å¤§é‡çš„å·¥ä½œï¼Œå…¶ä¸­ä¸€éƒ¨åˆ†å·¥ä½œæ˜¯ä»¥å¤§é‡çš„æ¡ä»¶è¡¨è¾¾å¼å®Œæˆçš„ é‡æž„ï¼šå»ºç«‹ç»§æ‰¿ä½“ç³»ï¼Œä»¥ä¸€ä¸ªå­ç±»è¡¨ç¤ºä¸€ç§ç‰¹æ®Šæƒ…å†µ]]></content>
      <categories>
        <category>é‡æž„</category>
      </categories>
      <tags>
        <tag>é‡æž„</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activityçš„ç”Ÿå‘½å‘¨æœŸå’Œå¯åŠ¨æ¨¡å¼]]></title>
    <url>%2F2017%2F07%2F13%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activityçš„ç”Ÿå‘½å‘¨æœŸå’Œå¯åŠ¨æ¨¡å¼ç”Ÿå‘½å‘¨æœŸåˆ†æžå…¸åž‹ç”Ÿå‘½å‘¨æœŸåˆ†æž onStartå’ŒonStopæ˜¯ä»ŽActivityæ˜¯å¦å¯è§çš„è¿™ä¸ªè§’åº¦å›žè°ƒçš„ï¼Œè€ŒonResumeå’ŒonPauseæ˜¯ä»ŽActivityæ˜¯å¦ä½äºŽå‰å°è¿™ä¸ªè§’åº¦æ¥å›žè°ƒçš„ã€‚ Activityçš„å¯åŠ¨è¿‡ç¨‹å¾ˆå¤æ‚ï¼Œæ¶‰åŠInstrumentationã€ActivityThreadå’ŒActivityManagerServiceï¼ˆç®€ç§°AMSï¼‰ï¼›ç®€å•ç†è§£ï¼Œå¯åŠ¨Activityçš„è¯·æ±‚ä¼šç”±Instrumentationæ¥å¤„ç†ï¼Œç„¶åŽå®ƒé€šè¿‡Binderå‘AMSå‘è¯·æ±‚ï¼ŒAMSå†…éƒ¨ç»´æŠ¤ä¸€ä¸ªActivityStackå¹¶è´Ÿè´£æ ˆå†…çš„Activityçš„çŠ¶æ€åŒæ­¥ï¼ŒAMSé€šè¿‡ActivityThreadåŽ»åŒæ­¥Activityçš„çŠ¶æ€ä»Žè€Œå®Œæˆç”Ÿå‘½å‘¨æœŸæ–¹æ³•çš„è°ƒç”¨ã€‚ å‡è®¾å½“å‰Activityæ˜¯Aï¼Œæ–°å¯åŠ¨ä¸€ä¸ªActivity Bï¼Œé‚£ä¹ˆAçš„onPauseå…ˆæ‰§è¡Œï¼Œç„¶åŽBçš„onCreateã€onStartã€onResumeï¼Œå†æ˜¯Açš„onStopã€‚ æ‰€ä»¥Androidå®˜æ–¹æ–‡æ¡£ä¸­æœ‰è¯´æ˜Žï¼Œä¸èƒ½åœ¨onPauseä¸­ä½œé‡é‡çº§çš„è€—æ—¶æ“ä½œï¼Œå› ä¸ºonPauseæ‰§è¡Œå®ŒåŽæ–°çš„Activityæ‰èƒ½Resumeã€‚æ³¨ï¼šä¸è¦åœ¨onPauseå’ŒonStopä¸­æ‰§è¡Œè€—æ—¶æ“ä½œï¼Œå°¤å…¶æ˜¯onPauseã€‚ å¼‚å¸¸æƒ…å†µä¸‹çš„ç”Ÿå‘½å‘¨æœŸåˆ†æž èµ„æºç›¸å…³çš„ç³»ç»Ÿé…ç½®æ”¹å˜å¯¼è‡´Activityè¢«æ€æ­»å¹¶é‡æ–°åˆ›å»º é…ç½®æ”¹å˜ï¼ˆæ—‹è½¬ï¼‰onPauseâ€“&gt;onSaveInstanceStateâ€“&gt;onStopâ€“&gt;onDestroyâ€“&gt;é‡å»ºâ€“&gt;onCreateâ€“&gt;onStartâ€“&gt;onRestoreInstanceState æ³¨æ„ï¼šonSaveInstanceStateåœ¨onStopä¹‹å‰ï¼ŒonRestoreInstanceStateåœ¨onStartä¹‹åŽ èµ„æºå†…å­˜ä¸è¶³å¯¼è‡´ä½Žä¼˜å…ˆçº§çš„Activityè¢«æ€æ­» å±å¹•æ—‹è½¬æ—¶å€™Activityä¸æƒ³é‡æ–°åˆ›å»ºï¼Œé…ç½®android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot; Activityçš„å¯åŠ¨æ¨¡å¼ï¼ˆLaunchModeï¼‰ standardï¼šæ ‡å‡†æ¨¡å¼ ä¸Žå¯åŠ¨ä»–çš„Activityè¿è¡Œåœ¨åŒä¸€ä¸ªçš„ä»»åŠ¡æ ˆä¸­ï¼› singleTopï¼šæ ˆé¡¶å¤ç”¨æ¨¡å¼ singleTaskï¼šæ ˆå†…å¤ç”¨æ¨¡å¼ å¤šæ¬¡å¯åŠ¨Activityä¸ä¼šé‡å¤åˆ›å»ºå®žä¾‹ï¼Œå›žè°ƒå…¶onNewIntentï¼Œå¹¶é™„å¸¦ClearTopæ•ˆæžœã€‚ ä»€ä¹ˆæ˜¯ä»»åŠ¡æ ˆï¼Ÿï¼Ÿ ä¸Žå‚æ•°TaskAffinityå…³è”ï¼Œä¹Ÿç§°ä¸ºä»»åŠ¡ç›¸å…³æ€§ï¼Œè¯¥å±žæ€§è¡¨ç¤ºä»»åŠ¡æ ˆçš„åå­—ï¼Œé»˜è®¤å°±æ˜¯packageNameï¼Œä¹Ÿå¯ä»¥å•ç‹¬æŒ‡å®šTaskAffinityçš„å±žæ€§ï¼› æ ¹æ®Activityæ˜¯å¦ä½äºŽæš‚åœçŠ¶æ€ï¼Œåˆå¯ä»¥åˆ†ä¸ºå‰å°ä»»åŠ¡æ ˆå’ŒåŽå°ä»»åŠ¡æ ˆã€‚ 1adb shell dumpsys activiy Activityçš„Flag FLAG_ACTIVITY_NEW_TASKâ€”&gt;â€singleTaskâ€ FLAG_ACTIVITY_SINGLE_TOPâ€”&gt;â€singleTopâ€ FLAG_ACITIVY_CLEAR_TOPâ€”&gt;ä¸€èˆ¬é…åˆâ€œsingleTaskâ€ä½¿ç”¨ï¼Œå›žè°ƒonNewIntent FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS ç§»é™¤åŽ†å²Activityåˆ—è¡¨ IntentFilterçš„åŒ¹é…è§„åˆ™ actionçš„åŒ¹é…è§„åˆ™â€”&gt;Intentä¸­å¿…é¡»æœ‰ä¸€ä¸ªactionèƒ½å¤Ÿå’ŒIntentFilterä¸­çš„æŸä¸ªactionç›¸åŒ categotyçš„åŒ¹é…è§„åˆ™â€”&gt;Intentä¸­å¯ä»¥æ²¡æœ‰categoryï¼Œä½†æ˜¯å¦‚æžœæœ‰categotyï¼Œåˆ™æ¯ä¸ªcategoryéƒ½éœ€è¦å’ŒIntentFilterä¸­çš„ç›¸åŒã€‚ åœ¨startActiviyæ—¶ï¼Œç³»ç»Ÿé»˜è®¤ä¼šä¸ºIntentåŠ ä¸Šandroid.intent.categoty.DEFAULTè¿™ä¸ªcategoryï¼Œæ‰€ä»¥IntentFilterä¸­å¿…é¡»æœ‰ä¸Šè¿°categoryæ‰èƒ½æŽ¥å—éšå¼è°ƒç”¨ï¼› dataçš„åŒ¹é…è§„åˆ™: mimeType + URI URIé»˜è®¤ä¸ºcontentå’Œfileï¼›å¦‚æžœè¦ä¸ºIntentå®Œæ•´æŒ‡å®šdataï¼Œå¿…é¡»è°ƒç”¨setDataAndTypeæ–¹æ³•ã€‚ åˆ¤æ–­æ˜¯å¦æœ‰Activityé…ç½®éšå¼Intentâ€”&gt;å¯ä»¥ç”¨PackageManagerçš„resolveActivityæ–¹æ³•æˆ–è€…Intentçš„resolveActivityæ–¹æ³•]]></content>
      <categories>
        <category>Androidå¼€å‘è‰ºæœ¯æŽ¢ç´¢</category>
      </categories>
      <tags>
        <tag>Activityçš„ç”Ÿå‘½å‘¨æœŸå’Œå¯åŠ¨æ¨¡å¼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2017%2F05%2F16%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Generate static files1$ hexo generate More info: Generating Run server1$ hexo server More info: Server Deploy to remote sites1$ hexo deploy BenefitsWith this feature, now you can put all your configurations into one place (source/_data/next.yml), you donâ€™t need to touch next/_config.yml. If there are any new options in new releases, you just need to copy those options from next/_config.yml, paste into _data/next.yml and set their values to whatever you want. How to use this feature Please ensure you are using Hexo 3 (or above) Create an file named next.yml in siteâ€™s source/_data directory (create _data directory if it did not exist) Copy NexT theme options both in siteâ€™s _config.yml and themeâ€™s _config.yml into next.yml. Use --config source/_data/next.yml parameter to start server, generate or deploy.For example: hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml. More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
