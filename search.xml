<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重构 改善既有的代码设计]]></title>
    <url>%2F2017%2F07%2F13%2Frefactor%2F</url>
    <content type="text"><![CDATA[《重构改善既有代码设计》 重构 Extract Method (提炼函数) Move Method (搬移函数） Self Encapsulate Field (自封装字段) Replace Type Code With State/Strategy (以状态／策略模式取代状态码) Replace Condition with Polymorphism (以多态取代条件表达式) 重构原则 何为重构 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 为何重构 改进软件设计、是软件更容易理解、帮助找到bug、提高编程速度。 何时重构 添加功能时重构、修补错误时重构、复审代码时重构 重构与间接层 间接层价值： 允许逻辑共享、分开解释意图和实现、隔离变化、封装条件逻辑（多态） 重构的难题 数据库迁移、修改已公布的接口、难以重构的复杂设计 ​ 代码的坏味道 Duplicated code（重复代码） Long Method（过长函数） Large Class（过大的类） Long Parameter List (过长参数列） Divergent Change （发散式变化）一种类受多种变化的影响，类过大，需Extract class Shotgun Surgery（散弹式修改）一种变化引起多个类修改，需Move Method移到同一个类 Feature Envy（依恋情结）总是一起变化的东西放在一块 Data Clumps （数据泥团）多个类中重复的字段、方法。需Extract class到一个独立对象 Primitive Obsesstion （基本类型偏执）必要时用对象代替基本数据 Switch Statement（switch语句）需要抽出方法，用子类或state/strategy模式替代 Parallel Inheritance Hierarchies （平行继承体系）散弹修改的一种，需用引用代替继承 Lazy Class（冗余类） Speculative Generality（夸夸其谈未来性）多余的抽象、委托、参数应该去除 Temporary Field (迷惑的暂时字段) 可以的话提炼到一个独立的类中 Message ChainsI（过度耦合的消息链） Middle Man（中间人）过度使用委托 Inappropriate Intimacy (狎昵关系) 拆散过渡亲密的类，Move Method 或 Move Field到合适的地方；提炼共性到新类；Replace Inheritance with Delegation Alternative Classes With Different Interfaces (异曲同工的类) 重新命名或提取超类 Incomplete Library Class (不完美的类库) Data Class（存粹的数据类）注意封装和访问权限 Refused Bequest（被拒绝的馈赠）子类服用的超类的行为（实现），却不愿支持超类的接口，需重构（这里思考Basesso类的3个abstract方法有这个问题，不愿支持超类的接口） Comments（过多注释） ​ 重新组织函数 Extract Method（提炼函数） 将一段代码放进一个独立的函数中，并让函数名称解释该函数的用途。 如果源函数中局部变量比较多，先用Replace Temp With Query减少临时变量，源函数中读取的临时变量和参数，提炼到目标函数作为参数，并考虑是否需要返回值。 Inline Method （内联函数） 一个函数和本体一样清楚易懂，在函数调用点插入函数体，然后移除该函数。 Inline Temp（内联临时变量） 将临时变量替换为对它赋值的表达式或函数。 Replace Temp With Query（以查询取代临时变量） 将临时变量的计算代码提炼到一个独立的函数中，这样临时变量的引用点就可以替换为新函数的调用。 以查询代替临时变量可以减少临时变量，是提炼函数的重要步骤。 Introduce Explaining Variable (引入解释性变量) 将该复杂表达式的结果放进一个临时变量，以此变量名称来解释表达式的作用。 或者Extract Method来处理 Split Temporary Variable (分解临时变量) 某个临时变量，既不是循环变量也不是收集变量；针对每次赋值，创造一个独立的、有合理名称的临时变量来分解重复赋值。 Remove Assignments to Parameters(移除对参数的赋值） 代码对参数进行赋值，以一个临时变量取代该参数的位置 Java是按值传递的 1234void aMethod(Object foo) &#123; foo.modifySomeWay(); //that's OK，将改变foo引用的对象 foo = anothnerObject; //trouble will follow, 函数返回后并不会改变foo。&#125; Replace Method with Method Object(以函数对象取代函数） 有一个大型函数其中存在大量的局部变量，很难Extract Method来分解这个函数，那么使用函数对象。 将原函数替代成函数对象，该函数对象的构造函数接受源对象和原函数的参数作为参数； 针对原函数每个临时变量和每个参数，在新的函数对象中建立一个对应的字段保存； 然后就可以在函数对象中Extract Method来分解原函数； Substitute Algorithm (替换算法) 将函数本体替换为新的算法，建议先考虑分解函数再做替换。 ​ 在对象之间搬移特性 Move Method (搬移函数) 函数与其他类耦合过多，考虑使用委托或搬移到合适的类中。 搬移过程中，当目标类需要源类特性时，1）将这个特性也搬移到目标类 2）建立使用目标类到源类的使用 3）将源对象或该特性变量作为参数传递给目标类 Move Field (搬移字段) 某个字段被所驻类之外的另一个类更多地用到，考虑搬移这个字段到目标类。 Self Encapsulate（使用自我封装）在字段搬移后，就只需要修改访问函数（set／get），而无需修改引用点。 Extract Class（提炼类） 建立一个新类，将相关字段和函数从旧类搬移到新类。 可能需要双向连接，尽量避免建议新类到旧类的连接；决定是否公开新类； Inline Class（内联化类） 将这个类的所有特性搬移到另一个类，然后移除这个类； Hide Delegate (隐藏“委托关系“) 客户类通过委托类来调用另一个对象，在服务类上建立客户需要的所有委托函数，用于隐藏委托关系。 Remove Middle Man（移除中间人） 某个类做了过多的委托动作，那么可以直接让客户类调用受托类； 服务类中建立一个函数，直接返回受托类，客户类直接调用该类； 隐藏委托关系与移除中间人互为逆向的行为。 Introduce foreign Method (引入外加函数) 场景：你需要为提供服务的类增加一个函数，但是却无法修改这个类 应对：在客户类中建立一个函数，并传入一个服务类的实例参数； 如果需要外加多个函数，考虑使用引入本地扩展。 Introduce Local Extension (引入本地扩展) 场景：你需要为服务类提供一些额外的函数，但是你无法修改这个类 应对：建立一个新类，包含这些额外的函数，让这个扩展品称为源类的字类（subclass）或包装类（wrapper）； ​ 重新组织数据 Self Encapsulate Field (自封装字段) 直接访问字段，产生耦合关系；为这些字段建立get/set函数，并以这些函数访问字段。 直接访问字段还是通过get/set函数访问哪个好没有定论。 Replace Data Value with Object(以对象取代数据值) 如果有一个数据项需要与其他数据或者行为一起使用才有意义，那么将数据变成对象。 数据值 —&gt; 值对象,值对象应该是不可修改的 区别：如果数据可修改，使用引用对象，Change value to Reference Change Value into Reference(将值对象改为引用对象) 从一个类衍生出多个相等的实例，希望它们是同一个对象；将值对象变成引用对象； 多个Order共享同一个Customer对象 引用对象都代表真实世界中的一个实物，可以用==直接检查两个对象是否相等；如“客户”、“账户”等.. 值对象不可变，完全由其数据值来定义，有多个副本存在，需要复写equals()判断是否相等，如“日期”、“钱”.. Change Reference to Value(将引用对象改为值对象) 有一个引用对象，很小且不可变，将它改为值对象。 值对象是“不可变”（immutable）的，表示对象自身是不可变的。判断相等用equals()方法 Replace Array with Object(以对象代替组数) 有一个数组，其中的元素各自代表不同的东西 以对象代替数组，对于数组中的每一个元素，以一个字段来表示 Duplicate Observed Data(复制“被监视的数据”) 有一些领域（Model）数据置身于GUI控件中，而领域函数需要访问需要访问这数据； 将该数据复制到领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据； Change Unidirectional Association to Bidirectional(将单向关联改为双向关联) 场景：两个类都需要使用对方的特性，但只有一条单向关联 实现：添加一个反向指针，并使修改函数能够同事更新两条连接 决定哪个类是控制端；控制端（提供控制函数，维护反向指针），修改函数调用控制函数；被控制端（提供一个辅助函数提供反向指针），修改函数调用控制端的控制函数。 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联) 场景：两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性； 去除不必要的关联 Replace Magic Number with Symbolic Constant(以字面常量代替魔法数) 创建一个常量，根据其意义命名，替换上述魔法数 Encapsulate Field(封装字段) 将public字段声明为private，并提供相应的get/set访问函数 Encapsulate Collection(封装集合) 场景：有一个函数返回一个集合 优化：让这个函数返回该集合的一个只读副本，并提供添加／移除该集合元素的方法 Replace Record with Data Class(以数据类取代记录) 为记录结构型数据创建一个数据对象 Replace Type Code with Class(以类取代类型码) 场景：类中又一个数值类型码，但它并不影响类的行为 以一个新的类替换该数值类型码 Replace Type Code with Subclasses(以子类取代类型码) 场景：有一个不可变的类型码，它会影响类的行为 重构：以字类取代这个类型码，借助多态实现变化行为,将和特定字类相关的字段／函数push down到字类 Replace Type Code with State/Stratege(以状态／策略取代类型码) 场景：如果一个类型码的值在对象生命周期发生变化或者其他原因是宿主类不能被继承； 重构：以状态对象或策略模式取代类型码 Replace Subclass with Fields(以字段代替子类) 场景：各个子类的唯一差别只在“返回常量数据”的函数身上 重构：修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类 ​ 简化条件表达式 Decompose Conditional(简化条件表达式) 场景：有一个复杂的条件if-then-else语句 从if、then、else段落中分别提炼出独立的函数，函数名可以直观反映出函数的用途 Consolidate Conditional Expression(合并条件表达式) 场景：有一系列的条件测试，均得到相同的结果 重构：将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立的函数 使用||、&amp;&amp;、？：合并测试条件 Consolidate Duplicate Conditional Fragments(合并重复的条件片段) 场景：在条件表达式的每个分支上都有相同的一段代码 重构：将这段代码搬移到条件表达式外，并提炼出独立函数 Remove Control Flag(移除控制标记) 在一系列的布尔表达式中，某个变量带有控制标记（control flag）的作用 以break或者return语句取代这个控制标记 Replace Nested Conditional with Guard Clauses(以位语句取代嵌套的条件表达式) 场景：函数中条件逻辑使人迷惑 重构：使用卫语句表现所有特殊情况，立即返回结果；最后处理正常逻辑； 使用卫语句检查特殊条件，立刻返回或抛出异常； 可以先将条件表达式反转实现卫语句（P253）； Replace Conditional with Polymorphism(以多态取代条件表达式) 场景：有一个条件表达式，根据对象类型的不同选择不同的行为 重构：将这个条件表达式的每个分支放进一个子类的复写函数中，然后将原始的函数声明为抽象 在使用Replace Coditional with Polymorphism之前,必须建立一个继承结构：优先使用Repalce Type Code with Subclass，但是如果需要在对象创建后修改类型码，就不能用继承手法，那么使用 Replace Type Code with State/Stratege; Introduce Null Object(引入Null对象) 场景：你需要再三检查某个对象是否为null 重构：建立Null对象，替换null值的判断 空对象继承源对象，或者实现Null Interface；空对象一定是一个常量，它的任何成分都不会变化； Introduce Assertion(引入断言) 某一段代码需要对程序状态作出假设，以断言明确表示这种假设 简化函数调用 Rename Method(函数改名) 给每一个函数取一个可以揭示函数用途的、直观的名字 Add Parameter(添加参数) 为此函数添加一个对象参数，让该对象参数带进函数所需信息 Remove Parameter(移除参数) 移除多余的参数 Separate Query from Modifier(将查询函数和修改函数分离) 场景：某个函数既返回对象状态值，有修改对象状态 重构：建立两个独立的函数，一个负责查询，另一个负责修改 注意并发编程中，可保留查询-修改函数，调用各自独立的查询函数和修改函数，并声明为synchronised Parameterize Method(令函数携带参数) 若干函数做了类似的工作，但因少数几个值致使行为略有不同 建立单一函数，以参数表达那些不同的值 Replace Parameter with Explicit Method(以明确函数取代参数) 有一个函数安全取决于参数值而采取不同的行为 针对该参数的每一个可能值，建立一个独立函数；相反与Parameterize Method Preserve Whole Object(保持完整对象) 场景：你从对象中取出一些值，将它们作为参数传递给函数 重构：改为传递整个对象 Replace Parameter with Methods(以函数取代参数) 场景：对象调用一个函数，并将所得的结果作为参数，传递给另一个函数 重构：让参数接收这去处该项参数，并直接调用前一个函数 如果函数可以通过其他途径获取参数值，那么就应该去除该多余的参数 Introduce Parameter Object(引入参数对象) 场景：某些参数总是很自然的同时出现 重构：以一个对象取代这些参数，比如Range模式，范围对象取代(start,end) Remove Setting Method(移除设值函数) 场景：类中的某个字段应该在对象创建的时候被设值，然后不再改变 重构：去除该字段所有设值函数，同时声明该字段为final Hide Method(隐藏函数) 有一个函数从类没有被其他任何类用到过 将这个函数修改为private Replace Constructor with Factory Method(以工厂函数取代构造函数) 场景：在派生子类的过程中，需要根据类型码，创建相应的对象 重构：使用工厂函数取代构造函数 Encapsulate Downcast(封装向下转型) 场景：某个函数返回的对象需要由函数的调用者执行向下转型 重构：将向下转型的动作移到函数中 123Object lastReading() &#123; return reading.lastElement();&#125; 改为： 123Reading lastReading() &#123; return (Reading)reading.lastElement();&#125; Replace Error Code with Exception(以异常取代错误码) 场景：某个函数返回一个特定的代码，表示某种错误的情况 重构：改用异常 12345678int withdraw(int amount) &#123; if(amount &gt; _balance) &#123; return -1; &#125; else &#123; _balance -= amount; return 0; &#125;&#125; 改为： 1234void withdraw(int amount) throws BalanceException &#123; if(amount &gt; _balance) throw new BalanceExctption(); _balance -= amount;&#125; 决定函数应该抛出受控异常（checked）还是非受控异常（unchecked） 如果函数的调用者有责任在调用前检查必要状态，就抛出unchecked异常 抛出checked异常可以新建一个异常类继承Exception，或者使用现有的checked异常类 Replace Exception with Test(以测试取代异常) 场景：面对一个调用者可以预先检查的条件，你抛出了一个异常 修改调用者，使它在函数调用之前预先检查 1234567double getValueForPeriod(int periodNumber) &#123; try &#123; return _values[periodNumber]; &#125; catch(ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125; 改为： 1234double getValueForPeriod(int periodNumber) &#123; if ( periodNumber &gt;= _values.length ) return 0; return _values[periodNumber];&#125; 异常应该只被用于那些产生意料之外的错误行为，而不应该成为条件检查的工具；不要用try-catch语句作为条件判断语句； 概括处理关系 Pull Up Field(字段上移) 如果两个子类拥有相同的字段，将该子段移到超类 Pull Up Method(函数上移) 场景：有些函数在子类中产生完全相同的结果 重构：将该函数移至超类 Pull Up Method过程中最麻烦的一点就是：被提升的函数可能会引用只出现在子类而不出现在超类的特性。 如果被引用的是一个函数，你可以将该函数一同提升到超类；或者在超类中建立一个抽象函数；或者建立一个委托函数 如果被引用的是子类的字段，你可以将该字段也提升到超类；或者先在子类中自封装字段，然后在超类中把取值函数声明为抽象 Pull Up Constructor Body(构造函数本体上移) 在子类中各拥有一些构造函数，它们的本体几乎一致 在超类中新建一个构造函数，并在子类构造函数中调用它 Pull Down Method(函数下移) 超类中的某个函数只与部分（而非全部）子类有关，将这个函数移到相关的那些子类中去 Pull Down Field(字段下移) 超类中的某个字段只被部分（而非全部）子类所用到，将这个字段移到需要它的那个子类中去 Extract SubClass(提炼子类) 场景：类中的某些特性只被某些（而非全部）实例用到 重构：新建一个子类，将上述一部分特性移到子类中 Extract SuperClass(提炼超类) 场景：两个类具有相似的特性 重构：为这两个类建立一个超类，将这些相同的特性搬移到超类 Extract Interface(提炼接口) 场景：若干客户使用类接口中的同一子集，或者两个类的接口有相同的部分 重构：将相同的子集提炼到一个独立的接口中 Collapse Hierarchy(折叠继承体系) 超类和子类之间无太大区别，将它们合为一体 From Template Method(塑造模版函数) 场景：你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作细节上有所不同 重构：将这些细节操作分别放进独立的函数中，并保持它们都有相同的签名，于是原函数也变得相同了；然后将原函数上移到超类 Replace Inheritance with Delegation(以委托取代继承) 场景：某些子类只使用超类接口中的一部分，或者根本不需要继承而来的数据 重构：在子类中新建一个子段用以保存超类；调整子类函数令它委托超类；然后去掉继承关系 Replace Delegation with Inheritance(以继承取代委托) 场景：你在两个类之间使用委托关系，并经常为整个接口编写很多及其简单的委托函数 重构：让委托类继承受托类 大型重构 Tease Apart Inheritance(梳理并分解继承体系) 场景：某个继承体系同时承担两项责任 重构：建立两个继承体系，并通过委托关系让其中一个可以调用另一个 Convert Procedural Design to Objects(将过程化设计转化为对象设计) 场景：你手中有一些传统过程化风格的代码 重构：将数据记录变为对象，将大块行为分为小块，并将行为移入相关对象之中 Separate Domain from Presentation(将领域和显示分离) 某些GUI类中包含了领域逻辑 将领域逻辑分离出来，为它们建立独立的领域类 Extract Hierarchy(提炼继承体系) 场景：你有某个类做了大量的工作，其中一部分工作是以大量的条件表达式完成的 重构：建立继承体系，以一个子类表示一种特殊情况]]></content>
      <categories>
        <category>重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>refactor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2017%2F05%2F16%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Generate static files1$ hexo generate More info: Generating Run server1$ hexo server More info: Server Deploy to remote sites1$ hexo deploy BenefitsWith this feature, now you can put all your configurations into one place (source/_data/next.yml), you don’t need to touch next/_config.yml. If there are any new options in new releases, you just need to copy those options from next/_config.yml, paste into _data/next.yml and set their values to whatever you want. How to use this feature Please ensure you are using Hexo 3 (or above) Create an file named next.yml in site’s source/_data directory (create _data directory if it did not exist) Copy NexT theme options both in site’s _config.yml and theme’s _config.yml into next.yml. Use --config source/_data/next.yml parameter to start server, generate or deploy.For example: hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml. More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
