<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RxJava 源码分析1]]></title>
    <url>%2F2018%2F03%2F08%2FRxJava%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901%2F</url>
    <content type="text"><![CDATA[基于 RxJava 2.1.2 给定下面的一段代码，从源码的角度分析 RxJava 的实现原理： 12345678910111213141516171819202122232425262728293031323334353637ObservableOnSubscribe&lt;Integer&gt; oos = new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(max); &#125; e.onComplete(); &#125;&#125;;Observer&lt;Integer&gt; o = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;;Observable.create(oos) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.computation()) .subscribe(o); 分析源码之前，我们先定义一下名词，RxJava 是基于观察者模式的，这里将被观察者叫做主题（Source），观察者叫做观察者（Observer）。 上面的代码首先创建了一个主题对象，然后又创建了一个观察者对象，最后将两者关联起来，并且最重要的一点，指定了主题对象和观察者对象执行的线程。 Observable.create(oos)首先分析这行代码做了什么事情： 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ObjectHelper 只是用来做非空判断，这里就不用管它了。看看 RxJavaPlugins 做了什么： 123456789101112131415/** * Calls the associated hook function. * @param &lt;T&gt; the value type * @param source the hook's input value * @return the value returned by the hook */@SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;)@NonNullpublic static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 注释上都说了，这是一个钩子函数，也就是说如果 onObservableAssembly 的值不为空，那么就调用这个钩子函数，onObservableAssembly 是一个静态变量，需要我们主动的去设置才会赋值，这里当做空来考虑，如果 onObservableAssembly 为空的话，也就是说这个方法啥都没做，直接返回 source 参数，也就是上面的 ObservableCreate 对象。 总结一下，Observable.create(oos) 只是创建了一个 ObservableCreate 对象。这个方法就暂时先分析到这里，至于这个对象内部有什么东西，我们后面会说到。 observeOn(AndroidSchedulers.mainThread())既然之前的 create 方法创建了一个 ObservableCreate 对象并返回，也就是说 observeOn(Schedulers.computation()) 这个方法是调用的 ObservableCreate 这个对象上的方法。 1public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; ObservableCreate 是继承至 Observable 的。 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; Observable 的 observeOn 是 final 的，所以走的父类的方法。继续跟踪 observeOn 调用的同名方法： 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; ObjectHelper 跳过。这里又是一个 onAssembly 方法的调用，我很好奇这个单词是什么意思。点进去看一下： 1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 同样是一个钩子方法，现在也是有经验的人呢，再看到这个方法，就直接跳过，只关心它传递的参数和返回值就行了。它的返回值默认就是传递进来的参数。 所以，observeOn 方法就是创建并返回了一个 ObservableObserveOn 对象（大神教你起类名系列二），这里预警一下，之后像这样类似的类名差不多还有3个。 subscribeOn(Schedulers.computation())由于 observeOn 创建并返回了一个 ObservableObserveOn 对象，所以这里调用的是 ObservableObserveOn 对象上的方法。 1public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; 也是继承至 Observable 。 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 不出意料，也是 final 的，创建了一个 ObservableSubscribeOn 对象（大神教你起类名系列三）并返回。 subscribe(o)前面 subscribeOn 创建了一个 ObservableSubscribeOn 对象并返回，所以这里调用的是 ObservableSubscribeOn 这个对象上面的方法。 1public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; 继承至 Observable 类。 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 这个方法也是 final 的，所以是调用的这个方法。 public final void subscribe(Observer&lt;? super T&gt; observer) { … } 这个方法是我们需要分析的重点，看看内部具体的代码吧先： 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 这里忽略 ObjectHelper 和异常处理的代码只有两行代码是关键。 先看 observer = RxJavaPlugins.onSubscribe(this, observer); 1234567public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) &#123; BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe; if (f != null) &#123; return apply(f, source, observer); &#125; return observer;&#125; 没想到啊没想到，你这浓眉大眼的家伙也是一个钩子方法。所以这行代码相当于 obsever = observer; 接着看，subscribeActual(observer); 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 这是一个抽象方法，没啥好分析的。 接下来我们要进入正题了，根据我们编写的代码，是 ObservableSubscribeOn 这个对象调用了 subscribe 方法，所以我们看看这个类的 subscribeActual 方法。 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 这里需要注意的是 s 这个参数，后面会有很多地方看到这个参数，一定要搞清楚这个参数是谁传递过来的。比如说： 12A.subscribe(B)那么，参数 s 就是 B。 在我们的代码中是 ObservableSubscribeOn.subscribe(o); 理解了这一点，我们详细分析代码里面的内容：首先创建了一个 SubscribeOnObserver （大神教你起类名系列四）。然后调用了我们创建的对象 o 的 onSubscribe 方法： 1234@Overridepublic void onSubscribe(Disposable d) &#123;&#125; 我们的 onSubscribe 方法里面啥都没做。不过一般来说，你应该调用一下 onStart 方法。 接下来是调用 parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); setDisposable 的方法不影响流程分析，这里就先跳过了，有兴趣的可以点进去看一下。然后就是 scheduler 变量，这个变量就是我们使用 subscribeOn 传递的参数： 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; 这个 scheduler 就是 Schedulers.computation()。然后调用了它的 scheduleDirect 方法： 123public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125; 1234567891011public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); w.schedule(task, delay, unit); return task;&#125; 这两个方法是父类的，Schedulers.computation() 返回的是一个 ComputationScheduler 对象，这里找具体的实现类由于调用链比较长，就不给出了，自己点着点着就能找到了。看看 ComputationScheduler 有没有复写这两个方法： 123456@NonNull@Overridepublic Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) &#123; PoolWorker w = pool.get().getEventLoop(); return w.scheduleDirect(run, delay, unit);&#125; 它覆盖了父类的第2个 scheduleDirect 方法。这里就不深入分析里面的池了。看 w.scheduleDirect(run, delay, unit);： 12345678910111213141516public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 熟悉的线程池使用代码。希望看到这里你还没有忘记我们要分析的是什么。简单的归纳一下，其实就是向我们创建的 scheduler 里面提交了一个 runnable。最终这个 Runnable 肯定会执行，那么看看这个 Runnable 里面有什么代码： 1parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); 123456789101112final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; run 方法里面就只有一句代码，但是我们需要搞清楚这里的 source 和 parent 分别是哪个对象。 parent 可以直接看到是 SubscribeOnObserver 对象。 source 是使用的外部类的变量。 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; 这里调用了 super 方法，所以构造函数里传递的变量就是 source。 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 这里是我们之前分析过的创建 ObservableSubscribeOn 的代码，这里的 this 指的是 observeOn 创建的 ObservableObserveOn 对象。希望看到这里你没有搞晕，如果你是使用手机看的，并且看懂了，我是真的佩服。 也就是说，run 里面的代码就是调用了 ObservableObserveOn 对象的 subscribe 方法。之前我们分析过了，subscribe 方法实际上没有做什么，只是调用了 subscribeActual 方法，所以我们进入这个类内部看看： 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 我们在 observeOn 传递的 scheduler 不是 TrampolineScheduler 类型的，所以只需要看 else 的代码。这里是先创建了一个工作线程（由于我们使用的是 AndroidScheduler，所以这里是指的主线程），然后调用了 source 的 subscribe 方法。需要注意的是这里最后创建了一个 ObserveOnObserver 对象（大神教你起类名系列五）。 先看看 createWork，在 HandlerScheduler 中： 1234@Overridepublic Worker createWorker() &#123; return new HandlerWorker(handler);&#125; 返回了一个 HandlerWorker 对象。 再看 source.subscribe()，首先这里的 source 指的是 create 方法创建的 ObservableCreate 对象，调用 subscribe 传递的是 ObserveOnObserver。看看这个对象的 subscribeActual 方法： 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 这里的参数 observer 是 ObserveOnObserver，source 是我们代码中创建的 oos 对象。 首先创建了一个 CreateEmitter 对象。 接着看 ObserveOnObserver 的 onSubscribe 方法做了啥： 12345678910111213141516171819202122232425262728293031@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.validate(this.s, s)) &#123; this.s = s; if (s instanceof QueueDisposable) &#123; @SuppressWarnings("unchecked") QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) &#123; sourceMode = m; queue = qd; done = true; actual.onSubscribe(this); schedule(); return; &#125; if (m == QueueDisposable.ASYNC) &#123; sourceMode = m; queue = qd; actual.onSubscribe(this); return; &#125; &#125; queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); actual.onSubscribe(this); &#125;&#125; 这里代码比较长，只分析重要的代码，就是 actual.onSubscribe 这句。actual 是构造函数中赋值的，所以我们回到创建 ObserveOnObserver 的地方，actual 指的是 SubscribeOnObserver 对象。所以它调用了 SubscribeOnObserver 的 onSubscribe 方法。接下来分析一下它的 onSubscribe 方法做了什么，这里不看也不会影响流程。 123456789SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; this.s = new AtomicReference&lt;Disposable&gt;();&#125;@Overridepublic void onSubscribe(Disposable s) &#123; DisposableHelper.setOnce(this.s, s);&#125; 这个方法调用了 setOnce 方法： 1234567891011public static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; ObjectHelper.requireNonNull(d, "d is null"); if (!field.compareAndSet(null, d)) &#123; d.dispose(); if (field.get() != DISPOSED) &#123; reportDisposableSet(); &#125; return false; &#125; return true;&#125; 这里涉及到了乐观锁等玩意，简单来说就是先判断 field 的值是否为空，如果为空则设置为 d，不为空则将 d dispose。然后判断 field 的值，由于 field 的值只能设定一次非 DISPOSED 值，所以如果不为 DISPOSED，说明已经被设置过了，再报出异常，如果为 DISPOSED 是可以再次设置的。按照正常的流程，这里只是将 field 的值设置为 d，然后返回true。这个方法可以先不用管。 回到主线流程上，source.subscribe(parent); 这是最重要的一句代码。source 是在构造函数赋值的，看看构造方法： 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 也就是说这里的 source 是我们代码中创建的 oos 对象。parent 是新创建的 CreateEmitter 对象。看看我们 oos 的 subscribe 方法： 123456789@Overridepublic void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e("aprz", Thread.currentThread().getName()); final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(i); &#125; e.onComplete();&#125; 这里就是事件开始的起点。所有的事件都由 ObservableEmitter 开始发送，看看它的代码，它是一个接口，在我们的例子中，它的实现类是 CreateEmitter，所有我们分析这个类的 onNext 方法： 12345678910@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; isDisposed 方法返回 false 才会去调用 observer 的 onNext 方法，这个 observer 是谁呢? 看到这里我们就要从后往前推一遍之前的代码了，不管你绝不绝望，反正我是很绝望。这的 observer 是 ObserveOnObserver 对象。 接下来我们就进入 ObserveOnObserver 里面，看看它接受事件之后做了什么，上面的参数 e 就是： 1234567891011@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125; 调用了 schedule 方法： 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; 向 work 中提交了一个 Runnable，这里传递的是 this。说明它自己肯定实现了这个接口，我们看看它的 run 方法做了啥： 12345678@Overridepublic void run() &#123; if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125; 这里一般是走 drainNormal 吧，我猜的，我们分析这个方法吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; 代码很长，具体做了啥我们暂时不用关心，只需要注意到 a.onNexe(v) 这行代码，这个 a 是 actual 变量，actual 又是 SubscribeOnObserver 对象，我们看看它的 onNext 方法： 1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; 很简单，这里的 actual 就是我们创建的 o 了，所以最终调用到了我们的代码里面。 好了，到这里一个完整的流程就整理出来了，但是还有一个问题没有解决，就是线程切换是发生在哪里。因为为了不影响整体流程的分析，所以上面并没有去分析线程切换的东西，下面开始分析。 直接从 subscribeOn 开始，看 ObservableSubscribeOn 的代码 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 从这里开始就进行了线程的切换，根据上面的分析我们知道这里是将 SubscribeTask 作为一个 Runnable 对象给提交进了我们指定的 scheduler （subscribeOn 传递的）中。所以后面的流程都是在 scheduler 所在的线程在运行。 再看 observeOn，看 ObservableObserveOn 的代码。 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 这里的线程切换是发生在 ObserveOnObserver 这个对象的里面。 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; schedule 的流程，我们上面分析过，worker.schedule(this) 这行代码就发生了线程切换，是将 this 作为 Runnable 对象提交到了我们指定的（observerOn 传递的）scheduler 中。具体分析，由于之前的流程是在别的线程中，所以想要进行线程切换，最先想到的肯定是 Handler。由于我们传递的是 AndroidSchedulers.mainThread()，所以我们就分析这个吧。 AndroidSchedulers.mainThread() 的实现是 HandlerScheduler。看看它的 schedule 方法： 1234567891011121314151617181920212223242526@Overridepublic Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; if (run == null) throw new NullPointerException("run == null"); if (unit == null) throw new NullPointerException("unit == null"); if (disposed) &#123; return Disposables.disposed(); &#125; run = RxJavaPlugins.onSchedule(run); ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker's runnables. handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) &#123; handler.removeCallbacks(scheduled); return Disposables.disposed(); &#125; return scheduled;&#125; post 了一个 msg，这样就完成了线程的切换。 下面上一张图，有助于理解和记忆： 只需要理解，每次 observerOn 和 subscribeOn 的时候，内部都会创建一个新的 observable 和 observer。 新创建的 observable 会引用前面的 observable，就是代码中我们分析的 source 变量。 新创建的 observer 会引用前面的 observer，就是代码中我们分析的 actual 变量。 最后我们 subscribe 的时候，是调用的最后创建的 observable 的方法。而每个 observable 内部又调用了 source 的 subscribe 方法，这样就形成了一层一层往前传递的调用链。当调用到最前面的一个 observable 的时候，就是我们自己创建的 observable，在这里我们需要手动触发该与该 observable 对应的 observer 对象的 onNext 方法。而 observer 的 onNext 方法的内部又调用了 actual 的 onNext 方法，这样就形成了一层一层往后传递的调用链。 虽然在我们的例子中，CreateEmitter 并不是一个 observer ，但是它也有 onNext 等方法，可以把它看做一个 observer。 如此，RxJava 的一个流程就理清楚了。这货的流程和 OkHttp 怎么有点像，只是稍微有点不一样。 2018年01月08日20:49:03 补充一下关于背压的知识：在异步订阅的时候，使用 Observable，默认的缓冲大小是 128，超过 这个数量之后会 resize，也就是说会缓冲所有的事件，这样就会导致内存占用一直增加。]]></content>
      <categories>
        <category>Rxjava</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构 改善既有的代码设计]]></title>
    <url>%2F2017%2F07%2F13%2Frefactor%2F</url>
    <content type="text"><![CDATA[《重构改善既有代码设计》 重构 Extract Method (提炼函数) Move Method (搬移函数） Self Encapsulate Field (自封装字段) Replace Type Code With State/Strategy (以状态／策略模式取代状态码) Replace Condition with Polymorphism (以多态取代条件表达式) 重构原则 何为重构 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 为何重构 改进软件设计、是软件更容易理解、帮助找到bug、提高编程速度。 何时重构 添加功能时重构、修补错误时重构、复审代码时重构 重构与间接层 间接层价值： 允许逻辑共享、分开解释意图和实现、隔离变化、封装条件逻辑（多态） 重构的难题 数据库迁移、修改已公布的接口、难以重构的复杂设计 ​ 代码的坏味道 Duplicated code（重复代码） Long Method（过长函数） Large Class（过大的类） Long Parameter List (过长参数列） Divergent Change （发散式变化）一种类受多种变化的影响，类过大，需Extract class Shotgun Surgery（散弹式修改）一种变化引起多个类修改，需Move Method移到同一个类 Feature Envy（依恋情结）总是一起变化的东西放在一块 Data Clumps （数据泥团）多个类中重复的字段、方法。需Extract class到一个独立对象 Primitive Obsesstion （基本类型偏执）必要时用对象代替基本数据 Switch Statement（switch语句）需要抽出方法，用子类或state/strategy模式替代 Parallel Inheritance Hierarchies （平行继承体系）散弹修改的一种，需用引用代替继承 Lazy Class（冗余类） Speculative Generality（夸夸其谈未来性）多余的抽象、委托、参数应该去除 Temporary Field (迷惑的暂时字段) 可以的话提炼到一个独立的类中 Message ChainsI（过度耦合的消息链） Middle Man（中间人）过度使用委托 Inappropriate Intimacy (狎昵关系) 拆散过渡亲密的类，Move Method 或 Move Field到合适的地方；提炼共性到新类；Replace Inheritance with Delegation Alternative Classes With Different Interfaces (异曲同工的类) 重新命名或提取超类 Incomplete Library Class (不完美的类库) Data Class（存粹的数据类）注意封装和访问权限 Refused Bequest（被拒绝的馈赠）子类服用的超类的行为（实现），却不愿支持超类的接口，需重构（这里思考Basesso类的3个abstract方法有这个问题，不愿支持超类的接口） Comments（过多注释） ​ 重新组织函数 Extract Method（提炼函数） 将一段代码放进一个独立的函数中，并让函数名称解释该函数的用途。 如果源函数中局部变量比较多，先用Replace Temp With Query减少临时变量，源函数中读取的临时变量和参数，提炼到目标函数作为参数，并考虑是否需要返回值。 Inline Method （内联函数） 一个函数和本体一样清楚易懂，在函数调用点插入函数体，然后移除该函数。 Inline Temp（内联临时变量） 将临时变量替换为对它赋值的表达式或函数。 Replace Temp With Query（以查询取代临时变量） 将临时变量的计算代码提炼到一个独立的函数中，这样临时变量的引用点就可以替换为新函数的调用。 以查询代替临时变量可以减少临时变量，是提炼函数的重要步骤。 Introduce Explaining Variable (引入解释性变量) 将该复杂表达式的结果放进一个临时变量，以此变量名称来解释表达式的作用。 或者Extract Method来处理 Split Temporary Variable (分解临时变量) 某个临时变量，既不是循环变量也不是收集变量；针对每次赋值，创造一个独立的、有合理名称的临时变量来分解重复赋值。 Remove Assignments to Parameters(移除对参数的赋值） 代码对参数进行赋值，以一个临时变量取代该参数的位置 Java是按值传递的 1234void aMethod(Object foo) &#123; foo.modifySomeWay(); //that's OK，将改变foo引用的对象 foo = anothnerObject; //trouble will follow, 函数返回后并不会改变foo。&#125; Replace Method with Method Object(以函数对象取代函数） 有一个大型函数其中存在大量的局部变量，很难Extract Method来分解这个函数，那么使用函数对象。 将原函数替代成函数对象，该函数对象的构造函数接受源对象和原函数的参数作为参数； 针对原函数每个临时变量和每个参数，在新的函数对象中建立一个对应的字段保存； 然后就可以在函数对象中Extract Method来分解原函数； Substitute Algorithm (替换算法) 将函数本体替换为新的算法，建议先考虑分解函数再做替换。 ​ 在对象之间搬移特性 Move Method (搬移函数) 函数与其他类耦合过多，考虑使用委托或搬移到合适的类中。 搬移过程中，当目标类需要源类特性时，1）将这个特性也搬移到目标类 2）建立使用目标类到源类的使用 3）将源对象或该特性变量作为参数传递给目标类 Move Field (搬移字段) 某个字段被所驻类之外的另一个类更多地用到，考虑搬移这个字段到目标类。 Self Encapsulate（使用自我封装）在字段搬移后，就只需要修改访问函数（set／get），而无需修改引用点。 Extract Class（提炼类） 建立一个新类，将相关字段和函数从旧类搬移到新类。 可能需要双向连接，尽量避免建议新类到旧类的连接；决定是否公开新类； Inline Class（内联化类） 将这个类的所有特性搬移到另一个类，然后移除这个类； Hide Delegate (隐藏“委托关系“) 客户类通过委托类来调用另一个对象，在服务类上建立客户需要的所有委托函数，用于隐藏委托关系。 Remove Middle Man（移除中间人） 某个类做了过多的委托动作，那么可以直接让客户类调用受托类； 服务类中建立一个函数，直接返回受托类，客户类直接调用该类； 隐藏委托关系与移除中间人互为逆向的行为。 Introduce foreign Method (引入外加函数) 场景：你需要为提供服务的类增加一个函数，但是却无法修改这个类 应对：在客户类中建立一个函数，并传入一个服务类的实例参数； 如果需要外加多个函数，考虑使用引入本地扩展。 Introduce Local Extension (引入本地扩展) 场景：你需要为服务类提供一些额外的函数，但是你无法修改这个类 应对：建立一个新类，包含这些额外的函数，让这个扩展品称为源类的字类（subclass）或包装类（wrapper）； ​ 重新组织数据 Self Encapsulate Field (自封装字段) 直接访问字段，产生耦合关系；为这些字段建立get/set函数，并以这些函数访问字段。 直接访问字段还是通过get/set函数访问哪个好没有定论。 Replace Data Value with Object(以对象取代数据值) 如果有一个数据项需要与其他数据或者行为一起使用才有意义，那么将数据变成对象。 数据值 —&gt; 值对象,值对象应该是不可修改的 区别：如果数据可修改，使用引用对象，Change value to Reference Change Value into Reference(将值对象改为引用对象) 从一个类衍生出多个相等的实例，希望它们是同一个对象；将值对象变成引用对象； 多个Order共享同一个Customer对象 引用对象都代表真实世界中的一个实物，可以用==直接检查两个对象是否相等；如“客户”、“账户”等.. 值对象不可变，完全由其数据值来定义，有多个副本存在，需要复写equals()判断是否相等，如“日期”、“钱”.. Change Reference to Value(将引用对象改为值对象) 有一个引用对象，很小且不可变，将它改为值对象。 值对象是“不可变”（immutable）的，表示对象自身是不可变的。判断相等用equals()方法 Replace Array with Object(以对象代替组数) 有一个数组，其中的元素各自代表不同的东西 以对象代替数组，对于数组中的每一个元素，以一个字段来表示 Duplicate Observed Data(复制“被监视的数据”) 有一些领域（Model）数据置身于GUI控件中，而领域函数需要访问需要访问这数据； 将该数据复制到领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据； Change Unidirectional Association to Bidirectional(将单向关联改为双向关联) 场景：两个类都需要使用对方的特性，但只有一条单向关联 实现：添加一个反向指针，并使修改函数能够同事更新两条连接 决定哪个类是控制端；控制端（提供控制函数，维护反向指针），修改函数调用控制函数；被控制端（提供一个辅助函数提供反向指针），修改函数调用控制端的控制函数。 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联) 场景：两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性； 去除不必要的关联 Replace Magic Number with Symbolic Constant(以字面常量代替魔法数) 创建一个常量，根据其意义命名，替换上述魔法数 Encapsulate Field(封装字段) 将public字段声明为private，并提供相应的get/set访问函数 Encapsulate Collection(封装集合) 场景：有一个函数返回一个集合 优化：让这个函数返回该集合的一个只读副本，并提供添加／移除该集合元素的方法 Replace Record with Data Class(以数据类取代记录) 为记录结构型数据创建一个数据对象 Replace Type Code with Class(以类取代类型码) 场景：类中又一个数值类型码，但它并不影响类的行为 以一个新的类替换该数值类型码 Replace Type Code with Subclasses(以子类取代类型码) 场景：有一个不可变的类型码，它会影响类的行为 重构：以字类取代这个类型码，借助多态实现变化行为,将和特定字类相关的字段／函数push down到字类 Replace Type Code with State/Stratege(以状态／策略取代类型码) 场景：如果一个类型码的值在对象生命周期发生变化或者其他原因是宿主类不能被继承； 重构：以状态对象或策略模式取代类型码 Replace Subclass with Fields(以字段代替子类) 场景：各个子类的唯一差别只在“返回常量数据”的函数身上 重构：修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类 ​ 简化条件表达式 Decompose Conditional(简化条件表达式) 场景：有一个复杂的条件if-then-else语句 从if、then、else段落中分别提炼出独立的函数，函数名可以直观反映出函数的用途 Consolidate Conditional Expression(合并条件表达式) 场景：有一系列的条件测试，均得到相同的结果 重构：将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立的函数 使用||、&amp;&amp;、？：合并测试条件 Consolidate Duplicate Conditional Fragments(合并重复的条件片段) 场景：在条件表达式的每个分支上都有相同的一段代码 重构：将这段代码搬移到条件表达式外，并提炼出独立函数 Remove Control Flag(移除控制标记) 在一系列的布尔表达式中，某个变量带有控制标记（control flag）的作用 以break或者return语句取代这个控制标记 Replace Nested Conditional with Guard Clauses(以位语句取代嵌套的条件表达式) 场景：函数中条件逻辑使人迷惑 重构：使用卫语句表现所有特殊情况，立即返回结果；最后处理正常逻辑； 使用卫语句检查特殊条件，立刻返回或抛出异常； 可以先将条件表达式反转实现卫语句（P253）； Replace Conditional with Polymorphism(以多态取代条件表达式) 场景：有一个条件表达式，根据对象类型的不同选择不同的行为 重构：将这个条件表达式的每个分支放进一个子类的复写函数中，然后将原始的函数声明为抽象 在使用Replace Coditional with Polymorphism之前,必须建立一个继承结构：优先使用Repalce Type Code with Subclass，但是如果需要在对象创建后修改类型码，就不能用继承手法，那么使用 Replace Type Code with State/Stratege; Introduce Null Object(引入Null对象) 场景：你需要再三检查某个对象是否为null 重构：建立Null对象，替换null值的判断 空对象继承源对象，或者实现Null Interface；空对象一定是一个常量，它的任何成分都不会变化； Introduce Assertion(引入断言) 某一段代码需要对程序状态作出假设，以断言明确表示这种假设 简化函数调用 Rename Method(函数改名) 给每一个函数取一个可以揭示函数用途的、直观的名字 Add Parameter(添加参数) 为此函数添加一个对象参数，让该对象参数带进函数所需信息 Remove Parameter(移除参数) 移除多余的参数 Separate Query from Modifier(将查询函数和修改函数分离) 场景：某个函数既返回对象状态值，有修改对象状态 重构：建立两个独立的函数，一个负责查询，另一个负责修改 注意并发编程中，可保留查询-修改函数，调用各自独立的查询函数和修改函数，并声明为synchronised Parameterize Method(令函数携带参数) 若干函数做了类似的工作，但因少数几个值致使行为略有不同 建立单一函数，以参数表达那些不同的值 Replace Parameter with Explicit Method(以明确函数取代参数) 有一个函数安全取决于参数值而采取不同的行为 针对该参数的每一个可能值，建立一个独立函数；相反与Parameterize Method Preserve Whole Object(保持完整对象) 场景：你从对象中取出一些值，将它们作为参数传递给函数 重构：改为传递整个对象 Replace Parameter with Methods(以函数取代参数) 场景：对象调用一个函数，并将所得的结果作为参数，传递给另一个函数 重构：让参数接收这去处该项参数，并直接调用前一个函数 如果函数可以通过其他途径获取参数值，那么就应该去除该多余的参数 Introduce Parameter Object(引入参数对象) 场景：某些参数总是很自然的同时出现 重构：以一个对象取代这些参数，比如Range模式，范围对象取代(start,end) Remove Setting Method(移除设值函数) 场景：类中的某个字段应该在对象创建的时候被设值，然后不再改变 重构：去除该字段所有设值函数，同时声明该字段为final Hide Method(隐藏函数) 有一个函数从类没有被其他任何类用到过 将这个函数修改为private Replace Constructor with Factory Method(以工厂函数取代构造函数) 场景：在派生子类的过程中，需要根据类型码，创建相应的对象 重构：使用工厂函数取代构造函数 Encapsulate Downcast(封装向下转型) 场景：某个函数返回的对象需要由函数的调用者执行向下转型 重构：将向下转型的动作移到函数中 123Object lastReading() &#123; return reading.lastElement();&#125; 改为： 123Reading lastReading() &#123; return (Reading)reading.lastElement();&#125; Replace Error Code with Exception(以异常取代错误码) 场景：某个函数返回一个特定的代码，表示某种错误的情况 重构：改用异常 12345678int withdraw(int amount) &#123; if(amount &gt; _balance) &#123; return -1; &#125; else &#123; _balance -= amount; return 0; &#125;&#125; 改为： 1234void withdraw(int amount) throws BalanceException &#123; if(amount &gt; _balance) throw new BalanceExctption(); _balance -= amount;&#125; 决定函数应该抛出受控异常（checked）还是非受控异常（unchecked） 如果函数的调用者有责任在调用前检查必要状态，就抛出unchecked异常 抛出checked异常可以新建一个异常类继承Exception，或者使用现有的checked异常类 Replace Exception with Test(以测试取代异常) 场景：面对一个调用者可以预先检查的条件，你抛出了一个异常 修改调用者，使它在函数调用之前预先检查 1234567double getValueForPeriod(int periodNumber) &#123; try &#123; return _values[periodNumber]; &#125; catch(ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125; 改为： 1234double getValueForPeriod(int periodNumber) &#123; if ( periodNumber &gt;= _values.length ) return 0; return _values[periodNumber];&#125; 异常应该只被用于那些产生意料之外的错误行为，而不应该成为条件检查的工具；不要用try-catch语句作为条件判断语句； 概括处理关系 Pull Up Field(字段上移) 如果两个子类拥有相同的字段，将该子段移到超类 Pull Up Method(函数上移) 场景：有些函数在子类中产生完全相同的结果 重构：将该函数移至超类 Pull Up Method过程中最麻烦的一点就是：被提升的函数可能会引用只出现在子类而不出现在超类的特性。 如果被引用的是一个函数，你可以将该函数一同提升到超类；或者在超类中建立一个抽象函数；或者建立一个委托函数 如果被引用的是子类的字段，你可以将该字段也提升到超类；或者先在子类中自封装字段，然后在超类中把取值函数声明为抽象 Pull Up Constructor Body(构造函数本体上移) 在子类中各拥有一些构造函数，它们的本体几乎一致 在超类中新建一个构造函数，并在子类构造函数中调用它 Pull Down Method(函数下移) 超类中的某个函数只与部分（而非全部）子类有关，将这个函数移到相关的那些子类中去 Pull Down Field(字段下移) 超类中的某个字段只被部分（而非全部）子类所用到，将这个字段移到需要它的那个子类中去 Extract SubClass(提炼子类) 场景：类中的某些特性只被某些（而非全部）实例用到 重构：新建一个子类，将上述一部分特性移到子类中 Extract SuperClass(提炼超类) 场景：两个类具有相似的特性 重构：为这两个类建立一个超类，将这些相同的特性搬移到超类 Extract Interface(提炼接口) 场景：若干客户使用类接口中的同一子集，或者两个类的接口有相同的部分 重构：将相同的子集提炼到一个独立的接口中 Collapse Hierarchy(折叠继承体系) 超类和子类之间无太大区别，将它们合为一体 From Template Method(塑造模版函数) 场景：你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作细节上有所不同 重构：将这些细节操作分别放进独立的函数中，并保持它们都有相同的签名，于是原函数也变得相同了；然后将原函数上移到超类 Replace Inheritance with Delegation(以委托取代继承) 场景：某些子类只使用超类接口中的一部分，或者根本不需要继承而来的数据 重构：在子类中新建一个子段用以保存超类；调整子类函数令它委托超类；然后去掉继承关系 Replace Delegation with Inheritance(以继承取代委托) 场景：你在两个类之间使用委托关系，并经常为整个接口编写很多及其简单的委托函数 重构：让委托类继承受托类 大型重构 Tease Apart Inheritance(梳理并分解继承体系) 场景：某个继承体系同时承担两项责任 重构：建立两个继承体系，并通过委托关系让其中一个可以调用另一个 Convert Procedural Design to Objects(将过程化设计转化为对象设计) 场景：你手中有一些传统过程化风格的代码 重构：将数据记录变为对象，将大块行为分为小块，并将行为移入相关对象之中 Separate Domain from Presentation(将领域和显示分离) 某些GUI类中包含了领域逻辑 将领域逻辑分离出来，为它们建立独立的领域类 Extract Hierarchy(提炼继承体系) 场景：你有某个类做了大量的工作，其中一部分工作是以大量的条件表达式完成的 重构：建立继承体系，以一个子类表示一种特殊情况]]></content>
      <categories>
        <category>重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>refactor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2017%2F05%2F16%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Generate static files1$ hexo generate More info: Generating Run server1$ hexo server More info: Server Deploy to remote sites1$ hexo deploy BenefitsWith this feature, now you can put all your configurations into one place (source/_data/next.yml), you don’t need to touch next/_config.yml. If there are any new options in new releases, you just need to copy those options from next/_config.yml, paste into _data/next.yml and set their values to whatever you want. How to use this feature Please ensure you are using Hexo 3 (or above) Create an file named next.yml in site’s source/_data directory (create _data directory if it did not exist) Copy NexT theme options both in site’s _config.yml and theme’s _config.yml into next.yml. Use --config source/_data/next.yml parameter to start server, generate or deploy.For example: hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml. More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
