<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android动画深入分析]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[View动画View动画作用的对象是View, 它支持四种动画效果平移, 缩放, 旋转, 透明. 除了这四种典型的变化效果. 帧动画也属于View动画. View动画的种类View动画的四种变换效果对应着Animation的四个子类:TranslateAnimation, ScaleAnimation, RotateAnimation和AlphaAnimation. 对于View动画建议采用XML来定义动画 名称 标签 子类 效果 平移动画 &lt;translate&gt; TranslateAnimation 移动View 缩放动画 &lt;scale&gt; ScaleAnimation 放大或者缩小View 旋转动画 &lt;rotate&gt; RotateAnimation 旋转View 透明度动画 &lt;alpha&gt; AlphaAnimation 改变View的透明度 创建的动画的xml文件. 是放在res/anim这个文件夹下的. View动画描述文件的固有语法如下 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:shareInterpolator="true" android:interpolator="@android:anim/decelerate_interpolator" android:fillAfter="true"&gt; &lt;alpha android:fromAlpha="float" android:toAlpha="float"/&gt; &lt;scale android:fromXScale="float" android:toXScale="float" android:fromYScale="float" android:toYScale="float" android:pivotX="float" android:pivotY="float"/&gt; &lt;translate android:fromXDelta="float" android:toXDelta="float" android:fromYDelta="float" android:toYDelta="float"/&gt; &lt;rotate android:fromDegrees="float" android:toDegrees="float" android:pivotY="float" android:pivotX="float"/&gt;&lt;/set&gt; 关于动画我们可以只设置一种也可以设置多种的组合. set标签对应着AnimationSet类, 标签中的属性的意义: shareInterpolator 表示集合中的动画是否和集合共享一个插值器. 如果集合不指定插值器, 那么子动画就需要单独制定所需的插值器或者使用默认值 fillAfter 是否保留动画结束之后的状态 translate标签表示平移动画, 对应着TranslateAnimation类 属性值的意义就是from开头的为开始起点, to开头的结束点 scale标签表示缩放动画, 对应着ScaleAnimation类 属性值的意思from开头的表示开始时原图缩放的百分比. 用浮点数表示1表示100%(无变化),0.5表示50%(原来的一般), 2表示200%(原来的两倍). to开头的表示结束时的百分比. pivot表示缩放的轴点. rotate标签表示旋转动画, 对应着RotateAnimation类 fromDegrees旋转的开始角度, toDegrees旋转的结束角度. pivot旋转的轴点 alpha标签表示透明度动画, 对应AlphaAnimation类 fromAlpha表示透明度的起始值, toAlpha表示透明度的结束值. 上面这些标签还有一些通用的属性值. 例如duration执行时间. xml如果声明了之后那么我们就该在代码中应用了. 如下: 123View btn_main = findViewById(R.id.parent);Animation animation = AnimationUtils.loadAnimation(this, R.anim.temp);btn_main.startAnimation(animation); 同样也可以不需要xml直接在代码中生成动画对象. 123AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0);alphaAnimation.setDuration(1000);btn_main.startAnimation(alphaAnimation); 在开始动画之前可以给动画添加一个监听setAnimationListener()这样在动画开始结束和每一次循环下一次的时候都可以在回调方法中监听到. 12345public static interface AnimationListener &#123; void onAnimationStart(Animation animation); void onAnimationEnd(Animation animation); void onAnimationRepeat(Animation animation);&#125; 自定义View动画如果需要自定义View动画, 首先应该继承Animation这个抽象类来派生出一种新动画. 然后重写initialize()和applyTransformation()方法. 在initialize中做一些初始化动作, 在applyTransformation()中进行相应矩阵变换, 很多时候需要采用Camera来简化矩阵变换的过程. 而View动画变化主要就是矩阵的变换过程. 这里举一个Android中ApiDemo的一个自定义View动画. 大概效果就是这样可以参照官网的api也可在包中的MyRotateAnimation 帧动画帧动画是顺序播放一组预先定义好的图片, 类似于电影. 系统提供了AnimationDrawable来使用帧动画. 同样在xml中声明, 在res/drawable/包下创建文件, 并替换每个drawable图片即可 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/xx1" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx2" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx3" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx4" android:duration="500"/&gt;&lt;/animation-list&gt; 将上述的Drawable作为View的背景并通过Drawable来播放动画. 12AnimationDrawable background = (AnimationDrawable) iv_main.getBackground();background.start(); 帧动画比较容易引起OOM，应该尽量避免使用。 View动画的特殊使用场景前面介绍的View动画都是作用在某一个View对象上的. 还可以针对ViewGroup控制其子元素. 或者针对Activity切换的动画. LayoutAnimationLayoutAnimation作用于ViewGroup上的. 为ViewGroup指定一个动画, 这样当它的子元素出场时都会具有这种动画效果. 常用的使用场景是在ListView和GridView. 使用很简单步骤如下. 在res/anim/anim_item文件夹下创建xml文件. 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="0.5" android:animationOrder="random" android:animation="@anim/layout"&gt; &lt;/layoutAnimation&gt; delay: 子元素开始动画的延迟时间, 传入值是浮点值. 1为100%. 例如如果是0.5 入场动画周期为300ms(下面关联动画的duration时间), 那么每个子元素都需要延迟150ms才能播放入场动画. 而且这个时间会根据item的递增而增加. 比方说第一个为延迟150ms, 第二个就是300ms依次类推. animationOrder: 子元素动画的顺序, 有三种选择normal,reverse,random. reverse表示排在后面的元素先执行入场动画. random随机子元素执行动画. animation: 为子元素指定具体的入场动画. 里面放的就是针对View的animation动画的xml layoutAnimation声明完成之后, 在要作用的ViewGroup标签中增加android:layoutAnimation:&quot;@anim/xxx&quot;进行关联即可. 同样也可以通过Java代码动态创建LayoutAnimation类来实现. 12345678910//获得子元素需要执行的View动画Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_item); //创建一个LayoutAnimation动画对象LayoutAnimationController controller = new LayoutAnimationController(animation);controller.setDelay(0.5f);controller.setOrder(LayoutAnimationController.ORDER_RANDOM); //对ViewGrop进行绑定listView.setLayoutAnimation(controller); Activity的切换效果Activity默认是有一种切换效果的. 如果需要自定义切换效果, 主要用到overridePendingTransition()这个方法, 这个方法必须在startActivity()或者finish()之后调用才会生效 需要的形参有两个, 第一个是被打开时候所需的动画资源id, 第二个是被暂停时,所需的动画资源id. 属性动画属性动画是API新加入的特性, 和View动画不同, 它对作用对象进行了扩展, 属性动画可以对任何对象做动画. 属性动画不再像View动画那样只能支持四种简单的交换 . 属性动画中有valueAnimator. ObjectAnimator, AnimatorSet等概念 使用属性动画属性动画可以对任何对象的属性进行动画而不仅仅是View, 动画默认时间间隔为300ms, 默认帧率10ms/帧. 可以达到的效果为: 在一段时间间隔内完成对象从一个属性值到另一个属性值的改变. 属性动画是从API11增加的. 如: 改变一个对象的背景色属性, 典型的改变View的背景色, 下面的动画可以让背景颜色的渐变, 动画会无限循环而且会有反转效果. 123456ObjectAnimator colorAnim = ObjectAnimator.ofInt(activity_main, "backgroundColor", 0xffffa000, 0xffffa0ff); colorAnim.setDuration(5000); colorAnim.setEvaluator(new ArgbEvaluator()); colorAnim.setRepeatCount(ValueAnimator.INFINITE); colorAnim.setRepeatMode(ValueAnimator.REVERSE); colorAnim.start(); 动画集合,5秒内对View旋转平移缩放透明 12345678910111213AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether( ObjectAnimator.ofFloat(iv_main, "rotationX", 0,360), ObjectAnimator.ofFloat(iv_main, "rotationY", 0,360), ObjectAnimator.ofFloat(iv_main, "rotation", 0,360), ObjectAnimator.ofFloat(iv_main, "translationX", 0,200), ObjectAnimator.ofFloat(iv_main, "translationY", 0,200), ObjectAnimator.ofFloat(iv_main, "scaleX", 1,1.5f), ObjectAnimator.ofFloat(iv_main, "scaleY", 1,1.5f), ObjectAnimator.ofFloat(iv_main, "alpha", 1, 0.25f, 1) ); animatorSet.setDuration(5*1000).start(); 也可以使用xml的形式形式来声明 1234567891011121314151617181920212223242526&lt;set android:ordering=["together" | "sequentially"]&gt; &lt;objectAnimator android:propertyName="string" android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"]/&gt; &lt;animator android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"]/&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; 代码中使用： 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator);set.setTarget(mButton);set.start(); 理解插值器和估值器TimeInterpolator时间插值器, 作用是根据时间流逝的百分比来计算当前属性值改变的百分比. 系统预置的有 LinearInterpolator(线性插值器:匀速动画) AccelerateDecelerateInterpolator(加速减速插值器:动画两头慢中间快) DecelerateInterpolator(减速插值器:动画越来越慢) TypeEvaluator 类型估值算法, 也叫估值器. 作用是根据当前属性改变的百分比来计算改变后的属性值. 系统预置的估值器有 IntEvaluator 整形估值器 FloatEvaluator 浮点型估值器 ArgbEvaluator Color属性估值器 属性动画中的插值器和估值器都很重要, 他们是实现非匀速动画的重要手段 属性动画要求对象的该属性有set``get方法. 插值器和估值器算法除了系统提供的外. 也可以自定义. 实现方式也很简单, 因为插值器和估值算法都是一个接口, 且内部都只有一个方法, 我们只要派生一个类实现接口接可以. 具体就是: 自定义插值器需要实现Interpolator或者TimeInterpolator. 自定义估值算法需要实现TypeEvaluator 属性动画的监听器属性动画提供了监听器用于监听动画的播放过程 主要有两个接口AnimatorUpdateListener和AnimatorListener接口. AnimatorListener 通过接口的定义可以看出, 监听了动画的开始,结束,取消,以及重复播放. 系统为了方便开发提供了AnimatorListenerAdapter类. 他是AnimatorListener的适配器. 这样就不需要非得实现四个抽象方法而是按照我们的需要选择复写. AnimatorUpdateListener 比较特殊, 他会监听整个动画过程, 动画是由许多帧组成的. 每播放一帧onAnimationUpdate就会被调用一次 对任意属性做动画问题: 如果需要把一个button控件的宽增加200px. 应该怎么做? View动画只是支持四种基本的属性操作, 而Scale只是缩放. 并且还会对内容进行拉伸并且伴随着y轴的增加. 所以属性动画在这里就可以派上用场. 但是如果直接对width属性进行修改那么不会有效果. 分析一下: 属性动画的原理: 属性动画要求动画作用的对象提供该属性的get和set方法, 属性动画根据外界传递的该属性值的初始值和最终值, 以动画的效果多次调用set每次set的值也是不同. 最终达到终点值. 所以要让动画生效应该满足两个条件: 必须提供setXXX()方法, 如果动画没有传递初始值还要提供getXXX()方法. 这样系统在需要初始属性的时候在取值时不会因为没有getXXX()而发生Crash. set修改的值必须能改通过某种形式反映出来, 比如会带来UI的改变. (如果不满足这条,动画无效果但不会Crash) 那Button本身具备setWidth()为什么会无效果. 这是因为虽然Button提供了方法, 但是这个setWidth()方法并不是改变视图大小的, 他是TextView新添加的方法, View却没有这样的方法. 而setWidth()方法的内部,作用不是设置View的大小, 而是设置TextView的最大宽度和最小宽度, 这个和TextView的宽是两个东西. 这样说控件的宽度对应xml中的layout_width, 而setWidth()对应的就是xml中的width属性. 所以综合上述原因, 满足条件一而不满足条件二. 官网文档中给出了三种解决方案: 给你的对象加上get和set方法, 如果你有权限的话. 用一个类来包装(Wrapper)原始对象, 间接为其提供get和set方法. 采用valueAnimator, 监听动画过程,自己实现属性的改变. 比较： 虽然简单但是没有权限去SDK内部实现去 可以创建一个内部包装类创建set(),get()方法对View真正的宽度的LayoutParams.width属性进行修改. 采用ValueAnimator, 监听动画过程, 自己实现属性改变. ValueAnimator本身不作用于任何对象. 但是他可以对一个值做动画. 然后监听其动画过程，在动画过程中配合估值器Evaluator修改我们的对象属性. 属性动画的工作原理前面说过, 说属性画要求作用的对象提供该属性方法set方法, 属性动画根据传递的该属性的初始值和最终值, 以动画的效果多次去调用set方法. 每次set方法时候传递的值都是不一样的. 也就是随着时间的推移所传递的值会越来越接近终点值. 源码分析: 针对ObjectAnimator的start()为入口 1234567891011121314151617181920212223242526272829303132333435363738394041424344 @Overridepublic void start() &#123; // See if any of the current active/pending animators need to be canceled AnimationHandler handler = sAnimationHandler.get(); if (handler != null) &#123; int numAnims = handler.mAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; numAnims = handler.mPendingAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; numAnims = handler.mDelayedAnims.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; &#125; if (DBG) &#123; Log.d(LOG_TAG, "Anim target, duration: " + getTarget() + ", " + getDuration()); for (int i = 0; i &lt; mValues.length; ++i) &#123; PropertyValuesHolder pvh = mValues[i]; Log.d(LOG_TAG, " Values[" + i + "]: " + pvh.getPropertyName() + ", " + pvh.mKeyframes.getValue(0) + ", " + pvh.mKeyframes.getValue(1)); &#125; &#125; super.start();&#125; 这段代码主要就是取消和当前动画相同的动画. 最开始判断了当前动画,等待动画,延迟动画是否有一致的. 如果有那么就给取消. 最后调用了父类方法. 因为ObjectAnimator继承了ValueAnimator,所以继续看一下父类的start() 1234567891011121314151617181920212223242526private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException("Animators may only be run on Looper threads"); &#125; mReversing = playBackwards; mPlayingBackwards = playBackwards; int prevPlayingState = mPlayingState; mPlayingState = STOPPED; mStarted = true; mStartedDelay = false; mPaused = false; updateScaledDuration(); // in case the scale factor has changed since creation time AnimationHandler animationHandler = getOrCreateAnimationHandler(); animationHandler.mPendingAnimations.add(this); if (mStartDelay == 0) &#123; // This sets the initial value of the animation, prior to actually starting it running if (prevPlayingState != SEEKED) &#123; setCurrentPlayTime(0); &#125; mPlayingState = STOPPED; mRunning = true; notifyStartListeners(); &#125; animationHandler.start();&#125; 属性动画需要运行在有Looper的线程中, 最终会调用AnimationHandler.start()方法.AnimationHandler并不是Handler, 他是一个Runnable. 后面会调到JNI层, 然后JNI层还会调回, 然后run方法会被调用, 这个Runable涉及和底层的交互. 略过. 看重点. ValueAnimator的doAnimationFrame()方法, 内部最后调用了animationFrame()方法,而animationFrame()内部调用了animateValue()方法 1234567891011121314void animateValue(float fraction) &#123; fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].calculateValue(fraction); &#125; if (mUpdateListeners != null) &#123; int numListeners = mUpdateListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mUpdateListeners.get(i).onAnimationUpdate(this); &#125; &#125;&#125; 看到了calculateValue()方法, 这个就是计算每帧动画所对应的属性的值, 然后看一下set,get方法. 比如之前说的如果没有初始值, 则调用get方法等.. 查看PropertyValuesHolder类的setupValue() 12345678910111213141516private void setupValue(Object target, Keyframe kf) &#123; if (mProperty != null) &#123; Object value = convertBack(mProperty.get(target)); kf.setValue(value); &#125; if (mGetter == null) &#123; Class targetClass = target.getClass(); setupGetter(targetClass); if (mGetter == null) &#123; // Already logged the error - just return to avoid NPE return; &#125; &#125; Object value = convertBack(mGetter.invoke(target)); kf.setValue(value); 当动画的下一帧到来的时, setAnimatedValue()方法会将新的属性值给对象, 调用其set()方法.同样set也是反射调用 123456789void setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); &#125; if (mSetter != null) &#123; mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); &#125;&#125; 使用动画的注意事项 OOM问题: 在帧动画时候容易发生 内存泄漏: 如果有无限循环的属性动画, 在界面退出的时候一定要停止动画 ,否则activity会无法释放. 而View动画并不存在此问题. 兼容性问题: 主要是3.0以下系统 View动画问题: 因为是对原始View做的影像效果. 并未真正改变View的状态. 所以在动画完成之后，回导致设置setVisibility(View.GONE)无效. 这个时候调用view.clearAnimation()清除View效果即可。 不要使用px 动画交互. 系统3.0之前无论是属性动画还是View动画新的位置都无法触发单击事件.需要注意； 从3.0开始，属性动画的点击事件的触发位置为移动后位置，但是View动画仍在原位置。 硬件加速,提高动画流畅度]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>属性动画</tag>
        <tag>View动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的Drawable]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E7%9A%84Drawable%2F</url>
    <content type="text"><![CDATA[Drawable简介Drawable表示一种图像的概念. 优点:使用比自定义View的成本低, 非图片类型的Drawable占用空间较小. Drawable本身是一个抽象类. 是所有Drawable对象的基类, 每个具体的Drawable都是其子类. Drawable内部宽高通过getIntrinsicWidth和getIntrinsicHeight这两个方法获得. 需要注意这个内部宽高的概念针对不同的类型的Drawable, 对于图片形成的Drawable内部宽高就是图片的宽高. 而颜色所形成的Drawable没有内部宽高的概念. Drawable的内部宽高不等于它的大小. 当作为View的背景的视图, Drawable会被拉伸至View的同等大小. Drawable的分类BitmapDrawable表示一张图片, 在开发中直接引用原始图片也可, 下面给出在XML中描述稍微完整的声明 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@mipmap/ic_sample" android:antialias="true" android:dither="true" android:filter="true" android:gravity="top" android:mipMap="true" android:tileMode="repeat" &gt;&lt;/bitmap&gt; src: 图片的资源文件id(AS下可能不会自动提示mipmap,直接写入即可) antialias: 图片抗锯齿.属性值boolean 开启可以让图片变得平滑. dither: 抖动效果. 属性值Boolean. 当图片的像素配置和手机屏幕的像素配置不一致时,开启此选项可以让高质量的图片在低质量的屏幕上继续保持较好效果. 例如图片模式为ARGB8888,而设备屏幕所支持为RGB555. 开启可以让图片不会过于失真. filter: 过滤效果. 当图片尺寸被拉伸或者压缩,可以保持较好的效果. gravity: 可以对图片进行定位. 可以使用|组合属性使用. 可供使用的属性 可选项 含义 top 放在顶部, 不改变图片大小 bottom 放在底部, 不改变图片大小 left 放在左端, 不改变图片大小 right 放在右端, 不改变图片大小 center_vertical 使图片竖直居中, 不改变图片大小 fill_vertical 图片竖直方向填充容器 center_horizontal 使图片水平居中, 不改变图片大小 fill_horizontal 图片水平方向填充容器 center 图片同时水平和垂直居中, 不改变图片大小 fill 图片水平和竖直方向均填充容器, 这是默认值 clip_vertical 表示竖直方向的裁剪, 较少使用 clip_horizontal 表示水平方向的裁剪, 较少使用 mipmap: 纹理映射 默认为false tileMode: 平铺模式. 有四种值: disable关闭平铺模式(默认值), repeat普通平铺开启, mirror平铺的同时,平铺图片做镜面效果. clamp在原始图片最右边像素向右延伸, 最下边像素向下延伸.如图: NinePatchDrawable 表示一张.9格式的图片, .9图片可以自动的根据所需要的宽高进行相应的缩放并保证不失真. 和BitmapDrawable使用一样直接引入图片即可. xml方式如下: 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;nine-patch xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;xxxx&quot; android:dither=&quot;true&quot;/&gt; ShapeDrawable这是一种通过颜色来构成的图片, 它可以为纯色的图形, 也可以具有渐变的图形. 以下是一个简单使用方法 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;!--圆角--&gt; &lt;corners android:radius=&quot;50dp&quot;/&gt; &lt;padding android:top=&quot;5dp&quot;/&gt; &lt;!--填充--&gt; &lt;solid android:color=&quot;@color/colorPrimary&quot;/&gt; &lt;!--gradient 和solid 互斥属性谁放在后面谁才有效--&gt; &lt;!--渐变--&gt; &lt;gradient android:angle=&quot;90&quot; android:startColor=&quot;#f00&quot; android:centerColor=&quot;#0f0&quot; android:endColor=&quot;#00f&quot;/&gt; &lt;!--边框--&gt; &lt;stroke android:width=&quot;30dp&quot; android:color=&quot;#ff0000&quot; /&gt;&lt;/shape&gt; 来说说具体的属性都有什么 shape: 表示图片的形状, 有四个选项: rectangle()矩形, oval(椭圆), line(横线), ring(圆环). 默认值为矩形. 另外line和ring这两个选项必须要通过&lt;stroke&gt;标签来指定线的宽度和颜色等信息, 否则无法达到预期效果.当ring这个形状还需要添加几个属性innerRadius圆环内半径, thickness圆环的厚度,外半径减去内半径的距离. 还有两个半分比的属性.效果一样. useLevel:基本都是用false, 否则可能无法到达预期的显示效果,除非被当做LevelListDrawable.如下图可以看看几个方式的样子 &lt;corner&gt; 表示shape的四个角度. 它只适用于矩形shape. 支持属性总共有五个,一个Radius和四个顶角如topLeftRadius等等. Radius的优先级最低, 会被其他属性覆盖. &lt;gradient&gt; 它与&lt;solid&gt;标签是互相互斥的. 其中solid表示纯色填充, 而gradient则表示渐变效果. 有如下属性: android:angle –渐变的角度, 默认为0, 其值必须为45的倍数. 0表示从左到右, 90表示从下到上. android:centerX –渐变的中心点横坐标(范围0~1) android:centerY –渐变的中心点纵坐标(范围0~1) android:startColor –渐变的起始色 android:centerColor –渐变的中间色 android:endColor –渐变的结束色 android:gradientRadius –渐变半径, 仅当android:type=”radial”时有效,并且当type=”radial”的时候必须声明此属性,否则崩溃 android:useLevel –一般为false.当Drawable作为StateListDrawable使用时为true android:type –渐变的类型, 有linear(线性渐变), radial(径向渐变), sweep(扫描线渐变)三种, 默认为线性渐变 看看type不同的格式什么样子 &lt;solid&gt;表示纯色填充, 通过android:color来指定颜色 &lt;stroke&gt; shape的描边,有四个属性. width描边的宽度, color描边的颜色, dashWidth组成虚线的线段的宽度, dashGap组成虚线的线段之间的间隔. &lt;padding&gt; 这个表示空白, 但是他表示的不是shape的空白, 而是包含它的View的空白, 有上下左右四个属性 &lt;size&gt; Drawable有两个方法获得固有高度. getIntrinsicWidth(), getIntrinsicHeight(). 就是如果是图片Drawable那就是图片的属性大小. 如果不是那就是返回-1. 如果size标签设置了大小. 在方法返回的时候就不再是-1. 但是作为View的背景, shape还会被拉伸或者缩为View的大小. LayerDrawable对应的标签是&lt;layer-list&gt;, 他表示一个层次化得Drawable集合.通过将不同的Drawable放置在不同的层面上从而达到一种叠加的效果. 一个这种标签可以包含多个item, 每个item表示一个Drawable. Item的结构比较简单，常见的有android:top、android:bottom、android:left、android:right，表示Drawable相对于View的上下左右偏移量。可以直接通过drawable属性引用一个Drawable也可以在item中自定义一个Drawable. 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#0ac39e" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="60dp"&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="1dp" android:left="1dp" android:right="1dp"&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; StateListDrawableStateList对应&lt;selector&gt;标签, 也是Drawable集合. 这个我们经常使用在开发中的按钮状态选择器. 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize="true" android:dither="true" android:variablePadding="false" &gt; &lt;!-- 只是列举一下 &lt;item android:state_pressed="true" android:drawable="xxx"/&gt; &lt;item android:state_focused="true" android:drawable="xxx"/&gt; &lt;item android:state_hovered="true" android:drawable="xxx"/&gt; &lt;item android:state_pressed="true" android:drawable="xxx"/&gt; &lt;item android:state_selected="true" android:drawable="xxx"/&gt; &lt;item android:state_checkable="true" android:drawable="xxx"/&gt; &lt;item android:state_checked="true" android:drawable="xxx"/&gt; &lt;item android:state_enabled="true" android:drawable="xxx"/&gt; &lt;item android:state_activated="true" android:drawable="xxx"/&gt; &lt;item android:state_window_focused="true" android:drawable="xxx"/&gt; --&gt;&lt;/selector&gt; select标签对应有三个属性 constantSize: 用于StateListDrawable的固有大小是否不随着其状态改变而改变的, 因为状态的改变会切换不同的item的drawable, 而不同的drawable具有不同的固有大小. 如果为true那就是整个StateListDrawable固有大小是内部所有Drawable的最大固有大小的值. false会随之变化, 默认为false dither: 是否开启抖动效果, 默认为true variablePadding: 表示padding是否随着状态的改变而改变, padding取得值是所有Drawable的最大值. 默认为false. 不会随之改变. &lt;item&gt;标签也比较简单, 指定一个drawable,并加一个状态判断值. 下面给出常见的状态判断 状态 含义 android:state_pressed 表示按下状态, 比如Button被按下后没有松开时的状态 android:state_focused 表示View已经获取了焦点 android:state_selected 表示用户选择了View android:state_checked 表示用户选中了View, 一般适用于CheckBox这类在选中和非选中之间切换的 android:state_enabled 表示View当前是否可用 默认状态的一定要放在最后一条, 因为系统是按照从上到下的顺序查找. 只要找到任何一个匹配状态的那么久结束了. LevelListDrawableLevelListDrawable对应于&lt;level-list&gt;标签, 也表示一个Drawable集合, 集合中每一个Drawable都有一个等级的概念, 根据不同的等级LevelListDrawable会切换不同的对应的Drawable. 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_sample" android:maxLevel="2" android:minLevel="2"/&gt; &lt;item android:drawable="@mipmap/ic_launcher" android:maxLevel="1" android:minLevel="1" /&gt;&lt;/level-list&gt; 这里就相当于给每一个Drawable设定一个标识. level-list会根据这个标识去自己的item中查找. 默认等级为0, Level的取值在0~10000. 在给每个Item声明等级的时候尽量最大和最小等级保持一致. 让每个item都可以有一个唯一标识等级, 而避免有一些公共拥有等级的Item导致出现和我们预期的不符. 如果作为了背景, 那么获得Drawable对象通过getLevel(), setLevel()来得到和设置不同的等级做到切换图片的效果. 如果是ImageView那么通过setImageLevel()前景设置其等级就可以,一定别忘了把Drawable设置前景再通过这种方式实现. TransitionDrawable对应着&lt;transition&gt;标签, 它用于实现两个Drawable之间的淡入淡出效果. 1234567&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_sample"/&gt; &lt;item android:drawable="@mipmap/ic_launcher"/&gt;&lt;/transition&gt; 12 TransitionDrawable drawable = (TransitionDrawable) iv_main.getBackground();drawable.startTransition(5000); 这个没什么好说的了, 很简单. 注意一下如果是给ImageView设置前景的话那么不要用getBackground()来获取了,通过getDrawable()来获取. InsetDrawableInsetDrawable对应&lt;inset&gt;标签, 它可以将其他Drawable内嵌到自己当中, 并可以在四周留出一定的距离. 当一个View希望自己的背景比自己的实际区域小的时候, 可以使用这个来实现.(相当于给使用的View增加了margin效果) LayerDrawable也可以实现此效果 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:insetBottom="20dp" android:insetTop="50dp" android:insetRight="20dp" android:insetLeft="20dp"&gt; &lt;shape &gt; &lt;solid android:color="#ffff00"/&gt; &lt;/shape&gt;&lt;/inset&gt; ScaleDrawableScaleDrawable对应&lt;scale&gt;标签, 他可以根据自己的等级level将制定的Drawable缩放到一定比例. 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@mipmap/ic_sample" android:scaleHeight="10%" android:scaleWidth="10%" android:scaleGravity="center"&gt;&lt;/scale&gt; 并在代码中设置等级, 默认为0是不显示ScaleDrawable 12ScaleDrawable drawable = (ScaleDrawable) findViewById(R.id.activity_main).getBackground();drawable.setLevel(1); 其中scaleHeight和scaleWidth需要的是百分比值. 有点别扭, 如果你设置了10%, 那么实际的意义就是缩放了原大小的10%, 相当于去掉了设置的值. 最终呈现出来的是1-设定的百分比. 就是展现了90%. 而设置的等级会影响最终的图片大小, 等级越大图片越大. 最好等级控制到0~10000 最后. ClipDrawableClipDrawable对应于&lt;clip&gt;标签, 他可以根据自己当前的等级来裁剪Drawable, 裁剪的方向通过android:clipOrientation和android:gravity这两个属性来共同控制. 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;clip xmlns:android="http://schemas.android.com/apk/res/android" android:clipOrientation="horizontal" android:drawable="@mipmap/ic_sample" android:gravity="center"&gt;&lt;/clip&gt; 首先android:clipOrientation 如果参数添加水平 horizontal. 实际上是竖直切割, 保留垂直方向的完整. 如果是Vertical反之. 看图吧. 而gravity有的属性和BitmapDrawable中的gravity一样. 这里现在是android:clipOrientation=&quot;horizontal&quot;它是以水平方向做的垂直切割. 那么通过给gravity设置左 中 右就是left, center, right可以达到不同的效果. 如图 重要的一点还有动态代码设置等级, 要是不设置等级就是默认的0, 0就是切割掉100%的部分,所以剩下的部位为0也就是空的 12ClipDrawable drawable = (ClipDrawable) findViewById(R.id.activity_main).getBackground();drawable.setLevel(5000); 这个等级的数还是1~10000. 等级为0那么意味着裁剪Drawable的100%部分. 什么东西没有.空的 等级为5000那么意味着裁剪Drawable的50%部分, 我上面的演示的图片都是以等级为5000为标准测试的 等级为10000那么就意味的裁剪部分为Drawable的100%部分, 也就是完全显示了. 可以看出来了, 综合上面的看出, 上面的gravity的方向可以认为是从那边开始进行裁剪保留. 自定义Drawable一般Drawable都是作为View的背景图, 或者ImageView的显示图片. 其工作原理核心就是draw()方法. 而系统会调用Drawable的draw()来绘制View的背景, 所以我们通过重写draw()来实现自定义Drawable. 一般draw(), setAlpha(), setColorFilter(), 和getOpacity()都是要实现的 , draw()里面的具体实现和我们View的onDraw()很相似. 可以参考ShapeDrawable和BitmapDrawable的源码去仿造实现. 在自定义的时候注意: 如果要定义的Drawable有固有的大小值, 那么最好重写getIntrinsicWidth()和getIntrinsicHeight()这两个方法. 因为它会影响到View的wrap_content布局. 最后内部大小不一定等于Drawable的实际大小, Drawable实际大小可以通过getBound()来获取.]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解RemoteViews]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%90%86%E8%A7%A3RemoteViews%2F</url>
    <content type="text"><![CDATA[RemoteView的应用简介:在开发中, 通知栏都知道是通过NotificationManager的notify方法实现. 桌面小部件则是通过AppWidgetProvider实现. 后者本质上是一个广播.更新他们无法像以前那样.这是因为不是一个进程,小部件是SystemServer进程. 为了跨进程更新界面,RemoteViews提供了一系列的set方法… RemoteViews通知栏的应用先使用系统默认的样式. –! 先不记录notification了. 发现书上的方法在编译环境23版本以上无效. 23以下是没有问题的.notification.setLatestEventInfo()此方法已经被删除了. 贴出自定义布局通知栏代码利用remoteViews 123456789101112131415161718192021222324252627/** * 打开自定义布局的通知栏 */private void displayRemoteViews() &#123; Notification notification = new Notification(); notification.icon = R.mipmap.ic_launcher; notification.tickerText = "我是小部件"; notification.when = System.currentTimeMillis(); notification.flags = Notification.FLAG_AUTO_CANCEL; Intent intent = new Intent(getApplicationContext(), MainActivity.class); PendingIntent pedingIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); RemoteViews remoteViews = new RemoteViews(getPackageName(), R.layout.layout_notification); remoteViews.setTextViewText(R.id.tv_msg, "我是文字信息"); remoteViews.setImageViewResource(R.id.iv_icon, R.mipmap.favicon); notification.contentView = remoteViews; notification.contentIntent = pedingIntent; PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, OpenActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); remoteViews.setOnClickPendingIntent(R.id.tv_open, openActivity2PendingIntent); NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); manager.notify(2, notification);&#125; 传入了一个自定义布局里面有一个imageView两个textView. 如下图: RemoteView在桌面小部件上的应用AppWidgetProvider是系统提供的用于实现桌面小部件的类, 继承BroadcaseReceiver.可以当成广播理解. 桌面小部件的开发步骤 1.定义小部件界面 在创建一个布局xml当做这个小部件要展示的样子 2.定义小部件配置信息 在res/xml文件夹下新建一个xxx_info.xml的文件 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android" android:initialLayout="@layout/layout_widget" android:minHeight="100dp" android:minWidth="100dp" android:updatePeriodMillis="60000" &gt;&lt;/appwidget-provider&gt; initiaLayout: 小工具所要使用的初始化布局 minHeight``minWidth: 指定小工具的尺寸 updatePeriodMillis: 自动刷新的时间, 单位毫秒 3.定义小部件的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Created by suzeyu on 16/8/11. * 定义小部件的实现类 */public class MyAppWidgetProvider extends AppWidgetProvider &#123; public static final String TAG = MyAppWidgetProvider.class.getName(); public static final String CLICK_ACTION = "com.szysky.note.androiddevseek_05.action.CLICK"; @Override public void onReceive(final Context context, Intent intent) &#123; super.onReceive(context, intent); Log.i(TAG, "onReceive: 接收到广播--&gt;"+intent.getAction()); //是触发的自己点击时发送的action那么就让小部件旋转 if (intent.getAction().equals(CLICK_ACTION))&#123; Toast.makeText(context, "准备旋转", Toast.LENGTH_SHORT).show(); AsyncTask.execute(new Runnable() &#123; @Override public void run() &#123; Bitmap srcBmp = BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon); AppWidgetManager widgetManager = AppWidgetManager.getInstance(context); for (int i = 0; i &lt; 37; i++) &#123; float degree = (i * 10) % 360; RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, rotateBmp(context, srcBmp, degree)); if (i==36)&#123; Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent peddingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, peddingIntent); &#125; widgetManager.updateAppWidget(new ComponentName(context, MyAppWidgetProvider.class), remoteViews); SystemClock.sleep(50); &#125; &#125; &#125;); &#125; &#125; /** * 旋转一个bitmap */ private Bitmap rotateBmp(Context context, Bitmap srcBmp, float degree) &#123; Matrix matrix = new Matrix(); matrix.reset(); matrix.setRotate(degree); return Bitmap.createBitmap(srcBmp, 0, 0, srcBmp.getWidth(), srcBmp.getHeight(), matrix, true); &#125; /** * 当自定义的小桌面被添加 这个方法只有在本实例中只有被添加的时候才调用 */ @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; super.onUpdate(context, appWidgetManager, appWidgetIds); final int counter = appWidgetIds.length; Log.i(TAG, "小桌面更新了 counter="+counter); for (int i = 0; i &lt; counter; i++) &#123; int appWidgetID = appWidgetIds[i]; onWidgetUpdate(context, appWidgetManager, appWidgetID); &#125; &#125; /** * 桌面小部件更新 这个方法只有在本实例中只有被添加的时候才调用 */ private void onWidgetUpdate(Context context, AppWidgetManager appWidgetManager, int appWidgetID) &#123; Log.i(TAG, "onWidgetUpdate: id=="+appWidgetID); RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon)); Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, pendingIntent); appWidgetManager.updateAppWidget(appWidgetID, remoteViews); &#125;&#125; 直接说用途把, 小部件被添加到桌面的时候, 会先走onUpdate()回调,这个时候执行方法通过RemoteViews()构建一个布局,并更新桌面上新的布局和设置了点击事件,然后走onReceive() . 如果当我们点击的小部件的时候, 会触发广播中的onReceive()然后进行图片的旋转.这就是上述代码的大体流程. 4.最后要在清单文件中声明小部件 12345678910&lt;receiver android:name=".MyAppWidgetProvider"&gt; &lt;meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_provider_info"/&gt; &lt;intent-filter&gt; &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE"/&gt; &lt;action android:name="com.szysky.note.androiddevseek_05.action.CLICK"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 第一个action则是作为小部件的表示而必须存在的. 第二个action就是要识别设定的单击行为. 然后就可以在主屏幕上长按添加小部件查看效果了 嫌麻烦就直接扣代码,这是链接 AppWidgetProvider这个类还有其他生命周期的回调, 其实就是当广播到来之后, AppWidgetProvider会自动根据广播的Action通过onReceive()来自动进行分发广播. onEnable(): 当该窗口小部件第一次添加到桌面时调用该方法, 可添加多次但只在第一次调用. onUpdate(): 小部件被添加时或者每次小部件更新时都会调用一次该方法, 小部件的更新时机由updatePeriodMillis来指定, 每个周期小部件都会自动更新一次. onDeleted(): 每删除一次小部件就会调用一次. onReceive(): 这是广播的内置方法, 用于分发具体的事件给其他方法. 下面就是分析了 PendingIntent概述PendingIntent和Intent的区别: PendingIntent: 等待意图, 有一个Intent将在某个待定的时刻发生. Intent: 是立刻发生. 使用场景 最典型的就是给RemoteViews添加单击事件, 因为RemoteViews运行在远程进程中, 因此RemoteViews不同于普通的View, 所以无法直接向View那样通过setOnClickListener()方法那样设置单击事件. 要想给RemoteViews设置单击事件, 就必须使用PendingIntent, PendingIntent通过send()和cancel()来发送和取消特定的待定Intent. PendingIntent支持三种待定意图: 启动Activity, 启动Service, 和发送广播 对应着PendingIntent三个静态方法 getActivity(),getService(), getBroadCast(). 当这三种方法返回的PendingIntent待定意图发生时候, 对应的效果就是我们日常开启这三大组件的情形. 上述三个方法都需要四个参数. 需要说一下第二个参数requestCode和第四个参数flags. 其中requestCode表示PendingIntent发送方的请求码, 多数情况下设为0即可, 另外requestCode会影响到flags的效果. flags: 常用的类型有: FLAG_ONE_SHOT, FLAG_UPDATE_CURRENT, FLAG_NO_CREATE, FLAG_CANCEL_CURRENT. 在此之前首先要明确一个概念, PendingIntent的匹配规则, 在什么情况下两个PendingIntent是相同的. PendingIntent匹配规则: 如果两个PendingIntent的内部Intent相同并且requestCode也相同那么这两个PendingIntent就是想同的. requestCode是int值不需要解释. 而Intent匹配规则是: 如果两个Intent的ComponentName和intent-filter都相同, 那么这两个Intent就是相同的. Extras是不参与Intent的匹配规则. FLAG_ONE_SHOT: 当前描述的PendingIntent只能被使用一次, 然后它就会被自动cancle, 如果后续还有相同的PendingIntent, 那么它们的send方法就会调用失败. 对于通知栏消息来说, 如果采用此标记, 那么同类的通知只能使用一次, 后续的通知单击后将无法打开. FLAG_NO_CREATE: 当前描述的PendingIntent不会主动创建, 如果当前PendingIntent之前不存在, 那么getActivity, getService, getBroadcast方法会直接返回null, 即获取PendingIntent失败. 这个标记很少见, 它无法单独使用,因此日常中没有太多意义. FLAG_CANCEL_CURRENT: 当前描述的PendingIntent如果已经存在, 那么他们都会被cancel, 然后系统会创建一个新的PendingIntent. 对于通知栏消息来说, 那些被cancel的消息单击后将无法打开. FLAG_UPDATE_CURRENT: 当前描述的PendingIntent如果已经存在, 那么他们都会自动被更新, 即它们的Intent中的Extra会被换成新的. 规则说了接下来结合实际使用说明: 如果manager.notify(1, notification),如果参数1的id是常量,那么多次调用notify()只能弹出一个通知, 后续的通知会把前面的通知全部替代, 如果每次id都是不一样的, 那么多次调用notify()就会弹出多个通知. 所以如果notify()是常量, 那么不管PendingIntent是否匹配, 后面的通知都会直接替换前面的通知. 如果notify()每次不同, 那么当pendingIntent不匹配时(这里指的匹配就是上面介绍的Intent和requestCode是否同时相同), 不管采用何种标记, 这些通知之间都不会互相干扰. 但是如果PendingIntent匹配时就要用到去按照之前说的标记区别来划分 FLAG_ONE_SHOT–&gt; 那么后续通知中的PendingIntent会和第一条通知保持一致, 包括Extras, 单击任何一条通知后, 剩下的通知均无法再打开, 当所有的通知都被清除后, 会再次重复这个过程. FLAG_CANCEL_CURRENT–&gt; 那么只有最新的通知可以打开, 之前弹出的所有通知均无法打开 FLAG_UPDATE_CURRENT–&gt; 那么之前弹出的通知中的PendingIntent会被更新, 最终他们和最新的一条通知保持完全的一致, 包括其中的Extras,并且这些通知都是可以打开的. ​ RemoteViews的内部机制RemoteViews的作用是在其他进程中显示并更新View界面. 最常用的构造函数就是public RemoteViews(String packageName, int layoutId), 注意RemoteViews目前并不能支持所有的View类型, 目前支持如下(不包括其子类): Layout FrameLayout, LinearLayout, RelativeLayout, GridLayout View TextView, ImageView, ImageButton, Button, AnalogClock, Chronometer, ProgressBar, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub RemoteViews没有提供findviewById()方法, 只有一系列的set()方法. 方法名 作用 setTextViewText() 设置TextView的文本 setTextViewSize() 设置TextView的字体大小 setTextColor() 设置TextView的字体颜色 setImageViewResource() 设置imageView的图片资源 setImageViewBitmap() 设置imageView的图片 setInt() 反射调用View对象的参数类型为int的方法 setLong() 反射调用View对象的参数类型为long的方法 setBoolean() 反射调用View对象的参数类型为boolean的方法 setOnClickPendingIntent() 为View添加单击事件, 事件类型只能PendingIntent RemoteViews的工作流程 通知栏和桌面小部件分别由NotificationManager和AppWidgetManager管理, 而这两个管理者都是通过Binder分别和SystemServer进程中的NotificationManagerService以及AppWidgetService进行通信. 由此可见,通知栏和桌面小部件中的布局文件实际上是在NotificationManagerService以及AppWidgetService中被加载的, 而他们运行在系统的SystemServer中, 这就和我们的进程构成了进程间通信. 最开始RemoteViews会通过Binder传递到SystemServer进程, RemoteViews实现了Parcelable接口. 系统根据RemoteViews中的包名等信息去得到该应用的资源, 然后通过LayoutInflate去加载RemoteViews中的布局文件. 在SystemServer进程中加载后的布局文件是一个普通的View, 只不过相对于我们的进程他是一个RemoteViews而已. 接着系统会对View执行一系列界面更新任务, 这些任务就是之前的设置的set(). set方法对View所做的更新不是立即执行, 在RemoteViews内部会记录所有的更新操作, 具体的执行时机要等到RemoteViews被加载以后才能执行, 这样RemoteViews就可以在SystemServer进程中显示, 这就是我们看到的通知栏或者桌面小部件. 当需要更新RemoteViews时, 我们需要调用set方法并通过NotificationManager和AppWidgetManager来提交更新任务, 具体的更新操作也是在SystemServer进程中完成的. 为什么不支持所有的View和其操作? 因为代价太大, View的方法太多, 另外就是大量的IPC操作会影响效率. 为了解决这个问题, 系统并没有通过Binder直接支持View的跨进程访问, 而是提供了一个Action的概念, Action代表一个View操作, Action同样实现了Parcelable接口. 系统首先将View操作封装到Action对象并将这些对象跨进程传输到远程进程, 接着在远程进程中执行Action对象中的具体操作. 在我们的应用中每调用一次set(), RemoteViews中就会添加一个对应的Action对象, 当我们通过NotificationManager和AppWidgetManager来提交我们的更新时, 这些Action对象就会传输到远程进程并在远程进程中一次执行. 如图: 远程进程通过RemoteViews的apply方法来进行View的更新操作, RemoteViews的apply方法内部则会去遍历所有的Action对象并调用他们的apply方法, 具体的View更新操作是由Action对象的apply方法来完成的. 上述做法的好处是显而易见的, 首先不需要定义大量的Binder接口, 其次通过远程进程中批量执行RemoteViews的修改操作从而避免了大量的IPC操作, 这就提高了程序的性能. 接下来从源码角度分析. 首先最长用到的setTextViewText(),源码如下 123public void setTextViewText(int viewId, CharSequence text) &#123; setCharSequence(viewId, "setText", text);&#125; 接收的参数比较简单,继续跟进setCharSequence()方法. 123public void setCharSequence(int viewId, String methodName, CharSequence value) &#123; addAction(new ReflectionAction(viewId, methodName, ReflectionAction.CHAR_SEQUENCE, value));&#125; 从这里实现看到, 内部并没有对View进程直接的操作, 而是添加一个ReflectionAction()一个看名字类似反射类型的对象. 接下看addAction() 12345678910private void addAction(Action a) &#123; //省略部分代码... if (mActions == null) &#123; mActions = new ArrayList&lt;Action&gt;(); &#125; mActions.add(a); // update the memory usage stats a.updateMemoryUsageEstimate(mMemoryUsageCounter);&#125; 这里看到, 在RemoteViews内部有一个mActions成员, 它是一个ArrayList, 外界每调用一次set(), RemoteViews就会为其创建一个Action对象并加入到这个集合中, 这里仅仅将Action对象保存了起来, 并未对View进行实际的操作, 这一点在上面的理论分析中已经提到过. 接下来再看ReflectionAction的实现之前, 先看一下RemoteViews的apply()方法以及Action类的实现. 12345678910111213141516171819202122232425262728293031323334public View apply(Context context, ViewGroup parent, OnClickHandler handler) &#123; RemoteViews rvToApply = getRemoteViewsToApply(context); View result; final Context contextForResources = getContextForResources(context); Context inflationContext = new ContextWrapper(context) &#123; @Override public Resources getResources() &#123; return contextForResources.getResources(); &#125; @Override public Resources.Theme getTheme() &#123; return contextForResources.getTheme(); &#125; @Override public String getPackageName() &#123; return contextForResources.getPackageName(); &#125; &#125;; LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); // Clone inflater so we load resources from correct context and // we don't add a filter to the static version returned by getSystemService. inflater = inflater.cloneInContext(inflationContext); inflater.setFilter(this); result = inflater.inflate(rvToApply.getLayoutId(), parent, false); rvToApply.performApply(result, parent, handler); return result; &#125; 这段代码首先通过LayoutInflate去加载RemoteViews中的布局文件, RemoteViews中的布局文件可以通过getLayoutId()这个方法获得, 加载完布局文件后会通过performApply()去执行一些更新操作,如下: 12345678910private void performApply(View v, ViewGroup parent, OnClickHandler handler) &#123; if (mActions != null) &#123; handler = handler == null ? DEFAULT_ON_CLICK_HANDLER : handler; final int count = mActions.size(); for (int i = 0; i &lt; count; i++) &#123; Action a = mActions.get(i); a.apply(v, parent, handler); &#125; &#125; &#125; 这个实现就是遍历mActions并执行每个Action对象的apply()方法, 这里猜想Action对象的apply方法就是真正操作View的地方. RemoteViews在通知栏和桌面小部件中的工作过程和上面描述的过程是一致的. 当调用了RemoteViews的set方法时, 并不会立刻更新他们的界面, 而必须要通过NotificationManager的notify方法以及AppWidgetManager的updateAppWidget才能更新他们的界面. 实际上在AppWidgetManager的updateAppWidget内部实现中, 他们就是通过RemoteViews的apply以及reapply方法来加载或者更新布局的. apply和reApply的区别在于:前者会加载布局并更新界面, 而后者只会更新界面. 通知栏和桌面小部件在初始化界面的时候回调用apply()方法, 而在后续的更新界面时则会调用reapply()方法. 了解了apply()以及reapply()的作用后, 接着看Action的子类具体实现, 先看ReflectionAction的具体实现. 12345678910111213141516171819202122232425262728293031323334private final class ReflectionAction extends Action &#123; //省略部分代码 ... String methodName; int type; Object value; ReflectionAction(int viewId, String methodName, int type, Object value) &#123; this.viewId = viewId; this.methodName = methodName; this.type = type; this.value = value; &#125; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final View view = root.findViewById(viewId); if (view == null) return; Class&lt;?&gt; param = getParameterType(); if (param == null) &#123; throw new ActionException("bad type: " + this.type); &#125; try &#123; getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value)); &#125; catch (ActionException e) &#123; throw e; &#125; catch (Exception ex) &#123; throw new ActionException(ex); &#125; &#125; // ...&#125; ReflectionAction表示的是一个反射动作, 通过它对View的操作会以反射的方式来调用, 其中getMethod就是根据方法名来得到反射所需要的Method对象. 除了ReflectionAction, 还有其他的Action. 例如: TextViewSizeAction, ViewPaddingAction, SetOnClickPendingIntent等. 看一下TextViewSizeAction 1234567891011121314151617181920212223private class TextViewSizeAction extends Action &#123; public TextViewSizeAction(int viewId, int units, float size) &#123; this.viewId = viewId; this.units = units; this.size = size; &#125; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final TextView target = (TextView) root.findViewById(viewId); if (target == null) return; target.setTextSize(units, size); &#125; public String getActionName() &#123; return "TextViewSizeAction"; &#125; int units; float size; public final static int TAG = 13;&#125; 这个类没有使用反射, 因为setTextSize的方法有两个参数,因此无法复用ReflectionAction, 因为这个反射调用只能有一个参数. 关于单击事件, RemoteViews只支持发起PendingIntent,不支持onClickListener()这种模式. setOnClickPendingIntent,setPendingIntentTemplate,setOnClickFillIntent这三个的区别. setOnClickPendingIntent: 只支持普通View设置点击事件, 不能给集合(ListView,StackView)中的View设置点击事件,如item. 因为开销比较大, 系统禁止了这种方式. 如果要给集合中的item添加点击事件,则必须使用后两种组合使用才可以. RemoteViews的意义可以模拟一个通知栏效果并实现跨进程的UI更新. 一个应用需要能够更新另一个应用中的某个界面，这个时候我们当然可以选择AIDL去实现，但是如果对界面的更新比较频繁，这个时候就会有效率问题，同时AIDL接口就有可能会变得很复杂 这个时候如果采用RemoteViews来实现就没有这个问题了，当然RemoteViews也会有点缺点，那就是他仅支持一些常见的View,对于自定义VIew他是不支持的]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>RemoteViews</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的工作原理]]></title>
    <url>%2F2018%2F03%2F01%2FView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRoot和DecorView这是在View三大流程之前(measure, layout, draw),需要了解的概念. ViewRoot对应于ViewRootImpl, 它是连接WindowManager和DecorView的纽带. View的三大流程都是通过ViewRoot来完成的. 当一个Activity对象在ActivityThread被创建后. 会将DecorView添加到Window中, 同时会创建ViewRootImp对象, 并将ViewRootImpl对象和DecorView建立关联. View绘制流程是从ViewRoot的PerformTraversals()开始的. 经过三大流程才能将一个View绘制出来. PerformTraversals()会依次调用performMeasure, performLayout, performDraw. 而前两种内部的调用基本一致,都是先调用measure()/layout(),然后再调用onMeasure()/onLayout()在这个方法中会对所有子元素进行测量和绘制.依次向内部传递. performDraw()有点不同是在draw调用的dispatchDraw(). PerformTraversals绘制流程如下图： ​ measure过程: 决定了View宽高, measure后可以通过getMeasureWidth和getMeasureHeight来获取View的宽高. 一般情况下是最终宽高. layout过程: 决定了View的顶点坐标和实际View的宽高. 完成后通过getTop, getBottom, getLeft, getRight获得四个顶点, 通过getWidth,和getHeight获得宽高 draw过程: 只有draw()方法完成之后View的内容才会显示出来. 12setContentView(R.layout.activity_inside_intercept);((ViewGroup) getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); 上面第一行可以说无时无刻不存在. 而下面这行在上一章说过就是获得我们设置的布局.那DecorView布局究竟是怎么样的, 下图. DecorView就是一个FrameLayout. 而一般情况下它的布局就如上面图那样(具体和主题有关系). 而我们经常setContentView(xxx). 就是把我们编写的xml的布局添加到了DecorView的android.R.id.content的控件布局中. 所以也就能说通为什么getChildAt(0)会获得我们的的布局.并且为什么我们用的关联布局的方法是setContent… MeasureSpec 很大程度上决定一个View的尺寸规格, 之所以不是绝对, 是因为这个过程还受父容器的影响. 理解MeasureSpecMeasureSpec本身是一个32位的int值, 但是却表示了两种信息. 高2位: 代表了SpecMode, 测量模式 低30位: 代表了SpecSize, 在上述测量模式中的大小 1234567891011121314151617181920212223242526272829303132public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; .....&#125; 是不是挺有意思. 三种类型分别高二位01, 00, 10来代表. 直接利用位运算. 来实现可以让频繁计算的东西使用最接近计算机的运算方式. 不需要额外的转换. 也避免了过多的对象内存分配. 说一下SpecMode的三种模式 UNSPECIFIED: 父容器不对View有任何的限制,要多大就给多大, 这种情况一般用于系统内部,表示一中测量状态 EXACTLY: 父容器已经检测出View所需要的精确大小, 这个时候View的最终大小就是SpecSize所指定的值. 对应着LayoutParams中的match_parent和具体的数值. AT_MOST: 父容器制定了一个可用的大小及SpecSize, View的大小不能超过这个值, 它对应与LayoutParams中的wrap_content MeasureSpec和LayoutParams关系通常设置的LayoutParams,系统会在父容器的的约束下转换成对应的MeasureSpec,然后根据这个MeasureSpec来确定View测量后的宽高. 所以View自身的MeasureSpec是需要LayoutParams和父容器一起组合生成的. 上面讲述的是普通View, 但是顶级View(DecorView)有所不同. DecorView是物理窗口尺寸和自身的LayoutParams决定的. 具体在ViewRootImpl类measureHierarchy()进行生成的. MeasureSpec一旦确定, onMeasure中就可以测量View的宽高. 对于我们日常操作的View View的measure过程是由ViewGroup传递而来的. 看ViewGroup#measureChildWithMargins()方法 123456789101112131415protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 上面会对子元素进行measure, 而在此之前,会通过getChildMeasureSpec()来得到子元素的MeasureSpec. 通过调用方法传入的参数看到. 生成View的MeasureSpec和父容器的MeasureSpec, View自身方向的padding``margin, 和自身的LayoutParams这三个因素相关联. 而其中的getChildmeasureSpec()方法: 就是根据父容器的MeasureSpec同时结合View自身的LayoutParams来确定子元素的MeasureSpec.这个方法总结如下: dp/px: 不管父容器的MeasureSpec是什么. View都是EXACTLY(精确模式), 而大小遵循自身LayoutParams的大小. match_parent: 如果父容器是EXACTLY(精确模式),那么子View也是EXACTLY(精确模式)并且大小是父容器的剩余空间. 如果父容器是AT_MOST(最大模式),那么子View也是AT_MOST(最大模式)并且大小不会超过父容器的剩余空间. wrap_content: 不管父容器是什么. View都是AT_MOST(最大模式), 并且大小不能超过父容器剩余空间. 上述没有说明UNSPECIFIED在match_parent和wrap_content中. 因为这个模式主要用于系统多次Measure的情形,一般来说不需要关注. 普通View的MeasureSpec的创建流程,规则如下表所示： View的工作流程 主要指measure, layout, draw三大流程. 即测量,布局,绘制. measure过程这里面存在两种场景: View: 通过了measure方法就完成了测量过程 ViewGroup: 除了测量自己,还会遍历去调用所有子元素的measure方法. 各个子元素在递归去执行这个流程 View的measure过程 View的measure过程由其measure()方法来完成, measure()方法是一个final类型, 而在内部调用了onMeasure()这个可不是final, 所以也可以自定义的时候复写. 看一下内部. 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; setMeasureDimension()会设置View宽高的测量值. 这里需要看一下getDefaultSize()这个方法. 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 看到如果这个view是EXACTLY(精准模式), 那么返回的大小就是==SpecSize==. UNSPECIFIED一般用于系统测量先不说. 而AT_MOST(最大模式)的时候. 虽然是不同模式但是默认情况下和精确模式是一样的结果. getSuggestedMinimumWidth()和getSuggestedMinimumHeight(). 看一下实现. 1234567protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; 首先会看是否设置了背景. 无背景: 那么宽度为mMinWidth,这个值对应布局中的android:minWidth属性,默认为0. 有背景: 那么取mMinWidth和mBackground.getMinimumHeight()最大值. 而getMinimumHeight()根据看一下: 1234public int getMinimumHeight() &#123; final int intrinsicHeight = getIntrinsicHeight(); return intrinsicHeight &gt; 0 ? intrinsicHeight : 0;&#125; 原来getMinimumHeight()返回的就是Drawable的原始高度. 如果没有就返回0. 关于原始高度举个例子ShapeDrawable无原始宽高, BitmapDrawble有原始宽高就是图片的尺寸. 整理getDefaultSize(): 直接继承View的自定义控件需要重写onMeasure()方法并设置wrap_content时的自身大小,否则在布局中使用wrap_content虽然View自身的MeasureSpec的低30位保存了父容器计算自身的剩余大小. 但是在==自定义的时候如果不进行处理wrap_content,那么就会调用默认setMeasureDimension()方法. 而默认中方法的实参传递的是getDefaultSize()这个方法中对AT_MOST这种模式没有处理. 直接沿用和精确模式的大小(相当于设置了wrap_content却得到了match_parent的显示结果)== 可以针对这个问题, 做出对应的编码进行解决: 123456789101112131415161718192021222324@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpaceMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpaceMode = MeasureSpec.getMode(heightMeasureSpec); //设置两个默认值宽高 int defaultHeight = 100; int defaultWidth = 100; // 针对AT_MOST模式进行特殊处理 if (widthSpaceMode == MeasureSpec.AT_MOST &amp;&amp; heightSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, defaultHeight); &#125; else if (widthSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, heightSpaceSize); &#125; else if (heightSpaceMode == MeasureSpec.AT_MOST) setMeasuredDimension(widthMeasureSpec, defaultHeight); &#125; &#125; ViewGroup的Measure 对于ViewGroup不光会测量自己,还会遍历调用所有的子元素的measure(). 和View不同的是ViewGroup是一个抽象类,它没有重写onMeasure,但提供了measureChildren()的方法. 这个measureChildren()方法内部比较简单就是遍历自己的孩子然后调用-&gt;measureChild() 这个measureChild()这个方法前面贴过源码. 就是取出子元素的LayoutParams,并调用-&gt;getChildMeasureSpec(). 通过传入子元素的LayoutParams里面的宽高属性, 子元素的padding和margin, 父元素当前(当前ViewGroup)的MeasureSpec属性来计算出子元素的MeasureSpec最后调用-&gt;child.measure()传入之前计算的测量规格. ViewGroup为什么没有定义测量的具体过程? 因为具体的测量过程需要交给子类去实现的. 比如LinearLayout,RelativeLayout. 看一下LinearLayout的onMeasure()是如何定义的. 12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; 根据设置的排列方式这里分之了两种测量方法. 稍微看一下大概轮廓,选择measureVertical()不贴源码了这个方法300行呢! 首先这个方法会遍历每个子元素并执行-&gt;measureChildBeforeLayout()方法.这个方法内部会调用子元素的measure(), 这样子元素会依次测量. 并且会通过mTotalLenght这个变量来存储LinearLayout在竖直方向上的初步高度, 每测量一个就会增加. 当子元素测量完之后,LinearLayout会测量自己的大小. 在对自己进行测量的时候. 如果布局中的高度采用的是match_parent或者具体数值, 那么它的测量过程和View一样,即高度为specSize. 如果布局中采用wrap_content那么高度就是所有的子元素总和但是不能超过父元素剩余空间, 还有竖直方向LinearLayout的padding. 具体可参考resolveSizeAndState()的实现. 到这里基本上measure测量过程已经做了比较详细的分析. 这个过程也是三大过程中最复杂的一个. 在measure完成之后就可以通过getMeasuredWidth/Height方法获取View的测量宽高. 但是请注意:某些极端情况下,measure可能执行多次. 所以尽量在onLayout()方法中去获得最终宽高. 正确获取宽高方法首先明确一点:View的measure和Activity的生命周期方法不是同步执行.所以无法保证在某个生命周期(onCreate,onStart)获取到正确的测量宽高 Activity/View#onWindowFocusChanged() view.post(runnable) ViewTreeObserver#onGlobalLayout view.measure() onWindowFocusChanged():View已经初始化完毕,宽高已经准备好. 这里需要注意只要Activity的焦点发生变化此方法就会被调用.所以如果你的界面会频繁的进行onPause和onResume.并且里面有很多关联依赖的方法. 那就请注意这不是一个好办法. 通过post可以将一个runnable投递到消息队列的尾部,然后等待Looper调用此runnable的时候.View已经初始化完毕. 使用ViewTreeObserver. 当View的可见性发生了改变的时候.onGlobalLayout()将发生回调.注意伴随着View树的状态改变等,这个回调方法可能会被调用多次. 使用代码如下 123456789ViewTreeObserver viewTreeObserver = view.getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); int height = view.getMeasuredHeight(); int width = view.getMeasuredWidth(); &#125; &#125;); view.measure(widthMeasureSpec, heightMeasureSpec) 也可以手动进行测量,但是需要分情况处理. match_parent 当View是此属性的时候无法使用measure(),首先使用这种方法需要的参数,是通过父容器和子元素组合来生成的子元素的MeasureSpec属性. 所以在外部我们不知道父元素的参数值得时候只能处理不需要父元素数据就可以生成子元素的MeasureSpec的模式 所以很清楚, 这个match_patch这个模式,在给其子元素构造MeasureSpec的时候需要得值parentSize,所以得到的也是无效. 具体数值px/dx 假设这里是100px, 首先构成宽高对应的MeasureSpec属性 123int widthSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int heightSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY); view.measure(widthSpec, heightSpec); wrap_content 123int widthSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST);int heightSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST); view.measure(widthSpec, heightSpec); 通过(1&lt;&lt;30) - 1 可以构成一个MeasureSpec低30位的最大值. 用理论上View能支持的最大值去构造MeasureSpec 关于网上一些在make的使用传入UNSPECIFIED,属于违背了内部实现的规范.不用最好 关于网上另一种measure()直接传入LayoutParams.WRAP_CONTENT. 其实也只有当子元素为wrap_content和子元素为match_parent并且父元素是wrap_conetnt时会碰巧有效. layout过程在ViewGroup中会先通过layout()方法确定本身的位置. 然后调用onLayout()方法遍历所有的子元素,并调用子元素的layout()方法确定子元素的位置…依次循环. 提出View的layout方法, 这里抽取部分代码 123456789101112public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); &#125; &#125; 这样来看,大致流程通过setFrame()方法来设定View的四个顶点的位置, 即mLeft,mTop,mBottom,mRight,这四个顶点一旦确定.当前View的位置也就确定. 然后会调用onLayout()方法. 这个方法是确定子元素的View位置. 这里的和onMeasure()类似, onLayout()具体实现和具体的布局有关, 所以View和ViewGroup均没有真正实现onLayout()方法. 看一下LinearLayout的onLayout()源码 12345678@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; 和onMeasure()一样分支,接下来跟进layoutVertical()贴出主要代码 1234567891011121314151617181920212223242526272829303132void layoutVertical(int left, int top, int right, int bottom) &#123; //省略一部分... for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; //省略一部分... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; 上面代码大体逻辑: 首先遍历所有孩子并调用setChildFrame()来为子元素指定对应的位置. 其中childTop会逐渐增大, 这就意味着后面的子元素会被放置在靠下的位置. 而setChildFrame()内部仅有一行代码, 就是调用子元素的layout()并传入它自身应该存放的位置. 123private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; 而在setChildFrame()中传入的宽高就是子元素的测量宽高. 而在子元素的layout()中通过setFrame()来设置元素的四个顶点. View的测量宽高getMeasureWidth()/getMeasureHeight() 和 layout后用getWidth()/getHeight()获得的最终宽/高有什么区别? 在一般情况下,测量measure和layout时候的值是完全一样的. 因为layout()中接受的参数就是通过测量的结果获取到的. 并且内部直接通过setFrame()赋值到自己的四个成员变量上. 但是如果对layout()进行了复写.如下 1234 @Overrideprotected void layout(int l, int t, int r, int b) &#123; super.layout( l, t+200, r, b+200);&#125; 如果进行了这样的复写, 那么最终宽高永远会与测量的出来的值相差200,但是这样做会导致显示不正常，并没有什么意义. draw过程这个过程只是将View绘制到屏幕上面. 绘制背景background.draw(canvas) 绘制自己onDraw() 绘制childrendispatchDraw() 绘制装饰onDrawScrollBars() View绘制过程传递是通过dispatchDraw()实现的. 传递了自己的画布. 这个方法会遍历子元素并且调用元素的draw() View一个特有的方法setWillNotDraw(), 这个方法是设置了true那么系统会进行相应的优化. 在View中默认是关闭的. 而ViewGroup默认是开启的. 如果我们继承了自定义ViewGroup如果还需要绘制自己的内容那么需要显示的关闭此标记. 自定义View自定义View的分类相关代码 1.继承View重写onDraw方法 这种方法主要用于实现一些不规则的效果, 不方便组合布局实现,或者又有动态显示的一些图形. 需要自己绘制那么就重写onDraw()方法. 这种方法需要自己支持wrap_content和padding 2.继承ViewGroup派生特殊Layout 这种方式用于实现自定义布局, 这种布局的实现稍微复杂,需要合适的处理ViewGroup的测量,布局这两个过程,并同时处理子元素的测量和布局过程. 3.继承特定的View(TextView) 比较常见, 一般用于扩展已有的View的功能. 这种不需要自己处理wrap_content和padding 4.继承特定ViewGroup(LinearLayout) 当某种效果看起来像几种View的组合在一起的时候,可以采用这种方式. 这种方式不需要自己处理ViewGroup的测量和布局. 其实这种方式和2没什么区别, 主要是2更接近于底层的View实现. 自定义View的须知 让View支持wrap_content 最好让你的View支持padding -&gt; 如果直接继承View,在draw()中不处理padding,那么属性是无法起作用的. 还有继承ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin会造成的影响. 尽量不要在View中使用Handler -&gt; 内部已经提供了post系列方法. 除非很明确要是用Handler发送消息. View中如果有线程或者动画,需要及时的停止.-&gt; 当包含此View的Activity退出或者此View被remove的时候,View的onDetachedFromWindow()会被调用,可以适当处理防止内存泄漏. View带有的滑动嵌套时,需要处理好滑动冲突. 自定义View实例1.自定义View派生类 首先写一个类继承View, 并在ondraw()画一个圆. 并设置margin属性. 效果没有问题,因为margin属性是由父容器控制的. 问题1:这里把android:layout_width=&quot;wrap_content&quot;设置根据内容. 发现无效. 对于直接继承View的空间，不管是设置match_parent也好,wrap_content也好父容器都会给分配自己剩余空间的大小给子容器作为specSize的空间大小这时需要手动处理. 如果不对wrap_content处理那就是相当于和match_parent填充父容器的效果一样. 所以增添对onMeasure()方法中的AT_MOST模式的制定默认大小, 然后在运行, ok,如下 问题2:这时加上属性padding=20dp发现无效. 无变化. 之前说过margin是交给父容器分配的.padding确实要自己要分配处理的. 这时需要在onDraw()来处理. 处理后如下 问题3:有时候我们需要提供自定义属性. 例如android:id=这种. 接下来添加自定义属性. 在values目录下创建自定义属性的xml. 名字随便当最好attrs.xml或者attrs_xxx_xxx.xml. 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;declare-styleable name=&quot;CircleView&quot;&gt; &lt;attr name=&quot;circle_color&quot; format=&quot;color&quot;/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 上面相当于,定义了一个CircleView的属性集合. 在这个集合里面会有自定义属性. 这里的format格式可以是指定尺寸的dimension, 资源id引用的reference, 基本类型string, integer ,boolean等. 声明好了属性在我们自定义View中就可以引用处理了. 如构造方法中. 1234567891011public CircleView(Context context, AttributeSet attrs) &#123; super(context, attrs, defStyleAttr); //获得一个自定义的对应属性值集合 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView); //取出属性集合中的某个属性值 mColor = typedArray.getColor(R.styleable.CircleView_circle_color, Color.GREEN); //释放资源 typedArray.recycle(); init(); &#125; 在布局中使用即可. 先声明schemas. xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; ,使用app来替代之前的类似android前缀的引导. 继承View的派生类就到此为止了.]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的事件体系]]></title>
    <url>%2F2018%2F02%2F28%2FView%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[View 的基础知识 View的位置参数 View相对于父容器的坐标top，left，right，bottom。 12width = right - leftheight = bottom - top 从Android 3.0开始增加了x、y、translationX、tranlationY；其中： View也提供了相应的get/set方法，关系换算： 12x = left + translationXy = top + translationY 注意⚠️：View在平移的过程中，top和left的值并不会改变，此时发生改变的是x、y、translationX和translationY。 MotionEvent 和 TouchSlop ACTION_DOWN——手指刚接触屏幕 ACTION_MOVE——手指在屏幕上移动 ACTION_UP——手指从屏幕上松开的一瞬间 getX/getY返回的是相对于当前View的左上角的x和y的坐标，而getRawX/getRawY返回的是是相对于手机屏幕左上角的坐标。 TouchSlop 是系统能识别出的被认为是滑动的最小距离(8dp)。 ViewConfigrarion.get(getContext()).getScaledTouchSlop() VelocityTracker、GestureDetector和Scroller VelocityTracker用于追踪手指在滑动过程中的速度。 GestureDetector 手势检测，用于检测单击、滑动、长按、双击等行为。需要实现接口onGestureListener和onDoubleTapListener比较常用的有：onSingleTapUp（单击）、onFling（快速滑动）、onScoll（拖动）、onLongPress（长按）、onDoubleTap（双击）。 Scroll实现弹性滑动。 ​ View的滑动 使用scrollTo/srollBy123public void scrollTo (int x, int y);//绝对坐标滑动public void scrollBy(int x, int y);//相对坐标滑动 如果从左到右滑动，那么mSrollX为负值，反之为正；如果从上往下滑动，那么mScrollY为负值，反之为正；使用scrollTo和scrollBy来实现View的滑动，只能将View的内容进行移动，不影响内部元素的点击事件，但是并不能改变View的原始布局位置。 使用动画 View动画，用xml实现 View 动画是对View的影像做操作，并不能真正的改变View的位置参数和宽高；并且如果希望动画后的状态保留必须设置fillAfter属性为true。适用于没有交互性的（点击）场景。 属性动画 1ObjectAnimator.ofFloat(targetView, "translationX", 0, 100).setDuration(100).start(); 属性动画能够改变原始位置，没有缺点，优先推荐使用。 ​ 改变布局参数改变View的布局参数LayoutParams，适用于有交互的View，操作稍微复杂。 弹性滑动使用Scroller Scroller 本身不能实现 View 的滑动，它需要配合 View 的 computeScroll 方法才能完成弹性滑动的效果。通过不断地让 View 重绘，而每一次重绘距离滑动其实起始时间会有一个时间间隔，通过这个时间间隔 Scroller 得出 View 当前的滑动位置，知道了滑动位置就可以通过 scrollTo 方法完成 View 的滑动。 View 的每一次重绘都会导致 View 的小幅度滑动，而多次的小幅度滑动组成了弹性滑动，这就是 Scroller 滑动的工作机制。 123456789101112131415161718192021Scroller mScroller = new Scroller(mContext);// 缓慢滚动到指定的位置 private void smoothScrollTo(int destX, int destY)&#123; int scrollX = getScrollX(); int deltaX = destX - scrollX; // 以 1000ms 内滑向 destX， 效果是慢慢滑动 mScroller.startScroll(scrollX, destY, deltaX , 0, 1000); // View 的重绘 invalidate();&#125; // 重写 computeScroll 方法，并在内部完成平滑滚动的逻辑 @Overridepublic void computeScroll() &#123; //判断view是在指定时间内是否完成滑动,并计算出当前时间的 mScrolleX 和 mScrollY if (mScroller.computeScrollOffset())&#123; //通过mScroller获取当前位置，实现滑动 scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // 再次进行重绘 postInvalidate(); &#125;&#125; 通过动画属性动画：12ObjectAnimator animator = ObjectAnimator.ofFloat(view, "translationX", 0.0f, 100.0f);animator.setDuration(100).start(); 或者 1234567891011121314151617181920private void scroller()&#123; //动画起始位置 final int startX = 0; //动画要滑动的距离 final int deltax = 1000; final ValueAnimator animator = ValueAnimator.ofInt(0, 1).setDuration(2000); //动画添加监听器 animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //获取动画完成比例值 float fraction = animator.getAnimatedFraction(); //根据比例值对目标view进行滑动 targetView.scrollTo(startX +(int)(deltax * fraction), 0); //add other operation &#125; &#125;); //开始执行 animator.start();&#125; 第二种方法思想和Scroller很类似，通过时间流逝比例来计算滑动距离。 使用延迟策略 使用Handler或者View的postDelay方法，间隔的发送消息，计算滑动距离，并使用scrollTo完成滑动。 View的事件分发 点击事件的传递规则1public boolean dispatchTouchEvent(MotionEvent ev) 用来进行事件的分发，如果事件能够传递给当前的View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级的View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 1public boolean onInterceptTouchEvent(MotionEvent event) 在dispatchTouchEvent内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 1public boolean onTouchEvent(MotionEvent event) 在dispatchTouchEvent中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件。 伪代码表示： 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onIterceptTouchEvent(ev)) &#123; //拦截事件 consume = onTouchEvent(ev); //自己处理事件 &#125; else &#123; consume = child.dispatchTouchEvent(ev); //分发给子View处理事件 &#125; return consume;&#125; 注意⚠️如果一个View设置了OnTouchListener，那么onTouch方法将优先被调用；如果onTouch方法返回ture，onTouchEvent方法将不会被调用，返回false，onTouchEvent方法会被调用；在onTouchEvent中，如果设置了OnClickListener，那么它的onClick方法将被调用。优先级：onTouch—&gt;onTouchEvent—&gt;onClick 事件传递顺序：Activity—&gt;Window—&gt;View, 如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将被调用，以此类推，如果所有元素都不处理这个事件，那么最终传递给Activity的onTouchEvent来处理。 一个事件序列，从ACTION_DOWN开始，中间有数量不定的ACTION_MOVE,最终以ACTION_UP结束。 一个事件序列只能被一个View拦截且消耗，一旦某个View决定拦截，那么这个事件序列都只能由它来处理，并且它的onIterceptTouchEvent不会再被调用（onIterceptTouchEvent仅仅调用一次）。 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回false），那么同一事件序列中的其他事件都不会再交给它处理，并且事件将重新交给它的父元素去处理。 ViewGroup默认不拦截任何事件，onInterceptEvent方法默认返回false。 View没有onInterceptEvent方法，一旦有事件传递给它，那么onTouchEvent方法就会被调用。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable默认都为false。enable属性不影响onTouchEvent的返回值。 onClick发生的前提是View是可点击的，并且收到了down和up事件。 事件传递过程是由父元素分发到子元素，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预夫元素的事件分发过程（ACTION_DOWN除外）。 事件分发源码解析Activity对点击事件的分发过程 1Activiy—&gt;Window(PhoneWindow)—&gt;DecorView—&gt;ContentView—&gt;顶级ViewGroup—&gt;Views 顶级View对点击事件的分发过程 View对点击事件的处理 ​ /&gt; 总结： 参考: Android事件分发机制详解 [ Android事件分发机制完全解析，带你从源码的角度彻底理解(下)] View 的滑动冲突常见的滑动冲突场景： 场景1——外部滑动方向和内部滑动方向不一致（ViewPager + ListView） 场景2——外部滑动方向和内部滑动方向一致（SrcollView + ListView） 场景3——上面两种情况的嵌套（SlideMenu + ScrollView + ListView） 怎么处理？利用事件分发机制，针对滑动冲突使用外部拦截法和内部拦截法 外部拦截法 指点击事件通过父容器的拦截处理，如果父View需要拦截就拦截，否则交给子View处理，这种方法符合事件的分发机制。需要重写父容器的onInterceptTouchEvent方法。 12345678910111213141516171819202122232425262728public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; //必须返回false break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (满足父容器的拦截要求) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; //必须返回false break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 根据业务逻辑需要，在ACTION_MOVE方法中进行判断，如果需要父View处理则返回true，否则返回false，事件分发给子View去处理。 ACTION_DOWN 一定返回false，不要拦截它，否则根据View事件分发机制，后续ACTION_MOVE 与 ACTION_UP事件都将默认交给父View去处理！ 原则上ACTION_UP也需要返回false，如果返回true，并且滑动事件交给子View处理，那么子View将接收不到ACTION_UP事件，子View的onClick事件也无法触发。而父View不一样，如果父View在ACTION_MOVE中开始拦截事件，那么后续ACTION_UP也将默认交给父View处理！ 内部拦截法 即父View不拦截任何事件，所有事件都传递给子View，子View根据需要决定是自己消费事件还是给父View处理。这需要子View使用requestDisallowInterceptTouchEvent方法才能正常工作。下面是子View的dispatchTouchEvent方法的伪代码： 12345678910111213141516171819202122232425262728public boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; parent.requestDisallowInterceptTouchEvent(true);//父容器设置不拦截 break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) &#123; parent.requestDisallowInterceptTouchEvent(false);//父容器设置拦截 &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 父View需要重写onInterceptTouchEvent方法： 12345678public boolean onInterceptTouchEvent(MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125; 使用内部拦截法需要注意： 内部拦截法要求父View不能拦截ACTION_DOWN事件，由于ACTION_DOWN不受FLAG_DISALLOW_INTERCEPT标志位控制，一旦父容器拦截ACTION_DOWN那么所有的事件都不会传递给子View。 滑动策略的逻辑放在子View的dispatchTouchEvent方法的ACTION_MOVE中，如果父容器需要获取点击事件则调用 parent.requestDisallowInterceptTouchEvent(false)方法，让父容器去拦截事件。 参考： 一文解决Android View滑动冲突]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>View的事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 源码分析1]]></title>
    <url>%2F2018%2F02%2F26%2FRxJava%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901%2F</url>
    <content type="text"><![CDATA[基于 RxJava 2.1.2 给定下面的一段代码，从源码的角度分析 RxJava 的实现原理： 12345678910111213141516171819202122232425262728293031323334353637ObservableOnSubscribe&lt;Integer&gt; oos = new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(max); &#125; e.onComplete(); &#125;&#125;;Observer&lt;Integer&gt; o = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;;Observable.create(oos) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.computation()) .subscribe(o); 分析源码之前，我们先定义一下名词，RxJava 是基于观察者模式的，这里将被观察者叫做主题（Source），观察者叫做观察者（Observer）。 上面的代码首先创建了一个主题对象，然后又创建了一个观察者对象，最后将两者关联起来，并且最重要的一点，指定了主题对象和观察者对象执行的线程。 Observable.create(oos)首先分析这行代码做了什么事情： 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ObjectHelper 只是用来做非空判断，这里就不用管它了。看看 RxJavaPlugins 做了什么： 123456789101112131415/** * Calls the associated hook function. * @param &lt;T&gt; the value type * @param source the hook's input value * @return the value returned by the hook */@SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;)@NonNullpublic static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 注释上都说了，这是一个钩子函数，也就是说如果 onObservableAssembly 的值不为空，那么就调用这个钩子函数，onObservableAssembly 是一个静态变量，需要我们主动的去设置才会赋值，这里当做空来考虑，如果 onObservableAssembly 为空的话，也就是说这个方法啥都没做，直接返回 source 参数，也就是上面的 ObservableCreate 对象。 总结一下，Observable.create(oos) 只是创建了一个 ObservableCreate 对象。这个方法就暂时先分析到这里，至于这个对象内部有什么东西，我们后面会说到。 observeOn(AndroidSchedulers.mainThread())既然之前的 create 方法创建了一个 ObservableCreate 对象并返回，也就是说 observeOn(Schedulers.computation()) 这个方法是调用的 ObservableCreate 这个对象上的方法。 1public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; ObservableCreate 是继承至 Observable 的。 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; Observable 的 observeOn 是 final 的，所以走的父类的方法。继续跟踪 observeOn 调用的同名方法： 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; ObjectHelper 跳过。这里又是一个 onAssembly 方法的调用，我很好奇这个单词是什么意思。点进去看一下： 1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 同样是一个钩子方法，现在也是有经验的人呢，再看到这个方法，就直接跳过，只关心它传递的参数和返回值就行了。它的返回值默认就是传递进来的参数。 所以，observeOn 方法就是创建并返回了一个 ObservableObserveOn 对象（大神教你起类名系列二），这里预警一下，之后像这样类似的类名差不多还有3个。 subscribeOn(Schedulers.computation())由于 observeOn 创建并返回了一个 ObservableObserveOn 对象，所以这里调用的是 ObservableObserveOn 对象上的方法。 1public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; 也是继承至 Observable 。 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 不出意料，也是 final 的，创建了一个 ObservableSubscribeOn 对象（大神教你起类名系列三）并返回。 subscribe(o)前面 subscribeOn 创建了一个 ObservableSubscribeOn 对象并返回，所以这里调用的是 ObservableSubscribeOn 这个对象上面的方法。 1public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; 继承至 Observable 类。 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 这个方法也是 final 的，所以是调用的这个方法。 public final void subscribe(Observer&lt;? super T&gt; observer) { … } 这个方法是我们需要分析的重点，看看内部具体的代码吧先： 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 这里忽略 ObjectHelper 和异常处理的代码只有两行代码是关键。 先看 observer = RxJavaPlugins.onSubscribe(this, observer); 1234567public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) &#123; BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe; if (f != null) &#123; return apply(f, source, observer); &#125; return observer;&#125; 没想到啊没想到，你这浓眉大眼的家伙也是一个钩子方法。所以这行代码相当于 obsever = observer; 接着看，subscribeActual(observer); 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 这是一个抽象方法，没啥好分析的。 接下来我们要进入正题了，根据我们编写的代码，是 ObservableSubscribeOn 这个对象调用了 subscribe 方法，所以我们看看这个类的 subscribeActual 方法。 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 这里需要注意的是 s 这个参数，后面会有很多地方看到这个参数，一定要搞清楚这个参数是谁传递过来的。比如说： 12A.subscribe(B)那么，参数 s 就是 B。 在我们的代码中是 ObservableSubscribeOn.subscribe(o); 理解了这一点，我们详细分析代码里面的内容：首先创建了一个 SubscribeOnObserver （大神教你起类名系列四）。然后调用了我们创建的对象 o 的 onSubscribe 方法： 1234@Overridepublic void onSubscribe(Disposable d) &#123;&#125; 我们的 onSubscribe 方法里面啥都没做。不过一般来说，你应该调用一下 onStart 方法。 接下来是调用 parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); setDisposable 的方法不影响流程分析，这里就先跳过了，有兴趣的可以点进去看一下。然后就是 scheduler 变量，这个变量就是我们使用 subscribeOn 传递的参数： 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; 这个 scheduler 就是 Schedulers.computation()。然后调用了它的 scheduleDirect 方法： 123public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125; 1234567891011public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); w.schedule(task, delay, unit); return task;&#125; 这两个方法是父类的，Schedulers.computation() 返回的是一个 ComputationScheduler 对象，这里找具体的实现类由于调用链比较长，就不给出了，自己点着点着就能找到了。看看 ComputationScheduler 有没有复写这两个方法： 123456@NonNull@Overridepublic Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) &#123; PoolWorker w = pool.get().getEventLoop(); return w.scheduleDirect(run, delay, unit);&#125; 它覆盖了父类的第2个 scheduleDirect 方法。这里就不深入分析里面的池了。看 w.scheduleDirect(run, delay, unit);： 12345678910111213141516public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 熟悉的线程池使用代码。希望看到这里你还没有忘记我们要分析的是什么。简单的归纳一下，其实就是向我们创建的 scheduler 里面提交了一个 runnable。最终这个 Runnable 肯定会执行，那么看看这个 Runnable 里面有什么代码： 1parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); 123456789101112final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; run 方法里面就只有一句代码，但是我们需要搞清楚这里的 source 和 parent 分别是哪个对象。 parent 可以直接看到是 SubscribeOnObserver 对象。 source 是使用的外部类的变量。 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; 这里调用了 super 方法，所以构造函数里传递的变量就是 source。 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 这里是我们之前分析过的创建 ObservableSubscribeOn 的代码，这里的 this 指的是 observeOn 创建的 ObservableObserveOn 对象。希望看到这里你没有搞晕，如果你是使用手机看的，并且看懂了，我是真的佩服。 也就是说，run 里面的代码就是调用了 ObservableObserveOn 对象的 subscribe 方法。之前我们分析过了，subscribe 方法实际上没有做什么，只是调用了 subscribeActual 方法，所以我们进入这个类内部看看： 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 我们在 observeOn 传递的 scheduler 不是 TrampolineScheduler 类型的，所以只需要看 else 的代码。这里是先创建了一个工作线程（由于我们使用的是 AndroidScheduler，所以这里是指的主线程），然后调用了 source 的 subscribe 方法。需要注意的是这里最后创建了一个 ObserveOnObserver 对象（大神教你起类名系列五）。 先看看 createWork，在 HandlerScheduler 中： 1234@Overridepublic Worker createWorker() &#123; return new HandlerWorker(handler);&#125; 返回了一个 HandlerWorker 对象。 再看 source.subscribe()，首先这里的 source 指的是 create 方法创建的 ObservableCreate 对象，调用 subscribe 传递的是 ObserveOnObserver。看看这个对象的 subscribeActual 方法： 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 这里的参数 observer 是 ObserveOnObserver，source 是我们代码中创建的 oos 对象。 首先创建了一个 CreateEmitter 对象。 接着看 ObserveOnObserver 的 onSubscribe 方法做了啥： 12345678910111213141516171819202122232425262728293031@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.validate(this.s, s)) &#123; this.s = s; if (s instanceof QueueDisposable) &#123; @SuppressWarnings("unchecked") QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) &#123; sourceMode = m; queue = qd; done = true; actual.onSubscribe(this); schedule(); return; &#125; if (m == QueueDisposable.ASYNC) &#123; sourceMode = m; queue = qd; actual.onSubscribe(this); return; &#125; &#125; queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); actual.onSubscribe(this); &#125;&#125; 这里代码比较长，只分析重要的代码，就是 actual.onSubscribe 这句。actual 是构造函数中赋值的，所以我们回到创建 ObserveOnObserver 的地方，actual 指的是 SubscribeOnObserver 对象。所以它调用了 SubscribeOnObserver 的 onSubscribe 方法。接下来分析一下它的 onSubscribe 方法做了什么，这里不看也不会影响流程。 123456789SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; this.s = new AtomicReference&lt;Disposable&gt;();&#125;@Overridepublic void onSubscribe(Disposable s) &#123; DisposableHelper.setOnce(this.s, s);&#125; 这个方法调用了 setOnce 方法： 1234567891011public static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; ObjectHelper.requireNonNull(d, "d is null"); if (!field.compareAndSet(null, d)) &#123; d.dispose(); if (field.get() != DISPOSED) &#123; reportDisposableSet(); &#125; return false; &#125; return true;&#125; 这里涉及到了乐观锁等玩意，简单来说就是先判断 field 的值是否为空，如果为空则设置为 d，不为空则将 d dispose。然后判断 field 的值，由于 field 的值只能设定一次非 DISPOSED 值，所以如果不为 DISPOSED，说明已经被设置过了，再报出异常，如果为 DISPOSED 是可以再次设置的。按照正常的流程，这里只是将 field 的值设置为 d，然后返回true。这个方法可以先不用管。 回到主线流程上，source.subscribe(parent); 这是最重要的一句代码。source 是在构造函数赋值的，看看构造方法： 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 也就是说这里的 source 是我们代码中创建的 oos 对象。parent 是新创建的 CreateEmitter 对象。看看我们 oos 的 subscribe 方法： 123456789@Overridepublic void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e("aprz", Thread.currentThread().getName()); final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(i); &#125; e.onComplete();&#125; 这里就是事件开始的起点。所有的事件都由 ObservableEmitter 开始发送，看看它的代码，它是一个接口，在我们的例子中，它的实现类是 CreateEmitter，所有我们分析这个类的 onNext 方法： 12345678910@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; isDisposed 方法返回 false 才会去调用 observer 的 onNext 方法，这个 observer 是谁呢? 看到这里我们就要从后往前推一遍之前的代码了，不管你绝不绝望，反正我是很绝望。这的 observer 是 ObserveOnObserver 对象。 接下来我们就进入 ObserveOnObserver 里面，看看它接受事件之后做了什么，上面的参数 e 就是： 1234567891011@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125; 调用了 schedule 方法： 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; 向 work 中提交了一个 Runnable，这里传递的是 this。说明它自己肯定实现了这个接口，我们看看它的 run 方法做了啥： 12345678@Overridepublic void run() &#123; if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125; 这里一般是走 drainNormal 吧，我猜的，我们分析这个方法吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; 代码很长，具体做了啥我们暂时不用关心，只需要注意到 a.onNexe(v) 这行代码，这个 a 是 actual 变量，actual 又是 SubscribeOnObserver 对象，我们看看它的 onNext 方法： 1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; 很简单，这里的 actual 就是我们创建的 o 了，所以最终调用到了我们的代码里面。 好了，到这里一个完整的流程就整理出来了，但是还有一个问题没有解决，就是线程切换是发生在哪里。因为为了不影响整体流程的分析，所以上面并没有去分析线程切换的东西，下面开始分析。 直接从 subscribeOn 开始，看 ObservableSubscribeOn 的代码 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 从这里开始就进行了线程的切换，根据上面的分析我们知道这里是将 SubscribeTask 作为一个 Runnable 对象给提交进了我们指定的 scheduler （subscribeOn 传递的）中。所以后面的流程都是在 scheduler 所在的线程在运行。 再看 observeOn，看 ObservableObserveOn 的代码。 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 这里的线程切换是发生在 ObserveOnObserver 这个对象的里面。 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; schedule 的流程，我们上面分析过，worker.schedule(this) 这行代码就发生了线程切换，是将 this 作为 Runnable 对象提交到了我们指定的（observerOn 传递的）scheduler 中。具体分析，由于之前的流程是在别的线程中，所以想要进行线程切换，最先想到的肯定是 Handler。由于我们传递的是 AndroidSchedulers.mainThread()，所以我们就分析这个吧。 AndroidSchedulers.mainThread() 的实现是 HandlerScheduler。看看它的 schedule 方法： 1234567891011121314151617181920212223242526@Overridepublic Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; if (run == null) throw new NullPointerException("run == null"); if (unit == null) throw new NullPointerException("unit == null"); if (disposed) &#123; return Disposables.disposed(); &#125; run = RxJavaPlugins.onSchedule(run); ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker's runnables. handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) &#123; handler.removeCallbacks(scheduled); return Disposables.disposed(); &#125; return scheduled;&#125; post 了一个 msg，这样就完成了线程的切换。 下面上一张图，有助于理解和记忆： 只需要理解，每次 observerOn 和 subscribeOn 的时候，内部都会创建一个新的 observable 和 observer。 新创建的 observable 会引用前面的 observable，就是代码中我们分析的 source 变量。 新创建的 observer 会引用前面的 observer，就是代码中我们分析的 actual 变量。 最后我们 subscribe 的时候，是调用的最后创建的 observable 的方法。而每个 observable 内部又调用了 source 的 subscribe 方法，这样就形成了一层一层往前传递的调用链。当调用到最前面的一个 observable 的时候，就是我们自己创建的 observable，在这里我们需要手动触发该与该 observable 对应的 observer 对象的 onNext 方法。而 observer 的 onNext 方法的内部又调用了 actual 的 onNext 方法，这样就形成了一层一层往后传递的调用链。 虽然在我们的例子中，CreateEmitter 并不是一个 observer ，但是它也有 onNext 等方法，可以把它看做一个 observer。 如此，RxJava 的一个流程就理清楚了。这货的流程和 OkHttp 怎么有点像，只是稍微有点不一样。 2018年01月08日20:49:03 补充一下关于背压的知识：在异步订阅的时候，使用 Observable，默认的缓冲大小是 128，超过 这个数量之后会 resize，也就是说会缓冲所有的事件，这样就会导致内存占用一直增加。]]></content>
      <categories>
        <category>Rxjava</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC机制]]></title>
    <url>%2F2018%2F02%2F22%2FIPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android中的多进程模式开启多进程模式 在AndroidMenifest中为四大组件指定android:process属性 通过JNI在native层fork一个新的进程 查看进程信adb shell ps | grep packagename android:process 属性方式区别 “:remote”开头，进程名为packagename:remote ,属于当前应用的私有进程。 “com.packagename.remote”完整命名则属于全局进程，通过具有相同的ShareUID和签名，两个不同应用可以跑在同一个进程中。具有相同UID的应用可以共享数据（data目录、组件信息等） 多进程模式运行机制 不同的进程的组件会拥有独立的虚拟机、Application、以及内存空间。 多进程注意的问题： 静态成员和单列不能跨进程使用 线程同步失效 SharedPreference的可靠性下降 Application会多次创建 SharePref底层通过读写xml文件实现，并发执行读写操作可能会导致一定几率的数据丢失 ​ IPC基础概念介绍Serializable接口 123456public class User implements Serializable &#123; private static final long serialVersionUID = 87113688048893844L; public int userId; public String userName; public boolean isMale;&#125; 这个serialVersionUID是用来辅助序列化和反序列化的，序列化时会将该字段写入文件中，然后反序列化时检测文件中的serialVersionUID是否与当前类一致。如果不一致，将序列化失败。 最好能够手动指定serialVersionUID，这样版本更新后，我们可能删除或新增了一些Field，但是反序列化仍能成功。不指定的话由于类内部成员变化，所以计算hash值变化，导致反序列失败。 静态成员不参与序列化 transient关键字标记的成员变量不参与序列化 Serialable接口是序列化需要大量I/O操作，开销大 Parcelable接口 Parcelable主要用在内存序列化上，效率高，Android平台推荐用。 但是对象序列化后要网络传输和持久化存储推荐用Serialable。 Binder Binder是客户端和服务端通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务和数据。aidl类核心实现内部类Stub以及Stub的内部代理类Proxy。 DESCRIPTOR Binder的唯一标示，一般用当前Binder的类名 asInterface(android.os.IBinder obj) 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型对象，区分进程，如果客户端和服务端位于同一进程，返回服务端的Stub对象本身，否则返回Stub.proxy对象。 asBinder 返回当前的Binder对象 onTransact 运行在服务端的Binder线程池中，原型为 1public Boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flag) code确定目标方法，data目标参数，reply写入返回值。 Proxy#getBookList 这个方法运行在客户端，客户端远程调用该方法，创建输入型Parcel对象data，输出型Parcel对象_reply和返回值对象List。接着调用transact方法发起RPC（远程过程调用）请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC返回，当前线程继续执行，并从_reply中返回结果。 通过linkToDeath 和 unlinkToDeath给Binder设置死亡代理DeathRecipient，当服务端进程异常终止时，可以收到通知。 Android中的IPC方式 使用Bundle 使用文件共享（考虑并发读写的问题，注意⚠️SharedPrefences不支持跨进程读写） 使用Messenger 信使 使用AIDL ​ 使用Messager ​ Messgener的工作原理 AIDL 服务端：创建一个service来监听客户端的请求，创建一个AIDL文件，暴露出AIDL接口供客户端调用，最后在service中实现这个AIDL接口。 客户端：bindService绑定服务，调用AIDL接口 AIDL文件支持类型：基本数据类型、String、ArrayList、HashMap、Pacelable对象、其他AIDL接口。 注意⚠️自定义的Pacelable对象必须新建一个和它同名的AIDL文件，并显示import进来。 除了基本数据类型，其他参数必须表上方向：in、out、inout 1234##Book.aidlpackage com.ryg.chapter_2.aidl;parcelable Book; 123456789101112##IBookManager.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;import com.ryg.chapter_2.aidl.IOnNewBookArrivedListener;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookArrivedListener listener);//obsever mode void unregisterListener(IOnNewBookArrivedListener listener);&#125; 12345678##IOnNewBookArrivedListener.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;interface IOnNewBookArrivedListener &#123; void onNewBookArrived(in Book newBook);&#125; AIDL中观察者模式的使用，提供一个AIDL接口，客户端需要实现该listener（通过继承该Listener.Stub接口），传递给服务端，服务端处理完成后再回调回客户端。 注册和解注册，使用==RemoteCallbackList==，专门提供用于删除跨进程的listener接口。 如果某个远程方法是耗时的，那么要避免在客户端UI线程中去访问远程方法，否则会导致客户端ANR。客户端的onServiceConnected和onServiceDisconnected方法都运行在UI线程中，所以也不能在这里调用服务端的耗时方法。解决的办法是在非UI线程中调用原厂方法。 同理，如果有服务端需要调用客户端的listener方法，被调用的方法将运行在客户端的Binder线程池中，如果listener中的方法比较耗时，也要注意服务端的ANR问题。 Binder意外死亡重连 给Binder设置DeathRecipient监听（在客户端Binder线程中被回调） 在onServiceDisconnected中重连远程服务（在客户端UI线程被回调） 权限验证 AndroidMenifest.xml声明权限 123&lt;permission android:name="com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE" android:protectionLevel="normal" /&gt; 在服务队的onBind或者onTransact方法中进行权限验证。 使用ContentProvider继承ContentProvider，通过ContentResolver的query、update、insert、delete方法实现数据库SQLiteOpenHelper的CRUD操作。 使用Socket使用ServerSocket—&gt;TCP连接; UDP也是跨进城的通信方式。 Binder连接池 面对多个模块需要用到AIDL，我们不能针对每一个AIDL接口单独创建多个Service。 这种模式下：每个业务模块创建自己的AIDL接口并实现此接口，不同业务模块之间没有耦合，并向服务端提供自己的唯一标识和对应的Binder对象；对于服务端来说，只需要提供一个Service，并包含一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象；不同业务模块拿到自己的Binder对象后就可以进行远程方法调用了。 Binder连接池的作用就是将每个业务模块的Binder请求统一转发到远程的Service中去执行，从而避免重复创建Service。 Binder连接池工作原理 123456## Module A package com.ryg.chapter_2.binderpool;interface ISecurityCenter &#123; String encrypt(String content); String decrypt(String password);&#125; 12345## Module Bpackage com.ryg.chapter_2.binderpool;interface ICompute &#123; int add(int a, int b);&#125; 12345678910## BinderPool aidl interfacepackage com.ryg.chapter_2.binderpool;interface IBinderPool &#123; /** * @param binderCode, the unique token of specific Binder&lt;br/&gt; * @return specific Binder who's token is binderCode. */ IBinder queryBinder(int binderCode);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.ryg.chapter_2.binderpool;import java.util.concurrent.CountDownLatch;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;public class BinderPool &#123; private static final String TAG = "BinderPool"; public static final int BINDER_NONE = -1; public static final int BINDER_COMPUTE = 0; public static final int BINDER_SECURITY_CENTER = 1; private Context mContext; private IBinderPool mBinderPool; //BinderPool aidl interface private static volatile BinderPool sInstance; private CountDownLatch mConnectBinderPoolCountDownLatch; private BinderPool(Context context) &#123; mContext = context.getApplicationContext(); connectBinderPoolService(); &#125; // singleton, double check public static BinderPool getInsance(Context context) &#123; if (sInstance == null) &#123; synchronized (BinderPool.class) &#123; if (sInstance == null) &#123; sInstance = new BinderPool(context); &#125; &#125; &#125; return sInstance; &#125; /** ** 绑定BinderPool的远程服务 **/ private synchronized void connectBinderPoolService() &#123; mConnectBinderPoolCountDownLatch = new CountDownLatch(1); Intent service = new Intent(mContext, BinderPoolService.class); mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE); try &#123; //将bindService这异步操作转为同步的，耗时操作 mConnectBinderPoolCountDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * query binder by binderCode from binder pool * * @param binderCode * the unique token of binder * @return binder who's token is binderCode&lt;br&gt; * return null when not found or BinderPoolService died. */ public IBinder queryBinder(int binderCode) &#123; IBinder binder = null; try &#123; if (mBinderPool != null) &#123; binder = mBinderPool.queryBinder(binderCode); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; return binder; &#125; private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // ignored. &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinderPool = IBinderPool.Stub.asInterface(service); try &#123; mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient, 0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; mConnectBinderPoolCountDownLatch.countDown(); &#125; &#125;; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; Log.w(TAG, "binder died."); mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, 0); mBinderPool = null; connectBinderPoolService(); &#125; &#125;; /** * 当Binder连接池连接上远程服务时，会根据不同模块的标识bindeCode返回不同的Binder对象， * 通过这个对象所执行的操作发生在远程服务器 **/ public static class BinderPoolImpl extends IBinderPool.Stub &#123; public BinderPoolImpl() &#123; super(); &#125; @Override public IBinder queryBinder(int binderCode) throws RemoteException &#123; IBinder binder = null; switch (binderCode) &#123; case BINDER_SECURITY_CENTER: &#123; binder = new SecurityCenterImpl(); break; &#125; case BINDER_COMPUTE: &#123; binder = new ComputeImpl(); break; &#125; default: break; &#125; return binder; &#125; &#125;&#125; 有了BinderPool机制后，如果有一个新的业务模块需要加AIDL，那么在实现的自己的AIDL接口后，只需要修改BInderPoolImpl中的queryBinder方法给自己添加一个binderCode并返回对应的Binder对象即可，不需要创建新的Service。 选用合适的IPC方式 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据 四大组件间的进程通信 文件共享 简单易懂 不适合高并发场景，并且无法做到进程间即时通信 无并发，交换简单的数据、实时性不高的场景 AIDL 功能强大，支持一对多并发通信 使用复杂，需要处理好线程同步 一对多通信有RPC需求 Messager 功能一般，支持一对多串行通信 不能处理并发情形，不支持RPC，数据通过Message传输，只能支持Bundle数据类型 串行一对多即时通信，无RPC需求，或者无需返回结果RPC需求 ContentProvider 在数据源访问功能强大，支持一对多并发数据共享 可以理解为受约束的AIDL，主要提供数据源的CRUD 一对多的进程间数据共享 Socket 功能强大，通过网络传输字节流，支持一对多的并发实时通信 实现细节稍微繁琐，不支持直接的RPC 网络数据交换]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>AIDL</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的生命周期和启动模式]]></title>
    <url>%2F2017%2F07%2F13%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activity的生命周期和启动模式生命周期分析典型生命周期分析 onStart和onStop是从Activity是否可见的这个角度回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的。 Activity的启动过程很复杂，涉及Instrumentation、ActivityThread和ActivityManagerService（简称AMS）；简单理解，启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护一个ActivityStack并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期方法的调用。 假设当前Activity是A，新启动一个Activity B，那么A的onPause先执行，然后B的onCreate、onStart、onResume，再是A的onStop。 所以Android官方文档中有说明，不能在onPause中作重量级的耗时操作，因为onPause执行完后新的Activity才能Resume。注：不要在onPause和onStop中执行耗时操作，尤其是onPause。 异常情况下的生命周期分析 资源相关的系统配置改变导致Activity被杀死并重新创建 配置改变（旋转）onPause–&gt;onSaveInstanceState–&gt;onStop–&gt;onDestroy–&gt;重建–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState 注意：onSaveInstanceState在onStop之前，onRestoreInstanceState在onStart之后 资源内存不足导致低优先级的Activity被杀死 屏幕旋转时候Activity不想重新创建，配置android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot; Activity的启动模式（LaunchMode） standard：标准模式 与启动他的Activity运行在同一个的任务栈中； singleTop：栈顶复用模式 singleTask：栈内复用模式 多次启动Activity不会重复创建实例，回调其onNewIntent，并附带ClearTop效果。 什么是任务栈？？ 与参数TaskAffinity关联，也称为任务相关性，该属性表示任务栈的名字，默认就是packageName，也可以单独指定TaskAffinity的属性； 根据Activity是否位于暂停状态，又可以分为前台任务栈和后台任务栈。 1adb shell dumpsys activiy Activity的Flag FLAG_ACTIVITY_NEW_TASK—&gt;”singleTask” FLAG_ACTIVITY_SINGLE_TOP—&gt;”singleTop” FLAG_ACITIVY_CLEAR_TOP—&gt;一般配合“singleTask”使用，回调onNewIntent FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 移除历史Activity列表 IntentFilter的匹配规则 action的匹配规则—&gt;Intent中必须有一个action能够和IntentFilter中的某个action相同 categoty的匹配规则—&gt;Intent中可以没有category，但是如果有categoty，则每个category都需要和IntentFilter中的相同。 在startActiviy时，系统默认会为Intent加上android.intent.categoty.DEFAULT这个category，所以IntentFilter中必须有上述category才能接受隐式调用； data的匹配规则: mimeType + URI URI默认为content和file；如果要为Intent完整指定data，必须调用setDataAndType方法。 判断是否有Activity配置隐式Intent—&gt;可以用PackageManager的resolveActivity方法或者Intent的resolveActivity方法]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Activity的生命周期和启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重构 改善既有的代码设计]]></title>
    <url>%2F2017%2F07%2F13%2Frefactor%2F</url>
    <content type="text"><![CDATA[《重构改善既有代码设计》 重构 Extract Method (提炼函数) Move Method (搬移函数） Self Encapsulate Field (自封装字段) Replace Type Code With State/Strategy (以状态／策略模式取代状态码) Replace Condition with Polymorphism (以多态取代条件表达式) 重构原则 何为重构 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 为何重构 改进软件设计、是软件更容易理解、帮助找到bug、提高编程速度。 何时重构 添加功能时重构、修补错误时重构、复审代码时重构 重构与间接层 间接层价值： 允许逻辑共享、分开解释意图和实现、隔离变化、封装条件逻辑（多态） 重构的难题 数据库迁移、修改已公布的接口、难以重构的复杂设计 ​ 代码的坏味道 Duplicated code（重复代码） Long Method（过长函数） Large Class（过大的类） Long Parameter List (过长参数列） Divergent Change （发散式变化）一种类受多种变化的影响，类过大，需Extract class Shotgun Surgery（散弹式修改）一种变化引起多个类修改，需Move Method移到同一个类 Feature Envy（依恋情结）总是一起变化的东西放在一块 Data Clumps （数据泥团）多个类中重复的字段、方法。需Extract class到一个独立对象 Primitive Obsesstion （基本类型偏执）必要时用对象代替基本数据 Switch Statement（switch语句）需要抽出方法，用子类或state/strategy模式替代 Parallel Inheritance Hierarchies （平行继承体系）散弹修改的一种，需用引用代替继承 Lazy Class（冗余类） Speculative Generality（夸夸其谈未来性）多余的抽象、委托、参数应该去除 Temporary Field (迷惑的暂时字段) 可以的话提炼到一个独立的类中 Message ChainsI（过度耦合的消息链） Middle Man（中间人）过度使用委托 Inappropriate Intimacy (狎昵关系) 拆散过渡亲密的类，Move Method 或 Move Field到合适的地方；提炼共性到新类；Replace Inheritance with Delegation Alternative Classes With Different Interfaces (异曲同工的类) 重新命名或提取超类 Incomplete Library Class (不完美的类库) Data Class（存粹的数据类）注意封装和访问权限 Refused Bequest（被拒绝的馈赠）子类服用的超类的行为（实现），却不愿支持超类的接口，需重构（这里思考Basesso类的3个abstract方法有这个问题，不愿支持超类的接口） Comments（过多注释） ​ 重新组织函数 Extract Method（提炼函数） 将一段代码放进一个独立的函数中，并让函数名称解释该函数的用途。 如果源函数中局部变量比较多，先用Replace Temp With Query减少临时变量，源函数中读取的临时变量和参数，提炼到目标函数作为参数，并考虑是否需要返回值。 Inline Method （内联函数） 一个函数和本体一样清楚易懂，在函数调用点插入函数体，然后移除该函数。 Inline Temp（内联临时变量） 将临时变量替换为对它赋值的表达式或函数。 Replace Temp With Query（以查询取代临时变量） 将临时变量的计算代码提炼到一个独立的函数中，这样临时变量的引用点就可以替换为新函数的调用。 以查询代替临时变量可以减少临时变量，是提炼函数的重要步骤。 Introduce Explaining Variable (引入解释性变量) 将该复杂表达式的结果放进一个临时变量，以此变量名称来解释表达式的作用。 或者Extract Method来处理 Split Temporary Variable (分解临时变量) 某个临时变量，既不是循环变量也不是收集变量；针对每次赋值，创造一个独立的、有合理名称的临时变量来分解重复赋值。 Remove Assignments to Parameters(移除对参数的赋值） 代码对参数进行赋值，以一个临时变量取代该参数的位置 Java是按值传递的 1234void aMethod(Object foo) &#123; foo.modifySomeWay(); //that's OK，将改变foo引用的对象 foo = anothnerObject; //trouble will follow, 函数返回后并不会改变foo。&#125; Replace Method with Method Object(以函数对象取代函数） 有一个大型函数其中存在大量的局部变量，很难Extract Method来分解这个函数，那么使用函数对象。 将原函数替代成函数对象，该函数对象的构造函数接受源对象和原函数的参数作为参数； 针对原函数每个临时变量和每个参数，在新的函数对象中建立一个对应的字段保存； 然后就可以在函数对象中Extract Method来分解原函数； Substitute Algorithm (替换算法) 将函数本体替换为新的算法，建议先考虑分解函数再做替换。 ​ 在对象之间搬移特性 Move Method (搬移函数) 函数与其他类耦合过多，考虑使用委托或搬移到合适的类中。 搬移过程中，当目标类需要源类特性时，1）将这个特性也搬移到目标类 2）建立使用目标类到源类的使用 3）将源对象或该特性变量作为参数传递给目标类 Move Field (搬移字段) 某个字段被所驻类之外的另一个类更多地用到，考虑搬移这个字段到目标类。 Self Encapsulate（使用自我封装）在字段搬移后，就只需要修改访问函数（set／get），而无需修改引用点。 Extract Class（提炼类） 建立一个新类，将相关字段和函数从旧类搬移到新类。 可能需要双向连接，尽量避免建议新类到旧类的连接；决定是否公开新类； Inline Class（内联化类） 将这个类的所有特性搬移到另一个类，然后移除这个类； Hide Delegate (隐藏“委托关系“) 客户类通过委托类来调用另一个对象，在服务类上建立客户需要的所有委托函数，用于隐藏委托关系。 Remove Middle Man（移除中间人） 某个类做了过多的委托动作，那么可以直接让客户类调用受托类； 服务类中建立一个函数，直接返回受托类，客户类直接调用该类； 隐藏委托关系与移除中间人互为逆向的行为。 Introduce foreign Method (引入外加函数) 场景：你需要为提供服务的类增加一个函数，但是却无法修改这个类 应对：在客户类中建立一个函数，并传入一个服务类的实例参数； 如果需要外加多个函数，考虑使用引入本地扩展。 Introduce Local Extension (引入本地扩展) 场景：你需要为服务类提供一些额外的函数，但是你无法修改这个类 应对：建立一个新类，包含这些额外的函数，让这个扩展品称为源类的字类（subclass）或包装类（wrapper）； ​ 重新组织数据 Self Encapsulate Field (自封装字段) 直接访问字段，产生耦合关系；为这些字段建立get/set函数，并以这些函数访问字段。 直接访问字段还是通过get/set函数访问哪个好没有定论。 Replace Data Value with Object(以对象取代数据值) 如果有一个数据项需要与其他数据或者行为一起使用才有意义，那么将数据变成对象。 数据值 —&gt; 值对象,值对象应该是不可修改的 区别：如果数据可修改，使用引用对象，Change value to Reference Change Value into Reference(将值对象改为引用对象) 从一个类衍生出多个相等的实例，希望它们是同一个对象；将值对象变成引用对象； 多个Order共享同一个Customer对象 引用对象都代表真实世界中的一个实物，可以用==直接检查两个对象是否相等；如“客户”、“账户”等.. 值对象不可变，完全由其数据值来定义，有多个副本存在，需要复写equals()判断是否相等，如“日期”、“钱”.. Change Reference to Value(将引用对象改为值对象) 有一个引用对象，很小且不可变，将它改为值对象。 值对象是“不可变”（immutable）的，表示对象自身是不可变的。判断相等用equals()方法 Replace Array with Object(以对象代替组数) 有一个数组，其中的元素各自代表不同的东西 以对象代替数组，对于数组中的每一个元素，以一个字段来表示 Duplicate Observed Data(复制“被监视的数据”) 有一些领域（Model）数据置身于GUI控件中，而领域函数需要访问需要访问这数据； 将该数据复制到领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据； Change Unidirectional Association to Bidirectional(将单向关联改为双向关联) 场景：两个类都需要使用对方的特性，但只有一条单向关联 实现：添加一个反向指针，并使修改函数能够同事更新两条连接 决定哪个类是控制端；控制端（提供控制函数，维护反向指针），修改函数调用控制函数；被控制端（提供一个辅助函数提供反向指针），修改函数调用控制端的控制函数。 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联) 场景：两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性； 去除不必要的关联 Replace Magic Number with Symbolic Constant(以字面常量代替魔法数) 创建一个常量，根据其意义命名，替换上述魔法数 Encapsulate Field(封装字段) 将public字段声明为private，并提供相应的get/set访问函数 Encapsulate Collection(封装集合) 场景：有一个函数返回一个集合 优化：让这个函数返回该集合的一个只读副本，并提供添加／移除该集合元素的方法 Replace Record with Data Class(以数据类取代记录) 为记录结构型数据创建一个数据对象 Replace Type Code with Class(以类取代类型码) 场景：类中又一个数值类型码，但它并不影响类的行为 以一个新的类替换该数值类型码 Replace Type Code with Subclasses(以子类取代类型码) 场景：有一个不可变的类型码，它会影响类的行为 重构：以字类取代这个类型码，借助多态实现变化行为,将和特定字类相关的字段／函数push down到字类 Replace Type Code with State/Stratege(以状态／策略取代类型码) 场景：如果一个类型码的值在对象生命周期发生变化或者其他原因是宿主类不能被继承； 重构：以状态对象或策略模式取代类型码 Replace Subclass with Fields(以字段代替子类) 场景：各个子类的唯一差别只在“返回常量数据”的函数身上 重构：修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类 ​ 简化条件表达式 Decompose Conditional(简化条件表达式) 场景：有一个复杂的条件if-then-else语句 从if、then、else段落中分别提炼出独立的函数，函数名可以直观反映出函数的用途 Consolidate Conditional Expression(合并条件表达式) 场景：有一系列的条件测试，均得到相同的结果 重构：将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立的函数 使用||、&amp;&amp;、？：合并测试条件 Consolidate Duplicate Conditional Fragments(合并重复的条件片段) 场景：在条件表达式的每个分支上都有相同的一段代码 重构：将这段代码搬移到条件表达式外，并提炼出独立函数 Remove Control Flag(移除控制标记) 在一系列的布尔表达式中，某个变量带有控制标记（control flag）的作用 以break或者return语句取代这个控制标记 Replace Nested Conditional with Guard Clauses(以位语句取代嵌套的条件表达式) 场景：函数中条件逻辑使人迷惑 重构：使用卫语句表现所有特殊情况，立即返回结果；最后处理正常逻辑； 使用卫语句检查特殊条件，立刻返回或抛出异常； 可以先将条件表达式反转实现卫语句（P253）； Replace Conditional with Polymorphism(以多态取代条件表达式) 场景：有一个条件表达式，根据对象类型的不同选择不同的行为 重构：将这个条件表达式的每个分支放进一个子类的复写函数中，然后将原始的函数声明为抽象 在使用Replace Coditional with Polymorphism之前,必须建立一个继承结构：优先使用Repalce Type Code with Subclass，但是如果需要在对象创建后修改类型码，就不能用继承手法，那么使用 Replace Type Code with State/Stratege; Introduce Null Object(引入Null对象) 场景：你需要再三检查某个对象是否为null 重构：建立Null对象，替换null值的判断 空对象继承源对象，或者实现Null Interface；空对象一定是一个常量，它的任何成分都不会变化； Introduce Assertion(引入断言) 某一段代码需要对程序状态作出假设，以断言明确表示这种假设 简化函数调用 Rename Method(函数改名) 给每一个函数取一个可以揭示函数用途的、直观的名字 Add Parameter(添加参数) 为此函数添加一个对象参数，让该对象参数带进函数所需信息 Remove Parameter(移除参数) 移除多余的参数 Separate Query from Modifier(将查询函数和修改函数分离) 场景：某个函数既返回对象状态值，有修改对象状态 重构：建立两个独立的函数，一个负责查询，另一个负责修改 注意并发编程中，可保留查询-修改函数，调用各自独立的查询函数和修改函数，并声明为synchronised Parameterize Method(令函数携带参数) 若干函数做了类似的工作，但因少数几个值致使行为略有不同 建立单一函数，以参数表达那些不同的值 Replace Parameter with Explicit Method(以明确函数取代参数) 有一个函数安全取决于参数值而采取不同的行为 针对该参数的每一个可能值，建立一个独立函数；相反与Parameterize Method Preserve Whole Object(保持完整对象) 场景：你从对象中取出一些值，将它们作为参数传递给函数 重构：改为传递整个对象 Replace Parameter with Methods(以函数取代参数) 场景：对象调用一个函数，并将所得的结果作为参数，传递给另一个函数 重构：让参数接收这去处该项参数，并直接调用前一个函数 如果函数可以通过其他途径获取参数值，那么就应该去除该多余的参数 Introduce Parameter Object(引入参数对象) 场景：某些参数总是很自然的同时出现 重构：以一个对象取代这些参数，比如Range模式，范围对象取代(start,end) Remove Setting Method(移除设值函数) 场景：类中的某个字段应该在对象创建的时候被设值，然后不再改变 重构：去除该字段所有设值函数，同时声明该字段为final Hide Method(隐藏函数) 有一个函数从类没有被其他任何类用到过 将这个函数修改为private Replace Constructor with Factory Method(以工厂函数取代构造函数) 场景：在派生子类的过程中，需要根据类型码，创建相应的对象 重构：使用工厂函数取代构造函数 Encapsulate Downcast(封装向下转型) 场景：某个函数返回的对象需要由函数的调用者执行向下转型 重构：将向下转型的动作移到函数中 123Object lastReading() &#123; return reading.lastElement();&#125; 改为： 123Reading lastReading() &#123; return (Reading)reading.lastElement();&#125; Replace Error Code with Exception(以异常取代错误码) 场景：某个函数返回一个特定的代码，表示某种错误的情况 重构：改用异常 12345678int withdraw(int amount) &#123; if(amount &gt; _balance) &#123; return -1; &#125; else &#123; _balance -= amount; return 0; &#125;&#125; 改为： 1234void withdraw(int amount) throws BalanceException &#123; if(amount &gt; _balance) throw new BalanceExctption(); _balance -= amount;&#125; 决定函数应该抛出受控异常（checked）还是非受控异常（unchecked） 如果函数的调用者有责任在调用前检查必要状态，就抛出unchecked异常 抛出checked异常可以新建一个异常类继承Exception，或者使用现有的checked异常类 Replace Exception with Test(以测试取代异常) 场景：面对一个调用者可以预先检查的条件，你抛出了一个异常 修改调用者，使它在函数调用之前预先检查 1234567double getValueForPeriod(int periodNumber) &#123; try &#123; return _values[periodNumber]; &#125; catch(ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125; 改为： 1234double getValueForPeriod(int periodNumber) &#123; if ( periodNumber &gt;= _values.length ) return 0; return _values[periodNumber];&#125; 异常应该只被用于那些产生意料之外的错误行为，而不应该成为条件检查的工具；不要用try-catch语句作为条件判断语句； 概括处理关系 Pull Up Field(字段上移) 如果两个子类拥有相同的字段，将该子段移到超类 Pull Up Method(函数上移) 场景：有些函数在子类中产生完全相同的结果 重构：将该函数移至超类 Pull Up Method过程中最麻烦的一点就是：被提升的函数可能会引用只出现在子类而不出现在超类的特性。 如果被引用的是一个函数，你可以将该函数一同提升到超类；或者在超类中建立一个抽象函数；或者建立一个委托函数 如果被引用的是子类的字段，你可以将该字段也提升到超类；或者先在子类中自封装字段，然后在超类中把取值函数声明为抽象 Pull Up Constructor Body(构造函数本体上移) 在子类中各拥有一些构造函数，它们的本体几乎一致 在超类中新建一个构造函数，并在子类构造函数中调用它 Pull Down Method(函数下移) 超类中的某个函数只与部分（而非全部）子类有关，将这个函数移到相关的那些子类中去 Pull Down Field(字段下移) 超类中的某个字段只被部分（而非全部）子类所用到，将这个字段移到需要它的那个子类中去 Extract SubClass(提炼子类) 场景：类中的某些特性只被某些（而非全部）实例用到 重构：新建一个子类，将上述一部分特性移到子类中 Extract SuperClass(提炼超类) 场景：两个类具有相似的特性 重构：为这两个类建立一个超类，将这些相同的特性搬移到超类 Extract Interface(提炼接口) 场景：若干客户使用类接口中的同一子集，或者两个类的接口有相同的部分 重构：将相同的子集提炼到一个独立的接口中 Collapse Hierarchy(折叠继承体系) 超类和子类之间无太大区别，将它们合为一体 From Template Method(塑造模版函数) 场景：你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作细节上有所不同 重构：将这些细节操作分别放进独立的函数中，并保持它们都有相同的签名，于是原函数也变得相同了；然后将原函数上移到超类 Replace Inheritance with Delegation(以委托取代继承) 场景：某些子类只使用超类接口中的一部分，或者根本不需要继承而来的数据 重构：在子类中新建一个子段用以保存超类；调整子类函数令它委托超类；然后去掉继承关系 Replace Delegation with Inheritance(以继承取代委托) 场景：你在两个类之间使用委托关系，并经常为整个接口编写很多及其简单的委托函数 重构：让委托类继承受托类 大型重构 Tease Apart Inheritance(梳理并分解继承体系) 场景：某个继承体系同时承担两项责任 重构：建立两个继承体系，并通过委托关系让其中一个可以调用另一个 Convert Procedural Design to Objects(将过程化设计转化为对象设计) 场景：你手中有一些传统过程化风格的代码 重构：将数据记录变为对象，将大块行为分为小块，并将行为移入相关对象之中 Separate Domain from Presentation(将领域和显示分离) 某些GUI类中包含了领域逻辑 将领域逻辑分离出来，为它们建立独立的领域类 Extract Hierarchy(提炼继承体系) 场景：你有某个类做了大量的工作，其中一部分工作是以大量的条件表达式完成的 重构：建立继承体系，以一个子类表示一种特殊情况]]></content>
      <categories>
        <category>重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>refactor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2017%2F05%2F16%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Generate static files1$ hexo generate More info: Generating Run server1$ hexo server More info: Server Deploy to remote sites1$ hexo deploy BenefitsWith this feature, now you can put all your configurations into one place (source/_data/next.yml), you don’t need to touch next/_config.yml. If there are any new options in new releases, you just need to copy those options from next/_config.yml, paste into _data/next.yml and set their values to whatever you want. How to use this feature Please ensure you are using Hexo 3 (or above) Create an file named next.yml in site’s source/_data directory (create _data directory if it did not exist) Copy NexT theme options both in site’s _config.yml and theme’s _config.yml into next.yml. Use --config source/_data/next.yml parameter to start server, generate or deploy.For example: hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml. More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
