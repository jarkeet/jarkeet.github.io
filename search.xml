<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Jetpack之Lifecycle源码解析]]></title>
    <url>%2F2020%2F12%2F28%2FLifecycle%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Lifecycle 是 Jetpack 整个家族体系内最为基础的内容之一，正是因为有了 Lifecycle 的存在，使得如今开发者搭建依赖于生命周期变化的业务逻辑变得简单且高效了许多，使得我们可以以一种统一的方式来监听 Activity、Fragment、Service、甚至 Process 的生命周期变化，且大大减少了业务代码发生内存泄漏和 NPE 的风险。本文的内容就是对 Lifecycle 进行了一次全面的源码讲解，希望对你有所帮助 本文所讲的的源代码基于以下依赖库当前最新的 release 版本： 123456compileSdkVersion 29implementation 'androidx.appcompat:appcompat:1.1.0'implementation "androidx.lifecycle:lifecycle-common:2.2.0"implementation "androidx.lifecycle:lifecycle-common-java8:2.2.0"implementation "androidx.lifecycle:lifecycle-runtime:2.2.0" 一、Lifecycle1.1、如何使用现如今，如果我们想要根据 Activity 的生命周期状态的变化来管理我们的业务逻辑的话，那么可以很方便的使用类似如下代码来监听其生命周期状态的变化 1234567891011121314151617override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) lifecycle.addObserver(object : DefaultLifecycleObserver &#123; override fun onCreate(owner: LifecycleOwner) &#123; &#125; override fun onResume(owner: LifecycleOwner) &#123; &#125; override fun onDestroy(owner: LifecycleOwner) &#123; &#125; &#125;)&#125; 以上代码是基于接口的形式（DefaultLifecycleObserver）来进行事件回调的，每当 Activity 的生命周期函数被触发时，该接口的相应同名函数就会在之前或者之后被调用，以此来获得相应生命周期事件变化的通知 此外还有一种基于 OnLifecycleEvent 注解的方式来进行回调的方法，该方法主要是面向基于 Java 7 作为编译版本的平台，但该方式在以后会被逐步废弃，Google 官方也建议开发者尽量使用接口回调的形式 基于注解的方式不对函数名做特定要求，但是对于函数的入参类型、入参顺序、入参个数有特定要求，这个在后续章节会有介绍 123456789101112131415161718lifecycle.addObserver(object : LifecycleObserver &#123; @OnLifecycleEvent(Lifecycle.Event.ON_CREATE) fun onCreateEvent(lifecycleOwner: LifecycleOwner) &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY) fun onDestroyEvent(lifecycleOwner: LifecycleOwner) &#123; &#125; @OnLifecycleEvent(Lifecycle.Event.ON_ANY) fun onAnyEvent(lifecycleOwner: LifecycleOwner, event: Lifecycle.Event) &#123; &#125; &#125;) 1.2、LifecycleLifecycle 是一个抽象类，其本身的逻辑比较简单，在大多数时候我们会接触到的是其子类 LifecycleRegistry。Lifecycle 内部仅包含一个全局变量，三个抽象方法、两个枚举类 Lifecycle 内部包含的成员变量，用于在引入了 lifecycle-common-ktx 包的情况，即在使用 kotlin 协程库的时候才有用。在这里无需理会 123@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)@NonNullAtomicReference&lt;Object&gt; mInternalScopeRef = new AtomicReference&lt;&gt;(); 包含的三个抽象函数，分别用于添加 LifecycleObserver 、移除 LifecycleObserver、获取当前 Lifecycle 所处的状态值 123456789@MainThread public abstract void addObserver(@NonNull LifecycleObserver observer); @MainThread public abstract void removeObserver(@NonNull LifecycleObserver observer); @MainThread @NonNull public abstract State getCurrentState(); Lifecycle 内部包含的两个枚举类，用于标记 Activity/Fragment 等具有生命周期状态的事物当前所处的状态 Event 类用于抽象 Activity/Fragment 的生命周期事件发生变化时所触发的事件。例如，当 Activity 的每个生命周期事件回调函数（onCreate、onStart 等）被触发时都会被抽象为相应的 ON_CREATE、ON_START 两个 Event 123456789public enum Event &#123; ON_CREATE, ON_START, ON_RESUME, ON_PAUSE, ON_STOP, ON_DESTROY, ON_ANY &#125; State 类用于标记 Lifecycle 的当前生命周期状态 123456789101112131415public enum State &#123; //当处于 DESTROYED 状态时，Lifecycle 将不会发布其它 Event 值 //当 Activity 即将回调 onDestory 时则处于此状态 DESTROYED, //已初始化的状态。例如，当 Activity 的构造函数已完成，但还未回调 onCreate 时则处于此状态 INITIALIZED, CREATED, STARTED, RESUMED; //如果当前状态大于入参值 state 时，则返回 true public boolean isAtLeast(@NonNull State state) &#123; return compareTo(state) &gt;= 0; &#125;&#125; 二、Lifecycle 相关的接口在 Lifecycle 体系中，很多事件回调和类型定义都是通过接口的形式来实现的，这里再来罗列下开发者经常会使用到的几个接口及其作用 2.1、LifecycleOwnerLifecycleOwner 接口用于标记其实现类具备 Lifecycle 对象。我们日常使用的 androidx.appcompat.app.AppCompatActivity 和 androidx.fragment.app.Fragment 均实现了该接口 1234public interface LifecycleOwner &#123; @NonNull Lifecycle getLifecycle();&#125; 2.2、LifecycleObserverLifecycleObserver 是一个空接口，大部分情况下真正具有使用意义的是它的子接口 ，LifecycleObserver 可以说仅是用于类型标记 123public interface LifecycleObserver &#123;&#125; 1、LifecycleEventObserverLifecycleEventObserver 用于监听 Lifecycle 的生命周期变化，可以获取到生命周期事件发生的具体变化 12345public interface LifecycleEventObserver extends LifecycleObserver &#123; //当 LifecycleOwner 对象的生命周期事件发生变化时将回调此方法 void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event);&#125; 2、FullLifecycleObserverFullLifecycleObserver 根据 Activity/Fragment 这两个类的生命周期回调函数扩展了几个同名的抽象方法，可以看成是对 LifecycleEventObserver 进行更加具体的事件拆分 1234567891011121314interface FullLifecycleObserver extends LifecycleObserver &#123; void onCreate(LifecycleOwner owner); void onStart(LifecycleOwner owner); void onResume(LifecycleOwner owner); void onPause(LifecycleOwner owner); void onStop(LifecycleOwner owner); void onDestroy(LifecycleOwner owner);&#125; 3、DefaultLifecycleObserverDefaultLifecycleObserver 接口继承于 FullLifecycleObserver，androidx.lifecycle:lifecycle-common-java8:xxx 整个依赖库仅包含了该接口，从依赖库的命名上来看，可以看出它是用于 Java 8 平台的。DefaultLifecycleObserver 将 FullLifecycleObserver 的所有方法都进行了默认实现，让开发者可以只处理自己关心的生命周期事件。因为大多数时候我们仅需要使用一部分生命周期状态函数，如果使用 FullLifecycleObserver 的话我们就必须实现所有抽象方法，而大部分方法可能都是空实现 所以，为了简化代码，Jetpack 也提供了 DefaultLifecycleObserver 接口，而接口可以声明默认方法这一特性也是 Java 8 开始才有的，所以只有当你的项目是以 Java 8 作为目标编译版本时，才可以使用 DefaultLifecycleObserver。而 Google 官方也建议开发者尽量使用 DefaultLifecycleObserver ，因为 Java 8 最终是会成为 Android 开发的主流，而 Java 7 平台下通过注解 OnLifecycleEvent 来实现生命周期回调的方式最终会被废弃 1234567891011121314151617181920public interface DefaultLifecycleObserver extends FullLifecycleObserver &#123; @Override default void onCreate(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onStart(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onResume(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onPause(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onStop(@NonNull LifecycleOwner owner) &#123; &#125; @Override default void onDestroy(@NonNull LifecycleOwner owner) &#123; &#125;&#125; 4、FullLifecycleObserverAdapterFullLifecycleObserverAdapter 实现了 LifecycleEventObserver 接口，用于在收到 Lifecycle 生命周期事件状态变化时，对其两个构造函数参数（ FullLifecycleObserver、LifecycleEventObserver）进行事件转发 12345678910111213141516171819202122232425262728293031323334353637383940class FullLifecycleObserverAdapter implements LifecycleEventObserver &#123; private final FullLifecycleObserver mFullLifecycleObserver; private final LifecycleEventObserver mLifecycleEventObserver; FullLifecycleObserverAdapter(FullLifecycleObserver fullLifecycleObserver, LifecycleEventObserver lifecycleEventObserver) &#123; mFullLifecycleObserver = fullLifecycleObserver; mLifecycleEventObserver = lifecycleEventObserver; &#125; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; switch (event) &#123; case ON_CREATE: mFullLifecycleObserver.onCreate(source); break; case ON_START: mFullLifecycleObserver.onStart(source); break; case ON_RESUME: mFullLifecycleObserver.onResume(source); break; case ON_PAUSE: mFullLifecycleObserver.onPause(source); break; case ON_STOP: mFullLifecycleObserver.onStop(source); break; case ON_DESTROY: mFullLifecycleObserver.onDestroy(source); break; case ON_ANY: throw new IllegalArgumentException("ON_ANY must not been send by anybody"); &#125; if (mLifecycleEventObserver != null) &#123; mLifecycleEventObserver.onStateChanged(source, event); &#125; &#125;&#125; 2.3、OnLifecycleEventOnLifecycleEvent 是一个自定义注解，当开发者想要通过注解的形式来对应不同的生命周期回调时就需要使用到，这一般只用于编译版本是 Java 7 的情况 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface OnLifecycleEvent &#123; Lifecycle.Event value();&#125; 三、ReportFragment现如今，如果我们想要根据 Activity 的生命周期状态的变化来管理我们的业务逻辑的话，那么可以很方便的使用类似如下代码来监听其生命周期状态的变化 1234567891011121314151617override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) lifecycle.addObserver(object : LifecycleEventObserver &#123; override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event) &#123;when (event) &#123; Lifecycle.Event.ON_CREATE -&gt; TODO() Lifecycle.Event.ON_START -&gt; TODO() Lifecycle.Event.ON_RESUME -&gt; TODO() Lifecycle.Event.ON_PAUSE -&gt; TODO() Lifecycle.Event.ON_STOP -&gt; TODO() Lifecycle.Event.ON_DESTROY -&gt; TODO() Lifecycle.Event.ON_ANY -&gt; TODO() &#125; &#125; &#125;)&#125; 用是这样就能用了，但深究起来，此时一个很显而易见的问题就是，LifecycleEventObserver 是如何取得各个生命周期状态变化的事件（Lifecycle.Event）呢？或者说，是谁回调了 LifecycleEventObserver 的 onStateChanged 方法呢？ 现在我们在日常开发中，多数情况下我们使用的 Activity 都是继承于 androidx.appcompat.appcompat:xxx这个包内的 AppCompatActivity，而 AppCompatActivity 最终是会继承于 androidx.core.app.ComponentActivity， ComponentActivity 的 onCreate 函数是这样的： 123456@SuppressLint("RestrictedApi")@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ReportFragment.injectIfNeededIn(this);&#125; 而正是通过 ReportFragment 使得 LifecycleEventObserver 可以接收到 Activity 所有的的 Lifecycle.Event 这里就来详细看看 ReportFragment 的内部源码，一步步了解其实现逻辑 injectIfNeededIn() 函数是一个静态函数，以 android.app.Activity 对象作为入参参数 12345678910111213141516171819 public static void injectIfNeededIn(Activity activity) &#123; if (Build.VERSION.SDK_INT &gt;= 29) &#123; // On API 29+, we can register for the correct Lifecycle callbacks directly //当 API 等级为 29+ 时，我们可以直接向 android.app.Activity 注册生命周期回调 activity.registerActivityLifecycleCallbacks( new LifecycleCallbacks()); &#125; // Prior to API 29 and to maintain compatibility with older versions of // ProcessLifecycleOwner (which may not be updated when lifecycle-runtime is updated and // need to support activities that don't extend from FragmentActivity from support lib), // use a framework fragment to get the correct timing of Lifecycle events //在 API 29 之前，向 activity 添加一个不可见的 framework 中的 fragment，以此来取得 Activity 生命周期事件的正确回调 android.app.FragmentManager manager = activity.getFragmentManager(); if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) &#123; manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit(); // Hopefully, we are the first to make a transaction. manager.executePendingTransactions(); &#125;&#125; ReportFragment 的 injectIfNeededIn() 函数会根据两种情况来进行事件分发 运行设备的系统版本号小于 29。此情况会通过向 Activity 添加一个无 UI 界面的 Fragment（即 ReportFragment），间接获得 Activity 的各个生命周期事件的回调通知 运行设备的系统版本号大于或等于29。此情况会向 Activity 注册一个 LifecycleCallbacks ，以此来直接获得各个生命周期事件的回调通知。此时也会同时执行第一种情况的操作 之所以会进行这两种情况区分，是因为 registerActivityLifecycleCallbacks 是 SDK 29 时 android.app.Activity 新添加的方法，从这个版本开始支持直接在 LifecycleCallbacks 中取得事件通知。当用户的设备 SDK 版本小于 29 时，就还是需要通过 ReportFragment 来间接取得事件通知 3.1、SDK &gt;= 29先来看下 LifecycleCallbacks 类。其逻辑就是会在 Activity 的 onCreate、onStart、onResume 等方法被调用后通过 dispatch(activity, Lifecycle.Event.ON_XXX) 方法发送相应的 Event 值，并在 onPause、onStop、onDestroy 等方法被调用前发送相应的 Event 值 123456789101112131415161718192021222324static class LifecycleCallbacks implements Application.ActivityLifecycleCallbacks &#123; @Override public void onActivityCreated(@NonNull Activity activity, @Nullable Bundle bundle) &#123; &#125; @Override public void onActivityPostCreated(@NonNull Activity activity, @Nullable Bundle savedInstanceState) &#123; dispatch(activity, Lifecycle.Event.ON_CREATE); &#125; //省略部分相似代码 ··· @Override public void onActivityPreDestroyed(@NonNull Activity activity) &#123; dispatch(activity, Lifecycle.Event.ON_DESTROY); &#125; @Override public void onActivityDestroyed(@NonNull Activity activity) &#123; &#125;&#125; dispatch() 方法拿到 Event 值后，就会先通过 activity 拿到 Lifecycle 对象，再通过类型判断拿到 LifecycleRegistry 对象，最终通过调用 handleLifecycleEvent() 方法将 Event 值传递出去，从而使得外部得到各个生命周期事件的通知 从这也可以看出来，androidx.appcompat.app.AppCompatActivity 实现了 LifecycleOwner 接口后返回的 Lifecycle 对象就是 LifecycleRegistry，实际上 androidx.fragment.app.Fragment 也一样 123456789101112131415@SuppressWarnings("deprecation")static void dispatch(@NonNull Activity activity, @NonNull Lifecycle.Event event) &#123; //LifecycleRegistryOwner 已被废弃，主要看 LifecycleOwner if (activity instanceof LifecycleRegistryOwner) &#123; ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event); return; &#125; if (activity instanceof LifecycleOwner) &#123; Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle(); if (lifecycle instanceof LifecycleRegistry) &#123; ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event); &#125; &#125;&#125; 3.2、SDK &lt; 29再来看下向 Activity 添加的 ReportFragment 是如何生效的。由于 ReportFragment 是挂载在 Activity 身上的，ReportFragment 本身的生命周期函数和所在的 Activity 是相关联的，通过在 ReportFragment 相应的生命周期函数里调用 dispatch(Lifecycle.Event.ON_XXXX) 函数发送相应的 Event 值，以此来间接获得 Activity 的各个生命周期事件的回调通知 1234567891011121314151617181920@Override public void onActivityCreated(Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); //省略无关代码 dispatch(Lifecycle.Event.ON_CREATE); &#125; @Override public void onStart() &#123; super.onStart(); //省略无关代码 dispatch(Lifecycle.Event.ON_START); &#125; @Override public void onDestroy() &#123; super.onDestroy(); dispatch(Lifecycle.Event.ON_DESTROY); //省略无关代码 &#125; dispatch() 函数内部会判断目标设备的版本号来决定是否真的分发 Event 值，避免当 SDK 版本号大于 29 时和 LifecycleCallbacks 重复发送 12345678private void dispatch(@NonNull Lifecycle.Event event) &#123; if (Build.VERSION.SDK_INT &lt; 29) &#123; // Only dispatch events from ReportFragment on API levels prior // to API 29. On API 29+, this is handled by the ActivityLifecycleCallbacks // added in ReportFragment.injectIfNeededIn dispatch(getActivity(), event); &#125;&#125; 这样，ReportFragment 就通过上述逻辑向外部转发了 Activity 发生的 Event 值 四、LifecycleRegistryReportFragment 最终在向外传出 Lifecycle.Event 值时，调用的都是 LifecycleRegistry 对象的 handleLifecycleEvent(Lifecycle.Event) 方法，既然需要的 Event 值已经拿到了，那再来看下 LifecycleRegistry 是如何将 Event 值转发给 LifecycleObserver 的 LifecycleRegistry 是整个 Lifecycle 家族内一个很重要的类，其屏蔽了生命周期持有类（Activity / Fragment 等）的具体类型，使得外部（Activity / Fragment 等）可以只负责转发生命周期事件，由 LifecycleRegistry 来实现具体的事件回调和状态管理。androidx.activity.ComponentActivity 和 androidx.fragment.app.Fragment 都使用到了 LifecycleRegistry 12345678910111213141516 public class ComponentActivity extends androidx.core.app.ComponentActivity implements LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner, OnBackPressedDispatcherOwner &#123; private final LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this); @NonNull @Override public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; &#125; 123456789101112public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner, ViewModelStoreOwner, HasDefaultViewModelProviderFactory, SavedStateRegistryOwner &#123; LifecycleRegistry mLifecycleRegistry; @Override @NonNull public Lifecycle getLifecycle() &#123; return mLifecycleRegistry; &#125; &#125; 在具体看 LifecycleRegistry 的实现逻辑之前，需要先对 LifecycleRegistry 的定位、作用和必须具备的功能有一个大致的了解，可以从我们想要的效果来逆推实现这个效果所需要的步骤： 不单单是 Activity 和 Fragment 可以实现 LifecycleOwner 接口，像 Service、Dialog 等具有生命周期的类一样可以实现 LifecycleOwner 接口，而不管 LifecycleOwner 的实现类是什么，其本身所需要实现的功能/逻辑都是一样的：addObserver、removeObserver、getCurrentState、遍历循环 observers 进行 Event 通知等。所以 Google 官方势必需要提供一个通用的 Lifecycle 实现类，以此来简化开发者实现 LifecycleOwner 接口的成本，最终的实现类即 LifecycleRegistry（之后假设我们需要实现 LifecycleOwner 接口的仅有 Activity 一种，方便读者理解） LifecycleRegistry 需要持有 LifecycleOwner 对象来判断是否可以向其回调事件通知，但为了避免内存泄漏也不能直接强引用 LifecycleOwner 假设当 Activity 处于 State.STARTED 状态时向其添加了一个 LifecycleEventObserver ，此时就必须向 LifecycleEventObserver 同步当前的最新状态值，所以 LifecycleEventObserver 就会先后收到 Lifecycle.Event.ON_CREATE、Lifecycle.Event.ON_START 两个 Event LifecycleRegistry 向 Observer 发布 Event 值的触发条件有两种： 新添加了一个 Observer，需要向其同步 Activity 当前的 State 值。在同步的过程中新的 Event 值可能刚好又来了，此时需要考虑如何向所有 Observer 同步最新的 Event 值 Activity 的生命周期状态发生了变化，需要向 Observer 同步最新的 State 值。在同步的过程中可能又添加了新的 Observer 或者移除了 Observer ，此时一样需要考虑如何向所有 Observer 同步最新的 Event 值 有了以上的几点认知后，再来看下 LifecycleRegistry 的大致逻辑 LifecycleRegistry 自然是 Lifecycle 的子类，其构造函数需要传入 LifecycleOwner 对象 123456789101112131415public class LifecycleRegistry extends Lifecycle &#123; //一般一个 LifecycleRegistry 对应一个 LifecycleOwner 对象（Activity/Fragment等） //mState 就用来标记 LifecycleOwner 对象所处的当前生命周期状态 private State mState; //持有对 LifecycleOwner 的弱引用，避免内存泄露 private final WeakReference&lt;LifecycleOwner&gt; mLifecycleOwner; public LifecycleRegistry(@NonNull LifecycleOwner provider) &#123; mLifecycleOwner = new WeakReference&lt;&gt;(provider); mState = INITIALIZED; &#125; &#125; addObserver() 函数的主要逻辑是：将传入的 observer 对象包装为 ObserverWithState 类型，方便将注解形式的LifecycleObserver（Java 7）和接口实现的 LifecycleObserver（Java 8）进行状态回调时的入口统一为 dispatchEvent() 方法。此外，由于当添加 LifecycleObserver 时 Lifecycle 可能已经处于非 INITIALIZED 状态了，所以需要通过循环检查的方式来向 ObserverWithState 逐步下发 Event 值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//Lifecycle 类中对 addObserver 方法添加了 @MainThread 注解，意思是该方法只能用于主线程调用 //所以此处不需要考虑多线程的情况@Override public void addObserver(@NonNull LifecycleObserver observer) &#123; State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED; ObserverWithState statefulObserver = new ObserverWithState(observer, initialState); ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver); if (previous != null) &#123; //如果 observer 之前已经传进来过了，则不重复添加，直接返回 return; &#125; LifecycleOwner lifecycleOwner = mLifecycleOwner.get(); if (lifecycleOwner == null) &#123; // it is null we should be destroyed. Fallback quickly //如果 LifecycleOwner 对象已经被回收了，则直接返回 return; &#125; //如果 isReentrance 为 true，则说明此时以下两种情况至少有一个成立： //1. mAddingObserverCounter != 0。会出现这种情况，是由于开发者先添加了一个 LifecycleObserver ，当还在向其回调事件的过程中，在回调函数里又再次调用了 addObserver 方法添加了一个新的 LifecycleObserver //2.mHandlingEvent 为 true。即此时正处于向外回调 Lifecycle.Event 的状态 boolean isReentrance = mAddingObserverCounter != 0 || mHandlingEvent; State targetState = calculateTargetState(observer); //递增加一，标记当前正处于向新添加的 LifecycleObserver 回调 Event 值的过程 mAddingObserverCounter++; //statefulObserver.mState.compareTo(targetState) &lt; 0 成立的话说明 State 值还没遍历到目标状态 //mObserverMap.contains(observer) 成立的话说明 observer 还没有并移除 //因为有可能在遍历过程中开发者主动在回调函数里将 observer 给移除掉了，所以这里每次循环都检查下 while ((statefulObserver.mState.compareTo(targetState) &lt; 0 &amp;&amp; mObserverMap.contains(observer))) &#123; //将 observer 已经遍历到的当前的状态值 mState 保存下来 pushParentState(statefulObserver.mState); //向 observer 回调进入“statefulObserver.mState”前需要收到的 Event 值 statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState)); //移除 mState popParentState(); // mState / subling may have been changed recalculate targetState = calculateTargetState(observer); &#125; if (!isReentrance) &#123; // we do sync only on the top level. sync(); &#125; mAddingObserverCounter--; &#125; 向 LifecycleObserver 回调事件的过程可以用以下这张官方提供的图来展示 假设当前 LifecycleRegistry 的 mState 处于 RESUMED 状态，此时通过 addObserver 方法新添加的 LifecycleObserver 会被包装为 ObserverWithState，且初始化状态为 INITIALIZED。由于 RESUMED 大于INITIALIZED，ObserverWithState 就会按照 INITIALIZED -&gt; CREATED -&gt; STARTED -&gt; RESUMED 这样的顺序先后收到事件通知 假设当前 LifecycleRegistry 的 mState 处于 STARTED 状态。如果 LifecycleRegistry 收到 ON_RESUME 事件，mState 就需要变更为 RESUMED；如果 LifecycleRegistry 收到 ON_STOP 事件，mState 就需要变更为 CREATED；所以说，LifecycleRegistry 的 mState 会先后向不同方向迁移 ObserverWithState 将外界传入的 LifecycleObserver 对象传给 Lifecycling 进行类型包装，将反射逻辑和接口回调逻辑都给汇总综合成一个新的 LifecycleEventObserver 对象，从而使得 Event 分发过程都统一为一个入口 12345678910111213141516static class ObserverWithState &#123; State mState; LifecycleEventObserver mLifecycleObserver; ObserverWithState(LifecycleObserver observer, State initialState) &#123; mLifecycleObserver = Lifecycling.lifecycleEventObserver(observer); mState = initialState; &#125; void dispatchEvent(LifecycleOwner owner, Event event) &#123; State newState = getStateAfter(event); mState = min(mState, newState); mLifecycleObserver.onStateChanged(owner, event); mState = newState; &#125;&#125; 而在上文提到的，ReportFragment 最终在向外传出 Lifecycle.Event 值时，调用的都是 LifecycleRegistry 对象的 handleLifecycleEvent(Lifecycle.Event) 方法，该方法会根据接收到的 Event 值换算出对应的 State 值，然后更新本地的 mState，再向所有 Observer 进行事件通知，最终还是会调用到 ObserverWithState 的 dispatchEvent 方法，所以后边我们再来重点关注 dispatchEvent 方法即可 12345678910111213141516171819public void handleLifecycleEvent(@NonNull Lifecycle.Event event) &#123; State next = getStateAfter(event); moveToState(next);&#125;private void moveToState(State next) &#123; if (mState == next) &#123; return; &#125; mState = next; if (mHandlingEvent || mAddingObserverCounter != 0) &#123; mNewEventOccurred = true; // we will figure out what to do on upper level. return; &#125; mHandlingEvent = true; sync(); mHandlingEvent = false;&#125; 需要注意的一点是，对 androidx.fragment.app.Fragment 生命周期事件的监听一样需要使用到 LifecycleRegistry，Fragment 内部最终也是通过调用其 handleLifecycleEvent(Lifecycle.Event) 方法来完成其本身的生命周期事件通知，代码较为简单，这里不再赘述 五、Lifecycling上面说到了，LifecycleRegistry 会将外部传入的所有 LifecycleObserver 根据 Lifecycling 包装成 LifecycleEventObserver 对象，这里先来解释下为什么需要进行这层包装 LifecycleEventObserver 和 FullLifecycleObserver 都是继承于 LifecycleObserver 的接口，如果开发者自己实现的自定义 Observer 同时实现了这两个接口，那按道理来说 LifecycleRegistry 就必须在有事件触发的情况下同时回调这两个接口的所有方法 如果开发者自己实现的自定义 Observer 仅实现了 LifecycleEventObserver 和 FullLifecycleObserver 这两个接口当中的一个，那么也需要在有事件触发的情况下调用相应接口的对应方法 实现了通过以上两个接口来实现回调外，Google 也提供了通过注解的方法来声明生命周期回调函数，此时就只能通过反射来进行回调 基于以上三点现状，如果在 LifecycleRegistry 中直接对外部传入的 Observer 来进行类型判断、接口回调、反射调用等一系列操作的话，那势必会使得 LifecycleRegistry 整个类非常的臃肿，所以 Lifecycling 的作用就是来将这一系列的逻辑给封装起来，仅仅开放一个 onStateChanged 方法即可让 LifecycleRegistry 完成整个事件分发，从而使得整个流程会更加清晰明了且职责分明 那现在就来看下 lifecycleEventObserver 方法的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142@NonNull static LifecycleEventObserver lifecycleEventObserver(Object object) &#123; //以下对应于上述的第一点和第二点 boolean isLifecycleEventObserver = object instanceof LifecycleEventObserver; boolean isFullLifecycleObserver = object instanceof FullLifecycleObserver; if (isLifecycleEventObserver &amp;&amp; isFullLifecycleObserver) &#123; //如果 object 对象同时继承了 LifecycleEventObserver 和 FullLifecycleObserver 接口 //则将其包装为 FullLifecycleObserverAdapter 对象来进行事件转发 return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, (LifecycleEventObserver) object); &#125; if (isFullLifecycleObserver) &#123; //同上 return new FullLifecycleObserverAdapter((FullLifecycleObserver) object, null); &#125; if (isLifecycleEventObserver) &#123; //object 已经是需要的目标类型了（LifecycleEventObserver），直接原样返回即可 return (LifecycleEventObserver) object; &#125; //以下对应于上述所说的第三点，即反射操作 final Class&lt;?&gt; klass = object.getClass(); int type = getObserverConstructorType(klass); if (type == GENERATED_CALLBACK) &#123; List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors = sClassToAdapters.get(klass); if (constructors.size() == 1) &#123; GeneratedAdapter generatedAdapter = createGeneratedAdapter( constructors.get(0), object); return new SingleGeneratedAdapterObserver(generatedAdapter); &#125; GeneratedAdapter[] adapters = new GeneratedAdapter[constructors.size()]; for (int i = 0; i &lt; constructors.size(); i++) &#123; adapters[i] = createGeneratedAdapter(constructors.get(i), object); &#125; return new CompositeGeneratedAdaptersObserver(adapters); &#125; return new ReflectiveGenericLifecycleObserver(object); &#125; 5.1、前两种情况FullLifecycleObserver 根据 Activity/Fragment 这两个类的生命周期回调函数扩展了几个同名的抽象方法，可以看成是对 LifecycleEventObserver 进行更加具体的事件拆分，让使用者可以只处理自己关心的生命周期事件，这一般是用于 Java 8 以上的编译平台 1234567891011121314interface FullLifecycleObserver extends LifecycleObserver &#123; void onCreate(LifecycleOwner owner); void onStart(LifecycleOwner owner); void onResume(LifecycleOwner owner); void onPause(LifecycleOwner owner); void onStop(LifecycleOwner owner); void onDestroy(LifecycleOwner owner);&#125; FullLifecycleObserverAdapter 实现了 LifecycleEventObserver 接口，用于在收到 Lifecycle 生命周期事件状态变化时，对其两个构造函数参数（ FullLifecycleObserver、LifecycleEventObserver）进行事件转发 12345678910111213141516171819202122232425262728293031323334353637383940class FullLifecycleObserverAdapter implements LifecycleEventObserver &#123; private final FullLifecycleObserver mFullLifecycleObserver; private final LifecycleEventObserver mLifecycleEventObserver; FullLifecycleObserverAdapter(FullLifecycleObserver fullLifecycleObserver, LifecycleEventObserver lifecycleEventObserver) &#123; mFullLifecycleObserver = fullLifecycleObserver; mLifecycleEventObserver = lifecycleEventObserver; &#125; @Override public void onStateChanged(@NonNull LifecycleOwner source, @NonNull Lifecycle.Event event) &#123; switch (event) &#123; case ON_CREATE: mFullLifecycleObserver.onCreate(source); break; case ON_START: mFullLifecycleObserver.onStart(source); break; case ON_RESUME: mFullLifecycleObserver.onResume(source); break; case ON_PAUSE: mFullLifecycleObserver.onPause(source); break; case ON_STOP: mFullLifecycleObserver.onStop(source); break; case ON_DESTROY: mFullLifecycleObserver.onDestroy(source); break; case ON_ANY: throw new IllegalArgumentException("ON_ANY must not been send by anybody"); &#125; if (mLifecycleEventObserver != null) &#123; mLifecycleEventObserver.onStateChanged(source, event); &#125; &#125;&#125; 5.2、第三种情况对于第三种情况的反射操作，其逻辑相对来说会比较复杂，需要进行一系列的类型判断、类型缓存、反射调用等操作，这里主要来看下 ClassesInfoCache 对于使用 OnLifecycleEvent进行注解的函数是如何进行限制的 开发者应该都知道，Java 平台的反射操作是一个比较低效和耗费性能的行为，为了避免每次有需要进行事件回调时都再来对包含 OnLifecycleEvent 注解的 class 对象进行反射解析，所以 Lifecycling 内部对 Class、Method 等进行了缓存，以便后续复用。而 Lifecycling 就将这些缓存信息都封装存放在了 ClassesInfoCache 内部 此外，被注解的函数的入参类型、入参顺序、入参个数都有着严格的限制，毕竟如果开发者为回调函数声明了一个 String 类型的入参参数的话，Lifecycle 也不知道该向其传递什么属性值 ClassesInfoCache 内部会判断指定的 class 对象是否包含使用了 OnLifecycleEvent 进行注解的函数，并将判断结果缓存在 mHasLifecycleMethods 内，缓存信息会根据 createInfo(klass, methods) 来进行获取 123456789101112131415161718192021222324252627//判断指定的 class 对象是否包含使用了 OnLifecycleEvent 进行注解的函数 boolean hasLifecycleMethods(Class&lt;?&gt; klass) &#123; Boolean hasLifecycleMethods = mHasLifecycleMethods.get(klass); if (hasLifecycleMethods != null) &#123; //如果本地有缓存的话则直接返回缓存值 return hasLifecycleMethods; &#125; //本地还没有缓存值，以下逻辑就是来通过反射判断 klass 是否包含使用 OnLifecycleEvent 进行注解的函数 //获取 klass 包含的所有函数 Method[] methods = getDeclaredMethods(klass); for (Method method : methods) &#123; OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class); if (annotation != null) &#123; // Optimization for reflection, we know that this method is called // when there is no generated adapter. But there are methods with @OnLifecycleEvent // so we know that will use ReflectiveGenericLifecycleObserver, // so we createInfo in advance. // CreateInfo always initialize mHasLifecycleMethods for a class, so we don't do it // here. createInfo(klass, methods); return true; &#125; &#125; mHasLifecycleMethods.put(klass, false); return false; &#125; 而正是在 createInfo函数内部对被注解函数的入参类型、入参顺序、入参个数等进行了限制，当不符合规定时则会在运行时直接抛出异常 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980 //以下三个整数值用于标记被注解的函数的入参参数的个数//不包含入参参数private static final int CALL_TYPE_NO_ARG = 0;//包含一个入参参数 private static final int CALL_TYPE_PROVIDER = 1;//包含两个入参参数 private static final int CALL_TYPE_PROVIDER_WITH_EVENT = 2;private CallbackInfo createInfo(Class&lt;?&gt; klass, @Nullable Method[] declaredMethods) &#123; Class&lt;?&gt; superclass = klass.getSuperclass(); Map&lt;MethodReference, Lifecycle.Event&gt; handlerToEvent = new HashMap&lt;&gt;(); if (superclass != null) &#123; CallbackInfo superInfo = getInfo(superclass); if (superInfo != null) &#123; handlerToEvent.putAll(superInfo.mHandlerToEvent); &#125; &#125; Class&lt;?&gt;[] interfaces = klass.getInterfaces(); for (Class&lt;?&gt; intrfc : interfaces) &#123; for (Map.Entry&lt;MethodReference, Lifecycle.Event&gt; entry : getInfo( intrfc).mHandlerToEvent.entrySet()) &#123; verifyAndPutHandler(handlerToEvent, entry.getKey(), entry.getValue(), klass); &#125; &#125; Method[] methods = declaredMethods != null ? declaredMethods : getDeclaredMethods(klass); boolean hasLifecycleMethods = false; for (Method method : methods) &#123; //找到包含 OnLifecycleEvent 注解的函数 OnLifecycleEvent annotation = method.getAnnotation(OnLifecycleEvent.class); if (annotation == null) &#123; continue; &#125; hasLifecycleMethods = true; //以下的所有逻辑是这样的： //1. 获取 method 所对应的函数的参数个数和参数类型，即 params //2. 如果参数个数为 0，则 callType = CALL_TYPE_NO_ARG，method 不包含入参参数 //3. 如果参数个数大于 0，则第一个参数必须是 LifecycleOwner 类型的对象，否则抛出异常 //3.1、如果参数个数为 1，则 callType = CALL_TYPE_PROVIDER //3.2、如果参数个数为 2，则注解值 annotation 必须是 Lifecycle.Event.ON_ANY // 且第二个参数必须是 Lifecycle.Event 类型的对象，否则抛出异常 // 如果一切都符合条件，则 callType = CALL_TYPE_PROVIDER_WITH_EVENT //3.3、如果参数个数大于 2，则抛出异常，即要求 method 最多包含两个参数，且对参数类型和参数顺序进行了限制 Class&lt;?&gt;[] params = method.getParameterTypes(); int callType = CALL_TYPE_NO_ARG; if (params.length &gt; 0) &#123; callType = CALL_TYPE_PROVIDER; if (!params[0].isAssignableFrom(LifecycleOwner.class)) &#123; throw new IllegalArgumentException( "invalid parameter type. Must be one and instanceof LifecycleOwner"); &#125; &#125; Lifecycle.Event event = annotation.value(); if (params.length &gt; 1) &#123; callType = CALL_TYPE_PROVIDER_WITH_EVENT; if (!params[1].isAssignableFrom(Lifecycle.Event.class)) &#123; throw new IllegalArgumentException( "invalid parameter type. second arg must be an event"); &#125; if (event != Lifecycle.Event.ON_ANY) &#123; throw new IllegalArgumentException( "Second arg is supported only for ON_ANY value"); &#125; &#125; if (params.length &gt; 2) &#123; throw new IllegalArgumentException("cannot have more than 2 params"); &#125; MethodReference methodReference = new MethodReference(callType, method); verifyAndPutHandler(handlerToEvent, methodReference, event, klass); &#125; CallbackInfo info = new CallbackInfo(handlerToEvent); mCallbackMap.put(klass, info); mHasLifecycleMethods.put(klass, hasLifecycleMethods); return info; &#125; 然后最终在 MethodReference 类内部的 invokeCallback() 函数完成最终的反射调用 MethodReference 用于缓存具有 OnLifecycleEvent 注解的函数（Method）以及该函数所具有的入参个数（知道了入参个数就知道了该如何进行反射调用），通过 invokeCallback() 函数来进行 Lifecycle.Event 事件通知 12345678910111213141516171819202122232425262728293031323334353637static class MethodReference &#123; final int mCallType; final Method mMethod; MethodReference(int callType, Method method) &#123; mCallType = callType; mMethod = method; mMethod.setAccessible(true); &#125; void invokeCallback(LifecycleOwner source, Lifecycle.Event event, Object target) &#123; //noinspection TryWithIdenticalCatches //根据入参个数来传递特定的参数并进行反射回调 //因此用 OnLifecycleEvent 进行注解的函数，其入参个数、入参类型、入参声明顺序都有固定的要求 //当不符合要求时会导致反射失败从而抛出异常 try &#123; switch (mCallType) &#123; case CALL_TYPE_NO_ARG: mMethod.invoke(target); break; case CALL_TYPE_PROVIDER: mMethod.invoke(target, source); break; case CALL_TYPE_PROVIDER_WITH_EVENT: mMethod.invoke(target, source, event); break; &#125; &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException("Failed to call observer method", e.getCause()); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; &#125; //省略无关函数 ···· &#125; 六、总结Lifecycle 的整个事件流程都在上文大致讲述完毕了，这里再来做下总结 我们日常使用的 androidx.appcompat.app.AppCompatActivity 和 androidx.fragment.app.Fragment 都实现了 LifecycleOwner 接口，其 getLifecycle() 方法返回的 Lifecycle 对象均为 LifecycleRegistry AppCompatActivity 默认挂载了一个无 UI 界面的 ReportFragment，ReportFragment 会根据用户手机的系统版本号高低，用不同的方式获取到 AppCompatActivity 的事件变化通知，最终调用 LifecycleRegistry 的 handleLifecycleEvent(Lifecycle.Event) 方法将 Lifecycle.Event 传递出去。此时，LifecycleRegistry 就拿到了 Lifecycle.Event androidx.fragment.app.Fragment 会在内部直接调用 LifecycleRegistry 的 handleLifecycleEvent(Lifecycle.Event) 方法完成事件通知，此时，LifecycleRegistry 也拿到了 Lifecycle.Event LifecycleRegistry 会将外部 addObserver 传进来的 LifecycleObserver 对象都给包装成 ObserverWithState 类内部的 LifecycleEventObserver 对象，屏蔽了外部传进来的 LifecycleObserver 的差异性（可能是接口，也可能是注解） LifecycleRegistry 通过直接调用 ObserverWithState 类内部的 LifecycleEventObserver 对象的 onStateChanged 方法来完成最终的事件回调。至此整个流程就完成了]]></content>
      <categories>
        <category>Jetpack</category>
      </categories>
      <tags>
        <tag>Lifecycle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式六大原则]]></title>
    <url>%2F2019%2F06%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[1、单一职责原则（Single Responsibility Principle，简称SRP ） 核心思想：应该有且仅有一个原因引起类的变更 问题描述：假如有类Class1完成职责T1，T2，当职责T1或T2有变更需要修改时，有可能影响到该类的另外一个职责正常工作。 好处：类的复杂度降低、可读性提高、可维护性提高、扩展性提高、降低了变更引起的风险。 需注意：单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可以度量的，因项目和环境而异。 2、里氏替换原则（Liskov Substitution Principle,简称LSP） 核心思想：在使用基类的的地方可以任意使用其子类，能保证子类完美替换基类。 通俗来讲：只要父类能出现的地方子类就能出现。反之，父类则未必能胜任。 好处：增强程序的健壮性，即使增加了子类，原有的子类还可以继续运行。 需注意：如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系 采用依赖、聚合、组合等关系代替继承。 3、依赖倒置原则（Dependence Inversion Principle,简称DIP） 核心思想：高层模块不应该依赖底层模块，二者都该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象； 说明：高层模块就是调用端，低层模块就是具体实现类。抽象就是指接口或抽象类。细节就是实现类。 通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。 问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；假如修改类A，会给程序带来不必要的风险。 解决方案：将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。 好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。 4、接口隔离原则（Interface Segregation Principle,简称ISP） 核心思想：类间的依赖关系应该建立在最小的接口上 通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类B来说不是最小接口，则类B和类D必须去实现他们不需要的方法。 需注意： 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情 为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。 5、迪米特法则（Law of Demeter,简称LoD） 核心思想：类间解耦。 通俗来讲： 一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。 6、开放封闭原则（Open Close Principle,简称OCP） 核心思想：尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化 通俗来讲： 一个软件产品在生命周期内，都会发生变化，既然变化是一个既定的事实，我们就应该在设计的时候尽量适应这些变化，以提高项目的稳定性和灵活性。 一句话概括:单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。 总结：最后总结一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。 图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形 2.png 在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>六大原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git配置多个SSH Key]]></title>
    <url>%2F2019%2F06%2F15%2Fgit%E9%85%8D%E7%BD%AE%E5%A4%9A%E4%B8%AASSH-Key%2F</url>
    <content type="text"><![CDATA[git配置多个SSH Key当有多个git账号时，比如： 一个github，国际认可的仓库 一个gitee码云，国内仓库，速度快 这两者如果邮箱不同的话，在生成第二个key的时候会覆盖第一个的key，导致一个用不了。 解决办法就是： 生成两个（或多个）不同的公私密钥对，用config文件管理它们。 1 步骤我们假设原来在~/.ssh目录下已经生成了一个密钥对： 12id_rsaid_rsa.pub 1.1 生成第二个key接下来我们生成第二个ssh key： 1ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot; 这里不要一路回车，我们自己手动填写保存路径： Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Gary/.ssh/id_rsa): /c/Users/Gary/.ssh/id_rsa_github&lt;剩下两个直接回车&gt; 这里我们用id_rsa_github来区别原有密钥对，避免被覆盖。 完成之后，我们可以看到~/.ssh目录下多了两个文件，变成： id_rsa id_ras.pub id_rsa_github id_rsa_github.pub known_hosts 1.2 打开ssh-agent这里如果你用的github官方的bash，用： 1ssh-agent -s 如果是其他的，比如msysgit，用： 1eval $(ssh-agent -s) 略过这一步的话，下一步会提示这样的错误：Could not open a connection to your authentication agent. 1.3 添加私钥12ssh-add ~/.ssh/id_rsassh-add ~/.ssh/id_rsa_github 如果提示文件或目录不存在，就使用绝对地址。 1.4 创建config文件在~/.ssh目录下创建名为config的文件。 添加一下内容： 1234567891011# gitee Host gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee# github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github 其中，Host和HostName填写git服务器的域名。 IdentityFile指定私钥的路径。 如果在Linux系统下提示错误：Bad owner or permissions on /home/gary/.ssh/config 说明config权限过大，chmod命令调整： 1$ chmod 644 ~/.ssh/config 然后在github和gitee码云上添加公钥即可，这里不再多说。 1.5 测试然后用ssh命令分别测试： 1ssh -T git@github.com 2 调试如果到这里你没有成功的话，别急，教你解决问题的终极办法--debug 比如测试github： 1ssh -vT git@github.com -v 是输出编译信息，然后根据编译信息自己去解决问题吧。 就我自己来说一般是config里的host那块写错了。 3 关于用户名如果之前有设置全局用户名和邮箱的话，需要unset一下 12git config --global --unset user.namegit config --global --unset user.email 然后在不同的仓库下设置局部的用户名和邮箱比如在公司的repository下 12git config user.name "yourname" git config user.email "youremail" 在自己的github的仓库在执行刚刚的命令一遍即可。 这样就可以在不同的仓库，已不同的账号登录。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聊聊性能优化]]></title>
    <url>%2F2019%2F06%2F14%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[布局优化 尽量减少嵌套 include、merge、ViewStub 减少过度绘制 backgroud属性不要重复设置 简单页面优先使用LinearLayout 、FrameLayout、复杂页面使用ConstraintLayout onDraw不要做耗时任务，不要循环创建大量对象 ​ 渲染问题 过度绘制（设置 — 开发者选项 — 调试GPU过度绘制—x4次红色显示） ​ 1、移除或修改Theme、Window默认的Background 2、移除XML布局文件中非必需的Background 3、按需显示占位背景图片 4、控制绘制区域 布局优化 减少布局嵌套和层级 merge、include、ViewStub 查看渲染性能工具 GPU呈现模式分析 GPU monitor 启用严格模式：主线程上执行长时间操作会闪烁屏幕 性能优化必备神器Lint检查工具，Performance 内存优化内存泄漏 集合类泄漏 单例/静态变量造成的内存泄漏 匿名内部类/非静态内部类 资源未关闭造成的内存泄漏 分析工具：Memory Profiler、 Leakcanary、MAT、TraceView、GT（腾讯移动调试平台） 内存浪费 使用ArrayMap、SparseArray（避免了自动装箱）代替HashMap 避免使用Enum，内存耗费是final static int 的10几倍 内存抖动：避免循环体内大量创建大型对象 ​ 启动速度优化思路：Application、Activity创建以及回调等过程 启动页设置windowBackground属性，快速展示出来一个界面； 避免在启动时做密集沉重的初始化（Heavy app initialization）； 1、比如像友盟，bugly这样的业务非必要的可以的异步加载。 2、比如地图，推送等，非第一时间需要的可以在主线程做延时启动。当程序已经启动起来之后，在进行初始化。 3、对于图片，网络请求框架必须在主线程里初始化了。 同时因为我们一般会有闪屏页面，也可以把延时启动的地图，推动的启动在这个时间段里，这样合理安排时间片的使用。极大的提高了启动速度。 ​ 避免I/O操作、反序列化、网络操作、布局嵌套等。 Apk大小优化 lint工具去除无用资源 开启混淆和资源压缩 shrinkResources true minifyEnabled true 利用shape和colorTint减少部分图片 图片压缩 webp、pngcrush 矢量图形VectorDrawable 插件化部署 耗电优化 更细的耗电分析可以使用这个Battery Historian 使用JobScheduler JobScheduler来调整任务优先级等策略来达到降低损耗的目的, 避免频繁的唤醒硬件模块，造成不必要的电量消耗。避免在不合适的时间(例如低电量情况下、弱网络或者移动网络情况下的)执行过多的任务消耗电量。 懒惰第一的法则: 减少重复操作、推迟执行、合并处理 特别关注WakeLock、GPS、蓝牙等耗电业务 BitMap优化 对图片质量进行压缩 对图片尺寸进行压缩 使用libjpeg.so库进行压缩 RecyclerView 分页加载，ListView使用ViewHolder 网络优化 工具：WireShark、Fiddler、Charles、NetWork Profiler 减少网络请求频次、Api接口合并请求 Gzip压缩，用Protocol Buffer代替Json 列表加载请求缩略图、webp、图片缓存 IP直连，省去DNS解析过程 其他优化 主线程避免耗时操作、异步处理 采用线程池、避免线程切换开销 Google官方建议: Performance Android Performance Patterns 视屏 相关学习整理可以前往胡凯大佬的博客阅读，感谢他的无私分享： Android 性能优化典范 - 第 1 季 Android 性能优化典范 - 第 2 季 Android 性能优化典范 - 第 3 季 Android 性能优化典范 - 第 4 季 Android 性能优化典范 - 第 5 季 Android 性能优化典范 - 第 6 季]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit源码解析]]></title>
    <url>%2F2018%2F04%2F10%2FRetrofit%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Retrofit 是Android开发中非常流行的网络请求库，它能够让开发者使用接口定义加注解的方式，非常优雅的发送网络请求，其实Retrofit只是用统一接口的方式封装了网络请求，底层网络请求还是通过 OkHttp来实现的 。其封装过程十分的优雅，用两个字来概括就是—-解耦。 Retrofit GitHub 地址：https://github.com/square/retrofit 下面先看一下 Retrofit 的简单实用方式。 Retrofit 使用方法直接抄官网的： 第一步，声明 API 接口： 1234public interface GitHubService &#123; @GET("users/&#123;user&#125;/repos") Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path("user") String user);&#125; 第二步，构造出 Retrofit 对象： 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl("https://api.github.com/") .addConverterFactory(GsonConverterFactory.create()) .build(); 第三步，得到 API 接口，直接调用： 12GitHubService service = retrofit.create(GitHubService.class);//得到代理对象Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos("octocat"); 最后，就是调用 repos 执行 Call ： 1234// syncrepos.execute();// asyncrepos.enqueue(CallBack callback); 请求源码解析Retrofit请求流程对比一般的OkHttp请求流程： 我们先来看看发出网络请求部分的源码。 Retrofit.Builder首先切入点就是 Retrofit.Builder 。 123456789101112131415161718192021222324//Retrofit.java#Builderpublic static final class Builder &#123; private final Platform platform; private okhttp3.Call.Factory callFactory; private HttpUrl baseUrl; private final List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(); private final List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(); private Executor callbackExecutor; private boolean validateEagerly; Builder(Platform platform) &#123; this.platform = platform;// 确定平台，有 Android、 Java8 默认Platform 三种 // Add the built-in converter factory first. This prevents overriding its behavior but also // ensures correct behavior when using converters that consume all types. converterFactories.add(new BuiltInConverters()); &#125; public Builder() &#123; this(Platform.get()); &#125; ... &#125; 在 Retrofit.Builder 中有以下的方法： platform : 确定运行平台，Android环境对应于Android callFactory ： 设置网络请求 call 的工厂，默认就是上面的OkHttpClient baseUrl ： api 的 base url addConverterFactory ： 添加数据转换器工厂 addCallAdapterFactory ： 添加网络请求适配器工厂 callbackExecutor ： 回调方法执行器，用于切换线程 validateEagerly ： 是否提前解析接口方法 这些都是用来配置 Builder 的，这边用到了建造者模式。 建造者模式: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 那么我们来看下 Builder 的构造方法：来个小插曲，我们来看下 Retrofit 是如何确定平台的： Platform1234567891011121314151617181920212223242526//Platform.javaclass Platform &#123; private static final Platform PLATFORM = findPlatform(); static Platform get() &#123; return PLATFORM; &#125; private static Platform findPlatform() &#123; try &#123; Class.forName("android.os.Build"); if (Build.VERSION.SDK_INT != 0) &#123; return new Android();//这里构建了一个Android对象 &#125; &#125; catch (ClassNotFoundException ignored) &#123; &#125; try &#123; Class.forName("java.util.Optional"); return new Java8(); &#125; catch (ClassNotFoundException ignored) &#123; &#125; return new Platform(); &#125; ...&#125; 从上面的代码中可以看到，是通过反射来判断具体是哪个Platfrom，这个用到的简单的策略模式。 策略模式：定义一系列的算法，把它们一个个封装起来, 并且使它们可相互替换。 接着，在创建 Builder 对象并进行自定义配置后，我们就要调用 build() 方法来构建出 Retrofit 对象了。那么，我们来看下 build() 方法里干了什么： 123456789101112131415161718192021222324252627//Retrofit.javapublic Retrofit build() &#123; if (baseUrl == null) &#123; throw new IllegalStateException("Base URL required."); &#125; // 网络请求执行器 默认为 OkHttpClient okhttp3.Call.Factory callFactory = this.callFactory; if (callFactory == null) &#123; callFactory = new OkHttpClient(); &#125; // Android 平台下默认为 MainThreadExecutor 可切换到主线程 Executor callbackExecutor = this.callbackExecutor; if (callbackExecutor == null) &#123; callbackExecutor = platform.defaultCallbackExecutor(); &#125; // Make a defensive copy of the adapters and add the default Call adapter. List&lt;CallAdapter.Factory&gt; adapterFactories = new ArrayList&lt;&gt;(this.adapterFactories); // Android 平台下添加默认的 ExecutorCallAdapterFactory，文章后面会分析 adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor)); // Make a defensive copy of the converters. 默认有 BuiltInConverters List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(this.converterFactories); return new Retrofit(callFactory, baseUrl, converterFactories, adapterFactories, callbackExecutor, validateEagerly);&#125; 在 build() 中，配置了网络执行器OkHttpClient, 异步回调线程切换器MainThreadExecutor, 网络适配器工厂列表（默认添加ExecutorCallAdapterFactory），数据转换器工厂列表(默认添加BuiltInConverters),并以此构建出了Retrofit类。 RetrofitRetrofit 类的构造方法没什么好看的，只是简单的将Build的属性依次赋给Retrofit。 得到 Retrofit 对象后就是调用 create(final Class&lt;T&gt; service) 方法来创建我们 API 接口的实例。 所以我们需要跟进 create(final Class&lt;T&gt; service) 中来看下： 12345678910111213141516171819202122232425262728//Retrofit.javapublic &lt;T&gt; T create(final Class&lt;T&gt; service) &#123; Utils.validateServiceInterface(service); if (validateEagerly) &#123; eagerlyValidateMethods(service); &#125; //生成动态代理，后面调用代理的方法都将走到InvocationHandler的invoke方法 return (T) Proxy.newProxyInstance(service.getClassLoader(), new Class&lt;?&gt;[] &#123; service &#125;, new InvocationHandler() &#123; private final Platform platform = Platform.get(); @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // If the method is a method from Object then defer to normal invocation. if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(this, args); &#125; if (platform.isDefaultMethod(method)) &#123; return platform.invokeDefaultMethod(method, service, proxy, args); &#125; //敲黑板----&gt;最最最重要的3句话 ServiceMethod&lt;Object, Object&gt; serviceMethod = (ServiceMethod&lt;Object, Object&gt;) loadServiceMethod(method); OkHttpCall&lt;Object&gt; okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); return serviceMethod.callAdapter.adapt(okHttpCall); &#125; &#125;); &#125; 在上面的代码中，很巧妙的使用了动态代理模式：在调用代理类的任何方法时，都将统一执行InvocationHandler的invoke方法，并在这里添加额外的处理。 动态代理：代理类在程序运行前不存在、运行时由程序动态生成的代理方式。 这种代理方式的一大好处是可以方便对代理类的函数做统一或特殊处理，如记录所有函数执行时间、所有函数执行前添加验证判断、对某个特殊函数进行特殊操作，而不用像静态代理方式那样需要修改每个函数。 invoke中的核心就是以下3句话： 123456// 将接口中每个方法配置为一个 ServiceMethodServiceMethod serviceMethod = loadServiceMethod(method);//用ServiceMethod和args构造出一个 OkhttpCallOkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);//执行网络适配器的adapter方法return serviceMethod.callAdapter.adapt(okHttpCall); 这三句代码，下面我们重点分析。 在代理中，会根据参数中传入的具体接口方法来构造出对应的 ServiceMethod 。ServiceMethod 类的作用就是把接口的方法适配为对应的 HTTP call 。 1234567891011121314//Retrofit.javaServiceMethod loadServiceMethod(Method method) &#123; ServiceMethod result; synchronized (serviceMethodCache) &#123; // 先从缓存中取，若没有就去创建对应的 ServiceMethod result = serviceMethodCache.get(method); if (result == null) &#123; // 没有缓存就创建，之后再放入缓存中 result = new ServiceMethod.Builder(this, method).build(); serviceMethodCache.put(method, result); &#125; &#125; return result;&#125; 可以看到在内部还维护了一个 Map serviceMethodCache 来缓存 ServiceMethod，提高利用效率。ServiceMethod的创建还是用到了建造者模式，来复习一下 。 建造者模式: 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示. ServiceMethod发现 ServiceMethod 也是通过建造者模式来创建对象的。先看下它的Builder： 12345678910111213141516171819202122232425262728293031323334353637383940//ServiceMethod.java#Builder static final class Builder&lt;T, R&gt; &#123; final Retrofit retrofit; final Method method; final Annotation[] methodAnnotations; final Annotation[][] parameterAnnotationsArray; final Type[] parameterTypes; Type responseType; boolean gotField; boolean gotPart; boolean gotBody; boolean gotPath; boolean gotQuery; boolean gotUrl; String httpMethod;//GET\POST\PUT boolean hasBody; boolean isFormEncoded; boolean isMultipart; String relativeUrl;//path Headers headers;//Headers MediaType contentType; Set&lt;String&gt; relativeUrlParamNames; ParameterHandler&lt;?&gt;[] parameterHandlers;//用于解析接口的参数注解 Converter&lt;ResponseBody, T&gt; responseConverter;//每个SeviceMethod对应一个返回数据转换器 CallAdapter&lt;T, R&gt; callAdapter;//每个SeviceMethod对应一个网络适配器 Builder(Retrofit retrofit, Method method) &#123; this.retrofit = retrofit; //获取method方法 this.method = method; //获取接口方法的注解 this.methodAnnotations = method.getAnnotations(); //获取接口方法参数的类型 this.parameterTypes = method.getGenericParameterTypes(); //获取接口方法参数注解的类型 this.parameterAnnotationsArray = method.getParameterAnnotations(); &#125; ...&#125; 在构造方法中获取了method的注解，参数类型数组、参数注解的二维数组，然后看 build() 方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//ServiceMethod.java#Builder public ServiceMethod build() &#123; // 根据接口方法的注解和返回类型创建 callAdapter // 根据method的注解和返回值，获取retrofit中对应的CallAdapter // 如果没有添加 CallAdapter 那么默认会用 ExecutorCallAdapterFactory提供的callAdapter callAdapter = createCallAdapter(); // calladapter 的响应类型中的泛型，比如 Call&lt;User&gt; 中的 User responseType = callAdapter.responseType();//返回值类型 if (responseType == Response.class || responseType == okhttp3.Response.class) &#123; throw methodError("'" + Utils.getRawType(responseType).getName() + "' is not a valid response body type. Did you mean ResponseBody?"); &#125; // 根据method的返回值和注解获取retrofit中的 返回数据转换器 ResponseConverter responseConverter = createResponseConverter(); // 根据接口方法的注解构造请求方法，比如 @GET @POST @DELETE @PUT @Headers 等 for (Annotation annotation : methodAnnotations) &#123; parseMethodAnnotation(annotation); &#125; if (httpMethod == null) &#123; throw methodError("HTTP method annotation is required (e.g., @GET, @POST, etc.)."); &#125; // 若无 body 则不能有 isMultipart 和 isFormEncoded if (!hasBody) &#123; if (isMultipart) &#123; throw methodError( "Multipart can only be specified on HTTP methods with request body (e.g., @POST)."); &#125; if (isFormEncoded) &#123; throw methodError("FormUrlEncoded can only be specified on HTTP methods with " + "request body (e.g., @POST)."); &#125; &#125; // 下面的代码主要用来解析接口方法参数中的注解，比如 @Path @Query @QueryMap @Field @Body等等 // 相应的，每个方法的参数都创建了一个 ParameterHandler&lt;?&gt; 对象 int parameterCount = parameterAnnotationsArray.length; parameterHandlers = new ParameterHandler&lt;?&gt;[parameterCount]; for (int p = 0; p &lt; parameterCount; p++) &#123; Type parameterType = parameterTypes[p]; if (Utils.hasUnresolvableType(parameterType)) &#123; throw parameterError(p, "Parameter type must not include a type variable or wildcard: %s", parameterType); &#125; Annotation[] parameterAnnotations = parameterAnnotationsArray[p]; if (parameterAnnotations == null) &#123; throw parameterError(p, "No Retrofit annotation found."); &#125; //真的的解析参数注解的地方 parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations); &#125; // 检查构造出的请求有没有不对的地方？ if (relativeUrl == null &amp;&amp; !gotUrl) &#123; throw methodError("Missing either @%s URL or @Url parameter.", httpMethod); &#125; if (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123; throw methodError("Non-body HTTP method cannot contain @Body."); &#125; if (isFormEncoded &amp;&amp; !gotField) &#123; throw methodError("Form-encoded method must contain at least one @Field."); &#125; if (isMultipart &amp;&amp; !gotPart) &#123; throw methodError("Multipart method must contain at least one @Part."); &#125; return new ServiceMethod&lt;&gt;(this);&#125; 在 build() 中代码挺长的，总结起来就一句话： 解析API 接口中的方法，根据其返回值、方法注解、参数注解等配置组合成一个ServiceMethod对象。 细化下就是： 根据method的returnType和Annotations创建网络适配器 CallAdapter 和 返回数据转换器Converter； 根据method的注解构造网络请求方法，比如@GET、@POST，头部字段，相对路径等； 根据 method各个参数的注解填充到parameterHandlers[]，比如构造具体的网络请求的参数@Body、 @Field、 @Query、 @Part等； 代码中都是注释，在这里就不详细多讲了，到这里第一步如何构建ServiceMethod就分析完了。 1ServiceMethod serviceMethod = loadServiceMethod(method); 下面看第二句话： 1OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args); OkHttpCall看一下 OkHttpCall的构造方法，只是简单的将ServiceMethod和args传进来而已： 1234567891011121314151617181920212223242526272829final class OkHttpCall&lt;T&gt; implements Call&lt;T&gt; &#123; private final ServiceMethod&lt;T, ?&gt; serviceMethod; private final Object[] args; private volatile boolean canceled; // All guarded by this. private okhttp3.Call rawCall; //原始的Okhttp.Call private Throwable creationFailure; // Either a RuntimeException or IOException. private boolean executed; OkHttpCall(ServiceMethod&lt;T, ?&gt; serviceMethod, Object[] args) &#123; this.serviceMethod = serviceMethod; this.args = args; &#125; ... private okhttp3.Call createRawCall() throws IOException &#123; //通过ServiceMethod构建一个OkHttp的Request Request request = serviceMethod.toRequest(args); //这里的serviceMethod.callFactory就是OkHttpClient对象 okhttp3.Call call = serviceMethod.callFactory.newCall(request); if (call == null) &#123; throw new NullPointerException("Call.Factory returned null."); &#125; return call; &#125;&#125; 这里的OkHttpCall实现了retrofit2.Call接口，但网络请求最终还是委托给了okhttp3.Call rawCall来执行，这里也有点适配器模式的意思。先了解下Retrofit的Call接口： 12345678910package retrofit2;public interface Call&lt;T&gt; extends Cloneable &#123; //同步请求 Response&lt;T&gt; execute() throws IOException; //异步请求 void enqueue(Callback&lt;T&gt; callback); ... /** The original HTTP request. */ Request request();&#125; 再看一下createRawCall()如何创建一个rawCall，这里我们又回到了ServiceMethod里面，这里创建来一个RequestBuilder请求对象建造者，配合参数注解ParameterHandler将args配置到RequestBuilder中，最后构建出一个完整的的okhttp3.Request对象，具体如下： 123456789101112131415161718192021//ServiceMethod.java /** Builds an HTTP request from method arguments. */ Request toRequest(Object... args) throws IOException &#123; //http method, url, relativeUrl, headers, body, form创建一个完整的Http模版对象 RequestBuilder requestBuilder = new RequestBuilder(httpMethod, baseUrl, relativeUrl, headers, contentType, hasBody, isFormEncoded, isMultipart); ParameterHandler&lt;Object&gt;[] handlers = (ParameterHandler&lt;Object&gt;[]) parameterHandlers; int argumentCount = args != null ? args.length : 0; if (argumentCount != handlers.length) &#123; throw new IllegalArgumentException("Argument count (" + argumentCount + ") doesn't match expected count (" + handlers.length + ")"); &#125; for (int p = 0; p &lt; argumentCount; p++) &#123; handlers[p].apply(requestBuilder, args[p]);//将用户参数填充到requestBuilder &#125; return requestBuilder.build(); &#125; RequestBuilder对象，他的成员包括了http的完整内容method, url, relativePath, headers, body, form等参数： 1234567891011121314151617final class RequestBuilder &#123; private final String method;//get or post private final HttpUrl baseUrl;//url private String relativeUrl; private HttpUrl.Builder urlBuilder; private final Request.Builder requestBuilder; private MediaType contentType; //type private final boolean hasBody; private MultipartBody.Builder multipartBuilder; private FormBody.Builder formBuilder;//表单 private RequestBody body;//body ...&#125; 最后调用requestBuilder.build()构建了一个真正的请求okhttp3.Request. 接着通过serviceMethod.callFactory.newCall(request)就构建出OkHttp的rawCall，这个的 serviceMethod.callFactory网络执行器就是Retrotif默认的OkHttpClient对象。 概括一下：OkHttpCall中依赖了ServiceMethod和rawCall,通过ServiceMethod构建了一个原始的OkHttp Request请求，并通过OkHttpClient的newCall(request)创建rawCall来执行真正的网络请求。 ExecutorCallAdapterFactory在前面Retrofit的build过程中我们知道Platform是Android时，默认的 网络适配器工厂CallAdapter.Factory是ExecutorCallAdapterFactory，下面看一下这个工厂的创建过程： 12345678910111213141516171819//Platform.javastatic class Android extends Platform &#123; @Override public Executor defaultCallbackExecutor() &#123; return new MainThreadExecutor(); &#125; @Override CallAdapter.Factory defaultCallAdapterFactory(Executor callbackExecutor) &#123; return new ExecutorCallAdapterFactory(callbackExecutor); &#125; //用于切换到主线程 static class MainThreadExecutor implements Executor &#123; private final Handler handler = new Handler(Looper.getMainLooper()); @Override public void execute(Runnable r) &#123; handler.post(r); &#125; &#125;&#125; 其中包含了一个线程切换的执行器MainThreadExecutor用于异步回调切换回主线程执行。 默认的网络适配器工厂ExecutorCallAdapterFactory，继承了CallAdapter.Factory，其源码见下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//ExecutorCallAdapterFactory.javafinal class ExecutorCallAdapterFactory extends CallAdapter.Factory &#123; final Executor callbackExecutor; ExecutorCallAdapterFactory(Executor callbackExecutor) &#123; this.callbackExecutor = callbackExecutor; &#125; //根据返回值和注解返回对应的CallAdapter @Override public CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123; if (getRawType(returnType) != Call.class) &#123; return null; &#125; //Call&lt;Repo&gt;是returnType类型，他的responseType类型是Repo. final Type responseType = Utils.getCallResponseType(returnType); //Retrofit默认的网络适配器CallAdatper在这里返回，其实是个匿名类对象 return new CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123; @Override public Type responseType() &#123; return responseType; &#125; //这里的adapt方法会在Retrofit#create()中的第三句最核心代码被调用到了， //这里的call就是OkHttpCall对象 @Override public Call&lt;Object&gt; adapt(Call&lt;Object&gt; call) &#123; return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); &#125; &#125;; &#125; //ExecutorCallbackCall实现了线程切换 static final class ExecutorCallbackCall&lt;T&gt; implements Call&lt;T&gt; &#123; final Executor callbackExecutor; final Call&lt;T&gt; delegate;//这里的delegate就是OkHttpCall对象 ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123; this.callbackExecutor = callbackExecutor; this.delegate = delegate; &#125; @Override public void enqueue(final Callback&lt;T&gt; callback) &#123; if (callback == null) throw new NullPointerException("callback == null"); //异步执行，入队 delegate.enqueue(new Callback&lt;T&gt;() &#123; @Override public void onResponse(Call&lt;T&gt; call, final Response&lt;T&gt; response) &#123; //返回reponse后，切换到主线程执行，本质是通过handler来实现的 callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; if (delegate.isCanceled()) &#123; callback.onFailure(ExecutorCallbackCall.this, new IOException("Canceled")); &#125; else &#123; callback.onResponse(ExecutorCallbackCall.this, response); &#125; &#125; &#125;); &#125; @Override public void onFailure(Call&lt;T&gt; call, final Throwable t) &#123; callbackExecutor.execute(new Runnable() &#123; @Override public void run() &#123; callback.onFailure(ExecutorCallbackCall.this, t); &#125; &#125;); &#125; &#125;); &#125; ... //同步执行 @Override public Response&lt;T&gt; execute() throws IOException &#123; return delegate.execute(); &#125; @Override public Request request() &#123; return delegate.request(); &#125; &#125;&#125; 说明全在注释里面了，ExecutorCallAdapterFactory主要是返回了一个匿名的CallAdapter,该适配器能够将普通的Call&lt;T&gt;通过adapter适配为ExecutorCallbackCall&lt;T&gt;，我们回过去看Retrofit#create()中的第三句核心代码： 1return serviceMethod.callAdapter.adapt(okHttpCall); 没错这里传入的就是OkHttpCall，通过网络适配器返回的是一个ExecutorCallbackCall对象. ExecutorCallbackCall1return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call); 采用了装饰模式：ExecutorCallbackCall 为装饰者，而里面真正去执行网络请求的还是OkHttpCall。通过 ExecutorCallbackCall ，我们可以调用同步方法 execute() 或异步方法 enqueue(Callback&lt;T&gt; callback) 来执行该 call，异步调用后的callback会通过callbackExecutor切换回主线程执行. 于是委托关系是：ExecutorCallbackCall—&gt;retrofit.OkHttpCall—&gt;okhttp3.rawCall。 看一下同步的execute()方法，只是调用了delegate.execute()方法，delegate就是OkHttpCall。 再看OkHttpCall#execute()方法看一下它的execute()方法: 123456789101112131415161718192021222324252627282930313233343536 @Override public Response&lt;T&gt; execute() throws IOException &#123; okhttp3.Call call; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already executed."); executed = true; if (creationFailure != null) &#123; if (creationFailure instanceof IOException) &#123; throw (IOException) creationFailure; &#125; else &#123; throw (RuntimeException) creationFailure; &#125; &#125; call = rawCall; if (call == null) &#123; try &#123; // 根据 serviceMethod 中的配置参数创建出 Okhttp 中的 Request 对象 // 注意的一点，会调用上面的 ParameterHandler.apply 方法来填充网络请求参数 // 然后再根据 OkhttpClient 的newCall(request) 创建出 Okhttp类型的rawCall // 这一步也说明了在 Retrofit 中的 OkHttpCall 内部请求最后会转换为 OkHttp 的 Call call = rawCall = createRawCall(); &#125; catch (IOException | RuntimeException e) &#123; creationFailure = e; throw e; &#125; &#125; &#125; // 检查 call 是否取消 if (canceled) &#123; call.cancel(); &#125;// 执行 call 并转换响应的 response return parseResponse(call.execute()); &#125; 在 execute() 做的就是将 Retrofit 中的 call 转化为 OkHttp 中的 rawCall 。 最后让 OkHttp 的 call 去执行, 返回响应okhttp3.Response。 Response解析我们可以看到 OkHttpCall.execute() 中的最后一句：parseResponse(call.execute())，对响应的处理就是这个方法了。 再看OkHttpCall#parseResponse()OkHttpCall的execute()委托给了okhttp3.Call rawCall来执行，因此返回的Reponse数据也是在这里进一步处理： 123456789101112131415161718192021222324252627282930313233343536//OkHttpCall.javaResponse&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException &#123; ResponseBody rawBody = rawResponse.body(); // Remove the body's source (the only stateful object) so we can pass the response along. rawResponse = rawResponse.newBuilder() .body(new NoContentResponseBody(rawBody.contentType(), rawBody.contentLength())) .build(); // 如果返回的响应码不是成功的话，返回错误 Response int code = rawResponse.code(); if (code &lt; 200 || code &gt;= 300) &#123; try &#123; // Buffer the entire body to avoid future I/O. ResponseBody bufferedBody = Utils.buffer(rawBody); return Response.error(bufferedBody, rawResponse); &#125; finally &#123; rawBody.close(); &#125; &#125; // 如果返回的响应码是204或者205，返回没有 body 的成功 Response if (code == 204 || code == 205) &#123; return Response.success(null, rawResponse); &#125; ExceptionCatchingRequestBody catchingBody = new ExceptionCatchingRequestBody(rawBody); try &#123; // 将 body 转换为对应的泛型，然后返回成功 Response T body = serviceMethod.toResponse(catchingBody); return Response.success(body, rawResponse); &#125; catch (RuntimeException e) &#123; // If the underlying source threw an exception, propagate that rather than indicating it was // a runtime exception. catchingBody.throwIfCaught(); throw e; &#125;&#125; 关键是这句代码：T body = serviceMethod.toResponse(catchingBody); 将 ResponseBody 直接转化为了泛型，可以猜到这也是 返回数据转换器Converter 的功劳。 12345//ServiceMethod.java/** Builds a method return value from an HTTP response body. */T toResponse(ResponseBody body) throws IOException &#123; return responseConverter.convert(body);&#125; 果然没错，内部是调用了 responseConverter 的，那么responseConverter具体是什么？ BuiltInConverters在前面Retrofit的build()部分我们分析了BuiltInConverters是Retrofit默认的数据转换器工厂， 它内置了 responseBodyConverter、requestBodyConverter、ToStringConverter三大类，看下Converter的接口定义： 1234567891011121314151617181920212223242526//Convert对象被Factory工厂创建，Factory在Retrofit.Builder#addConverterFactory(factory)添加public interface Converter&lt;F, T&gt; &#123; T convert(F value) throws IOException; abstract class Factory &#123; //用于将OkHttp的ResponseBody转为任意类型T，比如Call&lt;SimpleResponse&gt; public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; //用于将任意类型T转为OkHttp的RequestBody，比如说类型@Body @Part public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123; return null; &#125; //Object to String Converter public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; return null; &#125; &#125;&#125; Converter.Factory工厂拥有3种Converter 类型： Converter ：用于将OkHttp的ResponseBody转为任意类型T。 Converter&lt;?, RequestBody&gt; ：用于将任意类型T转为OkHttp的RequestBody。 Converter&lt;?, String&gt;：转换成String类型的Converter。 再看BuiltInConverters中的responseBodyConverter： 123456789101112131415161718192021222324252627282930313233//BuiltInConverters.javafinal class BuiltInConverters extends Converter.Factory &#123; @Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; if (type == ResponseBody.class) &#123; return Utils.isAnnotationPresent(annotations, Streaming.class) ? StreamingResponseBodyConverter.INSTANCE : BufferingResponseBodyConverter.INSTANCE;//默认是这个喽 &#125; if (type == Void.class) &#123; return VoidResponseBodyConverter.INSTANCE; &#125; return null; &#125; ... static final class BufferingResponseBodyConverter implements Converter&lt;ResponseBody, ResponseBody&gt; &#123; static final BufferingResponseBodyConverter INSTANCE = new BufferingResponseBodyConverter(); @Override public ResponseBody convert(ResponseBody value) throws IOException &#123; try &#123; // Buffer the entire body to avoid future I/O. return Utils.buffer(value); &#125; finally &#123; value.close(); &#125; &#125; &#125;&#125; 默认是用了 BufferingResponseBodyConverter只是将ResponseBody 缓存了，返回的还是ResponseBody类型。所以OkHttpCall的execute()默认返回的还是Response类型。 GsonConverterFactory如果是 GsonConverterFactory 呢？该工厂自然是构建了一个 GsonResponseBodyConverterGson数据转换器，目的是把ResponseBody 借用gson 转化为用户定义的JavaBean-Type，其源码如下： 12345678//GsonConverterFactory.java@Override public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123; //这里的Type就是responseType，比如Call&lt;SimpleResponse&gt;中的SimpleResponse类型 TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type)); return new GsonResponseBodyConverter&lt;&gt;(gson, adapter); &#125; 其中GsonResponseBodyConverters定义为: 123456789101112131415161718final class GsonResponseBodyConverter&lt;T&gt; implements Converter&lt;ResponseBody, T&gt; &#123; private final Gson gson; private final TypeAdapter&lt;T&gt; adapter; GsonResponseBodyConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123; this.gson = gson; this.adapter = adapter; &#125; @Override public T convert(ResponseBody value) throws IOException &#123; JsonReader jsonReader = gson.newJsonReader(value.charStream()); try &#123; return adapter.read(jsonReader); &#125; finally &#123; value.close(); &#125; &#125;&#125; 显然也是在convert中将ResponseBody利用Gson转换为用户定义的类型T，比如Call中的T就是UserInfo。 呼呼，终于写完了，快晕了😷… 最后Retrofit只是把请求发送和响应封装了一下，内部访问网络仍然是通过 OkHttp ，其特别之处是能通过注解的方式构建网络请求，大大增加了可读性。 Retrofit源码设计中运用了很多设计模式，值得我们深入思考，比如外观模式（定义ApiService接口）、代理模式（Retrofit#create中的Proxy）、建造者模式（Retrofit#Builder，ServiceMethod#Builder）、策略模式(各种Platform)、适配器模式（CallAdapter.adapt）、装饰者模式（ExecutorCallbackCall（OkHttpCall））、工厂模式（CallAdapter.Factory， Converter.Factory）等，这使得Retrofit能够很好的解耦，配合OkHttp和Rxjava发挥出最大的优势。]]></content>
      <categories>
        <category>拆轮子</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OkHttp源码解析]]></title>
    <url>%2F2018%2F04%2F04%2FOkHttp%203.7%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[以下内容为转载自： OkHttp源码分析——整体架构 OkHttp是一个处理网络请求的开源项目,是Android端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。随着OkHttp的不断成熟，越来越多的Android开发者使用OkHttp作为网络框架。 之所以可以赢得如此多开发者的喜爱，主要得益于如下特点： 支持HTTPS/HTTP2/WebSocket（在OkHttp3.7中已经剥离对Spdy的支持，转而大力支持HTTP2） 内部维护任务队列线程池，友好支持并发访问 内部维护连接池，支持多路复用，减少连接创建开销 socket创建支持最佳路由 提供拦截器链（InterceptorChain），实现request与response的分层处理(如透明GZIP压缩，logging等) 为了一探OkHttp是如何具备以下特点的，笔者反复研究OkHttp框架源码，力求通过源码分析向各位解释一二。所以特意准备了几篇博客跟大家一起探讨下OkHttp的方方面面，今天首先从整体架构上分析下OkHttp。 简单使用首先来看下OkHttp的简单使用，OkHttp提供了两种调用方式： 同步调用 异步调用 同步调用1234567891011121314@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(false); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 首先加锁置标志位，接着使用分配器的executed方法将call加入到同步队列中，然后调用getResponseWithInterceptorChain方法（稍后分析）执行http请求，最后调用finishied方法将call从同步队列中删除 异步请求1234567void enqueue(Callback responseCallback, boolean forWebSocket) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; client.dispatcher().enqueue(new AsyncCall(responseCallback, forWebSocket));&#125; 同样先置标志位，然后将封装的一个执行体放到异步执行队列中。这里面引入了一个新的类AsyncCall，这个类继承于NamedRunnable，实现了Runnable接口。NamedRunnable可以给当前的线程设置名字，并且用模板方法将线程的执行体放到了execute方法中 拦截器除了同步调用和异步调用，OkHttp还提供了一个拦截器的概念。拦截器提供了拦截请求和拦截服务器应答的接口。OkHttp提供了一个拦截器链的概念，通过将一个个拦截器组合成一个拦截器链，可以达到在不同层面做不同拦截操作的效果，有点AOP的意思。具体拦截器的使用可以参考：Okhttp-wiki 之 Interceptors 拦截器 总体架构 上图是OkHttp的总体架构，大致可以分为以下几层： Interface——接口层：接受网络访问请求 Protocol——协议层：处理协议逻辑 Connection——连接层：管理网络连接，发送新的请求，接收服务器访问 Cache——缓存层：管理本地缓存 I/O——I/O层：实际数据读写实现 Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑 整体流程图： Interface——接口层：接口层接收用户的网络访问请求（同步请求/异步请求），发起实际的网络访问。OkHttpClient是OkHttp框架的客户端，更确切的说是一个用户面板。用户使用OkHttp进行各种设置，发起各种网络请求都是通过OkHttpClient完成的。每个OkHttpClient内部都维护了属于自己的任务队列，连接池，Cache，拦截器等，所以在使用OkHttp作为网络框架时应该全局共享一个OkHttpClient实例。 Call描述一个实际的访问请求，用户的每一个网络请求都是一个Call实例。Call本身只是一个接口，定义了Call的接口方法，实际执行过程中，OkHttp会为每一个请求创建一个RealCall,每一个RealCall内部有一个AsyncCall: 12345678910111213141516171819202122232425 final class AsyncCall extends NamedRunnable &#123; private final Callback responseCallback; AsyncCall(Callback responseCallback) &#123; super("OkHttp %s", redactedUrl()); this.responseCallback = responseCallback; &#125; String host() &#123; return originalRequest.url().host(); &#125; Request request() &#123; return originalRequest; &#125; RealCall get() &#123; return RealCall.this; &#125; @Override protected void execute() &#123; ... &#125; ...&#125; AsyncCall继承的NamedRunnable继承自Runnable接口： 12345678910111213141516171819public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; 所以每一个Call就是一个线程，而执行Call的过程就是执行其execute方法的过程。 Dispatcher是OkHttp的任务队列，其内部维护了一个线程池，当有接收到一个Call时，Dispatcher负责在线程池中找到空闲的线程并执行其execute方法。这部分将会单独拿一篇博客进行介绍，详细内容可参考本系列接下来的文章。 Protocol——协议层：处理协议逻辑Protocol层负责处理协议逻辑，OkHttp支持Http1/Http2/WebSocket协议，并在3.7版本中放弃了对Spdy协议，鼓励开发者使用Http/2。 Connection——连接层：管理网络连接，发送新的请求，接收服务器访问连接层顾名思义就是负责网络连接。在连接层中有一个连接池，统一管理所有的Socket连接，当用户新发起一个网络请求时，OkHttp会首先从连接池中查找是否有符合要求的连接，如果有则直接通过该连接发送网络请求；否则新创建一个网络连接。 RealConnection描述一个物理Socket连接，连接池中维护多个RealConnection实例。由于Http/2支持多路复用，一个RealConnection可以支持多个网络访问请求，所以OkHttp又引入了StreamAllocation来描述一个实际的网络请求开销（从逻辑上一个Stream对应一个Call，但在实际网络请求过程中一个Call常常涉及到多次请求。如重定向，Authenticate等场景。所以准确地说，一个Stream对应一次请求，而一个Call对应一组有逻辑关联的Stream），一个RealConnection对应一个或多个StreamAllocation,所以StreamAllocation可以看做是RealConenction的计数器，当RealConnection的引用计数变为0，且长时间没有被其他请求重新占用就将被释放。 连接层是OkHttp的核心部分，这部分当然也会单独拿一篇博客详细讲解，详细内容可参考本专题相关文章。 Cache——缓存层：管理本地缓存Cache层负责维护请求缓存，当用户的网络请求在本地已有符合要求的缓存时，OkHttp会直接从缓存中返回结果，从而节省网络开销。这部分内容也会单独拿一篇博客进行介绍，详细内容可参考本专题相关文章。 I/O——I/O层：实际数据读写实现I/O层负责实际的数据读写。OkHttp的另一大有点就是其高效的I/O操作，这归因于其高效的I/O库okio 这部分内容笔者也打算另开一个专题进行介绍。详细内容可以参考本博客相关内容。 Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑拦截器层提供了一个类AOP接口，方便用户可以切入到各个层面对网络访问进行拦截并执行相关逻辑。在下一篇博客中，笔者将通过介绍一个实际的网络访问请求实例来介绍拦截器的原理。 OkHttp源码分析——拦截器 前一篇博客中我们介绍了OkHttp的总体架构，接下来我们以一个具体的网络请求来讲述OkHttp进行网络访问的具体过程。由于该部分与OkHttp的拦截器概念紧密联系在一起，所以将这两部分放在一起进行讲解。 1.构造Demo首先构造一个简单的异步网络访问Demo: 12345678910111213141516OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d("OkHttp", "Call Failed:" + e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d("OkHttp", "Call succeeded:" + response.message()); &#125;&#125;); 2. 发起请求OkHttpClient.newCall实际是创建一个RealCall实例： 123456/** * Prepares the &#123;@code request&#125; to be executed at some point in the future. */@Override public Call newCall(Request request) &#123; return new RealCall(this, request, false /* for web socket */);&#125; RealCall.enqueue实际就是讲一个RealCall放入到任务队列中，等待合适的机会执行: 12345678@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); client.dispatcher().enqueue(new AsyncCall(responseCallback));&#125; 从代码中可以看到最终RealCall被转化成一个AsyncCall并被放入到任务队列中，任务队列中的分发逻辑这里先不说，相关实现会放在OkHttp源码分析——任务队列疑问进行介绍。这里只需要知道AsyncCall的excute方法最终将会被执行: 123456789101112131415161718192021222324[RealCall.java] @Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; client.dispatcher().finished(this); &#125; &#125; &#125; execute方法的逻辑并不复杂，简单的说就是： 调用getResponseWithInterceptorChain获取服务器返回 通知任务分发器(client.dispatcher)该任务已结束 getResponseWithInterceptorChain构建了一个拦截器链，通过依次执行该拦截器链中的每一个拦截器最终得到服务器返回。 3. 构建拦截器链首先来看下getResponseWithInterceptorChain的实现： 123456789101112131415161718[RealCall.java] Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!forWebSocket) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor(forWebSocket)); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest); &#125; 其逻辑大致分为两部分： 创建一系列拦截器，并将其放入一个拦截器数组中。这部分拦截器即包括用户自定义的拦截器也包括框架内部拦截器 创建一个拦截器链RealInterceptorChain,并执行拦截器链的proceed方法 接下来看下RealInterceptorChain的实现逻辑： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[RealInterceptorChain.java]public final class RealInterceptorChain implements Interceptor.Chain &#123; private final List&lt;Interceptor&gt; interceptors; private final StreamAllocation streamAllocation; private final HttpCodec httpCodec; private final RealConnection connection; private final int index; private final Request request; private int calls; public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection, int index, Request request) &#123; this.interceptors = interceptors; this.connection = connection; this.streamAllocation = streamAllocation; this.httpCodec = httpCodec; this.index = index; this.request = request; &#125; @Override public Connection connection() &#123; return connection; &#125; public StreamAllocation streamAllocation() &#123; return streamAllocation; &#125; public HttpCodec httpStream() &#123; return httpCodec; &#125; @Override public Request request() &#123; return request; &#125; @Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpCodec, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection) throws IOException &#123; ...... // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpCodec, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); ...... return response; &#125;&#125; 在proceed方法中的核心代码可以看到，proceed实际上也做了两件事： 创建下一个拦截链。传入index + 1使得下一个拦截器链只能从下一个拦截器开始访问 执行索引为index的intercept方法，并将下一个拦截器链传入该方法 接下来再看下第一个拦截器RetryAndFollowUpInterceptor的intercept方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[RetryAndFollowUpInterceptor.java]public final class RetryAndFollowUpInterceptor implements Interceptor &#123; @Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); streamAllocation = new StreamAllocation( client.connectionPool(), createAddress(request.url()), callStackTrace); int followUpCount = 0; Response priorResponse = null; while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException("Canceled"); &#125; Response response = null; boolean releaseConnection = true; try &#123; //执行下一个拦截器链的proceed方法 response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), false, request)) &#123; throw e.getLastConnectException(); &#125; releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. boolean requestSendStarted = !(e instanceof ConnectionShutdownException); if (!recover(e, requestSendStarted, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. ...... Request followUp = followUpRequest(response); closeQuietly(response.body()); ... &#125; &#125;&#125; 这段代码最关键的代码是: 1response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); 这行代码就是执行下一个拦截器链的proceed方法。而我们知道在下一个拦截器链中又会执行下一个拦截器的intercept方法。所以整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。这也是OkHttp拦截器的链式执行逻辑。而一个拦截器的intercept方法所执行的逻辑大致分为三部分： 在发起请求前对request进行处理 调用下一个拦截器，获取response 对response进行处理，返回给上一个拦截器 这就是OkHttp拦截器机制的核心逻辑。所以一个网络请求实际上就是一个个拦截器执行其intercept方法的过程。而这其中除了用户自定义的拦截器外还有几个核心拦截器完成了网络访问的核心逻辑，按照先后顺序依次是： RetryAndFollowUpInterceptor BridgeInterceptor CacheInterceptor ConnectIntercetot CallServerInterceptor 4 RetryAndFollowUpInterceptor如上文代码所示，RetryAndFollowUpInterceptor负责两部分逻辑： 在网络请求失败后进行重试 当服务器返回当前请求需要进行重定向时直接发起新的请求，并在条件允许情况下复用当前连接 5 BridgeInterceptor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public final class BridgeInterceptor implements Interceptor &#123; private final CookieJar cookieJar; public BridgeInterceptor(CookieJar cookieJar) &#123; this.cookieJar = cookieJar; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "BridgeInterceptor.intercept"); Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header("Content-Type", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header("Content-Length", Long.toString(contentLength)); requestBuilder.removeHeader("Transfer-Encoding"); &#125; else &#123; requestBuilder.header("Transfer-Encoding", "chunked"); requestBuilder.removeHeader("Content-Length"); &#125; &#125; if (userRequest.header("Host") == null) &#123; requestBuilder.header("Host", hostHeader(userRequest.url(), false)); &#125; if (userRequest.header("Connection") == null) &#123; requestBuilder.header("Connection", "Keep-Alive"); &#125; // If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header("Accept-Encoding") == null &amp;&amp; userRequest.header("Range") == null) &#123; transparentGzip = true; requestBuilder.header("Accept-Encoding", "gzip"); &#125; List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header("Cookie", cookieHeader(cookies)); &#125; if (userRequest.header("User-Agent") == null) &#123; requestBuilder.header("User-Agent", Version.userAgent()); &#125; Response networkResponse = chain.proceed(requestBuilder.build()); HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); if (transparentGzip &amp;&amp; "gzip".equalsIgnoreCase(networkResponse.header("Content-Encoding")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll("Content-Encoding") .removeAll("Content-Length") .build(); responseBuilder.headers(strippedHeaders); responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125;&#125; BridgeInterceptor主要负责以下几部分内容： 设置内容长度，内容编码 设置gzip压缩，并在接收到内容后进行解压。省去了应用层处理数据解压的麻烦 添加cookie 设置其他报头，如User-Agent,Host,Keep-alive等。其中Keep-Alive是实现多路复用的必要步骤 6. CacheInterceptor12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697[CacheInterceptor.intercept] @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "CacheInterceptor.intercept"); Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don't need the network, we're done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123; if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // Offer this request to the cache. CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; CacheInterceptor的职责很明确，就是负责Cache的管理 当网络请求有符合要求的Cache时直接返回Cache 当服务器返回内容有改变时更新当前cache 如果当前cache失效，删除 7 ConnectInterceptor12345678910111213141516171819202122[ConnectInterceptor.java]public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; Log.e("haha", "ConnectInterceptor.intercept"); RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals("GET"); HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpCodec, connection); &#125;&#125; ConnectInterceptor的intercept方法只有一行关键代码: 1RealConnection connection = streamAllocation.connection(); 即为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。 8. CallServerInterceptor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[CallServerInterceptor.java]@Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; HttpCodec httpCodec = realChain.httpStream(); StreamAllocation streamAllocation = realChain.streamAllocation(); RealConnection connection = (RealConnection) realChain.connection(); Request request = realChain.request(); long sentRequestMillis = System.currentTimeMillis(); httpCodec.writeRequestHeaders(request); Response.Builder responseBuilder = null; ...... httpCodec.finishRequest(); if (responseBuilder == null) &#123; responseBuilder = httpCodec.readResponseHeaders(false); &#125; Response response = responseBuilder .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); int code = response.code(); if (forWebSocket &amp;&amp; code == 101) &#123; // Connection is upgrading, but we need to ensure interceptors see a non-null response body. response = response.newBuilder() .body(Util.EMPTY_RESPONSE) .build(); &#125; else &#123; response = response.newBuilder() .body(httpCodec.openResponseBody(response)) .build(); &#125; if ("close".equalsIgnoreCase(response.request().header("Connection")) || "close".equalsIgnoreCase(response.header("Connection"))) &#123; streamAllocation.noNewStreams(); &#125; if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( "HTTP " + code + " had non-zero Content-Length: " + response.body().contentLength()); &#125; return response; &#125; CallServerInterceptor负责向服务器发起真正的访问请求，并在接收到服务器返回后读取响应返回。 8.整体流程以上就是整个网络访问的核心步骤，总结起来如下图所示： OkHttp源码分析——任务队列 前面的博客已经提到过，OkHttp的一个高效之处在于在内部维护了一个线程池，方便高效地执行异步请求。本篇博客将详细介绍OkHttp的任务队列机制。 1. 线程池的优点OkHttp的任务队列在内部维护了一个线程池用于执行具体的网络请求。而线程池最大的好处在于通过线程复用减少非核心任务的损耗。 多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举一个简单的例子： 假设在一台服务器完成一项任务的时间为T 1234&gt; T1 创建线程的时间&gt; T2 在线程中执行任务的时间，包括线程间同步所需时间&gt; T3 线程销毁的时间&gt; &gt; 显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。可以看出T1,T3是多线程本身的带来的开销（在Java中，通过映射pThead，并进一步通过&gt;SystemCall实现native线程），我们渴望减少T1,T3所用的时间，从而减少T的时间。但一些线&gt;程的使用者并没有注意到这一点，所以在程序中频繁的创建或销毁线程，这导致T1和T3在T中占有&gt;相当比例。显然这是突出了线程的弱点（T1，T3），而不是优点（并发性）。 线程池技术正是关注如何缩短或调整T1，T3时间的技术，从而提高服务器程序性能的。 通过对线程进行缓存，减少了创建销毁的时间损失 通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力 类似的还有Socket连接池、DB连接池、CommonPool(比如Jedis)等技术。 2. OkHttp的任务队列OkHttp的任务队列主要由两部分组成： 任务分发器dispatcher：负责为任务找到合适的执行线程 网络请求任务线程池 12345678910111213141516171819202122232425262728293031323334public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; private Runnable idleCallback; /** Executes calls. Created lazily. */ private ExecutorService executorService; /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); public Dispatcher(ExecutorService executorService) &#123; this.executorService = executorService; &#125; public Dispatcher() &#123; &#125; public synchronized ExecutorService executorService() &#123; if (executorService == null) &#123; executorService = new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp Dispatcher", false)); &#125; return executorService; &#125; ...&#125; 参数说明如下： readyAsyncCalls：待执行异步任务队列 runningAsyncCalls：运行中异步任务队列 runningSyncCalls：运行中同步任务队列 executorService：任务队列线程池： 123456789&gt; public ThreadPoolExecutor(int corePoolSize,&gt; int maximumPoolSize,&gt; long keepAliveTime,&gt; TimeUnit unit,&gt; BlockingQueue&lt;Runnable&gt; workQueue,&gt; ThreadFactory threadFactory) &#123;&gt; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,&gt; threadFactory, defaultHandler);&gt; &gt; int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁 int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理 long keepAliveTime: 当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive TimeUnit unit: 时间单位，一般用秒 BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列 ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置Daemon(即当JVM退出时，线程自动结束)等 可以看出，在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。 也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。 3. Dispatcher分发器dispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现非阻塞，高可用，高并发连接 1.同步请求当我们使用OkHttp进行同步请求时，一般构造如下： 12345OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();Response response = client.newCall(request).execute(); 接下来看看RealCall.execute 123456789101112131415@Override public Response execute() throws IOException &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException("Already Executed"); executed = true; &#125; captureCallStackTrace(); try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException("Canceled"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 同步调用的执行逻辑是： 将对应任务加入分发器 执行任务 执行完成后通知dispatcher对应任务已完成，对应任务出队 2.异步请求异步请求一般构造如下： 12345678910111213141516OkHttpClient client = new OkHttpClient();Request request = new Request.Builder() .url("http://publicobject.com/helloworld.txt") .build();client.newCall(request).enqueue(new Callback() &#123; @Override public void onFailure(Call call, IOException e) &#123; Log.d("OkHttp", "Call Failed:" + e.getMessage()); &#125; @Override public void onResponse(Call call, Response response) throws IOException &#123; Log.d("OkHttp", "Call succeeded:" + response.message()); &#125;&#125;); 当HttpClient的请求入队时，根据代码，我们可以发现实际上是Dispatcher进行了入队操作。 1234567891011synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; //添加正在运行的请求 runningAsyncCalls.add(call); //线程池执行请求 executorService().execute(call); &#125; else &#123; //添加到缓存队列排队等待 readyAsyncCalls.add(call); &#125;&#125; 如果满足条件： 当前请求数小于最大请求数（64） 对单一host的请求小于阈值（5） 将该任务插入正在执行任务队列，并执行对应任务。如果不满足则将其放入待执行队列。 接下来看看AsyncCall.execute 1234567891011121314151617181920212223242526@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; //执行耗时IO任务 Response response = getResponseWithInterceptorChain(forWebSocket); if (canceled) &#123; signalledCallback = true; //回调，注意这里回调是在线程池中，而不是想当然的主线程回调 responseCallback.onFailure(RealCall.this, new IOException("Canceled")); &#125; else &#123; signalledCallback = true; //回调，同上 responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! logger.log(Level.INFO, "Callback failure for " + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; //最关键的代码 client.dispatcher().finished(this); &#125;&#125; 当任务执行完成后，无论成功与否都会调用dispatcher.finished方法，通知分发器相关任务已结束： 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError("Call wasn't in-flight!"); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 空闲出多余线程，调用promoteCalls调用待执行的任务 如果当前整个线程池都空闲下来，执行空闲通知回调线程(idleCallback) 接下来看看promoteCalls： 12345678910111213141516private void promoteCalls() &#123; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Already running max capacity. if (readyAsyncCalls.isEmpty()) return; // No ready calls to promote. for (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123; AsyncCall call = i.next(); if (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; i.remove(); runningAsyncCalls.add(call); executorService().execute(call); &#125; if (runningAsyncCalls.size() &gt;= maxRequests) return; // Reached max capacity. &#125;&#125; promoteCalls的逻辑也很简单：扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。 4. 总结以上就是整个任务队列的实现细节，总结起来有以下几个特点： OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行 Okhttp采用Deque作为缓存，按照入队的顺序先进先出 OkHttp最出彩的地方就是在try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性 OkHttp源码分析——缓存策略 合理地利用本地缓存可以有效地减少网络开销，减少响应延迟。HTTP报头也定义了很多与缓存有关的域来控制缓存。今天就来讲讲OkHttp中关于缓存部分的实现细节。 1. HTTP缓存策略首先来了解下HTTP协议中缓存部分的相关域。 1.1 Expires超时时间，一般用在服务器的response报头中用于告知客户端对应资源的过期时间。当客户端需要再次请求相同资源时先比较其过期时间，如果尚未超过过期时间则直接返回缓存结果，如果已经超过则重新请求。 1.2 Cache-Control相对值，单位时秒，表示当前资源的有效期。Cache-Control比Expires优先级更高： 1Cache-Control:max-age=31536000,public 1.3 条件GET请求1.3.1 Last-Modified-Date客户端第一次请求时，服务器返回： 1Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT 当客户端二次请求时，可以头部加上如下header: 1If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT 如果当前资源没有被二次修改，服务器返回304告知客户端直接复用本地缓存。 1.3.2 ETagETag是对资源文件的一种摘要，可以通过ETag值来判断文件是否有修改。当客户端第一次请求某资源时，服务器返回： 1ETag: &quot;5694c7ef-24dc&quot; 客户端再次请求时，可在头部加上如下域： 1If-None-Match: &quot;5694c7ef-24dc&quot; 如果文件并未改变，则服务器返回304告知客户端可以复用本地缓存。 1.4 no-cache/no-store不使用缓存 1.5 only-if-cached只使用缓存 2. Cache源码分析OkHttp的缓存工作都是在CacheInterceptor中完成的,Cache部分有如下几个关键类： Cache：Cache管理器，其内部包含一个DiskLruCache将cache写入文件系统: 12345678910111213141516171819202122&gt; * &lt;h3&gt;Cache Optimization&lt;/h3&gt;&gt; *&gt; * &lt;p&gt;To measure cache effectiveness, this class tracks three statistics:&gt; * &lt;ul&gt;&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #requestCount() Request Count:&#125;&lt;/strong&gt; the number of HTTP&gt; * requests issued since this cache was created.&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #networkCount() Network Count:&#125;&lt;/strong&gt; the number of those&gt; * requests that required network use.&gt; * &lt;li&gt;&lt;strong&gt;&#123;@linkplain #hitCount() Hit Count:&#125;&lt;/strong&gt; the number of those requests&gt; * whose responses were served by the cache.&gt; * &lt;/ul&gt;&gt; *&gt; * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of&gt; * the response, the client will issue a conditional &#123;@code GET&#125;. The server will then send either&gt; * the updated response if it has changed, or a short &apos;not modified&apos; response if the client&apos;s copy&gt; * is still valid. Such responses increment both the network count and hit count.&gt; *&gt; * &lt;p&gt;The best way to improve the cache hit rate is by configuring the web server to return&gt; * cacheable responses. Although this client honors all &lt;a&gt; * href=&quot;http://tools.ietf.org/html/rfc7234&quot;&gt;HTTP/1.1 (RFC 7234)&lt;/a&gt; cache headers, it doesn&apos;t cache&gt; * partial responses.&gt; &gt; Cache内部通过requestCount,networkCount,hitCount三个统计指标来优化缓存效率 CacheStrategy：缓存策略。其内部维护一个request和response，通过指定request和response来描述是通过网络还是缓存获取response，抑或二者同时使用 123456789101112131415161718&gt; [CacheStrategy.java]&gt; /**&gt; * Given a request and cached response, this figures out whether to use the network, the cache, or&gt; * both.&gt; *&gt; * &lt;p&gt;Selecting a cache strategy may add conditions to the request (like the &quot;If-Modified-Since&quot;&gt; * header for conditional GETs) or warnings to the cached response (if the cached data is&gt; * potentially stale).&gt; */&gt; public final class CacheStrategy &#123;&gt; /** The request to send on the network, or null if this call doesn&apos;t use the network. */&gt; public final Request networkRequest;&gt;&gt; /** The cached response to return or validate; or null if this call doesn&apos;t use a cache. */&gt; public final Response cacheResponse;&gt; ......&gt; &#125;&gt; CacheStrategy$Factory:缓存策略工厂类根据实际请求返回对应的缓存策略 既然实际的缓存工作都是在CacheInterceptor中完成的，那么接下来看下CahceInterceptor的核心方法intercept方法源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101[CacheInterceptor.java]@Override public Response intercept(Chain chain) throws IOException &#123; //首先尝试获取缓存 Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); //获取缓存策略 CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; //如果有缓存，更新下相关统计指标：命中率 if (cache != null) &#123; cache.trackResponse(strategy); &#125; //如果当前缓存不符合要求，将其close if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // 如果不能使用网络，同时又没有符合条件的缓存，直接抛504错误 if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message("Unsatisfiable Request (only-if-cached)") .body(Util.EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // 如果有缓存同时又不使用网络，则直接返回缓存结果 if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; //尝试通过网络获取回复 Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // 如果既有缓存，同时又发起了请求，说明此时是一个Conditional Get请求 if (cacheResponse != null) &#123; // 如果服务端返回的是NOT_MODIFIED,缓存有效，将本地缓存和网络响应做合并 if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .sentRequestAtMillis(networkResponse.sentRequestAtMillis()) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis()) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123;// 如果响应资源有更新，关掉原有缓存 closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (cache != null) &#123; if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; // 将网络响应写入cache中 CacheRequest cacheRequest = cache.put(response); return cacheWritingResponse(cacheRequest, response); &#125; if (HttpMethod.invalidatesCache(networkRequest.method())) &#123; try &#123; cache.remove(networkRequest); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; &#125; &#125; return response; &#125; 核心逻辑都以中文注释的形式在代码中标注出来了，大家看代码即可。通过上面的代码可以看出，几乎所有的动作都是以CacheStrategy缓存策略为依据做出的，那么接下来看下缓存策略是如何生成的，相关代码实现在CacheStrategy$Factory.get()方法中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899[CacheStrategy$Factory] /** * Returns a strategy to satisfy &#123;@code request&#125; using the a cached response &#123;@code response&#125;. */ public CacheStrategy get() &#123; CacheStrategy candidate = getCandidate(); if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) &#123; // We're forbidden from using the network and the cache is insufficient. return new CacheStrategy(null, null); &#125; return candidate; &#125; /** Returns a strategy to use assuming the request can use the network. */ private CacheStrategy getCandidate() &#123; // 若本地没有缓存，发起网络请求 if (cacheResponse == null) &#123; return new CacheStrategy(request, null); &#125; // 如果当前请求是HTTPS，而缓存没有TLS握手，重新发起网络请求 if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123; return new CacheStrategy(request, null); &#125; // If this response shouldn't have been stored, it should never be used // as a response source. This check should be redundant as long as the // persistence store is well-behaved and the rules are constant. if (!isCacheable(cacheResponse, request)) &#123; return new CacheStrategy(request, null); &#125; //如果当前的缓存策略是不缓存或者是conditional get，发起网络请求 CacheControl requestCaching = request.cacheControl(); if (requestCaching.noCache() || hasConditions(request)) &#123; return new CacheStrategy(request, null); &#125; //ageMillis:缓存age long ageMillis = cacheResponseAge(); //freshMillis：缓存保鲜时间 long freshMillis = computeFreshnessLifetime(); if (requestCaching.maxAgeSeconds() != -1) &#123; freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds())); &#125; long minFreshMillis = 0; if (requestCaching.minFreshSeconds() != -1) &#123; minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds()); &#125; long maxStaleMillis = 0; CacheControl responseCaching = cacheResponse.cacheControl(); if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123; maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds()); &#125; //如果 age + min-fresh &gt;= max-age &amp;&amp; age + min-fresh &lt; max-age + max-stale，则虽然缓存过期了， //但是缓存继续可以使用，只是在头部添加 110 警告码 if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123; Response.Builder builder = cacheResponse.newBuilder(); if (ageMillis + minFreshMillis &gt;= freshMillis) &#123; builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\""); &#125; long oneDayMillis = 24 * 60 * 60 * 1000L; if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123; builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\""); &#125; return new CacheStrategy(null, builder.build()); &#125; // 发起conditional get请求 String conditionName; String conditionValue; if (etag != null) &#123; conditionName = "If-None-Match"; conditionValue = etag; &#125; else if (lastModified != null) &#123; conditionName = "If-Modified-Since"; conditionValue = lastModifiedString; &#125; else if (servedDate != null) &#123; conditionName = "If-Modified-Since"; conditionValue = servedDateString; &#125; else &#123; return new CacheStrategy(request, null); // No condition! Make a regular request. &#125; Headers.Builder conditionalRequestHeaders = request.headers().newBuilder(); Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue); Request conditionalRequest = request.newBuilder() .headers(conditionalRequestHeaders.build()) .build(); return new CacheStrategy(conditionalRequest, cacheResponse); &#125; 可以看到其核心逻辑在getCandidate函数中。基本就是HTTP缓存协议的实现，核心代码逻辑已通过中文注释说明，大家直接看代码就好。 3. DiskLruCacheCache内部通过DiskLruCache管理cache在文件系统层面的创建，读取，清理等等工作，接下来看下DiskLruCache的主要逻辑： 123456789101112131415161718192021222324252627282930313233343536public final class DiskLruCache implements Closeable, Flushable &#123; final FileSystem fileSystem; final File directory; private final File journalFile; private final File journalFileTmp; private final File journalFileBackup; private final int appVersion; private long maxSize; final int valueCount; private long size = 0; BufferedSink journalWriter; final LinkedHashMap&lt;String, Entry&gt; lruEntries = new LinkedHashMap&lt;&gt;(0, 0.75f, true); // Must be read and written when synchronized on 'this'. boolean initialized; boolean closed; boolean mostRecentTrimFailed; boolean mostRecentRebuildFailed; /** * To differentiate between old and current snapshots, each entry is given a sequence number each * time an edit is committed. A snapshot is stale if its sequence number is not equal to its * entry's sequence number. */ private long nextSequenceNumber = 0; /** Used to run 'cleanupRunnable' for journal rebuilds. */ private final Executor executor; private final Runnable cleanupRunnable = new Runnable() &#123; public void run() &#123; ...... &#125; &#125;; ... &#125; 3.1 journalFileDiskLruCache内部日志文件，对cache的每一次读写都对应一条日志记录，DiskLruCache通过分析日志分析和创建cache。日志文件格式如下： 123456789101112131415161718192021 libcore.io.DiskLruCache 1 100 2 CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054 DIRTY 335c4c6028171cfddfbaae1a9c313c52 CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342 REMOVE 335c4c6028171cfddfbaae1a9c313c52 DIRTY 1ab96a171faeeee38496d8b330771a7a CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234 READ 335c4c6028171cfddfbaae1a9c313c52 READ 3400330d1dfc7f3f7f4b8d4d803dfcf6前5行固定不变，分别为：常量：libcore.io.DiskLruCache；diskCache版本；应用程序版本；valueCount(后文介绍)，空行接下来每一行对应一个cache entry的一次状态记录，其格式为：[状态（DIRTY,CLEAN,READ,REMOVE），key，状态相关value(可选)]:- DIRTY:表明一个cache entry正在被创建或更新，每一个成功的DIRTY记录都应该对应一个CLEAN或REMOVE操作。如果一个DIRTY缺少预期匹配的CLEAN/REMOVE，则对应entry操作失败，需要将其从lruEntries中删除- CLEAN:说明cache已经被成功操作，当前可以被正常读取。每一个CLEAN行还需要记录其每一个value的长度- READ: 记录一次cache读取操作- REMOVE:记录一次cache清除 日志文件的应用场景主要有四个： DiskCacheLru初始化时通过读取日志文件创建cache容器：lruEntries。同时通过日志过滤操作不成功的cache项。相关逻辑在DiskLruCache.readJournalLine,DiskLruCache.processJournal 初始化完成后，为避免日志文件不断膨胀，对日志进行重建精简，具体逻辑在DiskLruCache.rebuildJournal 每当有cache操作时将其记录入日志文件中以备下次初始化时使用 当冗余日志过多时，通过调用cleanUpRunnable线程重建日志 3.2 DiskLruCache.Entry每一个DiskLruCache.Entry对应一个cache记录： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071private final class Entry &#123; final String key; /** Lengths of this entry's files. */ final long[] lengths; final File[] cleanFiles; final File[] dirtyFiles; /** True if this entry has ever been published. */ boolean readable; /** The ongoing edit or null if this entry is not being edited. */ Editor currentEditor; /** The sequence number of the most recently committed edit to this entry. */ long sequenceNumber; Entry(String key) &#123; this.key = key; lengths = new long[valueCount]; cleanFiles = new File[valueCount]; dirtyFiles = new File[valueCount]; // The names are repetitive so re-use the same builder to avoid allocations. StringBuilder fileBuilder = new StringBuilder(key).append('.'); int truncateTo = fileBuilder.length(); for (int i = 0; i &lt; valueCount; i++) &#123; fileBuilder.append(i); cleanFiles[i] = new File(directory, fileBuilder.toString()); fileBuilder.append(".tmp"); dirtyFiles[i] = new File(directory, fileBuilder.toString()); fileBuilder.setLength(truncateTo); &#125; &#125; ... /** * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a * single published snapshot. If we opened streams lazily then the streams could come from * different edits. */ Snapshot snapshot() &#123; if (!Thread.holdsLock(DiskLruCache.this)) throw new AssertionError(); Source[] sources = new Source[valueCount]; long[] lengths = this.lengths.clone(); // Defensive copy since these can be zeroed out. try &#123; for (int i = 0; i &lt; valueCount; i++) &#123; sources[i] = fileSystem.source(cleanFiles[i]); &#125; return new Snapshot(key, sequenceNumber, sources, lengths); &#125; catch (FileNotFoundException e) &#123; // A file must have been deleted manually! for (int i = 0; i &lt; valueCount; i++) &#123; if (sources[i] != null) &#123; Util.closeQuietly(sources[i]); &#125; else &#123; break; &#125; &#125; // Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache // size.) try &#123; removeEntry(this); &#125; catch (IOException ignored) &#123; &#125; return null; &#125; &#125;&#125; 一个Entry主要由以下几部分构成： key：每个cache都有一个key作为其标识符。当前cache的key为其对应URL的MD5字符串 cleanFiles/dirtyFiles：每一个Entry对应多个文件，其对应的文件数由DiskLruCache.valueCount指定。当前在OkHttp中valueCount为2。即每个cache对应2个cleanFiles，2个dirtyFiles。其中第一个cleanFiles/dirtyFiles记录cache的meta数据（如URL,创建时间，SSL握手记录等等），第二个文件记录cache的真正内容。cleanFiles记录处于稳定状态的cache结果，dirtyFiles记录处于创建或更新状态的cache currentEditor：entry编辑器，对entry的所有操作都是通过其编辑器完成。编辑器内部添加了同步锁 3.3 cleanupRunnable清理线程，用于重建精简日志： 12345678910111213141516171819202122232425private final Runnable cleanupRunnable = new Runnable() &#123; public void run() &#123; synchronized (DiskLruCache.this) &#123; if (!initialized | closed) &#123; return; // Nothing to do &#125; try &#123; trimToSize(); &#125; catch (IOException ignored) &#123; mostRecentTrimFailed = true; &#125; try &#123; if (journalRebuildRequired()) &#123; rebuildJournal(); redundantOpCount = 0; &#125; &#125; catch (IOException e) &#123; mostRecentRebuildFailed = true; journalWriter = Okio.buffer(Okio.blackhole()); &#125; &#125; &#125;&#125;; 其触发条件在journalRebuildRequired()方法中： 123456789/** * We only rebuild the journal when it will halve the size of the journal and eliminate at least * 2000 ops. */boolean journalRebuildRequired() &#123; final int redundantOpCompactThreshold = 2000; return redundantOpCount &gt;= redundantOpCompactThreshold &amp;&amp; redundantOpCount &gt;= lruEntries.size();&#125; 当冗余日志超过日志文件本身的一般且总条数超过2000时执行 3.4 SnapShotcache快照，记录了特定cache在某一个特定时刻的内容。每次向DiskLruCache请求时返回的都是目标cache的一个快照,相关逻辑在DiskLruCache.get中： 12345678910111213141516171819202122232425[DiskLruCache.java] /** * Returns a snapshot of the entry named &#123;@code key&#125;, or null if it doesn't exist is not currently * readable. If a value is returned, it is moved to the head of the LRU queue. */ public synchronized Snapshot get(String key) throws IOException &#123; initialize(); checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (entry == null || !entry.readable) return null; Snapshot snapshot = entry.snapshot(); if (snapshot == null) return null; redundantOpCount++; //日志记录 journalWriter.writeUtf8(READ).writeByte(' ').writeUtf8(key).writeByte('\n'); if (journalRebuildRequired()) &#123; executor.execute(cleanupRunnable); &#125; return snapshot; &#125; 3.5 lruEntries管理cache entry的容器，其数据结构是LinkedHashMap。通过LinkedHashMap本身的实现逻辑达到cache的LRU替换 3.6 FileSystem使用Okio对File的封装，简化了I/O操作。 3.7 DiskLruCache.editDiskLruCache可以看成是Cache在文件系统层的具体实现，所以其基本操作接口存在一一对应的关系： Cache.get() —&gt;DiskLruCache.get() Cache.put()—&gt;DiskLruCache.edit() //cache插入 Cache.remove()—&gt;DiskLruCache.remove() Cache.update()—&gt;DiskLruCache.edit()//cache更新 其中get操作在3.4已经介绍了，remove操作较为简单，put和update大致逻辑相似，因为篇幅限制，这里仅介绍Cache.put操作的逻辑，其他的操作大家看代码就好: 12345678910111213141516171819202122232425262728293031323334353637[okhttp3.Cache.java] CacheRequest put(Response response) &#123; String requestMethod = response.request().method(); if (HttpMethod.invalidatesCache(response.request().method())) &#123; try &#123; remove(response.request()); &#125; catch (IOException ignored) &#123; // The cache cannot be written. &#125; return null; &#125; if (!requestMethod.equals("GET")) &#123; // Don't cache non-GET responses. We're technically allowed to cache // HEAD requests and some POST requests, but the complexity of doing // so is high and the benefit is low. return null; &#125; if (HttpHeaders.hasVaryAll(response)) &#123; return null; &#125; Entry entry = new Entry(response); DiskLruCache.Editor editor = null; try &#123; editor = cache.edit(key(response.request().url())); if (editor == null) &#123; return null; &#125; entry.writeTo(editor); return new CacheRequestImpl(editor); &#125; catch (IOException e) &#123; abortQuietly(editor); return null; &#125; &#125; 可以看到核心逻辑在editor = cache.edit(key(response.request().url()));,相关代码在DiskLruCache.edit: 12345678910111213141516171819202122232425262728293031323334353637383940[okhttp3.internal.cache.DiskLruCache.java] synchronized Editor edit(String key, long expectedSequenceNumber) throws IOException &#123; initialize(); checkNotClosed(); validateKey(key); Entry entry = lruEntries.get(key); if (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == null || entry.sequenceNumber != expectedSequenceNumber)) &#123; return null; // Snapshot is stale. &#125; if (entry != null &amp;&amp; entry.currentEditor != null) &#123; return null; // 当前cache entry正在被其他对象操作 &#125; if (mostRecentTrimFailed || mostRecentRebuildFailed) &#123; // The OS has become our enemy! If the trim job failed, it means we are storing more data than // requested by the user. Do not allow edits so we do not go over that limit any further. If // the journal rebuild failed, the journal writer will not be active, meaning we will not be // able to record the edit, causing file leaks. In both cases, we want to retry the clean up // so we can get out of this state! executor.execute(cleanupRunnable); return null; &#125; // 日志接入DIRTY记录 journalWriter.writeUtf8(DIRTY).writeByte(' ').writeUtf8(key).writeByte('\n'); journalWriter.flush(); if (hasJournalErrors) &#123; return null; // Don't edit; the journal can't be written. &#125; if (entry == null) &#123; entry = new Entry(key); lruEntries.put(key, entry); &#125; Editor editor = new Editor(entry); entry.currentEditor = editor; return editor; &#125; edit方法返回对应CacheEntry的editor编辑器。接下来再来看下Cache.put()方法的entry.writeTo(editor);,其相关逻辑： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[okhttp3.internal.cache.DiskLruCache.java] public void writeTo(DiskLruCache.Editor editor) throws IOException &#123; BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA)); sink.writeUtf8(url) .writeByte('\n'); sink.writeUtf8(requestMethod) .writeByte('\n'); sink.writeDecimalLong(varyHeaders.size()) .writeByte('\n'); for (int i = 0, size = varyHeaders.size(); i &lt; size; i++) &#123; sink.writeUtf8(varyHeaders.name(i)) .writeUtf8(": ") .writeUtf8(varyHeaders.value(i)) .writeByte('\n'); &#125; sink.writeUtf8(new StatusLine(protocol, code, message).toString()) .writeByte('\n'); sink.writeDecimalLong(responseHeaders.size() + 2) .writeByte('\n'); for (int i = 0, size = responseHeaders.size(); i &lt; size; i++) &#123; sink.writeUtf8(responseHeaders.name(i)) .writeUtf8(": ") .writeUtf8(responseHeaders.value(i)) .writeByte('\n'); &#125; sink.writeUtf8(SENT_MILLIS) .writeUtf8(": ") .writeDecimalLong(sentRequestMillis) .writeByte('\n'); sink.writeUtf8(RECEIVED_MILLIS) .writeUtf8(": ") .writeDecimalLong(receivedResponseMillis) .writeByte('\n'); if (isHttps()) &#123; sink.writeByte('\n'); sink.writeUtf8(handshake.cipherSuite().javaName()) .writeByte('\n'); writeCertList(sink, handshake.peerCertificates()); writeCertList(sink, handshake.localCertificates()); // The handshake’s TLS version is null on HttpsURLConnection and on older cached responses. if (handshake.tlsVersion() != null) &#123; sink.writeUtf8(handshake.tlsVersion().javaName()) .writeByte('\n'); &#125; &#125; sink.close(); &#125; 其主要逻辑就是将对应请求的meta数据写入对应CacheEntry的索引为ENTRY_METADATA（0）的dirtyfile中。 最后再来看Cache.put()方法的return new CacheRequestImpl(editor);: 1234567891011121314151617181920212223242526272829303132333435363738394041424344[okhttp3.Cache$CacheRequestImpl]private final class CacheRequestImpl implements CacheRequest &#123; private final DiskLruCache.Editor editor; private Sink cacheOut; private Sink body; boolean done; public CacheRequestImpl(final DiskLruCache.Editor editor) &#123; this.editor = editor; this.cacheOut = editor.newSink(ENTRY_BODY); this.body = new ForwardingSink(cacheOut) &#123; @Override public void close() throws IOException &#123; synchronized (Cache.this) &#123; if (done) &#123; return; &#125; done = true; writeSuccessCount++; &#125; super.close(); editor.commit(); &#125; &#125;; &#125; @Override public void abort() &#123; synchronized (Cache.this) &#123; if (done) &#123; return; &#125; done = true; writeAbortCount++; &#125; Util.closeQuietly(cacheOut); try &#123; editor.abort(); &#125; catch (IOException ignored) &#123; &#125; &#125; @Override public Sink body() &#123; return body; &#125; &#125; 其中close,abort方法会调用editor.abort和editor.commit来更新日志，editor.commit还会将dirtyFile重置为cleanFile作为稳定可用的缓存，相关逻辑在okhttp3.internal.cache.DiskLruCache$Editor.completeEdit中: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061[okhttp3.internal.cache.DiskLruCache$Editor.completeEdit] synchronized void completeEdit(Editor editor, boolean success) throws IOException &#123; Entry entry = editor.entry; if (entry.currentEditor != editor) &#123; throw new IllegalStateException(); &#125; // If this edit is creating the entry for the first time, every index must have a value. if (success &amp;&amp; !entry.readable) &#123; for (int i = 0; i &lt; valueCount; i++) &#123; if (!editor.written[i]) &#123; editor.abort(); throw new IllegalStateException("Newly created entry didn't create value for index " + i); &#125; if (!fileSystem.exists(entry.dirtyFiles[i])) &#123; editor.abort(); return; &#125; &#125; &#125; for (int i = 0; i &lt; valueCount; i++) &#123; File dirty = entry.dirtyFiles[i]; if (success) &#123; if (fileSystem.exists(dirty)) &#123; File clean = entry.cleanFiles[i]; fileSystem.rename(dirty, clean);//将dirtyfile置为cleanfile long oldLength = entry.lengths[i]; long newLength = fileSystem.size(clean); entry.lengths[i] = newLength; size = size - oldLength + newLength; &#125; &#125; else &#123; fileSystem.delete(dirty);//若失败则删除dirtyfile &#125; &#125; redundantOpCount++; entry.currentEditor = null; //更新日志 if (entry.readable | success) &#123; entry.readable = true; journalWriter.writeUtf8(CLEAN).writeByte(' '); journalWriter.writeUtf8(entry.key); entry.writeLengths(journalWriter); journalWriter.writeByte('\n'); if (success) &#123; entry.sequenceNumber = nextSequenceNumber++; &#125; &#125; else &#123; lruEntries.remove(entry.key); journalWriter.writeUtf8(REMOVE).writeByte(' '); journalWriter.writeUtf8(entry.key); journalWriter.writeByte('\n'); &#125; journalWriter.flush(); if (size &gt; maxSize || journalRebuildRequired()) &#123; executor.execute(cleanupRunnable); &#125; &#125; CacheRequestImpl实现CacheRequest接口，向外部类(主要是CacheInterceptor)透出，外部对象通过CacheRequestImpl更新或写入缓存数据。 3.8总结总结起来DiskLruCache主要有以下几个特点： 通过LinkedHashMap实现LRU替换 通过本地维护Cache操作日志保证Cache原子性与可用性，同时为防止日志过分膨胀定时执行日志精简 每一个Cache项对应两个状态副本：DIRTY,CLEAN。CLEAN表示当前可用状态Cache，外部访问到的cache快照均为CLEAN状态；DIRTY为更新态Cache。由于更新和创建都只操作DIRTY状态副本，实现了Cache的读写分离 每一个Cache项有四个文件，两个状态（DIRTY,CLEAN）,每个状态对应两个文件：一个文件存储Cache meta数据，一个文件存储Cache内容数据 OkHttp源码分析——多路复用 接下来讲下OkHttp的连接池管理，这也是OkHttp的核心部分。通过维护连接池，最大限度重用现有连接，减少网络连接的创建开销，以此提升网络请求效率。 1. 背景1.1 keep-alive机制在HTTP1.0中HTTP的请求流程如下： 这种方法的好处是简单，各个请求互不干扰。但在复杂的网络请求场景下这种方式几乎不可用。例如：浏览器加载一个HTML网页，HTML中可能需要加载数十个资源，典型场景下这些资源中大部分来自同一个站点。按照HTTP1.0的做法，这需要建立数十个TCP连接，每个连接负责一个资源请求。创建一个TCP连接需要3次握手，而释放连接则需要2次或4次握手。重复的创建和释放连接极大地影响了网络效率，同时也增加了系统开销。 为了有效地解决这一问题，HTTP/1.1提出了Keep-Alive机制：当一个HTTP请求的数据传输结束后，TCP连接不立即释放，如果此时有新的HTTP请求，且其请求的Host通上次请求相同，则可以直接复用为释放的TCP连接，从而省去了TCP的释放和再次创建的开销，减少了网络延时: 在现代浏览器中，一般同时开启6～8个keepalive connections的socket连接，并保持一定的链路生命，当不需要时再关闭；而在服务器中，一般是由软件根据负载情况(比如FD最大值、Socket内存、超时时间、栈内存、栈数量等)决定是否主动关闭。 1.2 HTTP/2在HTTP/1.x中，如果客户端想发起多个并行请求必须建立多个TCP连接，这无疑增大了网络开销。另外HTTP/1.x不会压缩请求和响应报头，导致了不必要的网络流量；HTTP/1.x不支持资源优先级导致底层TCP连接利用率低下。而这些问题都是HTTP/2要着力解决的。简单来说HTTP/2主要解决了以下问题： 报头压缩：HTTP/2使用HPACK压缩格式压缩请求和响应报头数据，减少不必要流量开销 请求与响应复用：HTTP/2通过引入新的二进制分帧层实现了完整的请求和响应复用，客户端和服务器可以将HTTP消息分解为互不依赖的帧，然后交错发送，最后再在另一端将其重新组装 指定数据流优先级：将 HTTP 消息分解为很多独立的帧之后，我们就可以复用多个数据流中的帧，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。为了做到这一点，HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系 流控制：HTTP/2 提供了一组简单的构建块，这些构建块允许客户端和服务器实现其自己的数据流和连接级流控制 HTTP/2所有性能增强的核心在于新的二进制分帧层，它定义了如何封装HTTP消息并在客户端与服务器之间进行传输: 同时HTTP/2引入了三个新的概念： 数据流：基于TCP连接之上的逻辑双向字节流，对应一个请求及其响应。客户端每发起一个请求就建立一个数据流，后续该请求及其响应的所有数据都通过该数据流传输 消息：一个请求或响应对应的一系列数据帧 帧：HTTP/2的最小数据切片单位 上述概念之间的逻辑关系： 所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流 每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息 每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧 帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载，等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装 每个HTTP消息被分解为多个独立的帧后可以交错发送，从而在宏观上实现了多个请求或响应并行传输的效果。这类似于多进程环境下的时间分片机制 2. 连接池的使用与分析无论是HTTP/1.1的Keep-Alive机制还是HTTP/2的多路复用机制，在实现上都需要引入连接池来维护网络连接。接下来看下OkHttp中的连接池实现。 OkHttp内部通过ConnectionPool来管理连接池，首先来看下ConnectionPool的主要成员： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public final class ConnectionPool &#123; private static final Executor executor = new ThreadPoolExecutor(0 /* corePoolSize */, Integer.MAX_VALUE /* maximumPoolSize */, 60L /* keepAliveTime */, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory("OkHttp ConnectionPool", true)); /** The maximum number of idle connections for each address. */ private final int maxIdleConnections; private final long keepAliveDurationNs; private final Runnable cleanupRunnable = new Runnable() &#123; @Override public void run() &#123; ...... &#125; &#125;; private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;(); final RouteDatabase routeDatabase = new RouteDatabase(); boolean cleanupRunning; ...... /** *返回符合要求的可重用连接，如果没有返回NULL */ RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; ...... &#125; /* * 去除重复连接。主要针对多路复用场景下一个address只需要一个连接 */ Socket deduplicate(Address address, StreamAllocation streamAllocation) &#123; ...... &#125; /* * 将连接加入连接池 */ void put(RealConnection connection) &#123; ...... &#125; /* * 当有连接空闲时唤起cleanup线程清洗连接池 */ boolean connectionBecameIdle(RealConnection connection) &#123; ...... &#125; /** * 扫描连接池，清除空闲连接 */ long cleanup(long now) &#123; ...... &#125; /* * 标记泄露连接 */ private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; ...... &#125;&#125; 相关概念： Call：对Http请求的封装 Connection/RealConnection:物理连接的封装，其内部有List&lt;WeakReference&lt;StreamAllocation&gt;&gt;的引用计数 StreamAllocation: okhttp中引入了StreamAllocation负责管理一个连接上的流，同时在connection中也通过一个StreamAllocation的引用的列表来管理一个连接的流，从而使得连接与流之间解耦。关于StreamAllocation的定义可以看下这篇文章:okhttp源码学习笔记（二）– 连接与连接管理 connections: Deque双端队列，用于维护连接的容器 routeDatabase:用来记录连接失败的Route的黑名单，当连接失败的时候就会把失败的线路加进去 2.1 实例化首先来看下ConnectionPool的实例化过程，一个OkHttpClient只包含一个ConnectionPool，其实例化过程也在OkHttpClient的实例化过程中实现，值得一提的是ConnectionPool各个方法的调用并没有直接对外暴露，而是通过OkHttpClient的Internal接口统一对外暴露： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class OkHttpClient implements Cloneable, Call.Factory, WebSocket.Factory &#123; static &#123; Internal.instance = new Internal() &#123; @Override public void addLenient(Headers.Builder builder, String line) &#123; builder.addLenient(line); &#125; @Override public void addLenient(Headers.Builder builder, String name, String value) &#123; builder.addLenient(name, value); &#125; @Override public void setCache(Builder builder, InternalCache internalCache) &#123; builder.setInternalCache(internalCache); &#125; @Override public boolean connectionBecameIdle( ConnectionPool pool, RealConnection connection) &#123; return pool.connectionBecameIdle(connection); &#125; @Override public RealConnection get(ConnectionPool pool, Address address, StreamAllocation streamAllocation, Route route) &#123; return pool.get(address, streamAllocation, route); &#125; @Override public boolean equalsNonHost(Address a, Address b) &#123; return a.equalsNonHost(b); &#125; @Override public Socket deduplicate( ConnectionPool pool, Address address, StreamAllocation streamAllocation) &#123; return pool.deduplicate(address, streamAllocation); &#125; @Override public void put(ConnectionPool pool, RealConnection connection) &#123; pool.put(connection); &#125; @Override public RouteDatabase routeDatabase(ConnectionPool connectionPool) &#123; return connectionPool.routeDatabase; &#125; @Override public int code(Response.Builder responseBuilder) &#123; return responseBuilder.code; &#125; @Override public void apply(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, boolean isFallback) &#123; tlsConfiguration.apply(sslSocket, isFallback); &#125; @Override public HttpUrl getHttpUrlChecked(String url) throws MalformedURLException, UnknownHostException &#123; return HttpUrl.getChecked(url); &#125; @Override public StreamAllocation streamAllocation(Call call) &#123; return ((RealCall) call).streamAllocation(); &#125; @Override public Call newWebSocketCall(OkHttpClient client, Request originalRequest) &#123; return new RealCall(client, originalRequest, true); &#125; &#125;; ......&#125; 这样做的原因是： 12Escalate internal APIs in &#123;@code okhttp3&#125; so they can be used from OkHttp&apos;s implementationpackages. The only implementation of this interface is in &#123;@link OkHttpClient&#125;. Internal的唯一实现在OkHttpClient中，OkHttpClient通过这种方式暴露其API给外部类使用。 2.2 连接池维护ConnectionPool内部通过一个双端队列(dequeue)来维护当前所有连接，主要涉及到的操作包括： put：放入新连接 get：从连接池中获取连接 evictAll：关闭所有连接 connectionBecameIdle：连接变空闲后调用清理线程 deduplicate：清除重复的多路复用线程 2.2.1 StreamAllocation.findConnectionget是ConnectionPool中最为重要的方法，StreamAllocation在其findConnection方法内部通过调用get方法为其找到stream找到合适的连接，如果没有则新建一个连接。首先来看下findConnection的逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123; Route selectedRoute; synchronized (connectionPool) &#123; if (released) throw new IllegalStateException("released"); if (codec != null) throw new IllegalStateException("codec != null"); if (canceled) throw new IOException("Canceled"); // 一个StreamAllocation刻画的是一个Call的数据流动，一个Call可能存在多次请求(重定向，Authenticate等)，所以当发生类似重定向等事件时优先使用原有的连接 RealConnection allocatedConnection = this.connection; if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123; return allocatedConnection; &#125; // 试图从连接池中找到可复用的连接 Internal.instance.get(connectionPool, address, this, null); if (connection != null) &#123; return connection; &#125; selectedRoute = route; &#125; // 获取路由配置，所谓路由其实就是代理，ip地址等参数的一个组合 if (selectedRoute == null) &#123; selectedRoute = routeSelector.next(); &#125; RealConnection result; synchronized (connectionPool) &#123; if (canceled) throw new IOException("Canceled"); //拿到路由后可以尝试重新从连接池中获取连接，这里主要针对http2协议下清除域名碎片机制 Internal.instance.get(connectionPool, address, this, selectedRoute); if (connection != null) return connection; //新建连接 route = selectedRoute; refusedStreamCount = 0; result = new RealConnection(connectionPool, selectedRoute); //修改result连接stream计数，方便connection标记清理 acquire(result); &#125; // Do TCP + TLS handshakes. This is a blocking operation. result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); routeDatabase().connected(result.route()); Socket socket = null; synchronized (connectionPool) &#123; // 将新建的连接放入到连接池中 Internal.instance.put(connectionPool, result); // 如果同时存在多个连向同一个地址的多路复用连接，则关闭多余连接，只保留一个 if (result.isMultiplexed()) &#123; socket = Internal.instance.deduplicate(connectionPool, address, this); result = connection; &#125; &#125; closeQuietly(socket); return result; &#125; 其主要逻辑大致分为以下几个步骤： 查看当前streamAllocation是否有之前已经分配过的连接，有则直接使用 从连接池中查找可复用的连接，有则返回该连接 配置路由，配置后再次从连接池中查找是否有可复用连接，有则直接返回 新建一个连接，并修改其StreamAllocation标记计数，将其放入连接池中 查看连接池是否有重复的多路复用连接，有则清除 2.2.2 ConnectionPool.get接下来再来看get方法的源码： 1234567891011[ConnectionPool.java] RealConnection get(Address address, StreamAllocation streamAllocation, Route route) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; if (connection.isEligible(address, route)) &#123; streamAllocation.acquire(connection); return connection; &#125; &#125; return null; &#125; 其逻辑比较简单，遍历当前连接池，如果有符合条件的连接则修改器标记计数，然后返回。这里的关键逻辑在RealConnection.isEligible方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[RealConnection.java]/** * Returns true if this connection can carry a stream allocation to &#123;@code address&#125;. If non-null * &#123;@code route&#125; is the resolved route for a connection. */ public boolean isEligible(Address address, Route route) &#123; // If this connection is not accepting new streams, we&apos;re done. if (allocations.size() &gt;= allocationLimit || noNewStreams) return false; // If the non-host fields of the address don&apos;t overlap, we&apos;re done. if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false; // If the host exactly matches, we&apos;re done: this connection can carry the address. if (address.url().host().equals(this.route().address().url().host())) &#123; return true; // This connection is a perfect match. &#125; // At this point we don&apos;t have a hostname match. But we still be able to carry the request if // our connection coalescing requirements are met. See also: // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/ // 1. This connection must be HTTP/2. if (http2Connection == null) return false; // 2. The routes must share an IP address. This requires us to have a DNS address for both // hosts, which only happens after route planning. We can&apos;t coalesce connections that use a // proxy, since proxies don&apos;t tell us the origin server&apos;s IP address. if (route == null) return false; if (route.proxy().type() != Proxy.Type.DIRECT) return false; if (this.route.proxy().type() != Proxy.Type.DIRECT) return false; if (!this.route.socketAddress().equals(route.socketAddress())) return false; // 3. This connection&apos;s server certificate&apos;s must cover the new host. if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false; if (!supportsUrl(address.url())) return false; // 4. Certificate pinning must match the host. try &#123; address.certificatePinner().check(address.url().host(), handshake().peerCertificates()); &#125; catch (SSLPeerUnverifiedException e) &#123; return false; &#125; return true; // The caller&apos;s address can be carried by this connection. &#125; 连接没有达到共享上限 非host域必须完全一样 如果此时host域也相同，则符合条件，可以被复用 如果host不相同，在HTTP/2的域名切片场景下一样可以复用，具体细节可以参考：https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding 2.2.3 deduplicatededuplicate方法主要是针对在HTTP/2场景下多个多路复用连接清除的场景。如果当前连接是HTTP/2，那么所有指向该站点的请求都应该基于同一个TCP连接： 12345678910111213141516[ConnectionPool.java] /** * Replaces the connection held by &#123;@code streamAllocation&#125; with a shared connection if possible. * This recovers when multiple multiplexed connections are created concurrently. */ Socket deduplicate(Address address, StreamAllocation streamAllocation) &#123; assert (Thread.holdsLock(this)); for (RealConnection connection : connections) &#123; if (connection.isEligible(address, null) &amp;&amp; connection.isMultiplexed() &amp;&amp; connection != streamAllocation.connection()) &#123; return streamAllocation.releaseAndAcquire(connection); &#125; &#125; return null; &#125; put和evictAll比较简单，在这里就不写了，大家自行看源码。 2.3 自动回收连接池中有socket回收，而这个回收是以RealConnection的弱引用List&lt;Reference&lt;StreamAllocation&gt;&gt;是否为0来为依据的。ConnectionPool有一个独立的线程cleanupRunnable来清理连接池，其触发时机有两个： 当连接池中put新的连接时 当connectionBecameIdle接口被调用时 其代码如下： 1234567891011121314while (true) &#123; //执行清理并返回下场需要清理的时间 long waitNanos = cleanup(System.nanoTime()); if (waitNanos == -1) return; if (waitNanos &gt; 0) &#123; synchronized (ConnectionPool.this) &#123; try &#123; //在timeout内释放锁与时间片 ConnectionPool.this.wait(TimeUnit.NANOSECONDS.toMillis(waitNanos)); &#125; catch (InterruptedException ignored) &#123; &#125; &#125; &#125;&#125; 这段死循环实际上是一个阻塞的清理任务，首先进行清理(clean)，并返回下次需要清理的间隔时间，然后调用wait(timeout)进行等待以释放锁与时间片，当等待时间到了后，再次进行清理，并返回下次要清理的间隔时间… 接下来看下cleanup函数: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[ConnectionPool.java]long cleanup(long now) &#123; int inUseConnectionCount = 0; int idleConnectionCount = 0; RealConnection longestIdleConnection = null; long longestIdleDurationNs = Long.MIN_VALUE; //遍历`Deque`中所有的`RealConnection`，标记泄漏的连接 synchronized (this) &#123; for (RealConnection connection : connections) &#123; // 查询此连接内部StreamAllocation的引用数量 if (pruneAndGetAllocationCount(connection, now) &gt; 0) &#123; inUseConnectionCount++; continue; &#125; idleConnectionCount++; //选择排序法，标记出空闲连接 long idleDurationNs = now - connection.idleAtNanos; if (idleDurationNs &gt; longestIdleDurationNs) &#123; longestIdleDurationNs = idleDurationNs; longestIdleConnection = connection; &#125; &#125; if (longestIdleDurationNs &gt;= this.keepAliveDurationNs || idleConnectionCount &gt; this.maxIdleConnections) &#123; //如果(`空闲socket连接超过5个` //且`keepalive时间大于5分钟`) //就将此泄漏连接从`Deque`中移除 connections.remove(longestIdleConnection); &#125; else if (idleConnectionCount &gt; 0) &#123; //返回此连接即将到期的时间，供下次清理 //这里依据是在上文`connectionBecameIdle`中设定的计时 return keepAliveDurationNs - longestIdleDurationNs; &#125; else if (inUseConnectionCount &gt; 0) &#123; //全部都是活跃的连接，5分钟后再次清理 return keepAliveDurationNs; &#125; else &#123; //没有任何连接，跳出循环 cleanupRunning = false; return -1; &#125; &#125; //关闭连接，返回`0`，也就是立刻再次清理 closeQuietly(longestIdleConnection.socket()); return 0;&#125; 其基本逻辑如下： 遍历连接池中所有连接，标记泄露连接 如果被标记的连接满足(空闲socket连接超过5个&amp;&amp;keepalive时间大于5分钟)，就将此连接从Deque中移除，并关闭连接，返回0，也就是将要执行wait(0)，提醒立刻再次扫描 如果(目前还可以塞得下5个连接，但是有可能泄漏的连接(即空闲时间即将达到5分钟))，就返回此连接即将到期的剩余时间，供下次清理 如果(全部都是活跃的连接)，就返回默认的keep-alive时间，也就是5分钟后再执行清理 而pruneAndGetAllocationCount负责标记并找到不活跃连接: 1234567891011121314151617181920212223242526272829[ConnnecitonPool.java]//类似于引用计数法，如果引用全部为空，返回立刻清理private int pruneAndGetAllocationCount(RealConnection connection, long now) &#123; //虚引用列表 List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations; //遍历弱引用列表 for (int i = 0; i &lt; references.size(); ) &#123; Reference&lt;StreamAllocation&gt; reference = references.get(i); //如果正在被使用，跳过，接着循环 //是否置空是在上文`connectionBecameIdle`的`release`控制的 if (reference.get() != null) &#123; //非常明显的引用计数 i++; continue; &#125; //否则移除引用 references.remove(i); connection.noNewStreams = true; //如果所有分配的流均没了，标记为已经距离现在空闲了5分钟 if (references.isEmpty()) &#123; connection.idleAtNanos = now - keepAliveDurationNs; return 0; &#125; &#125; return references.size();&#125; OkHttp的连接池通过计数+标记清理的机制来管理连接池，使得无用连接可以被会回收，并保持多个健康的keep-alive连接。这也是OkHttp的连接池能保持高效的关键原因。]]></content>
      <categories>
        <category>拆轮子</category>
      </categories>
      <tags>
        <tag>OkHttp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap、LinkedHashMap、ConcurrentHashMap]]></title>
    <url>%2F2018%2F03%2F27%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMapHashMap 是基于哈希表的 Map 接口的实现，以 Key-Value 的形式存在，即存储的对象是 Entry (同时包含了 Key 和 Value) 。在HashMap中，其会根据hash算法来计算key-value的存储位置并进行快速存取。特别地，HashMap最多只允许一条Entry的键为Null(多条会覆盖)，但允许多条Entry的值为Null。此外，HashMap 是 Map 的一个非同步的实现。 我们知道，在Java中最常用的两种结构是数组和链表，几乎所有的数据结构都可以利用这两种来组合实现，HashMap 就是这种应用的一个典型。实际上，HashMap 就是一个链表数组，如下是它数据结构： 我们可以形象地看出HashMap底层实现还是数组，只是数组的每一项都是一条链。其中参数initialCapacity 就代表了该数组的长度，也就是桶的个数。在第三节我们已经了解了HashMap 的默认构造函数的源码： 1234567891011121314/** * Constructs an empty HashMap with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; //负载因子:用于衡量的是一个散列表的空间的使用程度 this.loadFactor = DEFAULT_LOAD_FACTOR; //HashMap进行扩容的阈值，它的值等于 HashMap 的容量乘以负载因子 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // HashMap的底层实现仍是数组，只是数组的每一项都是一条链 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); &#125; 每次新建一个HashMap时，都会初始化一个Entry类型的table数组，其中 Entry类型的定义如下： 1234567891011121314151617181920static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; // 键值对的键 V value; // 键值对的值 Entry&lt;K,V&gt; next; // 下一个节点 final int hash; // hash(key.hashCode())方法的返回值 /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; // Entry 的构造函数 value = v; next = n; key = k; hash = h; &#125; ......&#125; LinkedHashMap向链表合二为一即是LinkedHashMap。所谓LinkedHashMap，其落脚点在HashMap，因此更准确地说，它是一个将所有Entry节点链入一个双向链表双向链表的HashMap。在LinkedHashMapMap中，所有put进来的Entry都保存在如下面第一个图所示的哈希表中，但由于它又额外定义了一个以head为头结点的双向链表(如下面第二个图所示)，因此对于每次put进来Entry，除了将其保存到哈希表中对应的位置上之外，还会将其插入到双向链表的尾部。 更直观地，下图很好地还原了LinkedHashMap的原貌：HashMap和双向链表的密切配合和分工合作造就了LinkedHashMap。特别需要注意的是，next用于维护HashMap各个桶中的Entry链，before、after用于维护LinkedHashMap的双向链表，虽然它们的作用对象都是Entry，但是各自分离，是两码事儿。 其中，HashMap与LinkedHashMap的Entry结构示意图如下图所示： 基本元素 Entry LinkedHashMap采用的hash算法和HashMap相同，但是它重新定义了Entry。LinkedHashMap中的Entry增加了两个指针 before 和 after，它们分别用于维护双向链接列表。特别需要注意的是，next用于维护HashMap各个桶中Entry的连接顺序，before、after用于维护Entry插入的先后顺序的，源代码如下： 12345678910private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; // These fields comprise the doubly linked list used for iteration. Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; ...&#125; 特别地，由于LinkedHashMap是HashMap的子类，所以LinkedHashMap自然会拥有HashMap的所有特性。比如，LinkedHashMap也最多只允许一条Entry的键为Null(多条会覆盖)，但允许多条Entry的值为Null。此外，LinkedHashMap 也是 Map 的一个非同步的实现。此外，LinkedHashMap还可以用来实现LRU (Least recently used, 最近最少使用)算法。 ConcurrentHashMap线程不安全的HashMap 因为多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap. 效率低下的HashTable容器 HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。 锁分段技术 HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，那假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。 ConcurrentHashMap的结构 我们通过ConcurrentHashMap的类图来分析ConcurrentHashMap的结构。 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 SparseArray SparseArray是使用两个数组来实现的，⼀个int类型的mKeys，⼀个Object类型mValues，其中mKeys 是一个存储key的数组，它是有序排列的，所以可以使用二分查找很快地确认key 在mKeys所处位置index，然后并把value插入到Values的index对应位置。 SparseArray更加节约内存，一个int[]数组存储所有的key，一个object[] 数组存储所有的value. HashMap遇到冲突时,时间复杂度为O(n)。而SparseArray不会有冲突，采用二分搜索算法，时间复杂度为O(lgn). ArrayMapArrayMap也是用用两个数组来模拟Map，第一个数组存放存放item的hash值，第二数组是把key，value连续的存放在数组里，通过先算hash在第一个数组里找到它的hash index，根据这个index在去第二个数组里找到这个key-value。在这里，在第一个数组里查找hash index的方法当然是用二分查找啦（binary search）。]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap的加载和Cache]]></title>
    <url>%2F2018%2F03%2F21%2FBitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8CCache%2F</url>
    <content type="text"><![CDATA[Bitmap的高效加载先来简单介绍一下如何加载一个Bitmap, Bitmap在android中指的是一张图片, 可以是png格式也可以是jpg等其他常见的图片格式. 那么如何加载一个图片?首先BitmapFactory类提供了四种方法: decodeFile(), decodeResource(), decodeStream(), decodeByteArray(). 分别用于从文件系统, 资源文件, 输入流以及字节数组加载出一个Bitmap对象. 其中decodeFile和decodeResource又间接调用了decodeStream()方法, 这四类方法最终是在Android的底层实现的, 对应着BitmapFactory类的几个native方法. 高效加载的Bitmap的核心思想:采用BitmapFactory.Options来加载所需尺寸的图片. 比如说一个ImageView控件的大小为300*300. 而图片的大小为800*800. 这个时候如果直接加载那么就比较浪费资源, 需要更多的内存空间来加载图片, 这不是很必要的. 这里我们就可以先把图片按一定的采样率来缩小图片在进行加载. 不仅降低了内存占用,还在一定程度上避免了OOM异常. 也提高了加载bitmap时的性能. 而通过Options参数来缩放图片: 主要是用到了inSampleSize参数, 即采样率. 如果是inSampleSize=1那么和原图大小一样, 如果是inSampleSize=2那么宽高都为原图1/2, 而像素为原图的1/4, 占用的内存大小也为原图的1/4 如果是inSampleSize=3那么宽高都为原图1/3, 而像素为原图的1/9, 占用的内存大小也为原图的1/9 以此类推….. 要知道Android中加载图片具体在内存中的占有的大小是根据图片的像素决定的, 而与图片的实际占用空间大小没有关系.而且如果要加载mipmap下的图片, 还会根据不同的分辨率下的文件夹进行不同的放大缩小. 列举现在有一张图片像素为:1024*1024, 如果采用ARGB8888(四个颜色通道每个占有一个字节,相当于1点像素占用4个字节的空间)的格式来存储.(这里不考虑不同的资源文件下情况分析) 那么图片的占有大小就是1024*1024*4那现在这张图片在内存中占用4MB. 如果针对刚才的图片进行inSampleSize=2, 那么最后占用内存大小为512*512*4, 也就是1MB 采样率的数值必须是大于1的整数是才会有缩放效果, 并且采样率同时作用于宽/高, 这将导致缩放后的图片以这个采样率的2次方递减, 即内存占用缩放大小为1/(inSampleSize的二次方). 如果小于1那么相当于=1的时候. 在官方文档中指出, inSampleSize的取值应该总是为2的指数, 比如1,2,4,8,16,32…如果外界传递inSampleSize不为2的指数, 那么系统会向下取整并选择一个最接近的2的指数来代替. 比如如果inSampleSize=3,那么系统会选择2来代替. 但是这条规则并不作用于所有的android版本, 所以可以当成一个开发建议 整理一下开发中代码流程: 将BitmapFactory.Options的inJustDecodeBounds参数设置为true并加载图片. 从BitmapFactory.Options取出图片的原始宽高信息, 他们对应于outWidth和outHeight参数 根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize 将BitmapFactory.Options的inJustDecodeBounds参数设为false, 然后重新加载. 第一个步骤设置了一个参数, 这个参数的作用就是在加载图片的时候是否只是加载图片宽高信息而不把图片全部加载到内存. 所以这个操作是个轻量级的. 通过这些步骤就可以整理出以下的工具加载图片类调用decodeFixedSizeForResource()即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MyBitmapLoadUtil &#123; /** * 对一个Resources的资源文件进行指定长宽来加载进内存, 并把这个bitmap对象返回 * * @param res 资源文件对象 * @param resId 要操作的图片id * @param reqWidth 最终想要得到bitmap的宽度 * @param reqHeight 最终想要得到bitmap的高度 * @return 返回采样之后的bitmap对象 */ public static Bitmap decodeFixedSizeForResource(Resources res, int resId, int reqWidth, int reqHeight)&#123; // 首先先指定加载的模式 为只是获取资源文件的大小 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); //Calculate Size 计算要设置的采样率 并把值设置到option上 options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 关闭只加载属性模式, 并重新加载的时候传入自定义的options对象 options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options); &#125; /** * 一个计算工具类的方法, 传入图片的属性对象和 想要实现的目标大小. 通过计算得到采样值 */ private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) &#123; //Raw height and width of image //原始图片的宽高属性 final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; // 如果想要实现的宽高比原始图片的宽高小那么就可以计算出采样率, 否则不需要改变采样率 if (reqWidth &lt; height || reqHeight &lt; width)&#123; int halfWidth = width/2; int halfHeight = height/2; // 判断原始长宽的一半是否比目标大小小, 如果小那么增大采样率2倍, 直到出现修改后原始值会比目标值大的时候 while((halfHeight/inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth/inSampleSize) &gt;= reqWidth)&#123; inSampleSize *= 2; &#125; &#125; return inSampleSize; &#125;&#125; 当给ImageView设置的时候传入控件的大小, 就会自动转换返回. 可以看一下下面的两张图, 当加载一个分辨率很大的图片如果不使用此方法那么就出程序崩溃 了解一下一个原始图片到手机显示的最终占用内存大小 Android中的缓存策略目前常用的一种缓存算法是LRU(Least Recently Used), 最近最少使用算法. 核心思想: 当缓存存满时, 会优先淘汰那些近期最少使用的缓存对象. 采用LRU算法的缓存有两种: LruCache和DiskLruCache。LruCache用于实现内存缓存, DiskLruCache则充当了存储设备缓存, 当组合使用后就可以实现一个类似ImageLoader这样的类库. LruCacheLruCache是Android 3.1所提供的一个缓存类, 通过support-v4兼容包可以兼容到早期的Android版本 LruCache是一个泛型类, 它内部采用了一个LinkedHashMap以强引用的方式存储外界的缓存对象, 其提供了get和put方法来完成缓存的获取和添加的操作. 当缓存满了时, LruCache会移除较早使用的缓存对象, 然后在添加新的缓存对象. 普及一下各种引用的区别: 强引用: 直接的对象引用 软引用: 当一个对象只有软引用存在时, 系统内存不足时此对象会被gc回收 弱引用: 当一个对象只有弱引用存在时, 对象会随下一次gc时被回收 创建的缓存对象大小通过可用内存的1/8来进行分配, 并需要重写sizeOf()方法, sizeOf()是计算缓存对象的大小, 如果有需要还可以重写entryRemoved(),在Lru移除旧缓存的时候回调用此方法. 12345678int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);int cacheSize = maxMemory / 8;mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @override protected int sizeof(String key, Bitmap bitmap) &#123; return bitmap.getRowBytes() * bitmap.getHeight() / 1024; &#125;&#125; 获取、添加、 删除一个缓存对象： 123mMemoryCache.get(key);mMemoryCache.put(key);mMemoryCache.remove(key); DiskLruCacheDiskLruCache用于实现存储设备缓存, 即磁盘缓存. 它通过将缓存对象写入文件系统从而实现缓存的效果. 参考： Android DiskLruCache完全解析，硬盘缓存的最佳方案 1. DiskLruCache的创建 DiskLruCache并不能通过构造方法来创建, 他提供了open()方法用于创建自身, 如下所示 1public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) 这个方法有四个参数: File directory: 表示磁盘缓存在文件系统中的存储路径. 可以选择SD卡上的缓存目录, 具体是指/sdcard/Andriod/data/package_name/cache目录, package_name表示当前应用的包名, 当应用被卸载后, 此目录会一并删除掉. 也可以选择data目录下. 或者其他地方. 这里给出的建议:如果应用卸载后就希望删除缓存文件的话 , 那么就选择SD卡上的缓存目录, 如果希望保留缓存数据那就应该选择SD卡上的其他目录. int appVersion: 表示应用的版本号, 一般设为1即可. 当版本号发生改变的时候DiskLruCache会清空之前所有的缓存文件, 在实际开发中这个实用性不大. int valueCount: 表示单个节点所对应的数据的个数, 一般设为1. long maxSize: 表示缓存的总大小, 比如50MB, 当缓存大小超出这个设定值后, DiskLruCache会清除一些缓存而保证总大小不大于这个设定值. 2. DiskLruCache的缓存添加 DiskLruCache的缓存添加的操作是通过Editor完成的, Editor表示一个缓存对象的编辑对象. 如果还是缓存图片为例子, 每一张图片都通过图片的url为key, 这里由于url可能会有特殊字符所以采用url的md5值作为key. 根据这个key就可以通过edit()来获取Editor对象, 如果这个缓存对象正在被编辑, 那么edit()就会返回null. 即DiskLruCache不允许同时编辑一个缓存对象. 当用.edit(key)获得了Editor对象之后. 通过editor.newOutputStream(0)就可以得到一个文件输出流. 由于之前open()方法设置了一个节点只能有一个数据. 所以在获得输出流的时候传入常量0即可. 有了文件输出流, 可以当网络下载图片时, 图片就可以通过这个文件输出流写入到文件系统上. 别忘了使用Bufferedxxxxx写完之后, 要通过Editor中commit()来提交写操作, 如果下载中发生异常, 那么使用Editor中abort()来回退整个操作. 3. DiskLruCache的缓存查找 和缓存的添加过程类似, 缓存查找过程也需要将url转换成key, 然后通过DiskLruCache#get()方法可以得到一个Snapshot对象, 接着在通过Snapshot对象即可得到缓存的文件输入流, 有了文件输入流, 自然就可以得到Bitmap对象. 为了避免加载图片出现OOM所以采用压缩的方式. 在前面对BitmapFactory.Options的使用说明了. 但是这中方法对FileInputStream的缩放存在问题. 原因是FileInputStream是一种有序的文件流, 而两次decodeStream调用会影响文件的位置属性, 这样在第二次decodeStream的时候得到的会是null. 针对这一个问题, 可以通过文件流来得到它所对应的文件描述符, 然后通过BitmapFactory.decodeFileDescription()来加载一张缩放后的图片. ImageLoader的实现一个好的ImageLoader应该具备以下几点: 图片的压缩 网络拉取 内存缓存 磁盘缓存 图片的同步加载 图片的异步加载 也可以利用picasso和glide这种图片加载类库, 使用构建者模式提供使用. 本文练习demo实现了链式调用设置控件,并制定url然后自动去获取. 相关联的类在load包中 可以看看有了缓存的区别 ImageLoader的使用照片墙效果这里定义一个自定义的ImageView作为GridView的item布局控件, 之所以这样是想让图片的控件自动去使用设备达到宽高相等的效果比较好看些 1234567891011121314151617181920public class SquareImageView extends ImageView &#123; public SquareImageView(Context context) &#123; super(context); &#125; public SquareImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; // 由于这里准备提供给GridView控件使用, 对于一个水平线有几个是未知的 // 那么通过父控件的测量传到这里的宽度规格, 也当做高度即可 super.onMeasure(widthMeasureSpec, widthMeasureSpec); &#125;&#125; 这个实现很简单, 利用动态的宽度同时也当做高度即可实现预期的效果. 这个就是结果, 或许应该对网络加上判断非wifi给一个提示, 可能首次加载会需要比较多的流量. 1234567891011121314151617181920212223242526272829303132333435 // 根据连接网络的情况判断是否加载图片if (!NetWorkUtil.isWifi(getApplicationContext())) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage("首次使用会从手机网络下载图片, 是否确认下载?") .setTitle("友情提示") .setPositiveButton("好的.", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; mCanLoadForPhoneNet = true; imageAdapter.notifyDataSetChanged(); &#125; &#125;) .setNegativeButton("不行!", new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; Toast.makeText(getApplicationContext(), "瞅你扣那样!!!", Toast.LENGTH_LONG).show(); &#125; &#125;).show();&#125;else&#123; mCanLoadForPhoneNet = true;&#125;// NetWorkUtil类public class NetWorkUtil &#123; public static boolean isWifi(Context context) &#123; ConnectivityManager connectivityManager = (ConnectivityManager) context .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetInfo = connectivityManager.getActiveNetworkInfo(); if (activeNetInfo != null &amp;&amp; activeNetInfo.getType() == ConnectivityManager.TYPE_WIFI) &#123; return true; &#125; return false; &#125;&#125; 然后优化列表 只有在GridView静止的时候才进行图片加载, 避免滑动时候的无谓的线程加载消耗(即使ImageLoader内部使用了线程池, 你仍然有这么做的必要) 12345678910111213141516171819GridView gv_main = (GridView) findViewById(R.id.gv_main);// 监听GridView的滑动状态 gv_main.setOnScrollListener(new AbsListView.OnScrollListener() &#123; @Override public void onScrollStateChanged(AbsListView view, int scrollState) &#123; if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE)&#123; mIsGridViewIdle = true; // 并触发更新adapter imageAdapter.notifyDataSetChanged(); &#125;else&#123; mIsGridViewIdle = false; &#125; &#125; @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) &#123; &#125; &#125;); 最后在adapter中的getView()设置标记位的判断, 只有在wifi和静止的状态下才进行加载请求下面是getView()代码 123456789101112131415161718192021222324252627@Overridepublic View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; if (convertView == null)&#123; convertView = View.inflate(mContext, R.layout.item_photo_wall, null); holder = new ViewHolder(); holder.mImageView = (ImageView) convertView.findViewById(R.id.iv_square); convertView.setTag(holder); &#125;else&#123; holder = (ViewHolder) convertView.getTag(); &#125; // 设置默认图片 ImageView mImageView = holder.mImageView; mImageView.setImageResource(android.R.drawable.screen_background_dark_transparent); // 检测是否wifi 和 是否是滑动状态 // 优化重点 if (mCanLoadForPhoneNet &amp;&amp; mIsGridViewIdle)&#123; // 加载图片 mImageLoader.setImageView(mImageView).url(mUrls.get(position)); &#125; return convertView;&#125;]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
        <tag>图片缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FutureTask & Callable]]></title>
    <url>%2F2018%2F03%2F19%2FCallable%E5%92%8CFutureTask%2F</url>
    <content type="text"><![CDATA[在阅读AsyncTask源码时候，有看到FutureTask的概念，当时只知道它与线程创建有关系。今天来探究一下它的源码结构。 同时也有一些面试题，询问Java中创建线程的几种方式，除了Thread和Runnable之外，提到了Callable的概念。本文重点分析一下这两个概念的用法。 Runnable点进去看一下Runnable接口的定义： 1234 @FunctionalInterfacepublic interface Runnable &#123; public abstract void run();&#125; Runnable的代码非常简单，它是一个接口且只有一个run()，创建一个类实现它，把一些费时操作写在其中，然后使用某个线程去执行该Runnable实现类即可实现多线程。 Callable跟着IDE中的源码进入到Callable的声明中了解一下其结构： 12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Callable的代码也非常简单，不同的是它是一个泛型接口，call()函数返回的类型就是创建Callable传进来的V类型。Callable与Runnable的功能大致相似，唯一的区别是Callable在线程执行完后，可以返回值，并且能抛出异常。 FutureFuture根据源代码解释其作用是对Callable或者Runnable进行管理，取消、检测完成与否获取最终结果等。 123456789public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。 isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。 isDone方法表示任务是否已经完成，若任务完成，则返回true； get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回； get(long timeout, TimeUnit unit) 获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。 ​ Future和Callable的基本用法123456789101112131415161718192021class MyCallable implements Callable&lt;String&gt;&#123; @Override public String call() throws Exception &#123; System.out.println("做一些耗时的任务..."); Thread.sleep(5000); return "OK"; &#125;&#125;public class FutureSimpleDemo &#123; public static void main(String[] args) throws InterruptedException, ExecutionException &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;String&gt; future = executorService.submit(new MyCallable()); System.out.println("dosomething..."); System.out.println("得到异步任务返回结果：" + future.get()); System.out.println("Completed!"); &#125;&#125; 上面是Future基本用法的代码以及并运行，我们可以知道： 线程是属于异步计算模型，所以你不可能直接从别的线程中得到方法返回值。 这时候，Future就出场了。 Futrue可以监视目标线程调用call的情况，当你调用Future的get()方法以获得结果时，当前线程就开始阻塞，直接call方法结束返回结果。 Future引用对象指向的实际是FutureTask。 也就是说，总结一句话，Future可以得到别的线程任务方法的返回值。 FutureTask接下来重点看一下示例中task的包装类FutureTask。如下所示发现RutureTask是实现RunnableFuture接口的一个类： 1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; 而这个RunnableFuture接口结构： 1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125; FutureTask构造方法 123456public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; 1234public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; 在这里我们可以了解到： FutureTask最终都是执行Callable类型的任务。 如果构造函数参数是Runnable，会被Executors.callable方法转换为Callable类型。 接下来我们看看Executors.callable方法代码 12345public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); return new RunnableAdapter&lt;T&gt;(task, result);&#125; 代码很简单，直接返回一个RunnableAdapter实例。 接下来我们看看RunnableAdapter方法代码 123456789101112131415/** * A callable that runs given task and returns given result */static final class RunnableAdapter&lt;T&gt; implements Callable&lt;T&gt; &#123; final Runnable task; final T result; RunnableAdapter(Runnable task, T result) &#123; this.task = task; this.result = result; &#125; public T call() &#123; task.run(); return result; &#125;&#125; 可以了解到： RunnableAdapter是Excutors的一个静态内部类并且实现了Callable，也就是说RunnableAdapter是Callable子类。 call方法实现代码是，执行Runnable的run方法，并返回构造FutureTask传入result参数。 FutureTask总结FutureTask实现了两个接口，Runnable和Future，所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值，那么这个组合的使用有什么好处呢？假设有一个很费时逻辑需要计算并且返回这个值，同时这个值不是马上需要，那么就可以使用这个组合，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到！ FutureTask基本用法 12345678910111213141516171819public class CallableAndFuture &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; public Integer call() throws Exception &#123; return new Random().nextInt(100); &#125; &#125;; FutureTask&lt;Integer&gt; future = new FutureTask&lt;Integer&gt;(callable); new Thread(future).start(); try &#123; Thread.sleep(3000);// 主线程可能做一些事情 System.out.println(future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结合线程池使用12345678910111213141516171819202122232425262728293031323334public class FutureTaskDemo &#123; public static void main(String[] args) &#123; // 创建一个ExecutorService对象 ExecutorService executor = Executors.newCachedThreadPool(); // new 一个Callable实例 Task task = new Task(); // new一个 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task); // 提交futureTask对象进入线程池 executor.submit(futureTask); // 关闭线程池 executor.shutdown(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println("主线程在执行任务"); try &#123; // 获取futuretask结果 System.out.println("task运行结果" + futureTask.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println("所有任务执行完毕"); &#125;&#125; 同时定义一个实现Callable接口的Task类如下所示： 1234567891011public static class Task implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println("子线程在进行计算"); Thread.sleep(3000); int sum = 0; for (int i = 0; i &lt; 100; i++) sum += i; return sum; &#125; &#125; 结果输出： 1234子线程在进行计算主线程在执行任务task运行结果4950所有任务执行完毕 从FutureTask用法以及返回的结果可见FutureTask是可以去执行Callable的，并且Callable独立的线程可以返回自己的执行结果。]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Callable</tag>
        <tag>FutureTask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的线程和线程池]]></title>
    <url>%2F2018%2F03%2F15%2FAndroid%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[第11章: 不仅仅是在Android中, 就算java中线程都是一块很重要的知识, 占有不小的比重. 除了最常使用的Thread之外, 在Android之中可以扮演线程角色的还有很多: 如AsyncTask和IntentService, 同时HandlerThread也是一种特殊的线程. 虽然这些线程的表现形式有别于基础线程. 但是本质上还是传统的线程. 例如AsyncTask它的底层使用了线程池. 而对于IntentService和HandlerThread来说, 他们的底层则直接使用了线程. 根据不同的特性来实现不同的场景 AsyncTask: 封装了线程池和Handler, 它主要是为了方便开发者在子线程中更新UI. HandlerThread: 是一种具有消息循环的线程, 在它的内部可以使用Handler. IntentService: 是一个服务, 系统对其进行了封装使其可以更方便地执行后台任务, IntentService内部采用了HandlerThread来执行任务, 当任务执行完毕后IntentService会自动退出. 从执行任务的角度来看, 更像一个后台的线程. 但是因为其本身是一种服务, 所以导致不容易被系统杀死从而保证任务的执行. 而如果是一个后台线程, 由于这个时候进行中没有活动的四大组件, 那么这个进程的优先级会很低, 很容易被系统杀死, 这就是IntentService的优点. 线程的简单概述 在操作系统中, 线程是操作系统调度的最小单元, 同时线程又是一种受限的系统资源, 即线程不可能无限制的产生, 并且线程的创建和销毁都会有相应的开销. 当系统中存在大量的线程时, 系统会通过时间片转轮的方式调度每个线程, 因此线程不可能做到绝对的并行, 除非线程数量小于等于cpu的核心数. 但这种情况太少了, 所以线程池的概念就由此出现. 通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销. 主线程和子线程主线程是指进程所拥有的线程, 在Java中默认情况下一个进程只有一个线程, 这个线程就是主线程. 主线程主要处理界面交互相关的逻辑, 因为用户随时会和界面发生交互, 因此主线程在任何时候都必须有较高的响应速度, 否则就会产生一种界面卡顿的感觉. 为了保持较高的响应速度, 这就要求主线程中不能执行耗时的任务, 这个时候子线程就派上用场. 子线程也叫作工作线程, 除了主线程以外的线程都叫做子线程 Android沿用了Java的线程模型, 其中的线程也分为主线程和子线程, 其中主线程也叫UI线程. 主线程的作用是运行四大组件以及处理它们和用户的交互. 而子线程的作用则是执行耗时任务, 比如网络请求, I/O操作等. 从Android 3.0 开始系统要求网络访问必须在子线程中进行, 否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常, 这样做是为了避免主线程由于耗时操作所阻塞从而出现ANR现象. Android中的线程形态AsyncTask AsyncTask是一种轻量级的异步任务类, 他可以在线程池中执行后台任务, 然后把执行的进度和最终的结果传递给主线程并在主线程更新UI. 从实现上来说. AsyncTask封装了Thread和Handler, 通过AsyncTask可以更加方便地执行后台任务, 对于特别耗时的任务来说, 建议使用线程池. 123public abstract class AsyncTask&lt;Params, Progress, Result&gt; &#123; // 省略一大坨代码&#125; AsyncTask就是一个抽象的泛型类. 这三个泛型的意义. Params: 表示参数的类型 Progress: 表示后台任务的执行进度的类型 Result: 则表示后台任务的返回结果的类型 如果不需要传递具体的参数, 那么这三个泛型参数可以用Void来代替. AsyncTask提供了4个核心方法, 含义如下 onPreExecute(): 在主线程执行, 在异步任务执行之前, 此方法会被调用, 一般可以用于做一些准备工作 protected abstract Result doInBackground(Params... params): 在线程池中执行, 此方法用于执行异步任务, 参数params表示异步任务的输入参数. 在此方法中可以通过publishProgress()方法来更新任务的进度, publishProgress()方法会调用onProgressUpdate()方法. 另外此方法需要返回计算结果给onPostExecute() onProgressUpdate(Progress... values): 在主线程执行,在异步任务执行之后, 此方法会被调用, 其中result参数是后台任务的返回值, 即doInBackground()的返回值. onPostExecute(Result result): 在主线程执行, 在异步任务执行之后, 此方法会被调用, 其中result参数是后台任务的返回值, 即doInBackground的返回值. 除了上述的四种方法,还有onCancelled(), 它同样在主线程执行, 当异步任务被取消时, onCancelled()方法会被调用, 这个时候onPostExecute()则不会被调用. AsyncTask在使用过程中有一些条件限制 AsyncTask的类必须在主线程被加载, 这就意味着第一次访问AsyncTask必须发生在主线程, 这个问题不是绝对, 因为在Android 4.1及以上的版本已经被系统自动完成. 在Android 5.0的源码中, 可以看到ActivityThread#main()会调用AsyncTask#init()方法. AsyncTask的对象必须在主线程中创建. execute方法必须在UI线程调用. 不要在程序中直接调用onPreExecute(), onPostExecute(), doInBackground和onProgressUpdate() 一个AsyncTask对象只能执行一次, 即只能调用一次execute()方法, 否则会报运行时异常. 在Android 1.6之前, AsyncTask是串行执行任务的; Android 1.6的时候AsyncTask开始采用线程池里处理并行任务; 但是Android 3.0开始, 为了避免AsyncTask带来的并发错误, AsyncTask又采用了一个线程来串行的执行任务. 尽管如此在3.0以后, 仍然可以通过AsyncTask#executeOnExecutor()方法来并行执行任务. AsyncTask的工作原理这里以源码5.0来分析, 不同的版本源码具体实现是不同的. 为了分析AsyncTask的工作原理, 可以从它的execute()方法开始分析, execute()方法又会调用executeOnExecutor()方法. 123456789101112131415161718192021222324252627public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params);&#125;public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; sDefaultExecutor实际上是一个串行的线程池, 一个进程中所有的AsyncTask全都在这个串行的线程池中排队执行, 然后会先调用AsyncTask#onPreExecute()方法, 然后线程池开始执行. 看看SerialExecutor()的源码实现: 123456789101112131415161718192021222324252627public static final Executor SERIAL_EXECUTOR = new SerialExecutor();private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125;&#125; 在SerialExecutor的实现可以分析AsyncTask的排队执行的过程. 首先系统会把AsyncTask#Params参数封装成FutureTask对象, FutureTask是一个并发类, 在这里充当了Runnable的作用. 接着这个FutureTask会交给SerialExecutor#execute()方法去处理. 这个方法首先会把FutureTask对象插入到任务队列mTasks中, 如果这个时候没有正在活动AsyncTask任务, 那么就会调用SerialExecutor#scheduleNext()方法来执行下一个AsyncTask任务. 同时当一个AsyncTask任务执行完后, AsyncTask会继续执行其他任务直到所有的任务都执行完毕为止, 从这一点可以看出, 在默认情况下, AsyncTask是串行执行的 AsyncTask中有两个线程池(SerialExecutor串行和THREAD_POOL_EXECUTOR并发)和一个Handler(InternalHandler), 其中线程池SerialExecutor用于任务的排列, 而线程池THREAD_POOL_EXECUTOR用于真正的执行任务, 而InternalHandler用于将执行环境从线程切换到主线程, 其本质仍然是线程的调用过程. 在AsyncTask的构造方法中有如下这段代码, 由于FutureTask#run()方法会调用mWorker.call()方法, 因此mWorker的call方法最终会在线程池中执行. 123456789mWorker = new WorkerRunnable&lt;Params, Result&gt;() &#123; public Result call() throws Exception &#123; mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); &#125; &#125;; 在mWorker.call()方法中, 首先将mTaskInvoked设为了true. 表示当前任务已经被调用过了. 然后执行AsyncTask#doInBackground()方法, 接着将其返回值传递给postResult(), 这个方法的实现: 1234567private Result postResult(Result result) &#123; @SuppressWarnings("unchecked") Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult&lt;Result&gt;(this, result)); message.sendToTarget(); return result;&#125; 这里, postResult()会通过sHandler发送一个MESSAGE_POST_RESULT消息, 而sHandler的定义如下: 123456789101112131415161718private static final InternalHandler sHandler = new InternalHandler();private static class InternalHandler extends Handler &#123; @SuppressWarnings(&#123;"unchecked", "RawUseOfParameterizedType"&#125;) @Override public void handleMessage(Message msg) &#123; AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) &#123; case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; &#125; &#125;&#125; 可以看出sHandler是一个静态的Handler对象, 为了能够将执行环境切换到主线程, 这就要求sHandler这个对象必须在主线程中创建. 由于静态成员会在加载类的时候进行初始化, 因此这就变相要求AsyncTask的类必须在主线程中加载, 否则同一个进程中的AsyncTask都无法正常工作.sHandler收到了消息后会调用AsyncTask#finish()方法, 如下: 12345678private void finish(Result result) &#123; if (isCancelled()) &#123; onCancelled(result); &#125; else &#123; onPostExecute(result); &#125; mStatus = Status.FINISHED;&#125; 这个finish()方法很简单, 如果AsyncTask被取消了, 那么就调用onCancelled()方法, 否则就会调用onPostExecute()方法, 可以看到doInBackground的反馈结果会传递给onPostExecute()方法. 通过源码分析, 可以确定从3.0开始, 默认情况下AsyncTask就是串行的. 通过一段代码测试. 1234567891011121314151617181920212223242526272829303132333435 @Overridepublic void onClick(View v) &#123; switch (v.getId())&#123; case R.id.btn_main: new MyAsync("任务_1").execute(""); new MyAsync("任务_2").execute(""); new MyAsync("任务_3").execute(""); new MyAsync("任务_4").execute(""); new MyAsync("任务_5").execute(""); break; &#125;&#125;private static class MyAsync extends AsyncTask&lt;String, Integer, String&gt;&#123; private static final String TAG = MyAsync.class.getSimpleName(); private final String mTaskName; public MyAsync(String taskName)&#123; mTaskName = taskName; &#125; @Override protected String doInBackground(String... params) &#123; SystemClock.sleep(3000); return mTaskName; &#125; @Override protected void onPostExecute(String s) &#123; super.onPostExecute(s); SimpleDateFormat df = new SimpleDateFormat("HH:mm:ss"); Log.e(TAG, s+" onPostExecute finish time: " +df.format(new Date())); &#125;&#125; 给按钮添加一个点击触发, 点击的时候会触发五个AsyncTask的创建和执行 , 看一下结果 在5.0机器上测试所有的任务是串行执行的. 总共耗费了15秒. 而在2.x的版本所有的结束时间却都是一样的. 为了让AsyncTask可以在Android 3.0及以上版本并行，可以使用executeOnExecutor()那么结果看一下: 12345678910/*** 在版本3.0以上使用并行的方式开启*/private void checkConcurrent() &#123; new MyAsync("任务_1").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("任务_2").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("任务_3").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("任务_4").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,""); new MyAsync("任务_5").executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,"");&#125; ok, 按照你的需求可以选择使用哪种实现方式. HandlerThreadHandlerThread继承了Thread, 它是一种可以使用Handler的Thread, 它的实现也很简单, 就是run方法中通过Looper.prepare()来创建消息队列, 并通过Looper.loop()来开启消息循环, 这样在实际的使用中就允许在HandlerThread中创建Handler, 看一下run()方法. 12345678910111213@Overridepublic void run() &#123; mTid = Process.myTid(); Looper.prepare(); synchronized (this) &#123; mLooper = Looper.myLooper(); notifyAll(); &#125; Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 从HandlerThread的实现来看, 它和普通的Thread有显著的不同之处. 普通的Thread主要用于在run方法中执行一个耗时任务; 而HandlerThread在内部创建了消息队列, 外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务. HandlerThread是一个很有用的类, 在Android中一个具体使用场景就是IntentService. 由于HandlerThread#run()是一个无线循环方法, 因此当明确不需要再使用HandlerThread时, 最好通过quit()或者quitSafely()方法来终止线程的执行. IntentServiceIntentService是一种特殊的Service, 它继承了Service并且它是一个抽象类, 因此需要创建子类才能使用. IntentService可以用于执行后台耗时任务, 当任务执行后会自动停止, 同时由于本质是服务的原因, 这导致了它的优先级比单纯的线程要高很多, 所以IntentService比较适合执行一些高优先级的后台任务. IntentService封装了Handler和HandlerThread. 这是在onCreate()来实现的. 12345678910111213@Overridepublic void onCreate() &#123; // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service &amp; hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper);&#125; 当第一次启动的时候, onCreate()就会被调用, 内部就会创建一个HandlerThread, 然后使用它的Looper来构造一个Handler对象mServiceHandler. 这样通过 mServiceHandler发送的消息最终都会在HandlerThread中执行, 从这个角度看IntentService也可以用于执行后台任务. 每次启动IntentService的时候, 它的onStartCommand()方法就会被调用一次, IntentService在onStartCommand()中处理每个后台任务的Intent. 看看源码是如何处理外界的Intent的. 首先onStartCommand()调用了onStart() 1234567@Overridepublic void onStart(Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg);&#125; 这个方法只是通过mServiceHandler发送了一个消息, 所以这个消息会在HandlerThread中被处理. 消息收到后, 会将Intent对象传递给onHandlerIntent()方法去处理. 注意这个Intent对象和外界startService()参数传递内容是一样的. 通过Intent的参数就可以区分具体的后台任务, 这样在onHandlerIntent()方法中就可以对不同的后台任务做处理了. 当onHandlerIntent()方法执行完毕后, IntentService会通过stopSelf()方法来停止服务. 这里使用的方法是有参数的, 不使用无参数的stopSelf()是因为无参函数会立刻停止服务, 可能会导致还有没执行完的任务失效. 有参的stopSelf(int startId)在尝试 停止服务之前会判断最近启动的服务次数是否和startId这个参数值相等, 如果相等就立刻停止服务, 否则反之. 这个策略可以从AMS#stopServiceToken()方法的实现中找到依据. IntentService#onHandleIntent()方法是一个抽象方法, 他需要我们在子类中实现, 它的作用是从Intent参数中区分具体的任务并执行这些任务. 如果目前只存在一个后台任务, 那么onHandleIntent()方法执行完成后, stopSelf(int startId)会立即停止服务; 如果目前存在多个后台任务, 那么当onHandleIntent()方法执行完最后一个任务时, stopSelf(int startId)才会停止任务. 另外由于每次执行一个后台任务都必须启动一次IntentService, 而其内部则通过消息的方式向HandlerThread请求执行任务, Handler中的Looper是顺序处理消息的, 这就意味着IntentService也是顺序执行后台任务的, 当有多个后台任务同时存在时, 这些后台任务会按照外界发起的顺序排队执行. 用代码来演示一遍: 123456789101112131415161718192021222324252627282930313233// 派生一个IntentService 的子类public static class LocalIntentService extends IntentService &#123; private static final String TAG = LocalIntentService.class.getSimpleName(); public LocalIntentService() &#123; super(TAG); &#125; @Override protected void onHandleIntent(Intent intent) &#123; String task = intent.getStringExtra("task"); Log.d(TAG, "receiver task :"+task); SystemClock.sleep(2000); &#125; @Override public void onDestroy() &#123; Log.w(TAG, "onDestroy: 准备关闭" ); super.onDestroy(); &#125;&#125;// 开启3个服务Intent service = new Intent(this, LocalIntentService.class);service.putExtra("task", "hi, 我是数据1");startService(service);service.putExtra("task", "hi, 我是数据2");startService(service);service.putExtra("task", "hi, 我是数据3");startService(service); 可以看出, 三个后台任务是串行执行的, 他们的执行顺序就是发起请求的顺序. 当任务3完成了之后. LocalIntentService才真正的停止, 因为这是时候执行了onDestroy(). Android中的线程池概括一下线程池的优点: 重用线程池中的线程, 避免因为线程的创建和销毁所带来的性能开销. 能有效控制线程的最大并大数, 避免大量的线程之间因互相抢占系统资源而导致的阻塞现象. 能够对线程进行简单的管理, 并提供定时执行以及指定间隔循环执行等能力. Android中的线程池的概念来源于Java中的Executor, Executor是一个接口, 真正的线程池的实现为ThreadPoolExecutor. ThreadPoolExecutor提供了一系列参数来配制线程池, 通过不同的参数可以创建不同的线程池. 而从功能的特性来分的话可以分成四类. 下面说明. ThreadPoolExecutorThreadPoolExecutor是线程池的真正实现, 它的构造方法提供了一系列参数来配置线程池, 下面对构造方法中参数进行一下说明, 这些参数将会直接影响到线程池的功能特性. 12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125; corePoolSize: 线程池的核心线程数, 默认情况下, 核心线程会在线程池中一直存活, 即使都处于闲置状态. 如果将ThreadPoolExecutor#allowCoreThreadTimeOut属性设置为true, 那么闲置的核心线程在等待新任务到来时会有超时的策略, 这个时间间隔由keepAliveTime属性来决定. 当等待时间超过了keepAliveTime设定的值那么核心线程将会终止. maximumPoolSize: 线程池所能容纳的最大线程数, 当活动线程数达到这个数值之后, 后续的任务将会被阻塞. keepAliveTime: 非核心线程闲置的超时时长, 超过这个时长, 非核心线程就会被回收. allowCoreThreadTimeOut这个属性为true的时候, 这个属性同样会作用于核心线程. unit: 用于指定keepAliveTime参数的时间单位, 这是一个枚举, 常用的有TimeUtil.MILLISECONDS(毫秒), TimeUtil.SECONDS(秒)以及TimeUtil.MINUTES(分) workQueue: 线程池中的任务队列, 通过线程池的execute方法提交的Runnable对象会存储在这个参数中. threadFactory: 线程工厂, 为线程池提供创建新线程的功能. ThreadFactory是一个接口. 线程池执行任务时大致遵循如下规则: 如果线程池中的线程数量未达到核心线程的数量, 那么会直接启动一个核心线程来执行任务. 如果线程池中的线程数量已经达到或者超过核心线程的数量, 那么任务会被插入到任务队列中排队等待执行. 如果在步骤2中无法将任务插入到任务队列中, 这通常是因为任务队列已满, 这个时候如果线程数量未达到线程池的规定的最大值, 那么会立刻启动一个非核心线程来执行任务. 如果步骤3中的线程数量已经达到最大值的时候, 那么会拒绝执行此任务, ThreadPoolExecutor会调用RejectedExecution方法来通知调用者. ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现, 下面是Android 5.0源码的配置情况： 12345678910111213141516171819202122private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();private static final int CORE_POOL_SIZE = CPU_COUNT + 1;private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;private static final int KEEP_ALIVE = 1;private static final ThreadFactory sThreadFactory = new ThreadFactory() &#123; private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) &#123; return new Thread(r, "AsyncTask #" + mCount.getAndIncrement()); &#125;&#125;;private static final BlockingQueue&lt;Runnable&gt; sPoolWorkQueue = new LinkedBlockingQueue&lt;Runnable&gt;(128);/*** An &#123;@link Executor&#125; that can be used to execute tasks in parallel.*/public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 这个配置后的规格是这样的 核心线程数等于CPU核心数 + 1; 线程池的最大线程数为CPU核心数的2倍 + 1; 核心线程无超时机制, 非核心线程在闲置时有超时机制,超时时间为1秒. 任务队列的容量为128 线程池的分类1. FixedThreadPool 通过Executors#newFixedThreadPool()方法来创建. 它是一种线程数量固定的线程池, 当线程处于空闲状态时, 它们并不会被回收, 除非线程池关闭了. 当所有的线程都处于活动状态时, 新任务都会处于等待状态, 直到有线程空闲出来. 由于FixedThreadPool只有核心线程并且这些核心线程不会被回收, 这意味着它能够更加快速地响应外界的请求. 1234567891011121314151617181920/** * Creates a thread pool that reuses a fixed number of threads * operating off a shared unbounded queue. At any point, at most * &#123;@code nThreads&#125; threads will be active processing tasks. * If additional tasks are submitted when all threads are active, * they will wait in the queue until a thread is available. * If any thread terminates due to a failure during execution * prior to shutdown, a new one will take its place if needed to * execute subsequent tasks. The threads in the pool will exist * until it is explicitly &#123;@link ExecutorService#shutdown shutdown&#125;. * * @param nThreads the number of threads in the pool * @return the newly created thread pool * @throws IllegalArgumentException if &#123;@code nThreads &lt;= 0&#125; */ public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; 2. CachedThreadPool通过Executors#newCachedThreadPool()方法来创建. 它是一种线程数量不定的线程池, 它只有非核心线程, 并且其最大值线程数为Integer.MAX_VALUE. 这就可以认为这个最大线程数为任意大了. 当线程池中的线程都处于活动的时候, 线程池会创建新的线程来处理新任务, 否则就会利用空闲的线程来处理新任务. 线程池中的空闲线程都有超时机制, 这个超时时长为60S, 超过这个时间那么空闲线程就会被回收. 和FixedThreadPool不同的是, CachedThreadPool的任务队列其实相当于一个空集合, 这将导致任何任务都会立即被执行, 因为在这种场景下SynchronousQueue是无法插入任务的. SynchronousQueue是一个非常特殊的队列, 在很多情况下可以把它简单理解为一个无法存储元素的队列. 在实际使用中很少使用.这类线程比较适合执行大量的耗时较少的任务 123456789101112131415161718192021/** * Creates a thread pool that creates new threads as needed, but * will reuse previously constructed threads when they are * available. These pools will typically improve the performance * of programs that execute many short-lived asynchronous tasks. * Calls to &#123;@code execute&#125; will reuse previously constructed * threads if available. If no existing thread is available, a new * thread will be created and added to the pool. Threads that have * not been used for sixty seconds are terminated and removed from * the cache. Thus, a pool that remains idle for long enough will * not consume any resources. Note that pools with similar * properties but different details (for example, timeout parameters) * may be created using &#123;@link ThreadPoolExecutor&#125; constructors. * * @return the newly created thread pool */ public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); &#125; 3. ScheduledThreadPool 通过Executors#newScheduledThreadPool()方法来创建. 它的核心线程数量是固定的, 而非核心线程数是没有限制的, 并且当非核心线程闲置时会立刻被回收掉. 这类线程池用于执行定时任务和具有固定周期的重复任务 12345678910111213141516171819202122232425 /** * Creates a thread pool that can schedule commands to run after a * given delay, or to execute periodically. * @param corePoolSize the number of threads to keep in the pool, * even if they are idle * @return a newly created scheduled thread pool * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */ public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125;/** * Creates a new &#123;@code ScheduledThreadPoolExecutor&#125; with the * given core pool size. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @throws IllegalArgumentException if &#123;@code corePoolSize &lt; 0&#125; */ public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS, new DelayedWorkQueue()); &#125; 4. SingleThreadExecutor 通过Executors#newSingleThreadPool()方法来创建. 这类线程池内部只有一个核心线程, 它确保所有的任务都在同一个线程中按顺序执行. 这类线程池意义在于统一所有的外界任务到一个线程中, 这使得在这些任务之间不需要处理线程同步的问题 12345678910111213141516171819/** * Creates an Executor that uses a single worker thread operating * off an unbounded queue. (Note however that if this single * thread terminates due to a failure during execution prior to * shutdown, a new one will take its place if needed to execute * subsequent tasks.) Tasks are guaranteed to execute * sequentially, and no more than one task will be active at any * given time. Unlike the otherwise equivalent * &#123;@code newFixedThreadPool(1)&#125; the returned executor is * guaranteed not to be reconfigurable to use additional threads. * * @return the newly created single-threaded Executor */ public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>线程和线程池</tag>
        <tag>AsyncTask</tag>
        <tag>HandlerThread</tag>
        <tag>IntentService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动分析]]></title>
    <url>%2F2018%2F03%2F14%2FActivity%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基于Android 6.0的源码剖析， 分析android Activity启动流程，相关源码： 1234567891011121314151617frameworks/base/services/core/java/com/android/server/am/ - ActivityManagerService.java - ActivityStackSupervisor.java - ActivityStack.java - ActivityRecord.java - ProcessRecord.javaframeworks/base/core/java/android/app/ - IActivityManager.java - ActivityManagerNative.java (内含AMP) - ActivityManager.java - IApplicationThread.java - ApplicationThreadNative.java (内含ATP) - ActivityThread.java (内含ApplicationThread) - ContextImpl.java 一. 概述startActivity的整体流程与startService启动过程分析非常相近，但比Service启动更为复杂，多了stack/task以及UI的相关内容以及Activity的生命周期更为丰富。 Activity启动发起后，通过Binder最终交由system进程中的AMS来完成，则启动流程如下图： 接下来，从源码来说说每个过程。 二. 启动流程2.1 Activity.startActivity[-&gt; Activity.java] 123456789101112public void startActivity(Intent intent) &#123; this.startActivity(intent, null);&#125;public void startActivity(Intent intent, @Nullable Bundle options) &#123; if (options != null) &#123; startActivityForResult(intent, -1, options); &#125; else &#123; //[见小节2.2] startActivityForResult(intent, -1); &#125;&#125; 2.2 startActivityForResult[-&gt; Activity.java] 12345678910111213141516171819202122232425public void startActivityForResult(Intent intent, int requestCode) &#123; startActivityForResult(intent, requestCode, null);&#125;public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; //[见小节2.3] Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; //此时requestCode =-1 if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; cancelInputsAndStartExitTransition(options); &#125; else &#123; ... &#125;&#125; execStartActivity()方法的参数: mAppThread: 数据类型为ApplicationThread，通过mMainThread.getApplicationThread()方法获取。 mToken: 数据类型为IBinder. 2.3 execStartActivity[-&gt; Instrumentation.java] 12345678910111213141516171819202122232425262728293031323334353637public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; ... if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; //当该monitor阻塞activity启动,则直接返回 if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); //[见小节2.4] int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); //检查activity是否启动成功 checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; throw new RuntimeException("Failure from system", e); &#125; return null;&#125; 关于 ActivityManagerNative.getDefault()返回的是ActivityManagerProxy对象(跨进程返回Stub.Proxy对象). 此处startActivity()的共有10个参数, 下面说说每个参数传递AMP.startActivity()每一项的对应值: caller: 当前应用的ApplicationThread对象mAppThread; callingPackage: 调用当前ContextImpl.getBasePackageName(),获取当前Activity所在包名; intent: 这便是启动Activity时,传递过来的参数; resolvedType: 调用intent.resolveTypeIfNeeded而获取; resultTo: 来自于当前Activity.mToken resultWho: 来自于当前Activity.mEmbeddedID requestCode = -1; startFlags = 0; profilerInfo = null; options = null; 2.4 AMP.startActivity[-&gt; ActivityManagerNative.java :: ActivityManagerProxy] 123456789101112131415161718192021222324252627282930313233343536class ActivityManagerProxy implements IActivityManager &#123; ... public int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeStrongBinder(caller != null ? caller.asBinder() : null); data.writeString(callingPackage); intent.writeToParcel(data, 0); data.writeString(resolvedType); data.writeStrongBinder(resultTo); data.writeString(resultWho); data.writeInt(requestCode); data.writeInt(startFlags); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; if (options != null) &#123; data.writeInt(1); options.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; //[见流程2.5] mRemote.transact(START_ACTIVITY_TRANSACTION, data, reply, 0); reply.readException(); int result = reply.readInt(); reply.recycle(); data.recycle(); return result; &#125; ...&#125; AMP经过binder IPC,进入ActivityManagerNative(简称AMN)。接下来程序进入了system_sever进程，开始继续执行。 2.5 AMN.onTransact[-&gt; ActivityManagerNative.java] 123456789101112131415161718192021222324252627public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case START_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IActivityManager.descriptor); IBinder b = data.readStrongBinder(); IApplicationThread app = ApplicationThreadNative.asInterface(b); String callingPackage = data.readString(); Intent intent = Intent.CREATOR.createFromParcel(data); String resolvedType = data.readString(); IBinder resultTo = data.readStrongBinder(); String resultWho = data.readString(); int requestCode = data.readInt(); int startFlags = data.readInt(); ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; Bundle options = data.readInt() != 0 ? Bundle.CREATOR.createFromParcel(data) : null; //[见流程2.6] int result = startActivity(app, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options); reply.writeNoException(); reply.writeInt(result); return true; &#125; ... &#125; &#125; 2.6 AMS.startActivity[-&gt; ActivityManagerService.java] 123456789101112131415public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;public final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); //[见小节2.7] return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, false, userId, null, null);&#125; 此处mStackSupervisor的数据类型为ActivityStackSupervisor 2.7 ASS.startActivityMayWait当程序运行到这里时, ASS.startActivityMayWait的各个参数取值如下: caller = ApplicationThreadProxy, 用于跟调用者进程ApplicationThread进行通信的binder代理类. callingUid = -1; callingPackage = ContextImpl.getBasePackageName(),获取调用者Activity所在包名 intent: 这是启动Activity时传递过来的参数; resolvedType = intent.resolveTypeIfNeeded voiceSession = null; voiceInteractor = null; resultTo = Activity.mToken, 其中Activity是指调用者所在Activity, mToken对象保存自己所处的ActivityRecord信息 resultWho = Activity.mEmbeddedID, 其中Activity是指调用者所在Activity requestCode = -1; startFlags = 0; profilerInfo = null; outResult = null; config = null; options = null; ignoreTargetSecurity = false; userId = AMS.handleIncomingUser, 当调用者userId跟当前处于同一个userId,则直接返回该userId;当不相等时则根据调用者userId来决定是否需要将callingUserId转换为mCurrentUserId. iContainer = null; inTask = null; 再来看看这个方法的源码: [-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869final int startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration config, Bundle options, boolean ignoreTargetSecurity, int userId, IActivityContainer iContainer, TaskRecord inTask) &#123; ... boolean componentSpecified = intent.getComponent() != null; //创建新的Intent对象，即便intent被修改也不受影响 intent = new Intent(intent); //收集Intent所指向的Activity信息, 当存在多个可供选择的Activity,则直接向用户弹出resolveActivity [见2.7.1] ActivityInfo aInfo = resolveActivity(intent, resolvedType, startFlags, profilerInfo, userId); ActivityContainer container = (ActivityContainer)iContainer; synchronized (mService) &#123; if (container != null &amp;&amp; container.mParentActivity != null &amp;&amp; container.mParentActivity.state != RESUMED) &#123; ... //不进入该分支, container == nul &#125; final int realCallingPid = Binder.getCallingPid(); final int realCallingUid = Binder.getCallingUid(); int callingPid; if (callingUid &gt;= 0) &#123; callingPid = -1; &#125; else if (caller == null) &#123; callingPid = realCallingPid; callingUid = realCallingUid; &#125; else &#123; callingPid = callingUid = -1; &#125; final ActivityStack stack; if (container == null || container.mStack.isOnHomeDisplay()) &#123; stack = mFocusedStack; // 进入该分支 &#125; else &#123; stack = container.mStack; &#125; //此时mConfigWillChange = false stack.mConfigWillChange = config != null &amp;&amp; mService.mConfiguration.diff(config) != 0; final long origId = Binder.clearCallingIdentity(); if (aInfo != null &amp;&amp; (aInfo.applicationInfo.privateFlags &amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; // heavy-weight进程处理流程, 一般情况下不进入该分支 if (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123; ... &#125; &#125; //[见流程2.8] int res = startActivityLocked(caller, intent, resolvedType, aInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options, ignoreTargetSecurity, componentSpecified, null, container, inTask); Binder.restoreCallingIdentity(origId); if (stack.mConfigWillChange) &#123; ... //不进入该分支 &#125; if (outResult != null) &#123; ... //不进入该分支 &#125; return res; &#125;&#125; 该过程主要功能：通过resolveActivity来获取ActivityInfo信息, 然后再进入ASS.startActivityLocked().先来看看 2.7.1 ASS.resolveActivity12345678910111213141516171819// startFlags = 0; profilerInfo = null; userId代表caller UserIdActivityInfo resolveActivity(Intent intent, String resolvedType, int startFlags, ProfilerInfo profilerInfo, int userId) &#123; ActivityInfo aInfo; ResolveInfo rInfo = AppGlobals.getPackageManager().resolveIntent( intent, resolvedType, PackageManager.MATCH_DEFAULT_ONLY | ActivityManagerService.STOCK_PM_FLAGS, userId); aInfo = rInfo != null ? rInfo.activityInfo : null; if (aInfo != null) &#123; intent.setComponent(new ComponentName( aInfo.applicationInfo.packageName, aInfo.name)); if (!aInfo.processName.equals("system")) &#123; ... //对于非system进程，根据flags来设置相应的debug信息 &#125; &#125; return aInfo;&#125; ActivityManager类有如下4个flags用于调试： START_FLAG_DEBUG：用于调试debug app START_FLAG_OPENGL_TRACES：用于调试OpenGL tracing START_FLAG_NATIVE_DEBUGGING：用于调试native START_FLAG_TRACK_ALLOCATION: 用于调试allocation tracking 2.7.2 PKMS.resolveIntentAppGlobals.getPackageManager()经过函数层层调用，获取的是ApplicationPackageManager对象。经过binder IPC调用，最终会调用PackageManagerService对象。故此时调用方法为PMS.resolveIntent(). [-&gt; PackageManagerService.java] 12345678public ResolveInfo resolveIntent(Intent intent, String resolvedType, int flags, int userId) &#123; if (!sUserManager.exists(userId)) return null; enforceCrossUserPermission(Binder.getCallingUid(), userId, false, false, "resolve intent"); //[见流程2.7.3] List&lt;ResolveInfo&gt; query = queryIntentActivities(intent, resolvedType, flags, userId); //根据priority，preferred选择最佳的Activity return chooseBestActivity(intent, resolvedType, flags, query, userId); &#125; 2.7.3 PMS.queryIntentActivities123456789101112131415161718192021222324public List&lt;ResolveInfo&gt; queryIntentActivities(Intent intent, String resolvedType, int flags, int userId) &#123; ... ComponentName comp = intent.getComponent(); if (comp == null) &#123; if (intent.getSelector() != null) &#123; intent = intent.getSelector(); comp = intent.getComponent(); &#125; &#125; if (comp != null) &#123; final List&lt;ResolveInfo&gt; list = new ArrayList&lt;ResolveInfo&gt;(1); //获取Activity信息 final ActivityInfo ai = getActivityInfo(comp, flags, userId); if (ai != null) &#123; final ResolveInfo ri = new ResolveInfo(); ri.activityInfo = ai; list.add(ri); &#125; return list; &#125; ...&#125; ASS.resolveActivity()方法的核心功能是找到相应的Activity组件，并保存到intent对象。 2.8 ASS.startActivityLocked[-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117final int startActivityLocked(IApplicationThread caller, Intent intent, String resolvedType, ActivityInfo aInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, Bundle options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityContainer container, TaskRecord inTask) &#123; int err = ActivityManager.START_SUCCESS; //获取调用者的进程记录对象 ProcessRecord callerApp = null; if (caller != null) &#123; callerApp = mService.getRecordForAppLocked(caller); if (callerApp != null) &#123; callingPid = callerApp.pid; callingUid = callerApp.info.uid; &#125; else &#123; err = ActivityManager.START_PERMISSION_DENIED; &#125; &#125; final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; if (resultTo != null) &#123; //获取调用者所在的Activity sourceRecord = isInAnyStackLocked(resultTo); if (sourceRecord != null) &#123; if (requestCode &gt;= 0 &amp;&amp; !sourceRecord.finishing) &#123; ... //requestCode = -1 则不进入 &#125; &#125; &#125; final int launchFlags = intent.getFlags(); if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) &#123; ... // activity执行结果的返回由源Activity转换到新Activity, 不需要返回结果则不会进入该分支 &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == null) &#123; //从Intent中无法找到相应的Component err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == null) &#123; //从Intent中无法找到相应的ActivityInfo err = ActivityManager.START_INTENT_NOT_RESOLVED; &#125; if (err == ActivityManager.START_SUCCESS &amp;&amp; !isCurrentProfileLocked(userId) &amp;&amp; (aInfo.flags &amp; FLAG_SHOW_FOR_ALL_USERS) == 0) &#123; //尝试启动一个后台Activity, 但该Activity对当前用户不可见 err = ActivityManager.START_NOT_CURRENT_USER_ACTIVITY; &#125; ... //执行后resultStack = null final ActivityStack resultStack = resultRecord == null ? null : resultRecord.task.stack; ... //权限检查 // ActivityController不为空的情况，比如monkey测试过程 if (mService.mController != null) &#123; Intent watchIntent = intent.cloneFilter(); abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); &#125; if (abort) &#123; ... //权限检查不满足,才进入该分支则直接返回； return ActivityManager.START_SUCCESS; &#125; // 创建Activity记录对象 ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, this, container, options); if (outActivity != null) &#123; outActivity[0] = r; &#125; if (r.appTimeTracker == null &amp;&amp; sourceRecord != null) &#123; r.appTimeTracker = sourceRecord.appTimeTracker; &#125; // 将mFocusedStack赋予当前stack final ActivityStack stack = mFocusedStack; if (voiceSession == null &amp;&amp; (stack.mResumedActivity == null || stack.mResumedActivity.info.applicationInfo.uid != callingUid)) &#123; // 前台stack还没有resume状态的Activity时, 则检查app切换是否允许 [见流程2.8.1] if (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid, realCallingPid, realCallingUid, "Activity start")) &#123; PendingActivityLaunch pal = new PendingActivityLaunch(r, sourceRecord, startFlags, stack); // 当不允许切换,则把要启动的Activity添加到mPendingActivityLaunches对象, 并且直接返回. mPendingActivityLaunches.add(pal); ActivityOptions.abort(options); return ActivityManager.START_SWITCHES_CANCELED; &#125; &#125; if (mService.mDidAppSwitch) &#123; //从上次禁止app切换以来,这是第二次允许app切换,因此将允许切换时间设置为0,则表示可以任意切换app mService.mAppSwitchesAllowedTime = 0; &#125; else &#123; mService.mDidAppSwitch = true; &#125; //处理 pendind Activity的启动, 这些Activity是由于app switch禁用从而被hold的等待启动activity [见流程2.8.2] doPendingActivityLaunchesLocked(false); //[见流程2.9] err = startActivityUncheckedLocked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); if (err &lt; 0) &#123; notifyActivityDrawnForKeyguard(); &#125; return err;&#125; 其中有两个返回值代表启动Activity失败： START_INTENT_NOT_RESOLVED: 从Intent中无法找到相应的Component或者ActivityInfo START_NOT_CURRENT_USER_ACTIVITY：该Activity对当前用户不可见 2.8.1 AMS.checkAppSwitchAllowedLocked1234567891011121314151617181920212223boolean checkAppSwitchAllowedLocked(int sourcePid, int sourceUid, int callingPid, int callingUid, String name) &#123; if (mAppSwitchesAllowedTime &lt; SystemClock.uptimeMillis()) &#123; return true; &#125; int perm = checkComponentPermission( android.Manifest.permission.STOP_APP_SWITCHES, sourcePid, sourceUid, -1, true); if (perm == PackageManager.PERMISSION_GRANTED) &#123; return true; &#125; if (callingUid != -1 &amp;&amp; callingUid != sourceUid) &#123; perm = checkComponentPermission( android.Manifest.permission.STOP_APP_SWITCHES, callingPid, callingUid, -1, true); if (perm == PackageManager.PERMISSION_GRANTED) &#123; return true; &#125; &#125; return false;&#125; 当mAppSwitchesAllowedTime时间小于当前时长,或者具有STOP_APP_SWITCHES的权限,则允许app发生切换操作. 其中mAppSwitchesAllowedTime, 在AMS.stopAppSwitches()的过程中会设置为:mAppSwitchesAllowedTime = SystemClock.uptimeMillis() + APP_SWITCH_DELAY_TIME. 禁止app切换的timeout时长为5s(APP_SWITCH_DELAY_TIME = 5s). 当发送5秒超时或者执行AMS.resumeAppSwitches()过程会将mAppSwitchesAllowedTime设置0, 都会开启允许app执行切换的操作.另外,禁止App切换的操作,对于同一个app是不受影响的,有兴趣可以进一步查看checkComponentPermission过程. 2.8.2 ASS.doPendingActivityLaunchesLocked[-&gt; ActivityStackSupervisor.java] 123456789101112final void doPendingActivityLaunchesLocked(boolean doResume) &#123; while (!mPendingActivityLaunches.isEmpty()) &#123; PendingActivityLaunch pal = mPendingActivityLaunches.remove(0); try &#123; //[见流程2.9] startActivityUncheckedLocked(pal.r, pal.sourceRecord, null, null, pal.startFlags, doResume &amp;&amp; mPendingActivityLaunches.isEmpty(), null, null); &#125; catch (Exception e) &#123; ... &#125; &#125;&#125; mPendingActivityLaunches记录着所有将要启动的Activity, 是由于在startActivityLocked的过程时App切换功能被禁止, 也就是不运行切换Activity, 那么此时便会把相应的Activity加入到mPendingActivityLaunches队列. 该队列的成员在执行完doPendingActivityLaunchesLocked便会清空. 启动mPendingActivityLaunches中所有的Activity, 由于doResume = false, 那么这些activtity并不会进入resume状态,而是设置delayedResume = true, 会延迟resume. 2.9 ASS.startActivityUncheckedLocked[-&gt; ActivityStackSupervisor.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404// sourceRecord是指调用者， r是指本次将要启动的Activityfinal int startActivityUncheckedLocked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, Bundle options, TaskRecord inTask) &#123; final Intent intent = r.intent; final int callingUid = r.launchedFromUid; if (inTask != null &amp;&amp; !inTask.inRecents) &#123; inTask = null; &#125; final boolean launchSingleTop = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TOP; final boolean launchSingleInstance = r.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE; final boolean launchSingleTask = r.launchMode == ActivityInfo.LAUNCH_SINGLE_TASK; int launchFlags = intent.getFlags(); // 当intent和activity manifest存在冲突，则manifest优先 if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0 &amp;&amp; (launchSingleInstance || launchSingleTask)) &#123; launchFlags &amp;= ~(Intent.FLAG_ACTIVITY_NEW_DOCUMENT | Intent.FLAG_ACTIVITY_MULTIPLE_TASK); &#125; else &#123; ... &#125; final boolean launchTaskBehind = r.mLaunchTaskBehind &amp;&amp; !launchSingleTask &amp;&amp; !launchSingleInstance &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0; if (r.resultTo != null &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; r.resultTo.task.stack != null) &#123; r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); r.resultTo = null; &#125; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_DOCUMENT) != 0 &amp;&amp; r.resultTo == null) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; if (launchTaskBehind || r.info.documentLaunchMode == ActivityInfo.DOCUMENT_LAUNCH_ALWAYS) &#123; launchFlags |= Intent.FLAG_ACTIVITY_MULTIPLE_TASK; &#125; &#125; mUserLeaving = (launchFlags &amp; Intent.FLAG_ACTIVITY_NO_USER_ACTION) == 0; //当本次不需要resume，则设置为延迟resume的状态 if (!doResume) &#123; r.delayedResume = true; &#125; ActivityRecord notTop = (launchFlags &amp; Intent.FLAG_ACTIVITY_PREVIOUS_IS_TOP) != 0 ? r : null; if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; ActivityRecord checkedCaller = sourceRecord; if (checkedCaller == null) &#123; checkedCaller = mFocusedStack.topRunningNonDelayedActivityLocked(notTop); &#125; if (!checkedCaller.realActivity.equals(r.realActivity)) &#123; //调用者 与将要启动的Activity不相同时，进入该分支。 startFlags &amp;= ~ActivityManager.START_FLAG_ONLY_IF_NEEDED; &#125; &#125; boolean addingToTask = false; TaskRecord reuseTask = null; //当调用者不是来自activity，而是明确指定task的情况。 if (sourceRecord == null &amp;&amp; inTask != null &amp;&amp; inTask.stack != null) &#123; ... //目前sourceRecord不为空，则不进入该分支 &#125; else &#123; inTask = null; &#125; if (inTask == null) &#123; if (sourceRecord == null) &#123; //调用者并不是Activity context,则强制创建新task if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0 &amp;&amp; inTask == null) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; &#125; else if (sourceRecord.launchMode == ActivityInfo.LAUNCH_SINGLE_INSTANCE) &#123; //调用者activity带有single instance，则创建新task launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; else if (launchSingleInstance || launchSingleTask) &#123; //目标activity带有single instance或者single task，则创建新task launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; &#125; &#125; ActivityInfo newTaskInfo = null; Intent newTaskIntent = null; ActivityStack sourceStack; if (sourceRecord != null) &#123; if (sourceRecord.finishing) &#123; //调用者处于即将finish状态，则创建新task if ((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) == 0) &#123; launchFlags |= Intent.FLAG_ACTIVITY_NEW_TASK; newTaskInfo = sourceRecord.info; newTaskIntent = sourceRecord.task.intent; &#125; sourceRecord = null; sourceStack = null; &#125; else &#123; //当调用者Activity不为空，且不处于finishing状态，则其所在栈赋于sourceStack sourceStack = sourceRecord.task.stack; &#125; &#125; else &#123; sourceStack = null; &#125; boolean movedHome = false; ActivityStack targetStack; intent.setFlags(launchFlags); final boolean noAnimation = (launchFlags &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0; if (((launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0 &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_MULTIPLE_TASK) == 0) || launchSingleInstance || launchSingleTask) &#123; if (inTask == null &amp;&amp; r.resultTo == null) &#123; //从mActivityDisplays开始查询是否有相应ActivityRecord ActivityRecord intentActivity = !launchSingleInstance ? findTaskLocked(r) : findActivityLocked(intent, r.info); if (intentActivity != null) &#123; if (isLockTaskModeViolation(intentActivity.task, (launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; if (r.task == null) &#123; r.task = intentActivity.task; &#125; if (intentActivity.task.intent == null) &#123; intentActivity.task.setIntent(r); &#125; targetStack = intentActivity.task.stack; targetStack.mLastPausedActivity = null; final ActivityStack focusStack = getFocusedStack(); ActivityRecord curTop = (focusStack == null) ? null : focusStack.topRunningNonDelayedActivityLocked(notTop); boolean movedToFront = false; if (curTop != null &amp;&amp; (curTop.task != intentActivity.task || curTop.task != focusStack.topTask())) &#123; r.intent.addFlags(Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT); if (sourceRecord == null || (sourceStack.topActivity() != null &amp;&amp; sourceStack.topActivity().task == sourceRecord.task)) &#123; if (launchTaskBehind &amp;&amp; sourceRecord != null) &#123; intentActivity.setTaskToAffiliateWith(sourceRecord.task); &#125; movedHome = true; //将该task移至前台 targetStack.moveTaskToFrontLocked(intentActivity.task, noAnimation, options, r.appTimeTracker, "bringingFoundTaskToFront"); movedToFront = true; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; //将toReturnTo设置为home intentActivity.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; options = null; &#125; &#125; if (!movedToFront) &#123; targetStack.moveToFront("intentActivityFound"); &#125; if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; //重置目标task intentActivity = targetStack.resetTaskIfNeededLocked(intentActivity, r); &#125; if ((startFlags &amp; ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; if (doResume) &#123; resumeTopActivitiesLocked(targetStack, null, options); //当没有启动至前台，则通知Keyguard if (!movedToFront) &#123; notifyActivityDrawnForKeyguard(); &#125; &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) &#123; reuseTask = intentActivity.task; //移除所有跟已存在的task有关联的activity reuseTask.performClearTaskLocked(); reuseTask.setIntent(r); &#125; else if ((launchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0 || launchSingleInstance || launchSingleTask) &#123; ActivityRecord top = intentActivity.task.performClearTaskLocked(r, launchFlags); if (top != null) &#123; if (top.frontOfTask) &#123; top.task.setIntent(r); &#125; //触发onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); &#125; else &#123; sourceRecord = intentActivity; TaskRecord task = sourceRecord.task; if (task != null &amp;&amp; task.stack == null) &#123; targetStack = computeStackFocus(sourceRecord, false /* newTask */); targetStack.addTask( task, !launchTaskBehind /* toTop */, false /* moving */); &#125; &#125; &#125; else if (r.realActivity.equals(intentActivity.task.realActivity)) &#123; if (((launchFlags&amp;Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop) &amp;&amp; intentActivity.realActivity.equals(r.realActivity)) &#123; if (intentActivity.frontOfTask) &#123; intentActivity.task.setIntent(r); &#125; //触发onNewIntent() intentActivity.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); &#125; else if (!r.intent.filterEquals(intentActivity.task.intent)) &#123; addingToTask = true; sourceRecord = intentActivity; &#125; &#125; else if ((launchFlags&amp;Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) == 0) &#123; addingToTask = true; sourceRecord = intentActivity; &#125; else if (!intentActivity.task.rootWasReset) &#123; intentActivity.task.setIntent(r); &#125; if (!addingToTask &amp;&amp; reuseTask == null) &#123; if (doResume) &#123; targetStack.resumeTopActivityLocked(null, options); if (!movedToFront) &#123; notifyActivityDrawnForKeyguard(); &#125; &#125; else &#123; ActivityOptions.abort(options); &#125; return ActivityManager.START_TASK_TO_FRONT; &#125; &#125; &#125; &#125; if (r.packageName != null) &#123; //当启动的activity跟前台显示是同一个的情况 ActivityStack topStack = mFocusedStack; ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(notTop); if (top != null &amp;&amp; r.resultTo == null) &#123; if (top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if (top.app != null &amp;&amp; top.app.thread != null) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; topStack.mLastPausedActivity = null; if (doResume) &#123; resumeTopActivitiesLocked(); &#125; ActivityOptions.abort(options); if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; &#125; //触发onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; &#125; &#125; &#125; else &#123; if (r.resultTo != null &amp;&amp; r.resultTo.task.stack != null) &#123; r.resultTo.task.stack.sendActivityResultLocked(-1, r.resultTo, r.resultWho, r.requestCode, Activity.RESULT_CANCELED, null); &#125; ActivityOptions.abort(options); return ActivityManager.START_CLASS_NOT_FOUND; &#125; boolean newTask = false; boolean keepCurTransition = false; TaskRecord taskToAffiliate = launchTaskBehind &amp;&amp; sourceRecord != null ? sourceRecord.task : null; if (r.resultTo == null &amp;&amp; inTask == null &amp;&amp; !addingToTask &amp;&amp; (launchFlags &amp; Intent.FLAG_ACTIVITY_NEW_TASK) != 0) &#123; newTask = true; targetStack = computeStackFocus(r, newTask); targetStack.moveToFront("startingNewTask"); if (reuseTask == null) &#123; r.setTask(targetStack.createTaskRecord(getNextTaskId(), newTaskInfo != null ? newTaskInfo : r.info, newTaskIntent != null ? newTaskIntent : intent, voiceSession, voiceInteractor, !launchTaskBehind /* toTop */), taskToAffiliate); &#125; else &#123; r.setTask(reuseTask, taskToAffiliate); &#125; if (isLockTaskModeViolation(r.task)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; if (!movedHome) &#123; if ((launchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_TASK_ON_HOME)) &#123; r.task.setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; &#125; &#125; else if (sourceRecord != null) &#123; final TaskRecord sourceTask = sourceRecord.task; if (isLockTaskModeViolation(sourceTask)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = sourceTask.stack; targetStack.moveToFront("sourceStackToFront"); final TaskRecord topTask = targetStack.topTask(); if (topTask != sourceTask) &#123; targetStack.moveTaskToFrontLocked(sourceTask, noAnimation, options, r.appTimeTracker, "sourceTaskToFront"); &#125; if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_CLEAR_TOP) != 0) &#123; ActivityRecord top = sourceTask.performClearTaskLocked(r, launchFlags); keepCurTransition = true; if (top != null) &#123; //触发onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; ActivityOptions.abort(options); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; else if (!addingToTask &amp;&amp; (launchFlags&amp;Intent.FLAG_ACTIVITY_REORDER_TO_FRONT) != 0) &#123; final ActivityRecord top = sourceTask.findActivityInHistoryLocked(r); if (top != null) &#123; final TaskRecord task = top.task; task.moveActivityToFrontLocked(top); top.updateOptionsLocked(options); //触发onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); targetStack.mLastPausedActivity = null; if (doResume) &#123; targetStack.resumeTopActivityLocked(null); &#125; return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; r.setTask(sourceTask, null); &#125; else if (inTask != null) &#123; if (isLockTaskModeViolation(inTask)) &#123; return ActivityManager.START_RETURN_LOCK_TASK_MODE_VIOLATION; &#125; targetStack = inTask.stack; targetStack.moveTaskToFrontLocked(inTask, noAnimation, options, r.appTimeTracker, "inTaskToFront"); ActivityRecord top = inTask.getTopActivity(); if (top != null &amp;&amp; top.realActivity.equals(r.realActivity) &amp;&amp; top.userId == r.userId) &#123; if ((launchFlags &amp; Intent.FLAG_ACTIVITY_SINGLE_TOP) != 0 || launchSingleTop || launchSingleTask) &#123; if ((startFlags&amp;ActivityManager.START_FLAG_ONLY_IF_NEEDED) != 0) &#123; return ActivityManager.START_RETURN_INTENT_TO_CALLER; &#125; //触发onNewIntent() top.deliverNewIntentLocked(callingUid, r.intent, r.launchedFromPackage); return ActivityManager.START_DELIVERED_TO_TOP; &#125; &#125; if (!addingToTask) &#123; ActivityOptions.abort(options); return ActivityManager.START_TASK_TO_FRONT; &#125; r.setTask(inTask, null); &#125; else &#123; targetStack = computeStackFocus(r, newTask); targetStack.moveToFront("addingToTopTask"); ActivityRecord prev = targetStack.topActivity(); r.setTask(prev != null ? prev.task : targetStack.createTaskRecord(getNextTaskId(), r.info, intent, null, null, true), null); mWindowManager.moveTaskToTop(r.task.taskId); &#125; mService.grantUriPermissionFromIntentLocked(callingUid, r.packageName, intent, r.getUriPermissionsLocked(), r.userId); if (sourceRecord != null &amp;&amp; sourceRecord.isRecentsActivity()) &#123; r.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE); &#125; targetStack.mLastPausedActivity = null; //创建activity [见流程2.10] targetStack.startActivityLocked(r, newTask, doResume, keepCurTransition, options); if (!launchTaskBehind) &#123; mService.setFocusedActivityLocked(r, "startedActivity"); &#125; return ActivityManager.START_SUCCESS;&#125; 找到或创建新的Activit所属于的Task对象，之后调用AS.startActivityLocked 2.9.1 Launch Mode先来说说在ActivityInfo.java中定义了4类Launch Mode： LAUNCH_MULTIPLE(standard)：最常见的情形，每次启动Activity都是创建新的Activity; LAUNCH_SINGLE_TOP: 当Task顶部存在同一个Activity则不再重新创建；其余情况同上； LAUNCH_SINGLE_TASK：当Task栈存在同一个Activity(不在task顶部)，则不重新创建，而移除该Activity上面其他的Activity；其余情况同上； LAUNCH_SINGLE_INSTANCE：每个Task只有一个Activity. 再来说说几个常见的flag含义： FLAG_ACTIVITY_NEW_TASK：将Activity放入一个新启动的Task； FLAG_ACTIVITY_CLEAR_TASK：启动Activity时，将目标Activity关联的Task清除，再启动新Task，将该Activity放入该Task。该flags跟FLAG_ACTIVITY_NEW_TASK配合使用。 FLAG_ACTIVITY_CLEAR_TOP：启动非栈顶Activity时，先清除该Activity之上的Activity。例如Task已有A、B、C3个Activity，启动A，则清除B，C。类似于SingleTop。 最后再说说：设置FLAG_ACTIVITY_NEW_TASK的几个情况： 调用者并不是Activity context； 调用者activity带有single instance； 目标activity带有single instance或者single task； 调用者处于finishing状态； 2.10 AS.startActivityLocked[-&gt; ActivityStack.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120final void startActivityLocked(ActivityRecord r, boolean newTask, boolean doResume, boolean keepCurTransition, Bundle options) &#123; TaskRecord rTask = r.task; final int taskId = rTask.taskId; if (!r.mLaunchTaskBehind &amp;&amp; (taskForIdLocked(taskId) == null || newTask)) &#123; //task中的上一个activity已被移除，或者ams重用该task,则将该task移到顶部 insertTaskAtTop(rTask, r); mWindowManager.moveTaskToTop(taskId); &#125; TaskRecord task = null; if (!newTask) &#123; boolean startIt = true; for (int taskNdx = mTaskHistory.size() - 1; taskNdx &gt;= 0; --taskNdx) &#123; task = mTaskHistory.get(taskNdx); if (task.getTopActivity() == null) &#123; //该task所有activity都finishing continue; &#125; if (task == r.task) &#123; if (!startIt) &#123; task.addActivityToTop(r); r.putInHistory(); mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); ActivityOptions.abort(options); return; &#125; break; &#125; else if (task.numFullscreen &gt; 0) &#123; startIt = false; &#125; &#125; &#125; if (task == r.task &amp;&amp; mTaskHistory.indexOf(task) != (mTaskHistory.size() - 1)) &#123; mStackSupervisor.mUserLeaving = false; &#125; task = r.task; task.addActivityToTop(r); task.setFrontOfTask(); r.putInHistory(); mActivityTrigger.activityStartTrigger(r.intent, r.info, r.appInfo); if (!isHomeStack() || numActivities() &gt; 0) &#123; //当切换到新的task，或者下一个activity进程目前并没有运行，则 boolean showStartingIcon = newTask; ProcessRecord proc = r.app; if (proc == null) &#123; proc = mService.mProcessNames.get(r.processName, r.info.applicationInfo.uid); &#125; if (proc == null || proc.thread == null) &#123; showStartingIcon = true; &#125; if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_ANIMATION) != 0) &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, keepCurTransition); mNoAnimActivities.add(r); &#125; else &#123; mWindowManager.prepareAppTransition(newTask ? r.mLaunchTaskBehind ? AppTransition.TRANSIT_TASK_OPEN_BEHIND : AppTransition.TRANSIT_TASK_OPEN : AppTransition.TRANSIT_ACTIVITY_OPEN, keepCurTransition); mNoAnimActivities.remove(r); &#125; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); boolean doShow = true; if (newTask) &#123; if ((r.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED) != 0) &#123; resetTaskIfNeededLocked(r, r); doShow = topRunningNonDelayedActivityLocked(null) == r; &#125; &#125; else if (options != null &amp;&amp; new ActivityOptions(options).getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) &#123; doShow = false; &#125; if (r.mLaunchTaskBehind) &#123; mWindowManager.setAppVisibility(r.appToken, true); ensureActivitiesVisibleLocked(null, 0); &#125; else if (SHOW_APP_STARTING_PREVIEW &amp;&amp; doShow) &#123; ActivityRecord prev = mResumedActivity; if (prev != null) &#123; //当前activity所属不同的task if (prev.task != r.task) &#123; prev = null; &#125; //当前activity已经displayed else if (prev.nowVisible) &#123; prev = null; &#125; &#125; mWindowManager.setAppStartingWindow( r.appToken, r.packageName, r.theme, mService.compatibilityInfoForPackageLocked( r.info.applicationInfo), r.nonLocalizedLabel, r.labelRes, r.icon, r.logo, r.windowFlags, prev != null ? prev.appToken : null, showStartingIcon); r.mStartingWindowShown = true; &#125; &#125; else &#123; mWindowManager.addAppToken(task.mActivities.indexOf(r), r.appToken, r.task.taskId, mStackId, r.info.screenOrientation, r.fullscreen, (r.info.flags &amp; ActivityInfo.FLAG_SHOW_FOR_ALL_USERS) != 0, r.userId, r.info.configChanges, task.voiceSession != null, r.mLaunchTaskBehind); ActivityOptions.abort(options); options = null; &#125; if (doResume) &#123; // [见流程2.11] mStackSupervisor.resumeTopActivitiesLocked(this, r, options); &#125;&#125; 2.11 ASS.resumeTopActivitiesLocked1234567891011121314151617181920212223242526boolean resumeTopActivitiesLocked(ActivityStack targetStack, ActivityRecord target, Bundle targetOptions) &#123; if (targetStack == null) &#123; targetStack = mFocusedStack; &#125; boolean result = false; if (isFrontStack(targetStack)) &#123; //[见流程2.12] result = targetStack.resumeTopActivityLocked(target, targetOptions); &#125; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; final ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (stack == targetStack) &#123; //上面刚已启动 continue; &#125; if (isFrontStack(stack)) &#123; stack.resumeTopActivityLocked(null); &#125; &#125; &#125; return result;&#125; 2.12 AS.resumeTopActivityLocked12345678910111213141516171819final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; return false; //防止递归启动 &#125; boolean result = false; try &#123; mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; //[见流程2.13] result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; inResumeTopActivity用于保证每次只有一个Activity执行resumeTopActivityLocked()操作. 2.13 AS.resumeTopActivityInnerLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276private boolean resumeTopActivityInnerLocked(ActivityRecord prev, Bundle options) &#123; ... //系统没有进入booting或booted状态，则不允许启动Activity ActivityRecord parent = mActivityContainer.mParentActivity; if ((parent != null &amp;&amp; parent.state != ActivityState.RESUMED) || !mActivityContainer.isAttachedLocked()) &#123; return false; &#125; //top running之后的任意处于初始化状态且有显示StartingWindow, 则移除StartingWindow cancelInitializingActivities(); //找到第一个没有finishing的栈顶activity final ActivityRecord next = topRunningActivityLocked(null); final boolean userLeaving = mStackSupervisor.mUserLeaving; mStackSupervisor.mUserLeaving = false; final TaskRecord prevTask = prev != null ? prev.task : null; if (next == null) &#123; final String reason = "noMoreActivities"; if (!mFullscreen) &#123; //当该栈没有全屏，则尝试聚焦到下一个可见的stack final ActivityStack stack = getNextVisibleStackLocked(); if (adjustFocusToNextVisibleStackLocked(stack, reason)) &#123; return mStackSupervisor.resumeTopActivitiesLocked(stack, prev, null); &#125; &#125; ActivityOptions.abort(options); final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ? HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo(); //启动home桌面activity return isOnHomeDisplay() &amp;&amp; mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, reason); &#125; next.delayedResume = false; if (mResumedActivity == next &amp;&amp; next.state == ActivityState.RESUMED &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123; mWindowManager.executeAppTransition(); mNoAnimActivities.clear(); ActivityOptions.abort(options); return false; &#125; final TaskRecord nextTask = next.task; if (prevTask != null &amp;&amp; prevTask.stack == this &amp;&amp; prevTask.isOverHomeStack() &amp;&amp; prev.finishing &amp;&amp; prev.frontOfTask) &#123; if (prevTask == nextTask) &#123; prevTask.setFrontOfTask(); &#125; else if (prevTask != topTask()) &#123; final int taskNdx = mTaskHistory.indexOf(prevTask) + 1; mTaskHistory.get(taskNdx).setTaskToReturnTo(HOME_ACTIVITY_TYPE); &#125; else if (!isOnHomeDisplay()) &#123; return false; &#125; else if (!isHomeStack())&#123; final int returnTaskType = prevTask == null || !prevTask.isOverHomeStack() ? HOME_ACTIVITY_TYPE : prevTask.getTaskToReturnTo(); return isOnHomeDisplay() &amp;&amp; mStackSupervisor.resumeHomeStackTask(returnTaskType, prev, "prevFinished"); &#125; &#125; //处于睡眠或者关机状态，top activity已暂停的情况下 if (mService.isSleepingOrShuttingDown() &amp;&amp; mLastPausedActivity == next &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123; mWindowManager.executeAppTransition(); mNoAnimActivities.clear(); ActivityOptions.abort(options); return false; &#125; if (mService.mStartedUsers.get(next.userId) == null) &#123; return false; //拥有该activity的用户没有启动则直接返回 &#125; mStackSupervisor.mStoppingActivities.remove(next); mStackSupervisor.mGoingToSleepActivities.remove(next); next.sleeping = false; mStackSupervisor.mWaitingVisibleActivities.remove(next); mActivityTrigger.activityResumeTrigger(next.intent, next.info, next.appInfo); if (!mStackSupervisor.allPausedActivitiesComplete()) &#123; return false; //当正处于暂停activity，则直接返回 &#125; mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid); //需要等待暂停当前activity完成，再resume top activity boolean dontWaitForPause = (next.info.flags&amp;ActivityInfo.FLAG_RESUME_WHILE_PAUSING) != 0; //暂停其他Activity[见小节2.13.1] boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, true, dontWaitForPause); if (mResumedActivity != null) &#123; //当前resumd状态activity不为空，则需要先暂停该Activity pausing |= startPausingLocked(userLeaving, false, true, dontWaitForPause); &#125; if (pausing) &#123; if (next.app != null &amp;&amp; next.app.thread != null) &#123; mService.updateLruProcessLocked(next.app, true, null); &#125; return true; &#125; if (mService.isSleeping() &amp;&amp; mLastNoHistoryActivity != null &amp;&amp; !mLastNoHistoryActivity.finishing) &#123; requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED, null, "resume-no-history", false); mLastNoHistoryActivity = null; &#125; if (prev != null &amp;&amp; prev != next) &#123; if (!mStackSupervisor.mWaitingVisibleActivities.contains(prev) &amp;&amp; next != null &amp;&amp; !next.nowVisible) &#123; mStackSupervisor.mWaitingVisibleActivities.add(prev); &#125; else &#123; if (prev.finishing) &#123; mWindowManager.setAppVisibility(prev.appToken, false); &#125; &#125; &#125; AppGlobals.getPackageManager().setPackageStoppedState( next.packageName, false, next.userId); boolean anim = true; if (mIsAnimationBoostEnabled == true &amp;&amp; mPerf == null) &#123; mPerf = new BoostFramework(); &#125; if (prev != null) &#123; if (prev.finishing) &#123; if (mNoAnimActivities.contains(prev)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_CLOSE : AppTransition.TRANSIT_TASK_CLOSE, false); if(prev.task != next.task &amp;&amp; mPerf != null) &#123; mPerf.perfLockAcquire(aBoostTimeOut, aBoostParamVal); &#125; &#125; mWindowManager.setAppWillBeHidden(prev.appToken); mWindowManager.setAppVisibility(prev.appToken, false); &#125; else &#123; if (mNoAnimActivities.contains(next)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(prev.task == next.task ? AppTransition.TRANSIT_ACTIVITY_OPEN : next.mLaunchTaskBehind ? AppTransition.TRANSIT_TASK_OPEN_BEHIND : AppTransition.TRANSIT_TASK_OPEN, false); if(prev.task != next.task &amp;&amp; mPerf != null) &#123; mPerf.perfLockAcquire(aBoostTimeOut, aBoostParamVal); &#125; &#125; &#125; &#125; else &#123; if (mNoAnimActivities.contains(next)) &#123; anim = false; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_NONE, false); &#125; else &#123; mWindowManager.prepareAppTransition(AppTransition.TRANSIT_ACTIVITY_OPEN, false); &#125; &#125; Bundle resumeAnimOptions = null; if (anim) &#123; ActivityOptions opts = next.getOptionsForTargetActivityLocked(); if (opts != null) &#123; resumeAnimOptions = opts.toBundle(); &#125; next.applyOptionsLocked(); &#125; else &#123; next.clearOptionsLocked(); &#125; ActivityStack lastStack = mStackSupervisor.getLastStack(); //进程已存在的情况 if (next.app != null &amp;&amp; next.app.thread != null) &#123; //activity正在成为可见 mWindowManager.setAppVisibility(next.appToken, true); next.startLaunchTickingLocked(); ActivityRecord lastResumedActivity = lastStack == null ? null :lastStack.mResumedActivity; ActivityState lastState = next.state; mService.updateCpuStats(); //设置Activity状态为resumed next.state = ActivityState.RESUMED; mResumedActivity = next; next.task.touchActiveTime(); mRecentTasks.addLocked(next.task); mService.updateLruProcessLocked(next.app, true, null); updateLRUListLocked(next); mService.updateOomAdjLocked(); boolean notUpdated = true; if (mStackSupervisor.isFrontStack(this)) &#123; Configuration config = mWindowManager.updateOrientationFromAppTokens( mService.mConfiguration, next.mayFreezeScreenLocked(next.app) ? next.appToken : null); if (config != null) &#123; next.frozenBeforeDestroy = true; &#125; notUpdated = !mService.updateConfigurationLocked(config, next, false, false); &#125; if (notUpdated) &#123; ActivityRecord nextNext = topRunningActivityLocked(null); if (nextNext != next) &#123; mStackSupervisor.scheduleResumeTopActivities(); &#125; if (mStackSupervisor.reportResumedActivityLocked(next)) &#123; mNoAnimActivities.clear(); return true; &#125; return false; &#125; try &#123; //分发所有pending结果. ArrayList&lt;ResultInfo&gt; a = next.results; if (a != null) &#123; final int N = a.size(); if (!next.finishing &amp;&amp; N &gt; 0) &#123; next.app.thread.scheduleSendResult(next.appToken, a); &#125; &#125; if (next.newIntents != null) &#123; next.app.thread.scheduleNewIntent(next.newIntents, next.appToken); &#125; next.sleeping = false; mService.showAskCompatModeDialogLocked(next); next.app.pendingUiClean = true; next.app.forceProcessStateUpTo(mService.mTopProcessState); next.clearOptionsLocked(); //触发onResume() next.app.thread.scheduleResumeActivity(next.appToken, next.app.repProcState, mService.isNextTransitionForward(), resumeAnimOptions); mStackSupervisor.checkReadyForSleepLocked(); &#125; catch (Exception e) &#123; ... return true; &#125; next.visible = true; completeResumeLocked(next); next.stopped = false; &#125; else &#123; if (!next.hasBeenLaunched) &#123; next.hasBeenLaunched = true; &#125; else &#123; if (SHOW_APP_STARTING_PREVIEW) &#123; mWindowManager.setAppStartingWindow( next.appToken, next.packageName, next.theme, mService.compatibilityInfoForPackageLocked( next.info.applicationInfo), next.nonLocalizedLabel, next.labelRes, next.icon, next.logo, next.windowFlags, null, true); &#125; &#125; mStackSupervisor.startSpecificActivityLocked(next, true, true); &#125; return true;&#125; 主要分支功能： 当找不到需要resume的Activity，则直接回到桌面； 否则，当mResumedActivity不为空，则执行startPausingLocked()暂停该activity; 然后再进入startSpecificActivityLocked环节，接下来从这里继续往下说。 2.13.1 ASS.pauseBackStacks123456789101112131415boolean pauseBackStacks(boolean userLeaving, boolean resuming, boolean dontWait) &#123; boolean someActivityPaused = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack) &amp;&amp; stack.mResumedActivity != null) &#123; //[见小节2.13.2] someActivityPaused |= stack.startPausingLocked(userLeaving, false, resuming, dontWait); &#125; &#125; &#125; return someActivityPaused;&#125; 暂停所有处于后台栈的所有Activity。 2.13.2 AS.startPausingLocked12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final boolean startPausingLocked(boolean userLeaving, boolean uiSleeping, boolean resuming, boolean dontWait) &#123; if (mPausingActivity != null) &#123; if (!mService.isSleeping()) &#123; completePauseLocked(false); &#125; &#125; ActivityRecord prev = mResumedActivity; ... if (mActivityContainer.mParentActivity == null) &#123; //暂停所有子栈的Activity mStackSupervisor.pauseChildStacks(prev, userLeaving, uiSleeping, resuming, dontWait); &#125; ... final ActivityRecord next = mStackSupervisor.topRunningActivityLocked(); if (prev.app != null &amp;&amp; prev.app.thread != null) &#123; EventLog.writeEvent(EventLogTags.AM_PAUSE_ACTIVITY, prev.userId, System.identityHashCode(prev), prev.shortComponentName); mService.updateUsageStats(prev, false); //暂停目标Activity prev.app.thread.schedulePauseActivity(prev.appToken, prev.finishing, userLeaving, prev.configChangeFlags, dontWait); &#125;else &#123; ... &#125; if (!uiSleeping &amp;&amp; !mService.isSleepingOrShuttingDown()) &#123; mStackSupervisor.acquireLaunchWakelock(); //申请wakelock &#125; if (mPausingActivity != null) &#123; if (!uiSleeping) &#123; prev.pauseKeyDispatchingLocked(); &#125; if (dontWait) &#123; completePauseLocked(false); return false; &#125; else &#123; Message msg = mHandler.obtainMessage(PAUSE_TIMEOUT_MSG); msg.obj = prev; prev.pauseTime = SystemClock.uptimeMillis(); //500ms后，执行暂停超时的消息 mHandler.sendMessageDelayed(msg, PAUSE_TIMEOUT); return true; &#125; &#125; else &#123; if (!resuming) &#123; //调度暂停失败，则认为已暂停完成，开始执行resume操作 mStackSupervisor.getFocusedStack().resumeTopActivityLocked(null); &#125; return false; &#125; 该方法中，下一步通过Binder调用，进入acitivity所在进程来执行schedulePauseActivity()操作。 接下来，对于dontWait=true则执行执行completePauseLocked，否则等待app通知或许500ms超时再执行该方法。 3.13.3 completePauseLocked2.14 ASS.startSpecificActivityLocked1234567891011121314151617181920212223242526void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !"android".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; //真正的启动Activity【见流程2.17】 realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; &#125; //当进程不存在则创建进程 [见流程2.14.1] mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true);&#125; 2.15 AMS.startProcessLocked在文章理解Android进程启动之全过程中，详细介绍了AMS.startProcessLocked()整个过程，创建完新进程后会在新进程中调用AMP.attachApplication，该方法经过binder ipc后调用到AMS.attachApplicationLocked。 1234567891011121314private final boolean attachApplicationLocked(IApplicationThread thread, int pid) &#123; ... ////只有当系统启动完，或者app允许启动过程允许，则会true boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); thread.bindApplication(...); if (normalMode) &#123; //【见流程2.16】 if (mStackSupervisor.attachApplicationLocked(app)) &#123; didSomething = true; &#125; &#125; ...&#125; 在执行完bindApplication()之后进入ASS.attachApplicationLocked() 2.16 ASS.attachApplicationLocked123456789101112131415161718192021222324252627282930313233boolean attachApplicationLocked(ProcessRecord app) throws RemoteException &#123; final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) &#123; ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) &#123; final ActivityStack stack = stacks.get(stackNdx); if (!isFrontStack(stack)) &#123; continue; &#125; //获取前台stack中栈顶第一个非finishing的Activity ActivityRecord hr = stack.topRunningActivityLocked(null); if (hr != null) &#123; if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) &#123; try &#123; //真正的启动Activity【见流程2.17】 if (realStartActivityLocked(hr, app, true, true)) &#123; didSomething = true; &#125; &#125; catch (RemoteException e) &#123; throw e; &#125; &#125; &#125; &#125; &#125; if (!didSomething) &#123; //启动Activity不成功，则确保有可见的Activity ensureActivitiesVisibleLocked(null, 0); &#125; return didSomething;&#125; 2.17 ASS.realStartActivityLocked123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException &#123; if (andResume) &#123; r.startFreezingScreenLocked(app, 0); mWindowManager.setAppVisibility(r.appToken, true); //调度启动ticks用以收集应用启动慢的信息 r.startLaunchTickingLocked(); &#125; if (checkConfig) &#123; Configuration config = mWindowManager.updateOrientationFromAppTokens( mService.mConfiguration, r.mayFreezeScreenLocked(app) ? r.appToken : null); //更新Configuration mService.updateConfigurationLocked(config, r, false, false); &#125; r.app = app; app.waitingToKill = null; r.launchCount++; r.lastLaunchTime = SystemClock.uptimeMillis(); int idx = app.activities.indexOf(r); if (idx &lt; 0) &#123; app.activities.add(r); &#125; mService.updateLruProcessLocked(app, true, null); mService.updateOomAdjLocked(); final TaskRecord task = r.task; if (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV) &#123; setLockTaskModeLocked(task, LOCK_TASK_MODE_LOCKED, "mLockTaskAuth==LAUNCHABLE", false); &#125; final ActivityStack stack = task.stack; try &#123; if (app.thread == null) &#123; throw new RemoteException(); &#125; List&lt;ResultInfo&gt; results = null; List&lt;ReferrerIntent&gt; newIntents = null; if (andResume) &#123; results = r.results; newIntents = r.newIntents; &#125; if (r.isHomeActivity() &amp;&amp; r.isNotResolverActivity()) &#123; //home进程是该栈的根进程 mService.mHomeProcess = task.mActivities.get(0).app; &#125; mService.ensurePackageDexOpt(r.intent.getComponent().getPackageName()); ... if (andResume) &#123; app.hasShownUi = true; app.pendingUiClean = true; &#125; //将该进程设置为前台进程PROCESS_STATE_TOP app.forceProcessStateUpTo(mService.mTopProcessState); //【见流程2.18】 app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(stack.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); if ((app.info.privateFlags&amp;ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != 0) &#123; ... //处理heavy-weight进程 &#125; &#125; catch (RemoteException e) &#123; if (r.launchFailed) &#123; //第二次启动失败，则结束该activity mService.appDiedLocked(app); stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, null, "2nd-crash", false); return false; &#125; //这是第一个启动失败，则重启进程 app.activities.remove(r); throw e; &#125; //将该进程加入到mLRUActivities队列顶部 stack.updateLRUListLocked(r)； if (andResume) &#123; //启动过程的一部分 stack.minimalResumeActivityLocked(r); &#125; else &#123; r.state = STOPPED; r.stopped = true; &#125; if (isFrontStack(stack)) &#123; //当系统发生更新时，只会执行一次的用户向导 mService.startSetupActivityLocked(); &#125; //更新所有与该Activity具有绑定关系的Service连接 mService.mServices.updateServiceConnectionActivitiesLocked(r.app); return true;&#125; 2.18 ATP.scheduleLaunchActivity[-&gt; ApplicationThreadProxy.java] 1234567891011121314151617181920212223242526272829303132333435public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) throws RemoteException &#123; Parcel data = Parcel.obtain(); data.writeInterfaceToken(IApplicationThread.descriptor); intent.writeToParcel(data, 0); data.writeStrongBinder(token); data.writeInt(ident); info.writeToParcel(data, 0); curConfig.writeToParcel(data, 0); if (overrideConfig != null) &#123; data.writeInt(1); overrideConfig.writeToParcel(data, 0); &#125; else &#123; data.writeInt(0); &#125; compatInfo.writeToParcel(data, 0); data.writeString(referrer); data.writeStrongBinder(voiceInteractor != null ? voiceInteractor.asBinder() : null); data.writeInt(procState); data.writeBundle(state); data.writePersistableBundle(persistentState); data.writeTypedList(pendingResults); data.writeTypedList(pendingNewIntents); data.writeInt(notResumed ? 1 : 0); data.writeInt(isForward ? 1 : 0); if (profilerInfo != null) &#123; data.writeInt(1); profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE); &#125; else &#123; data.writeInt(0); &#125; //【见流程2.19】 mRemote.transact(SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION, data, null, IBinder.FLAG_ONEWAY); data.recycle(); &#125; 2.19 ATN.onTransact[-&gt; ApplicationThreadNative.java] 123456789101112131415161718192021222324252627282930313233343536public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case SCHEDULE_LAUNCH_ACTIVITY_TRANSACTION: &#123; data.enforceInterface(IApplicationThread.descriptor); Intent intent = Intent.CREATOR.createFromParcel(data); IBinder b = data.readStrongBinder(); int ident = data.readInt(); ActivityInfo info = ActivityInfo.CREATOR.createFromParcel(data); Configuration curConfig = Configuration.CREATOR.createFromParcel(data); Configuration overrideConfig = null; if (data.readInt() != 0) &#123; overrideConfig = Configuration.CREATOR.createFromParcel(data); &#125; CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data); String referrer = data.readString(); IVoiceInteractor voiceInteractor = IVoiceInteractor.Stub.asInterface( data.readStrongBinder()); int procState = data.readInt(); Bundle state = data.readBundle(); PersistableBundle persistentState = data.readPersistableBundle(); List&lt;ResultInfo&gt; ri = data.createTypedArrayList(ResultInfo.CREATOR); List&lt;ReferrerIntent&gt; pi = data.createTypedArrayList(ReferrerIntent.CREATOR); boolean notResumed = data.readInt() != 0; boolean isForward = data.readInt() != 0; ProfilerInfo profilerInfo = data.readInt() != 0 ? ProfilerInfo.CREATOR.createFromParcel(data) : null; //【见流程2.20】 scheduleLaunchActivity(intent, b, ident, info, curConfig, overrideConfig, compatInfo, referrer, voiceInteractor, procState, state, persistentState, ri, pi, notResumed, isForward, profilerInfo); return true; &#125; ... &#125;&#125; 2.20 AT.scheduleLaunchActivity[-&gt; ApplicationThread.java] 1234567891011121314151617181920212223242526272829public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); //【见流程2.21】 sendMessage(H.LAUNCH_ACTIVITY, r); &#125; 2.21 H.handleMessage[-&gt; ActivityThread.java ::H] 123456789101112public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); //【见流程2.22】 handleLaunchActivity(r, null); &#125; break; ... &#125;&#125; 2.22 ActivityThread.handleLaunchActivity[-&gt; ActivityThread.java] 12345678910111213141516171819202122232425262728private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; unscheduleGcIdler(); mSomeActivitiesChanged = true; //最终回调目标Activity的onConfigurationChanged() handleConfigurationChanged(null, null); //初始化wms WindowManagerGlobal.initialize(); //最终回调目标Activity的onCreate[见流程2.23] Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //最终回调目标Activity的onStart,onResume. handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnPause(r.activity); r.paused = true; &#125; &#125; else &#123; //存在error则停止该Activity ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, false); &#125;&#125; 2.23 ActivityThread.performLaunchActivity[-&gt; ActivityThread.java] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; ... &#125; try &#123; //创建Application对象 Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; ... r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; ... &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (Exception e) &#123; ... &#125; return activity;&#125; 到此，正式进入了Activity的onCreate, onStart, onResume这些生命周期的过程。 三. 总结本文详细startActivity的整个启动流程， 流程[2.1 ~2.4]:运行在调用者所在进程，比如从桌面启动Activity，则调用者所在进程为launcher进程，launcher进程利用ActivityManagerProxy作为Binder Client，进入system_server进程(AMS相应的Server端)。 流程[2.5 ~2.18]:运行在system_server系统进程，整个过程最为复杂、核心的过程，下面其中部分步骤：流程[2.7]：会调用到resolveActivity()，借助PackageManager来查询系统中所有符合要求的Activity，当存在多个满足条件的Activity则会弹框让用户来选择;流程[2.8]：创建ActivityRecord对象，并检查是否运行App切换，然后再处理mPendingActivityLaunches中的activity;流程[2.9]：为Activity找到或创建新的Task对象，设置flags信息；流程[2.13]：当没有处于非finishing状态的Activity，则直接回到桌面； 否则，当mResumedActivity不为空则执行startPausingLocked()暂停该activity;然后再进入startSpecificActivityLocked()环节;流程[2.14]：当目标进程已存在则直接进入流程[2.17]，当进程不存在则创建进程，经过层层调用还是会进入流程[2.17];流程[2.17]：system_server进程利用的ATP(Binder Client)，经过Binder，程序接下来进入目标进程。 流程[2.19 ~2.18]:运行在目标进程，通过Handler消息机制，该进程中的Binder线程向主线程发送H.LAUNCH_ACTIVITY，最终会通过反射创建目标Activity，然后进入onCreate()生命周期。 从另一个角度下图来概括： 启动流程： 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求； system_server进程接收到请求后，向zygote进程发送创建进程的请求； Zygote进程fork出新的子进程，即App进程； App进程，通过Binder IPC向sytem_server进程发起attachApplication请求； system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求； App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息； 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 启动Activity较为复杂，后续计划再进一步讲解生命周期过程与系统是如何交互，以及UI渲染过程，敬请期待。]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>ActivityThread</tag>
        <tag>AMS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android的消息机制]]></title>
    <url>%2F2018%2F03%2F13%2FAndroid%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android的消息机制主要指Handler的运行机制, Handler的运行需要底层的MessageQueue和Loopper的支撑. MessageQueue消息机制, 内部存储了一组消息, 以队列的形式对外提供插入和删除工作. 虽然叫消息队列,但是其内部存储结构并不是真正的队列,而是采用单链表的数据结构来存储消息列表. Looper消息循环, 因为MessageQueue本质只是一个消息的存储单元, 它不能去处理消息, 而Looper就是为实现处理而产生的. Looper会以无限循环的形式去查找是否有新消息, 如果有的话就处理消息, 否在就一直等待. Looper中有一个特殊的概念ThreadLocal, ThreadLocal并不是一个线程, 它可以在每个线程中进行数据的存储. 我们使用的Handler创建的时候都会采用当前线程的Looper来构造消息循环系统, 而这个当前线程就是通过ThreadLocal来进行操作的. 有一点需要记住: 一个新的线程默认是没有Looper的, 如果要使用Handler就必为线程创建Looper, 而我们使用主线程的时候之所以不需要创建Looper是因为. UI线程也就是ActivityThread在被创建的时候就会初始化Looper, 所以我们在主线程也就可以直接使用Handler的原因. Android 的消息机制描述在日常开发中如果不小心在子线程更新了UI那么就会抛出异常, 这一步骤是在ViewRootImpl#checkThread()方法完成的. 123456void checkThread() &#123; if (mThread != Thread.currentThread()) &#123; throw new CalledFromWrongThreadException( "Only the original thread that created a view hierarchy can touch its views."); &#125;&#125; 那Handler可以认为是为了在子线程处理完操作可以切回到主线程进行UI操作的用途. 那为什么不能再子线程进行UI处理呢? 这是因为Android的UI线程控件不是线程安全, 如果在多线程中并发的访问可能会导致UI控件处于不可预期的状态, 虽然可以用加锁的形式让上述问题消失, 但是有两个弊端: 加锁机制会让UI访问的逻辑变得复杂 锁机制会降低UI的访问的效率, 因为锁机制会阻塞某些线程的执行. 因为这样, 最简单且高效的方法就是采用单线程模型来处理UI操作. 当Handler, Looper, MessageQueue都准备好之后. 就可以通过Handler#post()方法将一个Runnable投递到Handler内部的Looper中去处理, 也可以通过send()方法来发送一个消息, 这个消息同样会在Looper中处理. 而post()内部也是通过send()来发送的. Android消息机制分析ThreadLocal的工作原理ThreadLocal是一个线程内部的数据存储类, 通过他可以在指定的线程中存储数据. 数据存储以后, 只能在指定线程中可以获取到存储的数据. 而其他线程无法获取. 而Android中的Looper ,ActivityThread, AMS都用到了ThreadLocal. 可以这样来说: 当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候, 可以采用ThreadLocal. 可以自己用三个线程分别对一个ThreadLocal对象进行操作, 虽然操作的是一个对象, 但是每个线程在获取值的时候却不相同. 这是因为: 不同的线程访问同一个ThreadLocal#get()方法的时候, ThreadLocal内部会从各自的线程中取出一个ThreadLocalMap对象, 然后再从Map中根据当前ThreadLocal的索引去查找出对应的value值. 可以看出不同的线程中的ThreadLocalMap是不相同的. 所以也就是为什么使用ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不影响. 还是用源码来梳理流程 ThreadLocal是一个泛型类, 它的定义为public class ThreadLocal&lt;T&gt;, 看一下set()或者get()就明白了. 12345678910111213141516171819//ThreadLocal.javapublic void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;//Thread.java/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; 首先会通过getMap()方法来获取当前线程中的ThreadLocal数据。在Thread类的内部有一个成员专门用于存储线程的ThreadLocal的数据ThreadLocal.ThreadLocalMap threadLocals. 所以对ThreadLocal所做的读写操作仅限于当前线程的对应数据。 在ThreadLocalMap中有一个数组private Entry[] table，ThreadLocal设置的值就存在这个table数组中. 看一下set()方法. 12345678910111213141516171819202122232425262728293031323334353637/*** Set the value associated with key.** @param key the thread local object* @param value the value to be set*/private void set(ThreadLocal key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 这里只说大致的规则, 不需要具体看实现的算法；就是ThreadLocal的值在ThreadLocalMap的table数组中存储的。 接着看get()方法 12345678910public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125; 而ThreadLocal#get()方法, 同样是取出当前线程ThreadLocalMap对象, 接着获取ThreadLocalMap中的Entry[] table数组里的值. 参考: 理解Java中的ThreadLocal 消息队列的工作原理消息队列在android中指的是MessageQueue, MessageQueue主要包含两个操作: 插入和读取. 读取操作本身会伴随着删除的操作, 插入和读取对应的方法分别为enqueueMessage(),next(). 前者就是往消息队列中插入一条消息, 而后者就是取出一条消息并将其从消息队列中消除. 上面说过虽然MessageQueue称为消息队列, 但是内部实现使用的是单链表的数据结构来维护的消息列表. 单链表在插入和删除上比较有优势. 123456789101112131415161718192021222324252627282930313233343536373839404142boolean enqueueMessage(Message msg, long when) &#123;// 省略...synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + " sending message to a Handler on a dead thread"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125;&#125;return true;&#125; 可以看到enqueueMessage的实现主要操作就是单链表的插入操作. 继续看一下next()方法. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091Message next() &#123; final long ptr = mPtr; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // Got a message. mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; if (DEBUG) Log.v(TAG, "Returning message: " + msg); msg.markInUse(); return msg; &#125; &#125; else &#123; // No more messages. nextPollTimeoutMillis = -1; &#125; // Process the quit message now that all pending messages have been handled. if (mQuitting) &#123; dispose(); return null; &#125; if (pendingIdleHandlerCount &lt; 0 &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123; pendingIdleHandlerCount = mIdleHandlers.size(); &#125; if (pendingIdleHandlerCount &lt;= 0) &#123; // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; &#125; if (mPendingIdleHandlers == null) &#123; mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; &#125; mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); &#125; // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123; final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try &#123; keep = idler.queueIdle(); &#125; catch (Throwable t) &#123; Log.wtf(TAG, "IdleHandler threw exception", t); &#125; if (!keep) &#123; synchronized (this) &#123; mIdleHandlers.remove(idler); &#125; &#125; &#125; // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; &#125;&#125; next()是一个无限循环的方法, 如果消息队列中没有消息, 那么next方法会一直阻塞在这里. 当有新消息到来时, next方法会返回这条消息并将其从单链表中移除. Looper的工作原理Looper在Android的消息机制中扮演者消息循环的角色, 具体来说就是他会不停地从MessageQueue中查看是否有新消息. 如果有新消息就会处理. 否则就一直阻塞在那里. 先从构造方法开始, 在构造方法中他会创建一个MessageQueue即消息队列, 然后将当前线程的对象保存起来. 1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();//Looper指定的线程&#125; 构造函数是私有权限, 而内部使用的地方就是Looper#prepare()方法. 123456private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed));&#125; 这也就是为什么在使用Handler之前要有Looper的节奏, 而当调用了Looper.prepare(). 就不会出现异常的原因. Looper除了prepare()方法外, 还提供了prepareMainLooper()方法, 这个方法主要是给主线程也就是ActivityThread创建Looper使用的. 本质也是通过prepare()来实现的. 由于主线程的Looper比较特殊, 所以Looper提供了一个getMainLooper()方法, 通过它可以在任何地方获取到主线程的Looper. Looper的退出: quit(): 这个方法会直接退出Looper quitSafely(): 设定一个退出标记, 然后把消息队列中的已有消息处理完毕后才安全的退出. 如果Looper退出, 通过Handler发送的消息会失败, 这个时候Handler发送的消息会失败, 而Handler#send()方法这个时候回返回false. 在子线程中, 如果手动为其创建了Looper, 那么在所有的事情完成以后应该调用quit()方法来终止消息循环. 否则这个线程会一直处于等待的状态, 而如果退出了Looper以后, 这个线程就会立刻终止. Looper最重要的一个方法loop()方法, 只有调用了loop后, 消息循环系统才会真正的起作用,如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; msg.target.dispatchMessage(msg); if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, "Thread identity changed from 0x" + Long.toHexString(ident) + " to 0x" + Long.toHexString(newIdent) + " while dispatching to " + msg.target.getClass().getName() + " " + msg.callback + " what=" + msg.what); &#125; msg.recycleUnchecked(); &#125;&#125; 首先这个loop()方法是一个死循环, 唯一跳出循环的方式就是MessageQueue#next()方法返回null. 当Looper#quit()被调用时, Looper就会调用MessageQueue#quit()或者quitSafely()方法来通知消息队列退出, 当消息队列被标识为退出状态时, 它的next()方法就会返回null. 也就是说Looper必须退出, 否则loop方法就会无限循环下去. loop()会调用MessageQueue#next()方法来获取新消息. 而next是一个阻塞操作, 当没有消息时, next方法就会一直阻塞在那里. 这也导致loop()会一直阻塞在那里. 如果MessageQueue#next()返回了新消息, Looper就会处理这条消息: msg.target.dispatchMessage(msg), 这里的msg.target是发送这条消息的Handler对象, 这样Handler发送的消息最终又交给它的dispatcherMessage()来处理. 但是这里不同的是, Handler#dispatcherMessage()方法是在创建Handler时所使用的Looper中执行的，这样就成功的将代码逻辑切换到Looper指定的线程中去执行了. Handler的工作原理Handler主要包含消息的发送和接收过程. 消息的发送可以通过post的一系列方法以及send的一系列方法来实现. post的一系列方法最终就是还是通过send方法来实现的. 12345678910public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125; 上面这段代码是Handler#send()系列的最终调用. 可以看出, Handler发送消息的过程仅仅是向消息队列中插入了一条消息, MessageQueue#next()方法就是返回这条消息给Looper, Looper收到消息后就开始处理. 最终消息有Looper交由Handler处理, 即Handler#dispatchMessage()方法会被调用, 这个时候Handler就会进入了处理消息的阶段. 123456789101112public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125; 整理一下: 先检查msg.callback属性是否为null, 不为null就通过handleCallback()来处理消息. msg.callback是一个Runnable接口, 实际上就是post()中传递的Runnable参数. handleCallback()实现如下: 123private static void handleCallback(Message message) &#123; message.callback.run();&#125; 其次检查mCallback是否为null, 不为null就调用mCallback.handleMessage(msg)方法来处理消息. Callback是一个接口, 定义如下: 123public interface Callback &#123; public boolean handleMessage(Message msg);&#125; 通过Callback可以采用如下方式来创建Handler对象: Handler handler = new Handler(callback). 通过源码注释了解: 这个接口可以用来创建一个Handler的实例但并不需要派生Handler的子类并重写其handleMessage方法来处理具体的消息, 而CallBack给我们提供了另外一种方式使用Handler. 当我们不想派生子类时, 就可以通过Callback来实现. 最后, 调用Handler#handleMessage()方法来处理消息. Handler还有一个特殊的构造方法, 那就是通过一个特定的Looper来构造Handler： 123public Handler(Looper looper) &#123; this(looper, null, false);&#125; Handler默认的构造方法public Handler(), 这个构造方法会调用下面的构造函数. 很明显这就是为什么当前线程没有Looper的话, 就会抛出Can&#39;t create handler inside thread that has not called Looper.prepare()这个异常. 123456789101112public Handler(Callback callback, boolean async) &#123; //.... mLooper = Looper.myLooper(); if (mLooper == null) &#123; throw new RuntimeException( "Can't create handler inside thread that has not called Looper.prepare()"); &#125; mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async;&#125; 主线程的消息循环Android的主线程就是ActivityThread, 主程序的入口方法为main(), 在main()中系统通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue, 并通过Looper.loop()来开启主线程的消息循环. 当主线程的消息循环开始以后, ActivityThread还需要一个Handler来和消息队列进行交互, 这个Handler就是ActivityThread.H, 它的内部定义了一组消息类型, 主要包含了四大组件的启动和停止等过程. 12345678910111213141516171819202122232425private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; public static final int SHOW_WINDOW = 105; public static final int HIDE_WINDOW = 106; public static final int RESUME_ACTIVITY = 107; public static final int SEND_RESULT = 108; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int NEW_INTENT = 112; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; public static final int CONFIGURATION_CHANGED = 118; public static final int CLEAN_UP_CONTEXT = 119; public static final int GC_WHEN_IDLE = 120; public static final int BIND_SERVICE = 121; public static final int UNBIND_SERVICE = 122;&#125; ActivityThread通过ApplicationThread和AMS进行进程间通信, AMS以进程间通信的方式完成ActivityThread的请求后回调ApplicationThread中的Binder()方法, 然后ApplicationThread会向H发送消息, H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行, 即切换到主线程去执行, 这个过程就是主线程的消息循环模型.]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Handler</tag>
        <tag>Looper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[艺术探索读书笔记]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[四大组件的工作过程 引用 Android开发艺术探索读书笔记 先说两句，玉刚的书中主要侧重的是过程分析和代码讲解，这样一页一页的翻完之后总有一种意犹未尽却不够清晰的感觉，一开始我依然是用文字list的方式来梳理，后来发现看起来还是有点不够清晰，达不到我想要的效果，所以改了两版后我决定用图 + 文字说明的方式来表现，希望大家可以看得更清晰。注意这里左侧是用UML画的流程图，发现还挺方便的，类中的方法是按照调用顺序排列的，右侧的UML图则是真正的UML图，会标注出一些重要类的结构关系，排除各位看书时看到各种A继承B，B继承C时晕了的感觉。 四大组件概述： Activity的主要作用是展示一个界面并和用户交互，它扮演的是一种前台界面的角色。 Service是一种计算型组件，用于在后台执行一系列计算任务，但因为其本身还是运行在主线程中的，因此耗时的后台计算仍然需要在单独的线程中去完成。 BroadcastReceiver是一种消息型组件，用于在不同的组件乃至不同的应用之间传递消息。广播注册有两种方式，动态注册通过Context.registerReceiver()来实现，必须要应用启动才能注册；静态注册则在AndroidManifest文件中进行，应用安装时会被系统解析，不需要启动应用就可接收广播。 ContentProvider是一种共享型组件，用于向其他组件乃至其他应用共享数据。 ​ Activity的工作过程 注😖 启动Activity的真实实现是由ActivityManagerNative.getDefault().startActivity方法来完成的。 ActivityManagerService（AMS）继承自ActivityManagerNative，而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口，因此AMS也是一个Binder。 AMS这个Binder对象采用单例模式对外提供，第一次调用它的get方法时会通过create方法初始化，后续调用中直接返回之前创建的对象。 从makeApplication的实现可以看出，如果Application已经被创建过了，那么就不会再重复创建，这也意味着一个应用只有一个Application对象。Application的创建也是通过Instrumentation来完成的，这个过程和Activity对象的创建过程一样，都是通过类加载器来实现的。 ContextImpl是Context的具体实现，ContextImpl是通过Activity的attach方法来和Activity建立关联的，在attach方法中Activity还会完成Window的创建并建立自己和Window的关联，这样当Activity接受到事件就可以传递给window了。 ​ Service的工作过程启动过程： 绑定过程注 Service有两种状态：启动状态和绑定状态，两种状态是可以共存的。 BroadcastReceiver的工作过程BroadcastReceiver的工作过程包括广播注册过程、广播发送和接收过程。 动态注册 广播发送和接收 注： 静态注册是由PackageManagerService（PMS）在应用安装的时候完成整个注册过程的，除广播以外，其他三大组件也都是在应用安装时由PMS解析并注册的。 广播的发送有几种类型：普通广播、有序广播和粘性广播，有序广播和粘性广播与普通广播相比具有不同的特性，但是发送和接收过程是类似的。 FLAG_INCLUDE_STOPPED_PACKAGES:广播会发送给已经停止的应用，FLAG_EXCLUDE_STOPPED_PACKAGES广播不会发送给已经停止的应用 从Android 3.1开始，处于停止状态的应用无法接受到开机广播。 ContentProvider启动过程 当ContentProvider所在的进程启动时，会同时被启动并被发布到AMS中，需要注意的是，这个时候它的onCreate要先去Application的onCreate执行，这在四大组件中是一个少有的现象。 用启动的入口为ActivityThread的main方法，main方法会创建ActivityThread实例并创建主线程消息队列。 attach方法中远程调用AMS的attachApplication方法，并提供ApplicationThread用于和AMS的通信。 attachApplication方法会通过bindApplication方法和H来ActivityThread的handleBindApplication，这个方法会先创建Application，再加载ContentProvider，然后才会回调Application的onCreate方法。 ContentProvider的multiprocess属性决定了ContentProvider是否是单例（false时），一般都用单例。 ontentResolver的具体类是ApplicationContentResolver，当ContentProvider所在进程未启动时，第一次访问它会触发ContentProvider的创建以及进程启动。 Query流程 insert，delete和update方法类似，这里就不在分析了。 Android的消息机制 三大件：Hanlder，MessageQueue，Looper。 MessageQueue内部的数据结构并非队列，而是单链表，它只是用来存储数据。 Looper是真正的数据处理者，线程默认没有Looper，使用Handler必须为线程创建Looper，UI线程也就是ActivityThread创建时会初始化Looper，所以主线程中默认可以直接使用Handler。 UI线程检查当前线程的操作在ViewRootImpl的checkThread方法中，我们常见的不能在子线程中访问view的异常就是在这里抛出的。 不允许子线程访问主线程的原因是UI控件不是线程安全的，而加锁又会导致UI的操作过于复杂。 Handler的工作过程，图（page374），我简单概括一下就是：假设创建Handler的线程是A，耗时操作的线程是B，B线程中拿到handler实例发送消息或者post一个Runnable，实际是调用了MessageQueue的enqueueMessage方法，进入了消息队列，线程A中的Looper发现了这个消息，就会处理这个消息，也就是消息中的Runnable或者handler的handleMessage方法会被调用，这样handler中的业务逻辑就被切换到线程A中去了。 ThreadLocal我用一句大白话来讲解，就是看上去只new了一份，但在每个不同的线程中却可以拥有不同数据副本的神奇类。其本质是ThreadLocal中的Values类维护了一个Object[]，而每个Thread类中有一个ThreadLocal.Values成员，当调用ThreadLocal的set方法时，其实是根据一定规则把这个线程中对应的ThreadLocal值塞进了Values的Object[]数组中的某个index里。这个index总是为ThreadLocal的reference字段所标识的对象的下一个位置。 MessageQueue的工作原理：主要方法为enqueueMessage和next。a. enqueueMessag主要就是一个单链表的插入操作，b. next方法是一个无限循环，如果消息队列中没有消息，next方法就阻塞，有新消息到来时，next方法会返回这条消息并将其从单链表中删除。 Looper的工作原理：a. prepare方法，为当前没有Looper的线程创建Looper。b. prepareMainLooper和getMainLooper方法用于创建和获取ActivityThread的Looper。c. quit和quitSafely方法，前者立即退出，后者只是设定一个标记，当消息队列中的所有消息处理完毕后会才安全退出。子线程中创建的Looper建议不需要的时候都要手动终止。d. loop方法，死循环，阻塞获取msg并丢给msg.target.dispatchMessage方法去处理，这里的target就是handler。 Handler的工作原理：a. 无论sendMessage还是post最终都是调用的sendMessageAtTime方法。b. 发送消息其实就是把一条消息通过MessageQueue的enqueueMessage方法加入消息队列，Looper收到消息就会调用handler的dispatchMessage方法。它的处理过程参考书page388的流程图，一看就懂～c. 这里我补充一个东西，当我们直接Handler h = new Handler()时，本质调用的是Handler(Callback callback, Boolean async)构造方法，这个方法里会调用Looper.myLooper()方法，这个方法其实就是返回的ThreadLocal里保存的当前线程的Looper，这也就解释了为什么我们在主线程中这样new没有问题，子线程中如果不先Looper.prepare会抛出异常的原因，前面多次说了，因为ActivityThread会在初始化的时候创建自己的Looper。 主线程的消息循环： Window和WindowManager 一些基础知识： Window的实现类是PhoneWindow。 Window的具体实现位于WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。 Window实际是View的直接管理者。 常用的WindowManager.LayoutParams的Flag和Type1） FLAG： FLAG_NOT_FOCUSABLE，当前Window不获取焦点，也不接收各种输入事件，会同时启用FLAG_NOT_TOUCH_MODAL，事件会传递给下层具有焦点的Window。 FLAG_NOT_TOUCH_MODAL，当前Window区域外的单击事件传递给底层，区域内的单击事件自己处理，一般都需要开启。 FLAG_SHOW_WHEN_LOCKED，可以让Window显示在锁屏界面上。 2） Type： 应用Window，一般对应一个Activity。层级范围1～99。 子Window，不能单独存在，需要特定的父Window，比如一般的Dialog。层级范围1000～1999。 系统Window，需要权限声明，比如Toast。层级范围2000～2999。一般可以选用WindowManager.LayoutParams.TYPE_SYSTEM_ERROR，同时声明权限。 3） WindowManager提供的功能：addView，updateViewLayout，removeView Window的内部机制：Window并不实际存在，以View的形式存在。每个Window对应着一个View和ViewRootImpl，Window和View通过ViewRootImpl建立联系。所以在实际使用中其实我们并不能访问到真正的Window，而只能通过WindowManager。1） 几个重要的window类的关系（发现主席不大爱画UML，我就代工了）2） Window的添加过程 WindowManagerGlobal中的addView： 检查参数是否合法； 如果子Window还需要调节布局参数； 创建ViewRootImpl并将View添加到列表中； 通过ViewRootImpl的setView来更新界面并完成Window的添加过程：requestLayout中的scheduleTraversals是View绘制的入口，最终通过WindowSession来完成Window的添加过程，注意其实这里是个IPC过程，最终会通过WindowManagerService的addWindow方法来实现Window的添加。 3） Window的删除过程 WinodwManagerGlobal中的removeView； findViewLocked来查找待删除待View的索引，再调用removeViewLocked来做进一步删除； removeViewLocked通过ViewRootImpl的die方法来完成删除操作，包括同步和异步两种方式，同步方式可能会导致意外的错误，不推荐，一般使用异步的方式，其实就是通过handler发送了一个删除请求，将View添加到mDyingViews中； die方法本质调用了doDie方法，真正删除View的逻辑在该方法的dispatchDetachedFromWindow方法中，主要做了四件事：垃圾回收，通过Session的remove方法删除Window，调用View的dispatchDetachedFromWindow方法同时会回调View的onDetachedFromWindow以及onDetachedFromWindowInternal，调用WindowManagerGlobal的doRemoveView刷新数据。 4） Window的更新过程WindowManagerGlobal的updateViewLayout；更新View的LayoutParams；更新ViewImple的LayoutParams，实现对View的重新测量，布局，重绘；通过WindowSession更新Window的视图，WindowManagerService.relayoutWindow()。 Window的创建过程1） Activity Activity的attach方法中，系统会创建Activity所属的Window并为其设置回调； Window对象的创建通过PolicyManager的makeNewWindow方法； Window的具体实现是PhoneWindow类； Window创建好之后，通过PhoneWindow的setContentView将Activity与Window进行关联，这个方法大致步骤： a. 如果没有DecorView就创建，id是android.R.id.content；b. 将Activity设置的ContentView设置到DecorView的mContentParent中；c. 回调Activity的onContentChanged方法通知Activity视图已经发生改变；d. Activity onResume的时候会调用Activity的makeVisible方法真正完成DecorView的添加和显示。 2） Dialog a. 通过PolicyManager的makeNewWindow方法创建Window； b. 初始化DecorView，和Activity类似； c. Dialog的show方法中，通过WindowManager将DecorView添加到Window中； d. Dialog关闭时，会通过WindowManager来移除DecorView，方法为removeViewImmediate(mDecor)； e. 想要创建一个使用application context的Dialog可按照本章2-2的方法设置，dialog.getWindow.setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR)，记得在manifest中设置权限。 ​ 3） Toast a. Toast内部有两类IPC：Toast访问NotificationManagerService；NotificationManagerService（下文简称NMS）访问Toast的TN接口； b. Toast属于系统Window，内部视图mNextView一种为系统默认样式，另一种通过setView方法来指定一个自定义View。 c. TN是一个Binder类，NMS处理Toast的显示隐藏请求时会跨进程回调TN中的方法，所以TN运行在Binder线程池中，所以需要handler切换到当前发送Toast请求的线程中，也就是说没有Looper的线程是无法弹出Toast的。 d. Toast的show方法调用了NMS的enqueueToast方法，该方法先将Toast请求封装成ToastRecord并丢入mToastQueue队列中（非系统应用最多塞50个）。 e. NMS通过showNextToastLocked方法来显示当前View，Toast显示由ToastRecord的callback方法中的show方法完成，callback其实就是TN对象的远程Binder，所以最终调用的是TN中的方法，并运行在发起Toast请求应用的Binder线程池中。 f. 显示以后，NMS通过scheduleTimeoutLocked方法发送延时消息，延时后NMS通过cancelToastLocked方法来隐藏Toast并从队列中移除，隐藏依然通过ToastRecord的callback中的hide方法实现。 g. callback回调TN的show和hide方法后，会通过handler发送两个Runnable，里面的handleShow和handleHide方法是真正完成显示和隐藏Toast的地方。handleShow方法中将Toast的视图添加到Window中，handleHide方法将Toast视图从Window中移除。]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>四大组件UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[四大组件的工作过程]]></title>
    <url>%2F2018%2F03%2F09%2F%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[四大组件的运行状态四大组件中除了BroadcastReceiver以外, 其余的三种组件都必须在AndroidManifest中注册, 对于BroadcastReceiver来说, 既可以在清单文件中注册, 也可以通过代码来注册. 在调用形式上除了ContentProvider不需要借助Intent. 其余的三大组件都需要Intent Activity是一种展示型组件, 用于向用户直接地展示一个界面, 并且可以接收用户的输入信息从而进行交互. Activity是最重要的一种组件, 对于用户来说它就是应用的全部, 因为其他三大组件对用户来说是无法感知的. Activity的启动由Intent触发, 其中Intent可以分为显式和隐式. 显式Intent可以明确的指向一个Activity, 而隐式Intent则指向一个或者多个Activity组件. 或者是没有Activity组件可以处理这个隐式的Intent. 一个Activity具有特定的启动模式. 也可以通过finish来停止. 总结来说, Activity组件的主要作用是展示一个界面并和用户交互, 它扮演的是一种前台界面的角色. Service是一种计算型组件, 用于后台执行一系列计算任务. 运行在后台,用户是无法感知的. Service和Activity的不同: Activity组件只有一种运行模式,即Activity处于启动状态, 但是Service组件有两种状态: 启动状态和绑定状态. 当Service处于启动状态时, 这个时候Service内部可以做一些后台计算. 尽管Service组件是用于执行后台计算的, 但是它本身是运行在主线程的. 因此单独的耗时操作仍然需要单独的线程去执行. 当Service处于绑定状态时, 内部同样可以进行后台计算, 但是处于这种状态时, 外界可以很方便的和Service组件进行通信. Service可以停止, 需要灵活采用stopService和unBindService BroadcastReceiver是一种消息型组件, 用于在不同的组件乃至不同的应用之间传递消息. 同样无法被用户感知, 因为是运行在系统内部, 广播的注册方式有两种:静态注册和动态注册 静态注册: 在清单文件中进行注册广播, 这种广播在应用安装时会被系统解析, 此种形式的广播不需要应用启动就可以接收到相应的广播. 动态注册: 需要通过Context.registerReceiver()来实现, 并在不需要的时候通过Context.unRegisterReceiver()来解除广播. 此种形态的广播要应用启动才能注册和接收广播. 在实际开发中通过Context的一系列的send方法来发送广播, 被发送的广播会被系统发送给感兴趣的广播接收者, 发送和接收的过程的匹配是通过广播接收者的&lt;intent-filter&gt;来描述的. 可以实现低耦合的观察者模式, 观察者和被观察者之间可以没有任何耦合. 但广播不适合来做耗时操作. ContentProvider是一种数据共享组件, 用于向其他组件乃至其他应用共享数据. 无法被用户感知. 对于内容提供者来说, 它只需要实现增删改查四种基本操作, 在它内部维持着一份数据集合, 这个数据集合既可以通过数据库来实现, 也可以采用其他任何类型来实现, 例如list或者map. ContentProvider对数据集合的具体实现并没有任何要求. 要注意处理好内部的insert, delete, update, query方法的线程同步, 因为这几个方法是在Binder线程池被调用. Activity的工作过程虽然要打开一个Activity很简单, 但是不应该只是局限于表面. 了解其内部走向构成.所以一切从startActivity(intent)这个方法开始. startActivity()有好几种重载方式但是最终都是调用startActivityForResult()方法. 注意这里分析的是5.0版本的源码, 和6.0源码实现稍微不同 首先看startActivityForResult() 123456789101112131415161718192021222324252627282930313233public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; if (mParent == null) &#123; Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) &#123; mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); &#125; if (requestCode &gt;= 0) &#123; mStartedActivity = true; &#125; final View decor = mWindow != null ? mWindow.peekDecorView() : null; if (decor != null) &#123; decor.cancelPendingInputEvents(); &#125; // TODO Consider clearing/flushing other event sources and events for child windows. &#125; else &#123; if (options != null) &#123; mParent.startActivityFromChild(this, intent, requestCode, options); &#125; else &#123; // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); &#125; &#125; if (options != null &amp;&amp; !isTopOfTask()) &#123; mActivityTransitionState.startExitOutTransition(this, options); &#125;&#125; 关注mParent==null的分支. mParent代表的是ViewGroup, ActivityGroup最开始被用来在一个界面中嵌入多个子Activity, 在API13已经被废弃. 系统推荐使用Fragment代替ActivityGroup. 注意mMainThread.getApplicationThread()这个参数, 它的参数类型是ApplicationThread, ApplicationThread是ActivityThread的一个内部类. 看一下Instrumentation#execStartActivity()这个方法 12345678910111213141516171819202122232425262728293031323334public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) &#123; synchronized (mSync) &#123; final int N = mActivityMonitors.size(); for (int i=0; i&lt;N; i++) &#123; final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) &#123; am.mHits++; if (am.isBlocking()) &#123; return requestCode &gt;= 0 ? am.getResult() : null; &#125; break; &#125; &#125; &#125; &#125; try &#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); // 启动Activity的真正实现 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); &#125; catch (RemoteException e) &#123; &#125; return null;&#125; 代码中真正启动Activity的真正实现是由ActivityManagerNative.getDefault().startActivity()方法完成的. 后面对ActivityManagerService简称AMS. AMS继承自ActivityManagerNative, 而ActivityManagerNative继承自Binder并实现了IActivityManager这个Binder接口, 因此AMS也是一个Binder, 它是IActivityManager的具体实现. 由于ActivityManagerNative.getDefault()本质是一个IActivityManager类型的Binder对象, 因此具体实现是AMS. 在ActivityManagerNative中, AMS这个Binder对象采用单例模式对外提供, Singleton是一个单例封装类. 第一次调用它的get()方法时会通过create方法来初始化AMS这个Binder对象, 在后续调用中会返回这个对象. 具体实现如下代码. 1234567891011121314151617static public IActivityManager getDefault() &#123; return gDefault.get();&#125;private static final Singleton&lt;IActivityManager&gt; gDefault = new Singleton&lt;IActivityManager&gt;() &#123; protected IActivityManager create() &#123; IBinder b = ServiceManager.getService("activity"); if (false) &#123; Log.v("ActivityManager", "default service binder = " + b); &#125; IActivityManager am = asInterface(b); if (false) &#123; Log.v("ActivityManager", "default service = " + am); &#125; return am; &#125;&#125;; 由上可以看到关于Activity的启动是由ActivityManagerNative.getDefault()来启动的, 而ActivityManagerNative.getDefault()实际上是AMS, 所以Activity的启动过程又被转移到了AMS中, 接下来查看AMS中的startActivity()方法. 在分析AMS#startActivity()之前, 是否在开始时候碰到过Activity没有在清单文件中声明然后崩溃的现象? 这个步骤是在Instrumentation#execStartActivity()刚才分析ActivityManagerNative.getDefault().startActivity()的下一步. 有一个checkStartActivityResult(),看名字应该是检查的类, 看一下实现. 1234567891011121314151617181920212223242526272829303132public static void checkStartActivityResult(int res, Object intent) &#123; if (res &gt;= ActivityManager.START_SUCCESS) &#123; return; &#125; switch (res) &#123; case ActivityManager.START_INTENT_NOT_RESOLVED: case ActivityManager.START_CLASS_NOT_FOUND: if (intent instanceof Intent &amp;&amp; ((Intent)intent).getComponent() != null) throw new ActivityNotFoundException( "Unable to find explicit activity class " + ((Intent)intent).getComponent().toShortString() + "; have you declared this activity in your AndroidManifest.xml?"); throw new ActivityNotFoundException( "No Activity found to handle " + intent); case ActivityManager.START_PERMISSION_DENIED: throw new SecurityException("Not allowed to start activity " + intent); case ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT: throw new AndroidRuntimeException( "FORWARD_RESULT_FLAG used while also requesting a result"); case ActivityManager.START_NOT_ACTIVITY: throw new IllegalArgumentException( "PendingIntent is not an activity"); case ActivityManager.START_NOT_VOICE_COMPATIBLE: throw new SecurityException( "Starting under voice control not allowed for: " + intent); default: throw new AndroidRuntimeException("Unknown error code " + res + " when starting " + intent); &#125;&#125; 看出这个方法是一言不合就抛异常. 看ActivityManager.START_CLASS_NOT_FOUND这个判断分支抛出的异常是不是很眼熟? 对就是没有在清单文件中注册就在这里抛出. 所以这个方法就是检查启动Activity的结果. 回到AMS的startActivity() 123456789101112131415161718192021public final int startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options) &#123; // 直接调用下面方法 return startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo, resultWho, requestCode, startFlags, profilerInfo, options, UserHandle.getCallingUserId());&#125;@Overridepublic final int startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle options, int userId) &#123; enforceNotIsolatedCaller("startActivity"); userId = handleIncomingUser(Binder.getCallingPid(), Binder.getCallingUid(), userId, false, ALLOW_FULL_ONLY, "startActivity", null); // TODO: Switch to user app stacks here. return mStackSupervisor.startActivityMayWait(caller, -1, callingPackage, intent, resolvedType, null, null, resultTo, resultWho, requestCode, startFlags, profilerInfo, null, null, options, userId, null, null);&#125; Activity启动过程经过两次转移, 最后又转移到了mStackSupervisor.startActivityMayWait()这个方法, 所属类为ActivityStackSupervisor. 在startActivityMayWait()内部又调用了startActivityLocked()这里会返回结果码就是之前checkStartActivityResult()用到的. 继续跟进方法最后会调用startActivityUncheckedLocked(), 然后又调用了ActivityStack#resumeTopActivityLocked(). 这个时候启动过程已经从ActivityStackSupervisor转移到了ActivityStack类中. 看ActivityStack的resumeTopActivityLocked()方法实现 1234567891011121314151617181920final boolean resumeTopActivityLocked(ActivityRecord prev, Bundle options) &#123; if (mStackSupervisor.inResumeTopActivity) &#123; // Don't even start recursing. return false; &#125; boolean result = false; try &#123; // Protect against recursion. mStackSupervisor.inResumeTopActivity = true; if (mService.mLockScreenShown == ActivityManagerService.LOCK_SCREEN_LEAVING) &#123; mService.mLockScreenShown = ActivityManagerService.LOCK_SCREEN_HIDDEN; mService.updateSleepIfNeededLocked(); &#125; result = resumeTopActivityInnerLocked(prev, options); &#125; finally &#123; mStackSupervisor.inResumeTopActivity = false; &#125; return result;&#125; 从上可以看到result是根据调用的resumeTopActivityInnerLocked()返回, 而resumeTopActivityInnerLocked()又调用了ActivityStackSupervisor#startSpecificActivityLocked()方法. 看一下这个方法: 123456789101112131415161718192021222324252627282930void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) &#123; // Is this activity's application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); if (app != null &amp;&amp; app.thread != null) &#123; try &#123; if ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == 0 || !"android".equals(r.info.packageName)) &#123; app.addPackage(r.info.packageName, r.info.applicationInfo.versionCode, mService.mProcessStats); &#125; // 继续进入!!! realStartActivityLocked(r, app, andResume, checkConfig); return; &#125; catch (RemoteException e) &#123; Slog.w(TAG, "Exception when starting activity " + r.intent.getComponent().flattenToShortString(), e); &#125; // If a dead object exception was thrown -- fall through to // restart the application. &#125; mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, "activity", r.intent.getComponent(), false, false, true);&#125; 这个方法又进入了realStartActivityLocked(). 在这个方法中有如下一段代码: 12345app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), r.compat, r.launchedFromPackage, r.task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); 先整理一下刚才的调用过程, 我已经照着书上跟的不知所以然了…. Activity的启动过程在ActivityStackSupervisor和ActivityStack之间的传递顺序可以概括为下图： 继续看刚才app.thread.scheduleLaunchActivity()这个方法. 其中app.thread类型为IApplicationThread, 这个玩意继承了IInterface接口, 所以他也是一个Binder类型的接口. 从IApplicationThread声明的接口方法可以看出, 其内部包含了大量启动和停止Activity以及Service的接口. 那IApplicationThread的实现者是哪个类? 在ActivityThread中的内部类有一个ApplicationThread,看看定义 1234private class ApplicationThread extends ApplicationThreadNativepublic abstract class ApplicationThreadNative extends Binder implements IApplicationThread 可以看到ApplicationThread的继承关系, 而查看ApplicationThreadNative的作用其实和系统AIDL文件生成的类是一样的. 在ApplicationThreadNative的内部, 还有一个ApplicationThreadProxy类, 眼熟吧在第二章讲解的时候aidl生成的java文件中也有一个内部的代理类. 所以ApplicationThreadNative就是IApplicationThread的实现者, 由于ApplicationThreadNative被系统定义为抽象类, 所以ApplicationThread就成了IApplicationThread的实现者。 绕了一大圈, Activity启动过程最终回到了ApplicationThread中, ApplicationThread通过scheduleLaunchActivity()来启动Activity. 12345678910111213141516171819202122232425262728public final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 这段代码做的就是封装一个Activity的记录信息交给名字叫H的一个Handler对象去处理, 继续跟进看看里面的实现 1234567891011121314private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) Slog.v( TAG, "SCHEDULE " + what + " " + mH.codeToString(what) + ": " + arg1 + " / " + obj); Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125; 额, 没啥好瞅的就是封装一个message发送了一个消息. 好吧 那看看Handler接收的时候是如何处理的吧. 这个类里面对Handler进行了包装, 包装的类就是一个H的内部类. 1234567891011121314151617181920212223242526272829303132333435363738private class H extends Handler &#123; public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; //这里省略一堆常量声明 //在省略一堆switch分支, 直接看具体的消息处理 public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, "&gt;&gt;&gt; handling: " + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case PAUSE_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityPause"); handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;2) != 0); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityPause"); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; //这里又省去了一大坨的case分支 &#125; if (DEBUG_MESSAGES) Slog.v(TAG, "&lt;&lt;&lt; done: " + codeToString(msg.what)); &#125; 我们目前只关心LAUNCH_ACTIVITY这个标记，Activity的启动过程由ActivityThread的handleLaunchActivity()方法来实现。这个方法内部通过performLaunchActivity()方法最终完成了Activity对象的创建和启动过程. 并且ActivityThread通过handleResumeActivity()方法来调用被启动的onResume()这一生命周期方法. performLaunchActivity(ActivityClientRecord r, Intent customIntent)主要完成如下的几件事： 1. 从ActivityClientRecord中获取待启动的Activity信息 1234567891011121314151617ActivityInfo aInfo = r.activityInfo;if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE);&#125;ComponentName component = r.intent.getComponent();if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component);&#125;if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity);&#125; 2.通过Instrumentation的newActivity方法使用类加载器创建Activity对象 123456789java.lang.ClassLoader cl = r.packageInfo.getClassLoader();activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent);StrictMode.incrementExpectedActivityCount(activity.getClass());r.intent.setExtrasClassLoader(cl);r.intent.prepareToEnterProcess();if (r.state != null) &#123; r.state.setClassLoader(cl);&#125; 至于Instrumentation的newActivity实现就是通过类加载器创建了一个Activity对象： 123public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; return (Activity)cl.loadClass(className).newIntance();&#125; 3.通过LoadedApk的makeApplication()方法来尝试创建Application对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) &#123; if (mApplication != null) &#123;//已经有Applicaiton直接返回 return mApplication; &#125; Application app = null; String appClass = mApplicationInfo.className; if (forceDefaultAppClass || (appClass == null)) &#123; appClass = "android.app.Application"; &#125; try &#123; java.lang.ClassLoader cl = getClassLoader(); if (!mPackageName.equals("android")) &#123; initializeJavaContextClassLoader(); &#125; ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this); //通过Instrumentation创建Application app = mActivityThread.mInstrumentation.newApplication( cl, appClass, appContext); appContext.setOuterContext(app); &#125; catch (Exception e) &#123; if (!mActivityThread.mInstrumentation.onException(app, e)) &#123; throw new RuntimeException( "Unable to instantiate application " + appClass + ": " + e.toString(), e); &#125; &#125; mActivityThread.mAllApplications.add(app); mApplication = app; if (instrumentation != null) &#123; try &#123; //回调onCreate()方法 instrumentation.callApplicationOnCreate(app); &#125; catch (Exception e) &#123; if (!instrumentation.onException(app, e)) &#123; throw new RuntimeException( "Unable to create application " + app.getClass().getName() + ": " + e.toString(), e); &#125; &#125; &#125; // Rewrite the R 'constants' for all library apks. SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread) .getAssignedPackageIdentifiers(); final int N = packageIdentifiers.size(); for (int i = 0; i &lt; N; i++) &#123; final int id = packageIdentifiers.keyAt(i); if (id == 0x01 || id == 0x7f) &#123; continue; &#125; rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id); &#125; return app;&#125; 从这个方法中可以看到, 如果Application这个对象已经被创建过, 那么就不会再重复创建了, 这也就意味着一个应用只有一个Application对象的原因. Application对象的创建也是通过Instrumentation类来完成, 这个过程和Activity对象的创建是一致的, 都是通过类加载器来实现. Application创建完毕后, 系统会通过Instrumentation的callApplicationOnCreate()方法来调用Application#onCreate()方法. 4. 创建ContextImpl对象并通过Activity的attach方法来完成重要数据的初始化 123456789Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, "Launching activity " + r.activityInfo.name + " with config " + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); ContextImpl是一个很重要的数据结构, 它是Context的具体实现, Context中的大部分逻辑都是由ContentImpl来完成的. ContextImpl是通过Activity的attach()方法来和Activity建立关联的,除此之外, 在attach()中Activity还会完成Window的创建并建立自己和Window的关联, 这样当Window接收到外部输入事件收就可以将事件传递给Activity. 5. 调用Activity的onCreate()方法 mInstrumentation.callActivityOnCreate(activity, r.state);, 由于Activity的onCreate()已经被调用, 这也意味着Activity已经完成整个启动过程. Service的工作流程Service的启动过程同样从ContextImpl#startService()这个方法作为入口. 这个方法会调用startServiceCommon()并返回. 这个方法内部通过ActivityManagerNative.getDefault()获得一个AMS并调用startService()开启一个服务. 在这里通过AMS来启动一个服务的行为是属于远程调用的过程. 看一下AMS的startService() 1234567891011121314151617181920public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, int userId) &#123; enforceNotIsolatedCaller("startService"); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; if (DEBUG_SERVICE) Slog.v(TAG, "startService: " + service + " type=" + resolvedType); synchronized(this) &#123; final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; 这段主要就是AMS通过mServices这个对象来完成Service后续的启动过程. 这里mService的对象类型是ActiveServices(这是一个辅助AMS进行Service管理的类, 包括Service的启动,绑定和停止等). 这里调用了mServices.startServiceLocked()然后这个方法最后又调用了startServiceInnerLocked(), 实现如下. 1234567891011121314151617181920212223242526272829303132333435ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) &#123; ProcessStats.ServiceState stracker = r.getTracker(); if (stracker != null) &#123; stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity); &#125; r.callStart = false; synchronized (r.stats.getBatteryStats()) &#123; r.stats.startRunningLocked(); &#125; String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false); if (error != null) &#123; return new ComponentName("!!", error); &#125; if (r.startRequested &amp;&amp; addToStarting) &#123; boolean first = smap.mStartingBackground.size() == 0; smap.mStartingBackground.add(r); r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT; if (DEBUG_DELAYED_SERVICE) &#123; RuntimeException here = new RuntimeException("here"); here.fillInStackTrace(); Slog.v(TAG, "Starting background (first=" + first + "): " + r, here); &#125; else if (DEBUG_DELAYED_STARTS) &#123; Slog.v(TAG, "Starting background (first=" + first + "): " + r); &#125; if (first) &#123; smap.rescheduleDelayedStarts(); &#125; &#125; else if (callerFg) &#123; smap.ensureNotStartingBackground(r); &#125; return r.name; &#125; ServiceRecord描述的是一个Service记录, ServiceRecord一直贯穿着整个Service的启动过程. startServiceInnerLocked()方法并没有完成具体的启动工作, 而是把后续的工作交给了bringUpServiceLocked(),在bringUpServiceLocked()又调用了realStartServiceLocked()方法. 这个方法算是真正的启动一个Service. realStartServiceLocked()首先通过app.thread.scheduleCreateService()方法来创建Service对象并调用其onCreate(), 接着再通过sendServiceArgsLoceked()方法来调用Service的其他方法, 比如onStartCommond这两个过程均是进程间通信. app.thread对象是IApplicationThread类型，实际上是一个Binder，他的具体实现是ApplicationThread. 在Activity启动流程的时候已经解释过了. 所以只查看Application对Service的启动过程的处理即可. 这对应着它的scheduleCreateService(). 12345678910public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) &#123; updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s);&#125; 这个过程和Activity类似, 都是通过H来完成。H会接收这个CREATE_SERVICE消息并通过ActivityThread的handleCreateService方法完成Service的最终启动. 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void handleCreateService(CreateServiceData data) &#123; unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try &#123; java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( "Unable to instantiate service " + data.info.name + ": " + e.toString(), e); &#125; &#125; try &#123; if (localLOGV) Slog.v(TAG, "Creating service " + data.info.name); ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); //---------------- service.attach(context, this, data.info.name, data.token, app, ActivityManagerNative.getDefault()); service.onCreate(); //--------------- mServices.put(data.token, service); try &#123; ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; catch (RemoteException e) &#123; // nothing to do. &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(service, e)) &#123; throw new RuntimeException( "Unable to create service " + data.info.name + ": " + e.toString(), e); &#125; &#125;&#125; handleCreateService做了如下事情 通过类加载器创建Service的实例 创建Application对象并调用其onCreate(), 注意⚠️Application创建过程只会有一次. 接着创建ContextImpl对象并通过Service的attach方法建立二者之间的关系, 这个过程和Activity实际上是类似的. 调用onCreate()并将Service对象存储到ActivityThread中的一个列表. 就是final ArrayMap&lt;IBinder, Service&gt; mServices = new ArrayMap&lt;IBinder, Service&gt;(); onCreate()方法被执行了也就意味着Service已经启动了. 除此之外, ActivityThread中还会通过handleServiceArgs()方法调用Service的onStartCommand()方法. Service的绑定过程和启动过程一样, 绑定过程同样是从ContextImpl开始的. 先查看bindServiceCommon(). 12345678910111213141516171819202122232425262728293031323334private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, UserHandle user) &#123; IServiceConnection sd; if (conn == null) &#123; throw new IllegalArgumentException("connection is null"); &#125; if (mPackageInfo != null) &#123; sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags); &#125; else &#123; throw new RuntimeException("Not supported in system context"); &#125; validateServiceIntent(service); try &#123; IBinder token = getActivityToken(); if (token == null &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == 0 &amp;&amp; mPackageInfo != null &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123; flags |= BIND_WAIVE_PRIORITY; &#125; service.prepareToLeaveProcess(); int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, user.getIdentifier()); if (res &lt; 0) &#123; throw new SecurityException( "Not allowed to bind to service " + service); &#125; return res != 0; &#125; catch (RemoteException e) &#123; return false; &#125;&#125; 这段代码首先将客户端的ServiceConnection对象转化成为ServiceDispatcher.InnerConnection对象. 不能直接使用ServiceConnection对象必须借助于Binder才能让远程服务回调自己的方法. 而ServiceDispatcher的内部类InnerConnection刚好充当了Binder这个角色. ServiceDispatcher的作用就是连接ServiceConnection和InnerConnection的作用. 这个过程由LoadedApk的getServiceDispatcher()方法完成. 实现如下: 123456789101112131415161718192021public final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) &#123; synchronized (mServices) &#123; LoadedApk.ServiceDispatcher sd = null; ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context); if (map != null) &#123; sd = map.get(c); &#125; if (sd == null) &#123; sd = new ServiceDispatcher(c, context, handler, flags); if (map == null) &#123; map = new ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;(); mServices.put(context, map); &#125; map.put(c, sd); &#125; else &#123; sd.validate(context, handler); &#125; return sd.getIServiceConnection(); &#125;&#125; mService是一个ArrayMap, 它存储了一个应用当前活动的ServiceConnection和ServiceDispatcher的映射关系. 系统首先会查找是否存在相同的ServiceConnection, 如果不存在就会重新创建一个ServiceDispatch对象并将其存储在mService中, 其中的key是ServiceConnection,value是ServiceDispatcher, 在ServiceDispatcher的内部又保存了ServiceConnection和InnerConnection对象. 当Service和客户端建立连接后, 系统会通过InnerConnection来调用ServiceConnection中的onServiceConnected()方法. 这个过程是跨进程的. 当ServiceDispatcher创建好了以后, getServiceDispatcher会返回其保存的InnerConnection对象. 接着bindServiceCommon方法会通过AMS完成Service的具体绑定, 这对应着AMS#bindService()方法. 123456789101112131415public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, int userId) &#123; enforceNotIsolatedCaller("bindService"); // Refuse possible leaked file descriptors if (service != null &amp;&amp; service.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; synchronized(this) &#123; return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, userId); &#125;&#125; 然后AMS会调用ActivityService#bindServiceLocked()方法. 然后调用bringUpServiceLocked(), 继续调用. 发现调到了realStartServiceLocked. ⚠️这里面的逻辑和启动过程类似. 最终都是通过ApplicationThread来完成Service实例的创建并执行其onCreate()方法. 这里不再重复说明. 与Service启动稍微不同的是:😭 绑定过程: 会调用到app.thread(ActivityThread)的scheduleBindService()方法. 而这个过程的实现是在ActiveService#requestServiceBindingLocked()方法. 123456789101112131415161718192021222324private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) &#123; if (r.app == null || r.app.thread == null) &#123; // If service is not currently running, can't yet bind. return false; &#125; if ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; 0) &#123; try &#123; bumpServiceExecutingLocked(r, execInFg, "bind"); r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); if (!rebind) &#123; i.requested = true; &#125; i.hasBound = true; i.doRebind = false; &#125; catch (RemoteException e) &#123; if (DEBUG_SERVICE) Slog.v(TAG, "Crashed while binding " + r); return false; &#125; &#125; return true;&#125; app.thread实际上就是ApplicationThread. ApplicationThread的一系列以schedule开头的方法, 其内部都是通过Handler H来中转的. H的内部 接收到BIND_SERVICE消息需要处理时, 会交给ActivityThread#handleBindService(). 在handlerBindService中, 首先根据Service的token取出Service对象. 然后调用Service#onBind()方法, Service的onBinder方法返回一个Binder对象给客户端使用. 原则上来说, Service#onBind()方法被调用后, Service就处于绑定状态, 但是onBind方法是Service的方法, 这个时候客户端并不知道已经成功连接Service, 所以还必须调用客户端的ServiceConnection中的onServiceConnected(), 这个过程由是ActivityManagerNative.getDefault()也就是AMS的publishSevice()来完成。 handleBindService()实现如下: 1234567891011121314151617181920212223242526272829303132//ActivityThread.javaprivate void handleBindService(BindServiceData data) &#123; Service s = mServices.get(data.token); if (DEBUG_SERVICE) Slog.v(TAG, "handleBindService s=" + s + " rebind=" + data.rebind); if (s != null) &#123; try &#123; data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try &#123; if (!data.rebind) &#123; IBinder binder = s.onBind(data.intent); // 看我看我 ActivityManagerNative.getDefault().publishService( data.token, data.intent, binder); &#125; else &#123; s.onRebind(data.intent); ActivityManagerNative.getDefault().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); &#125; ensureJitEnabled(); &#125; catch (RemoteException ex) &#123; &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(s, e)) &#123; throw new RuntimeException( "Unable to bind to service " + s + " with " + data.intent + ": " + e.toString(), e); &#125; &#125; &#125;&#125; 还记得多次绑定会有什么效果么? Service#onBind()方法只会执行一次, 除非Service被终止了. 当Service的onBind()执行之后, 系统还需要告知客户端已经成功连接Service了. 这些过程是在AMS#publishService()实现. 12345678910111213public void publishService(IBinder token, Intent intent, IBinder service) &#123; // Refuse possible leaked file descriptors if (intent != null &amp;&amp; intent.hasFileDescriptors() == true) &#123; throw new IllegalArgumentException("File descriptors passed in Intent"); &#125; synchronized(this) &#123; if (!(token instanceof ServiceRecord)) &#123; throw new IllegalArgumentException("Invalid service token"); &#125; mServices.publishServiceLocked((ServiceRecord)token, intent, service); &#125;&#125; 可以看到这里将具体的工作交给了mServices.publishServiceLocked()它是一个ActiveService类型. 其核心代码就是: 1234c.conn.connected(r.name, service);//c的类型是ConnectionRecord//c.conn的类型是ServiceDispatcher.InnerConnection//service参数就是Service的onBind返回的Binder对象 123456789101112131415//看一下ServiceDispatcher.InnerConnection的定义private static class InnerConnection extends IServiceConnection.Stub &#123; final WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) &#123; mDispatcher = new WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd); &#125; public void connected(ComponentName name, IBinder service) &#123; LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if(sd != null) &#123; sd.connected(name, service); &#125; &#125;&#125; 而InnerConnection#connected()方法内又调用ServiceDispatcher的connected(),在内部就是创建一个RunConnection()发送到mActivityThread的消息中. 12345678//ServiceDispatch classpublic void connected(Conponment name, IBinder service) &#123; if(mActivityThread != null) &#123; mActiivtyThread.post(new RunConnection(name, service, 0)); &#125; else &#123; doConnect(name, service); &#125;&#125; 对于Service的绑定过程来说, ServiceDispatcher的mActivityThread是一个Handler, 也就是ActivityThread#H, 从前面的ServiceDispatcher的创建过程来说, mActivityThread不会为null, 所以RunConnection就可以经由H的post方法从而运行在主线程. 因此客户端的ServiceConnection中的方法是在主线程被回调的. RunConnection是一个Runnable接口, run()方法也是简单调用ServiceDispatcher#doConnected方法, 由于ServiceDispatcher内部保存了客户端的ServiceConnection对象, 因此他可以很方便调用ServiceConnection对象的onServiceConnected() 解绑和停止过程, 基本类似… 😄. BroadcastReceiver的工作流程简单回顾一下广播的使用方法, 首先定义广播接收者, 只需要继承BroadcastReceiver并重写onReceive()方法即可. 定义好了广播接收者, 还需要注册广播接收者, 分为两种静态注册或者动态注册. 注册完成之后就可以发送广播了. 广播的注册过程广播的注册有两种静态注册, 动态注册. 其中静态注册的广播在应用安装时由系统自动完成注册, 具体来说是有PMS(PackageManagerService)来完成整个注册过程的. 除了广播外, 其他三大组件也都是在应用安装时由PMS解析并注册的. 动态注册的过程是从ContextWrapper#registerReceiver()开始的. 和Activity或者Service一样. ContextWrapper并没有做实际的工作, 而是将注册的过程直接交给了ContextImpl来完成. ContextImpl#registerReceiver()方法调用了本类的registerReceiverInternal()方法. 12345678910111213141516171819202122232425262728private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) &#123; IIntentReceiver rd = null; if (receiver != null) &#123; if (mPackageInfo != null &amp;&amp; context != null) &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); &#125; else &#123; if (scheduler == null) &#123; scheduler = mMainThread.getHandler(); &#125; rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); &#125; &#125; try &#123; return ActivityManagerNative.getDefault().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); &#125; catch (RemoteException e) &#123; return null; &#125;&#125; 上述代码中, 系统首先从mPackageInfo获取到IIntentReceiver对象, 然后再采用跨进程的方式向AMS发送广播注册的请求. 之所以采用IIntentReceiver而不是直接采用BroadcastReceiver, 这是因为上述注册过程中是一个进程间通信的过程. 而BroadcastReceiver作为Android中的一个组件是不能直接跨进程传递的. 所有需要通过IIntentReceiver来中转一下. IIntentReceiver作为一个Binder接口, 它的具体实现是LoadedApk.ReceiverDispatcher.InnerReceiver, ReceiverDispatcher的内部同时保存了BroadcastReceiver和InnerReceiver, 这样当接收到广播的时候, ReceiverDispatcher可以很方便的调用BroadcastReceiver#onReceive()方法. 这里和·Service的原理很像, Service有个ServiceDispatcher类，并且其内部类InnerConnection同样也是一个Binder接口. 看一下LoadedApk.ReceiverDispatcher#getIIntentReceiver()的实现, 很显然getReceiverDispatcher()重新创建了一个ReceiverDispatcher对象并将其保存的InnerReceiver对象作为返回值返回, 其中InnerReceiver对象和BroadcastReceiver都是在ReceiverDispatcher的构造方法中被保存起来的. 1234567891011121314151617181920212223242526272829public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) &#123; synchronized (mReceivers) &#123; LoadedApk.ReceiverDispatcher rd = null; ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = null; if (registered) &#123; map = mReceivers.get(context); if (map != null) &#123; rd = map.get(r); &#125; &#125; if (rd == null) &#123; rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); if (registered) &#123; if (map == null) &#123; map = new ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;(); mReceivers.put(context, map); &#125; map.put(r, rd); &#125; &#125; else &#123; rd.validate(context, handler); &#125; rd.mForgotten = false; return rd.getIIntentReceiver(); &#125;&#125; 由于注册广播真正实现过程是在AMS中, 因此跟进AMS中, 首先看registerReceiver()方法, 这里只关心里面的核心部分. 这段代码最终会把远程的InnerReceiver对象以及IntentFilter对象存储起来, 这样整个广播的注册就完成了. 123456789public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) &#123; //... mRegisteredReceivers.put(receiver.asBinder(), rl); BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId); rl.add(bf); mReceiverResolver.addFilter(bf); &#125; 广播的发送和接收过程当通过send()发送广播时, AMS会查找出匹配的广播接收者并将广播发送给他们处理. 广播的发送种类有: 普通广播, 有序广播, 粘性广播. 这里分析普通广播. 广播的发送和接收, 本质就是一个过程的两个阶段. 广播的发送仍然开始于ContextImpl#sendBroadcase()方法, 之所以不是Context, 那是因为Context#sendBroad()是一个抽象方法. 和广播的注册过程一样, ContextWrapper#sendBroadcast()仍然什么都不做, 只是把事情交给了ContextImpl去处理, ContextImpl#sendBroadcast()源码如下 1234567891011@Overridepublic void sendBroadcast(Intent intent) &#123; warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); intent.prepareToLeaveProcess(); ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId());&#125; 看到ContextImpl里面也几乎什么都没有做, 内部直接向AMS发起了一个异步请求用于发送广播. 接下来看AMS#broadcastIntent()方法. 12345678910111213141516171819202122public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) &#123; enforceNotIsolatedCaller("broadcastIntent"); synchronized(this) &#123; intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, null, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; &#125;&#125; 看到这里, 又继续调用broadcastIntentLocked()方法, 这个方法有点长. 在代码开始处 12// By default broadcasts do not go to stopped apps.intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); 这个表示默认情况下广播不会发送给已经停止的应用, android5.0中. 而android 3.1开始就增添了两个标记为. 分别是FLAG_INCLUDE_STOPPED_PACKAGES, FLAG_EXCLUDE_STOPPED_PACKAGES. 用来控制广播是否要对处于停止的应用起作用. FLAG_INCLUDE_STOPPED_PACKAGES: 包含停止应用, 广播会发送给已停止的应用. FLAG_EXCLUDE_STOPPED_PACKAGES: 不包含已停止应用, 广播不会发送给已停止的应用 在android 3.1开始, 系统就为所有广播默认添加了FLAG_EXCLUDE_STOPPED_PACKAGES标识, 为了防止广播无意间或者不必要的时候调起已经停止运行的应用. 当这两个标记共存的时候以FLAG_INCLUDE_STOPPED_PACKAGES(非默认项为主). 应用处于停止分为两种 应用安装后未运行 被手动或者其他应用强停 开机广播同样受到了这个标志位的影响. 从Android 3.1开始处于停止状态的应用同样无法接受到开机广播, 而在android 3.1之前处于停止的状态也是可以接收到的开机广播的. 在broadcastIntentLocked()内部, 会根据intent-filter查找出匹配的广播接收者并经过一系列的条件过滤. 最终会将满足条件的广播接收者添加到BroadcastQueue中, 接着BroadcastQueue就会将广播发送给相应广播接收者. 12345678910111213141516171819if ((receivers != null &amp;&amp; receivers.size() &gt; 0) || resultTo != null) &#123; BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Enqueueing ordered broadcast " + r + ": prev had " + queue.mOrderedBroadcasts.size()); if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, "Enqueueing broadcast " + r.intent.getAction()); boolean replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r); if (!replaced) &#123; queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); &#125;&#125; 跟进BroadcastQueue#scheduleBroadcastsLocked() 1234567891011public void scheduleBroadcastsLocked() &#123; if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Schedule broadcasts [" + mQueueName + "]: current=" + mBroadcastsScheduled); if (mBroadcastsScheduled) &#123; return; &#125; mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true;&#125; 方法内并没有立即发送广播, 而是发送了一个BROADCAST_INTENT_MSG类型的消息, BroadcastQueue收到消息后会调用processNextBroadcast()方法. 这个方法对普通广播的处理如下: 12345678910111213141516171819// First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() &gt; 0) &#123; r = mParallelBroadcasts.remove(0);//取出广播 r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int N = r.receivers.size(); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, "Processing parallel broadcast [" + mQueueName + "] " + r); for (int i=0; i&lt;N; i++) &#123; Object target = r.receivers.get(i);//获取所有广播接受者 if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, "Delivering non-ordered on [" + mQueueName + "] to registered " + target + ": " + r); deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, false); &#125; addBroadcastToHistoryLocked(r); if (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, "Done with parallel broadcast [" + mQueueName + "] " + r); &#125; 无序广播存储在mParallelBroadcasts中, 系统会遍历这个集合并将其中的广播发送给他们所有的接收者, 具体的发送过程是通过deliverToRegisteredReceiverLocked()方法实现. deliverToRegisteredReceiverLocked()负责将一个广播发送给一个特定的接收者, 它的内部调用了performReceiverLocked方法来完成具体发送过程. performReceiverLocked()方法实现如下, 由于接收广播会调起应用程序, 因为app.thread不为null, 根据前面的总结app.thread仍然指ApplicationThread. 12345678910111213141516171819private static void performReceiveLocked(ProcessRecord app, IIntentReceiver receiver, Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) throws RemoteException &#123; // Send the intent to the receiver asynchronously using one-way binder calls. if (app != null) &#123; if (app.thread != null) &#123; // If we have an app thread, do the call through that so it is // correctly ordered with other one-way calls. app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode, data, extras, ordered, sticky, sendingUser, app.repProcState); &#125; else &#123; // Application has died. Receiver doesn't exist. throw new RemoteException("app.thread must not be null"); &#125; &#125; else &#123; receiver.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; &#125; 而调用的ApplicationThread#scheduleRegisteredReceiver()实现比较简单, 它通过InnerReceiver来实现广播的接收 1234567public void scheduleRegisteredReceiver(IIntentReceiver receiver, Intent intent, int resultCode, String dataStr, Bundle extras, boolean ordered, boolean sticky, int sendingUser, int processState) throws RemoteException &#123; updateProcessState(processState, false); receiver.performReceive(intent, resultCode, dataStr, extras, ordered, sticky, sendingUser);&#125; 上面的receiver.performReceive()中的receiver对应着IIntentReceiver类型的接口. 而具体的实现就是ReceiverDispatcher$InnerReceiver，看一下他的performReceiver()方法： 1234567891011121314151617181920212223242526272829public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; LoadedApk.ReceiverDispatcher rd = mDispatcher.get(); if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra("seq", -1); Slog.i(ActivityThread.TAG, "Receiving broadcast " + intent.getAction() + " seq=" + seq + " to " + (rd != null ? rd.mReceiver : null)); &#125; if (rd != null) &#123; rd.performReceive(intent, resultCode, data, extras, ordered, sticky, sendingUser); &#125; else &#123; // The activity manager dispatched a broadcast to a registered // receiver in this process, but before it could be delivered the // receiver was unregistered. Acknowledge the broadcast on its // behalf so that the system's broadcast sequence can continue. if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, "Finishing broadcast to unregistered receiver"); IActivityManager mgr = ActivityManagerNative.getDefault(); try &#123; if (extras != null) &#123; extras.setAllowFds(false); &#125; mgr.finishReceiver(this, resultCode, data, extras, false, intent.getFlags()); &#125; catch (RemoteException e) &#123; Slog.w(ActivityThread.TAG, "Couldn't finish broadcast to unregistered receiver"); &#125; &#125;&#125; 上面又调用了LoadedApk$ReceiverDispatcher#performReceive()的方法. 123456789101112131415161718public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) &#123; if (ActivityThread.DEBUG_BROADCAST) &#123; int seq = intent.getIntExtra("seq", -1); Slog.i(ActivityThread.TAG, "Enqueueing broadcast " + intent.getAction() + " seq=" + seq + " to " + mReceiver); &#125; Args args = new Args(intent, resultCode, data, extras, ordered, sticky, sendingUser); if (!mActivityThread.post(args)) &#123; if (mRegistered &amp;&amp; ordered) &#123; IActivityManager mgr = ActivityManagerNative.getDefault(); if (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG, "Finishing sync broadcast to " + mReceiver); args.sendFinished(mgr); &#125; &#125; &#125; 在performReceiver()这个方法中, 会创建一个Args对象并通过mActivityThread的post方法执行args中的逻辑. 而这些类的本质关系就是: Args: 实现了Runnable接口 mActivityThread: 是一个Handler, 就是ActivityThread中的mH. mH就是ActivityThread$H. 这个内部类H以前说过. 而Args中有的run()方法有如下代码: 12345ClassLoader cl = mReceiver.getClass().getClassLoader();intent.setExtrasClassLoader(cl);setExtrasClassLoader(cl);receiver.setPendingResult(this);receiver.onReceive(mContext, intent); 这个时候BroadcastReceiver#onReceive()方法被执行了, 也就是说应用已经接收到了广播, 同时onReceive()方法是在广播接收者的主线程中被调用的. ContentProvider的工作机制ContentProvider是一种内容共享型组件, 它通过Binder向其他组件乃至其他应用提供数据. 当ContentProvider所在的进程启动时, ContentProvider会同时启动并发布到AMS中. 要注意:这个时候ContentProvider的onCreate()方法是先于Application的onCreate()执行的这一点在四大组件是少有的现象. 当一个应用启动的时候, 入口的方法为ActivityThread#main()方法, main方法为一个静态方法, 在main方法中会创建ActivityThread的实例, 并创建主线程的消息队列, 然后在ActivityThread#attach()方法中会远程调用AMS#attachApplication()并将ApplicationThread对象提供给AMS. ApplicationThread是一个Binder对象, 它的Binder接口是IApplicationThread, 主要用于ActivityThread和AMS之间的通信, 这一点在前面多次提到. 在AMS的attachApplication()中, 会调用ApplicationThread#bindApplication(). 这个过程同样是跨进程的. bindApplication()中会经过 ActivityThread中的mh(Handler) 切换到ActivityThread中去执行, 具体的方式是handleBindApplication(). 在handleBindApplication()方法中, ActivityThread会创建Application对象并加载ContentProvider. 需要注意的是, ActivityThread会先加载ContentProvider, 然后在调用Application#onCreate()方法 以上就是ContentProvider的启动过程, ContentProvider启动后, 外界就可以通过它所提供的增删改查这四个接口来操作ContentProvider中的数据源, 这四个方法都是通过Binder来调用的, 外界无法直接访问ContentProvider, 它只能通过AMS根据URI来获取到对应的ContentProvider的Binder接口IContentProvider, 然后再通过IContentProvider来访问ContentProvider中的数据源. ContentProvider是否属于单实例? 具体ContentProvider是否是单实例取决于android:multiprocess属性来决定的, 当其值为false的时候, 就是单实例也是默认值. 如果为true那就为多实例. 这个时候在每一个调用者的进程中都会存在一个ContentProvider对象. 通过单实例的ContentProvider来分析一下启动过程 首先访问ContentProvider需要通过ContentResolver, ContentResolver是一个抽象类, 通过Content#getContentResolver()方法获取的实际上是ApplicationContentResolver对象, 而这个类继承了ContentProvider并实现了其抽象方法. 当ContentProvider所在的进程未启动时, 第一次访问它的时候就会触发ContentProvider的创建, 当然这也伴随着ContentProvider所在的进程的启动. 通过四个对数据的操作方法中的任何一个, 都可以触发ContentProvider的启动过程. 四种操作过程差不多, 那么这里以query方法为例 首先会获取IContentProvider对象, 不管是通过acquireUnstableProvider()方法还是直接通过acquireProvider()方法, 他们的本质都是一样的, 最终都是通过acquireProvider方法来获取ContentProvider. ApplicationContentResolver#acquireProvider()方法并没有处理任何逻辑, 它直接调用了ActivityThread#acquireProvider(), 这个方法如下: 123456789101112131415161718192021222324public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) &#123; final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) &#123; return provider; &#125; IActivityManager.ContentProviderHolder holder = null; try &#123; holder = ActivityManagerNative.getDefault().getContentProvider( getApplicationThread(), auth, userId, stable); &#125; catch (RemoteException ex) &#123; &#125; if (holder == null) &#123; Slog.e(TAG, "Failed to find provider info for " + auth); return null; &#125; // Install provider will increment the reference count for us, and break // any ties in the race. holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider;&#125; 这段代码主要从ActivityThread中查找是否已经存在了ContentProvider了, 如果存在那么就直接返回. ActivityThread中通过mProviderMap来存储已经启动的ContentProvider对象, 这个集合的存储类型ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap. 如果目前ContentProvider没有启动, 那么就发送一个进程间请求给AMS让其启动项目目标ContentProvider, 最后再通过installProvider()方法来修改引用计数. 那么AMS是如何启动ContentProvider的呢? 关于ContentProvider被启动的时候会伴随着进程的启动, 在AMS中, 首先会启动ContentProvider所在的进程, 然后再启动ContentProvider. 启动进程是由AMS#startProcessLocked()方法来完成, 其内部主要是通过Process#start()方法来完成一个新进程的启动, 新进程启动后其入口方法为ActivityThread#main()方法. 如下: 123456789101112131415161718192021222324252627282930313233343536373839404142 public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ActivityThreadMain"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0("&lt;pre-initialized&gt;"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, "ActivityThread")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); throw new RuntimeException("Main thread loop unexpectedly exited");&#125; ActivityThread#main()是一个静态方法, 在它的内部首先会创建ActivityThread实例并调用attach()方法来进行一系列初始化, 接着就开始进行消息循环. ActivityThread#attach()方法会将ApplicationThread对象通过AMS#attachApplication方法跨进程传递给AMS, 最终AMS会完成ContentProvider的创建过程. ActivityThread#attach()部分代码: 12345try &#123; mgr.attachApplication(mAppThread); &#125; catch (RemoteException ex) &#123; // Ignore &#125; AMS#attachApplication()方法调用了attachApplication(), 然后又调用了ApplicationThread#bindApplication(), 这个过程也属于进程通信. 而上面的bindApplication()方法会发送一个BIND_APPLICATION类型的消息给mH, 这是一个Handler, 它收到消息后会调用ActivityThread#handleBindApplication()方法. bindApplication()发送源码如下: 12345678910111213141516AppBindData data = new AppBindData();data.processName = processName;data.appInfo = appInfo;data.providers = providers;data.instrumentationName = instrumentationName;data.instrumentationArgs = instrumentationArgs;data.instrumentationWatcher = instrumentationWatcher;data.instrumentationUiAutomationConnection = instrumentationUiConnection;data.debugMode = debugMode;data.enableOpenGlTrace = enableOpenGlTrace;data.restrictedBackupMode = isRestrictedBackupMode;data.persistent = persistent;data.config = config;data.compatInfo = compatInfo;data.initProfilerInfo = profilerInfo;sendMessage(H.BIND_APPLICATION, data); ActivityThread#handlerBindApplication()则完成了Application以及ContentProvider 的创建，可以分为如下四个步骤: 创建ContentProvider和Instrumentation 创建Application对象 启动当前进程的ContentProvider并调用onCreate()方法. 主要内部实现是installContentProvider()完成了ContentProvider的启动工作, 首先会遍历当前进程的ProviderInfo的列表并一一调用installProvider()方法来启动他们, 接着将已经启动的ContentProvider发布到AMS中, AMS会把他们存储在ProviderMap中, 这样一来外部调用者就可以直接从AMS中获取到ContentProvider. installProvider()内部通过类加载器创建的ContentProvider实例并在方法中调用了attachInfo(), 在这内部调用了ContentProvider#onCreate() 调用Application#onCreate() 经过了上述的四个步骤, ContentProvider已经启动成功, 并且其所在的进程的Application也已经成功, 这意味着ContentProvider所在的进程已经完成了整个的启动过程, 然后其他应用就可以通过AMS来访问这个ContentProvider了. 当拿到了ContentProvider以后, 就可以通过它所提供的接口方法来访问它. 这里要注意: 这里的ContentProvider并不是原始的ContentProvider. 而是ContentProvider的Binder类型对象IContentProvider, 而IContentProvider的具体实现是ContentProviderNative和ContentProvider.Transport. 后者继承了前者. 如果还用query方法来解释流程: 那么最开始其他应用通过AMS获取到ContentProvider的Binder对象就是IContentProvider. 而IContentProvider的实际实现者是ContentProvider.Transport. 因此实际上外部应用调用的时候本质上会以进程间通信的方式调用ContentProvider.Transport的query()方法,然后他的内部又调用了ContentProvider的query方法，query方法的执行结果再通过Binder返回给调用者。]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>四大组件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava 源码分析]]></title>
    <url>%2F2018%2F03%2F08%2FRxJava%20%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[基于 RxJava 2.1.2 给定下面的一段代码，从源码的角度分析 RxJava 的实现原理： 12345678910111213141516171819202122232425262728293031323334353637ObservableOnSubscribe&lt;Integer&gt; oos = new ObservableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(max); &#125; e.onComplete(); &#125;&#125;;Observer&lt;Integer&gt; o = new Observer&lt;Integer&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; &#125; @Override public void onNext(Integer integer) &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onComplete() &#123; &#125;&#125;;Observable.create(oos) .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.computation()) .subscribe(o); 分析源码之前，我们先定义一下名词，RxJava 是基于观察者模式的，这里将被观察者叫做主题（Source），观察者叫做观察者（Observer）。 上面的代码首先创建了一个主题对象，然后又创建了一个观察者对象，最后将两者关联起来，并且最重要的一点，指定了主题对象和观察者对象执行的线程。 Observable.create(oos)首先分析这行代码做了什么事情： 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; ObjectHelper 只是用来做非空判断，这里就不用管它了。看看 RxJavaPlugins 做了什么： 123456789101112131415/** * Calls the associated hook function. * @param &lt;T&gt; the value type * @param source the hook's input value * @return the value returned by the hook */@SuppressWarnings(&#123; "rawtypes", "unchecked" &#125;)@NonNullpublic static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 注释上都说了，这是一个钩子函数，也就是说如果 onObservableAssembly 的值不为空，那么就调用这个钩子函数，onObservableAssembly 是一个静态变量，需要我们主动的去设置才会赋值，这里当做空来考虑，如果 onObservableAssembly 为空的话，也就是说这个方法啥都没做，直接返回 source 参数，也就是上面的 ObservableCreate 对象。 总结一下，Observable.create(oos) 只是创建了一个 ObservableCreate 对象。这个方法就暂时先分析到这里，至于这个对象内部有什么东西，我们后面会说到。 observeOn(AndroidSchedulers.mainThread())既然之前的 create 方法创建了一个 ObservableCreate 对象并返回，也就是说 observeOn(Schedulers.computation()) 这个方法是调用的 ObservableCreate 这个对象上的方法。 1public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123; ObservableCreate 是继承至 Observable 的。 123public final Observable&lt;T&gt; observeOn(Scheduler scheduler) &#123; return observeOn(scheduler, false, bufferSize());&#125; Observable 的 observeOn 是 final 的，所以走的父类的方法。继续跟踪 observeOn 调用的同名方法： 12345public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); ObjectHelper.verifyPositive(bufferSize, "bufferSize"); return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));&#125; ObjectHelper 跳过。这里又是一个 onAssembly 方法的调用，我很好奇这个单词是什么意思。点进去看一下： 1234567public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) &#123; Function&lt;? super Observable, ? extends Observable&gt; f = onObservableAssembly; if (f != null) &#123; return apply(f, source); &#125; return source;&#125; 同样是一个钩子方法，现在也是有经验的人呢，再看到这个方法，就直接跳过，只关心它传递的参数和返回值就行了。它的返回值默认就是传递进来的参数。 所以，observeOn 方法就是创建并返回了一个 ObservableObserveOn 对象（大神教你起类名系列二），这里预警一下，之后像这样类似的类名差不多还有3个。 subscribeOn(Schedulers.computation())由于 observeOn 创建并返回了一个 ObservableObserveOn 对象，所以这里调用的是 ObservableObserveOn 对象上的方法。 1public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; 也是继承至 Observable 。 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 不出意料，也是 final 的，创建了一个 ObservableSubscribeOn 对象（大神教你起类名系列三）并返回。 subscribe(o)前面 subscribeOn 创建了一个 ObservableSubscribeOn 对象并返回，所以这里调用的是 ObservableSubscribeOn 这个对象上面的方法。 1public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; &#123; 1abstract class AbstractObservableWithUpstream&lt;T, U&gt; extends Observable&lt;U&gt; implements HasUpstreamObservableSource&lt;T&gt; &#123; 继承至 Observable 类。 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 这个方法也是 final 的，所以是调用的这个方法。 public final void subscribe(Observer&lt;? super T&gt; observer) { … } 这个方法是我们需要分析的重点，看看内部具体的代码吧先： 123456789101112131415161718192021public final void subscribe(Observer&lt;? super T&gt; observer) &#123; ObjectHelper.requireNonNull(observer, "observer is null"); try &#123; observer = RxJavaPlugins.onSubscribe(this, observer); ObjectHelper.requireNonNull(observer, "Plugin returned null Observer"); subscribeActual(observer); &#125; catch (NullPointerException e) &#123; // NOPMD throw e; &#125; catch (Throwable e) &#123; Exceptions.throwIfFatal(e); // can't call onError because no way to know if a Disposable has been set or not // can't call onSubscribe because the call might have set a Subscription already RxJavaPlugins.onError(e); NullPointerException npe = new NullPointerException("Actually not, but can't throw other exceptions due to RS"); npe.initCause(e); throw npe; &#125;&#125; 这里忽略 ObjectHelper 和异常处理的代码只有两行代码是关键。 先看 observer = RxJavaPlugins.onSubscribe(this, observer); 1234567public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) &#123; BiFunction&lt;? super Observable, ? super Observer, ? extends Observer&gt; f = onObservableSubscribe; if (f != null) &#123; return apply(f, source, observer); &#125; return observer;&#125; 没想到啊没想到，你这浓眉大眼的家伙也是一个钩子方法。所以这行代码相当于 obsever = observer; 接着看，subscribeActual(observer); 1protected abstract void subscribeActual(Observer&lt;? super T&gt; observer); 这是一个抽象方法，没啥好分析的。 接下来我们要进入正题了，根据我们编写的代码，是 ObservableSubscribeOn 这个对象调用了 subscribe 方法，所以我们看看这个类的 subscribeActual 方法。 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 这里需要注意的是 s 这个参数，后面会有很多地方看到这个参数，一定要搞清楚这个参数是谁传递过来的。比如说： 12A.subscribe(B)那么，参数 s 就是 B。 在我们的代码中是 ObservableSubscribeOn.subscribe(o); 理解了这一点，我们详细分析代码里面的内容：首先创建了一个 SubscribeOnObserver （大神教你起类名系列四）。然后调用了我们创建的对象 o 的 onSubscribe 方法： 1234@Overridepublic void onSubscribe(Disposable d) &#123;&#125; 我们的 onSubscribe 方法里面啥都没做。不过一般来说，你应该调用一下 onStart 方法。 接下来是调用 parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); setDisposable 的方法不影响流程分析，这里就先跳过了，有兴趣的可以点进去看一下。然后就是 scheduler 变量，这个变量就是我们使用 subscribeOn 传递的参数： 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; 这个 scheduler 就是 Schedulers.computation()。然后调用了它的 scheduleDirect 方法： 123public Disposable scheduleDirect(@NonNull Runnable run) &#123; return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);&#125; 1234567891011public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) &#123; final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); w.schedule(task, delay, unit); return task;&#125; 这两个方法是父类的，Schedulers.computation() 返回的是一个 ComputationScheduler 对象，这里找具体的实现类由于调用链比较长，就不给出了，自己点着点着就能找到了。看看 ComputationScheduler 有没有复写这两个方法： 123456@NonNull@Overridepublic Disposable scheduleDirect(@NonNull Runnable run, long delay, TimeUnit unit) &#123; PoolWorker w = pool.get().getEventLoop(); return w.scheduleDirect(run, delay, unit);&#125; 它覆盖了父类的第2个 scheduleDirect 方法。这里就不深入分析里面的池了。看 w.scheduleDirect(run, delay, unit);： 12345678910111213141516public Disposable scheduleDirect(final Runnable run, long delayTime, TimeUnit unit) &#123; ScheduledDirectTask task = new ScheduledDirectTask(RxJavaPlugins.onSchedule(run)); try &#123; Future&lt;?&gt; f; if (delayTime &lt;= 0L) &#123; f = executor.submit(task); &#125; else &#123; f = executor.schedule(task, delayTime, unit); &#125; task.setFuture(f); return task; &#125; catch (RejectedExecutionException ex) &#123; RxJavaPlugins.onError(ex); return EmptyDisposable.INSTANCE; &#125;&#125; 熟悉的线程池使用代码。希望看到这里你还没有忘记我们要分析的是什么。简单的归纳一下，其实就是向我们创建的 scheduler 里面提交了一个 runnable。最终这个 Runnable 肯定会执行，那么看看这个 Runnable 里面有什么代码： 1parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent))); 123456789101112final class SubscribeTask implements Runnable &#123; private final SubscribeOnObserver&lt;T&gt; parent; SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123; this.parent = parent; &#125; @Override public void run() &#123; source.subscribe(parent); &#125;&#125; run 方法里面就只有一句代码，但是我们需要搞清楚这里的 source 和 parent 分别是哪个对象。 parent 可以直接看到是 SubscribeOnObserver 对象。 source 是使用的外部类的变量。 1234public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) &#123; super(source); this.scheduler = scheduler;&#125; 这里调用了 super 方法，所以构造函数里传递的变量就是 source。 1234public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) &#123; ObjectHelper.requireNonNull(scheduler, "scheduler is null"); return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));&#125; 这里是我们之前分析过的创建 ObservableSubscribeOn 的代码，这里的 this 指的是 observeOn 创建的 ObservableObserveOn 对象。希望看到这里你没有搞晕，如果你是使用手机看的，并且看懂了，我是真的佩服。 也就是说，run 里面的代码就是调用了 ObservableObserveOn 对象的 subscribe 方法。之前我们分析过了，subscribe 方法实际上没有做什么，只是调用了 subscribeActual 方法，所以我们进入这个类内部看看： 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 我们在 observeOn 传递的 scheduler 不是 TrampolineScheduler 类型的，所以只需要看 else 的代码。这里是先创建了一个工作线程（由于我们使用的是 AndroidScheduler，所以这里是指的主线程），然后调用了 source 的 subscribe 方法。需要注意的是这里最后创建了一个 ObserveOnObserver 对象（大神教你起类名系列五）。 先看看 createWork，在 HandlerScheduler 中： 1234@Overridepublic Worker createWorker() &#123; return new HandlerWorker(handler);&#125; 返回了一个 HandlerWorker 对象。 再看 source.subscribe()，首先这里的 source 指的是 create 方法创建的 ObservableCreate 对象，调用 subscribe 传递的是 ObserveOnObserver。看看这个对象的 subscribeActual 方法： 123456789101112@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer); observer.onSubscribe(parent); try &#123; source.subscribe(parent); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); parent.onError(ex); &#125;&#125; 这里的参数 observer 是 ObserveOnObserver，source 是我们代码中创建的 oos 对象。 首先创建了一个 CreateEmitter 对象。 接着看 ObserveOnObserver 的 onSubscribe 方法做了啥： 12345678910111213141516171819202122232425262728293031@Overridepublic void onSubscribe(Disposable s) &#123; if (DisposableHelper.validate(this.s, s)) &#123; this.s = s; if (s instanceof QueueDisposable) &#123; @SuppressWarnings("unchecked") QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s; int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY); if (m == QueueDisposable.SYNC) &#123; sourceMode = m; queue = qd; done = true; actual.onSubscribe(this); schedule(); return; &#125; if (m == QueueDisposable.ASYNC) &#123; sourceMode = m; queue = qd; actual.onSubscribe(this); return; &#125; &#125; queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize); actual.onSubscribe(this); &#125;&#125; 这里代码比较长，只分析重要的代码，就是 actual.onSubscribe 这句。actual 是构造函数中赋值的，所以我们回到创建 ObserveOnObserver 的地方，actual 指的是 SubscribeOnObserver 对象。所以它调用了 SubscribeOnObserver 的 onSubscribe 方法。接下来分析一下它的 onSubscribe 方法做了什么，这里不看也不会影响流程。 123456789SubscribeOnObserver(Observer&lt;? super T&gt; actual) &#123; this.actual = actual; this.s = new AtomicReference&lt;Disposable&gt;();&#125;@Overridepublic void onSubscribe(Disposable s) &#123; DisposableHelper.setOnce(this.s, s);&#125; 这个方法调用了 setOnce 方法： 1234567891011public static boolean setOnce(AtomicReference&lt;Disposable&gt; field, Disposable d) &#123; ObjectHelper.requireNonNull(d, "d is null"); if (!field.compareAndSet(null, d)) &#123; d.dispose(); if (field.get() != DISPOSED) &#123; reportDisposableSet(); &#125; return false; &#125; return true;&#125; 这里涉及到了乐观锁等玩意，简单来说就是先判断 field 的值是否为空，如果为空则设置为 d，不为空则将 d dispose。然后判断 field 的值，由于 field 的值只能设定一次非 DISPOSED 值，所以如果不为 DISPOSED，说明已经被设置过了，再报出异常，如果为 DISPOSED 是可以再次设置的。按照正常的流程，这里只是将 field 的值设置为 d，然后返回true。这个方法可以先不用管。 回到主线流程上，source.subscribe(parent); 这是最重要的一句代码。source 是在构造函数赋值的，看看构造方法： 1234public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) &#123; ObjectHelper.requireNonNull(source, "source is null"); return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));&#125; 也就是说这里的 source 是我们代码中创建的 oos 对象。parent 是新创建的 CreateEmitter 对象。看看我们 oos 的 subscribe 方法： 123456789@Overridepublic void subscribe(ObservableEmitter&lt;Integer&gt; e) throws Exception &#123; Log.e("aprz", Thread.currentThread().getName()); final int max = 100; for (int i = 1; i &lt;= max; i++) &#123; e.onNext(i); &#125; e.onComplete();&#125; 这里就是事件开始的起点。所有的事件都由 ObservableEmitter 开始发送，看看它的代码，它是一个接口，在我们的例子中，它的实现类是 CreateEmitter，所有我们分析这个类的 onNext 方法： 12345678910@Overridepublic void onNext(T t) &#123; if (t == null) &#123; onError(new NullPointerException("onNext called with null. Null values are generally not allowed in 2.x operators and sources.")); return; &#125; if (!isDisposed()) &#123; observer.onNext(t); &#125;&#125; isDisposed 方法返回 false 才会去调用 observer 的 onNext 方法，这个 observer 是谁呢? 看到这里我们就要从后往前推一遍之前的代码了，不管你绝不绝望，反正我是很绝望。这的 observer 是 ObserveOnObserver 对象。 接下来我们就进入 ObserveOnObserver 里面，看看它接受事件之后做了什么，上面的参数 e 就是： 1234567891011@Overridepublic void onNext(T t) &#123; if (done) &#123; return; &#125; if (sourceMode != QueueDisposable.ASYNC) &#123; queue.offer(t); &#125; schedule();&#125; 调用了 schedule 方法： 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; 向 work 中提交了一个 Runnable，这里传递的是 this。说明它自己肯定实现了这个接口，我们看看它的 run 方法做了啥： 12345678@Overridepublic void run() &#123; if (outputFused) &#123; drainFused(); &#125; else &#123; drainNormal(); &#125;&#125; 这里一般是走 drainNormal 吧，我猜的，我们分析这个方法吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344void drainNormal() &#123; int missed = 1; final SimpleQueue&lt;T&gt; q = queue; final Observer&lt;? super T&gt; a = actual; for (;;) &#123; if (checkTerminated(done, q.isEmpty(), a)) &#123; return; &#125; for (;;) &#123; boolean d = done; T v; try &#123; v = q.poll(); &#125; catch (Throwable ex) &#123; Exceptions.throwIfFatal(ex); s.dispose(); q.clear(); a.onError(ex); worker.dispose(); return; &#125; boolean empty = v == null; if (checkTerminated(d, empty, a)) &#123; return; &#125; if (empty) &#123; break; &#125; a.onNext(v); &#125; missed = addAndGet(-missed); if (missed == 0) &#123; break; &#125; &#125;&#125; 代码很长，具体做了啥我们暂时不用关心，只需要注意到 a.onNexe(v) 这行代码，这个 a 是 actual 变量，actual 又是 SubscribeOnObserver 对象，我们看看它的 onNext 方法： 1234@Overridepublic void onNext(T t) &#123; actual.onNext(t);&#125; 很简单，这里的 actual 就是我们创建的 o 了，所以最终调用到了我们的代码里面。 好了，到这里一个完整的流程就整理出来了，但是还有一个问题没有解决，就是线程切换是发生在哪里。因为为了不影响整体流程的分析，所以上面并没有去分析线程切换的东西，下面开始分析。 直接从 subscribeOn 开始，看 ObservableSubscribeOn 的代码 12345678@Overridepublic void subscribeActual(final Observer&lt;? super T&gt; s) &#123; final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s); s.onSubscribe(parent); parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));&#125; 从这里开始就进行了线程的切换，根据上面的分析我们知道这里是将 SubscribeTask 作为一个 Runnable 对象给提交进了我们指定的 scheduler （subscribeOn 传递的）中。所以后面的流程都是在 scheduler 所在的线程在运行。 再看 observeOn，看 ObservableObserveOn 的代码。 12345678910@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) &#123; if (scheduler instanceof TrampolineScheduler) &#123; source.subscribe(observer); &#125; else &#123; Scheduler.Worker w = scheduler.createWorker(); source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize)); &#125;&#125; 这里的线程切换是发生在 ObserveOnObserver 这个对象的里面。 12345void schedule() &#123; if (getAndIncrement() == 0) &#123; worker.schedule(this); &#125;&#125; schedule 的流程，我们上面分析过，worker.schedule(this) 这行代码就发生了线程切换，是将 this 作为 Runnable 对象提交到了我们指定的（observerOn 传递的）scheduler 中。具体分析，由于之前的流程是在别的线程中，所以想要进行线程切换，最先想到的肯定是 Handler。由于我们传递的是 AndroidSchedulers.mainThread()，所以我们就分析这个吧。 AndroidSchedulers.mainThread() 的实现是 HandlerScheduler。看看它的 schedule 方法： 1234567891011121314151617181920212223242526@Overridepublic Disposable schedule(Runnable run, long delay, TimeUnit unit) &#123; if (run == null) throw new NullPointerException("run == null"); if (unit == null) throw new NullPointerException("unit == null"); if (disposed) &#123; return Disposables.disposed(); &#125; run = RxJavaPlugins.onSchedule(run); ScheduledRunnable scheduled = new ScheduledRunnable(handler, run); Message message = Message.obtain(handler, scheduled); message.obj = this; // Used as token for batch disposal of this worker's runnables. handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay))); // Re-check disposed state for removing in case we were racing a call to dispose(). if (disposed) &#123; handler.removeCallbacks(scheduled); return Disposables.disposed(); &#125; return scheduled;&#125; post 了一个 msg，这样就完成了线程的切换。 下面上一张图，有助于理解和记忆： 图中箭头的方向为事件传播的方向，如果定义方法调用的方向为顺序，那么当调用observable.subscribe(observer)的时候，⚠️订阅subscribe顺序是从下游回溯到上游，然后上游产生事件并发送，事件再传输到下游。 每次执行 observerOn 和 subscribeOn 的时候，内部都会创建一个新的 Observable 和 Observer对象。 下游的observable 会引用上游的 observable，即 source 变量。 上游的observer 会引用下游的 observer，即 actual 变量。 多次指定上游的线程只有第一次指定的有效, 也就是说多次调用subscribeOn() 只有第一次的有效, 其余的会被忽略。因为被观察者发送事件在所有上游线程切换完成之后才执行。 多次指定下游的线程是可以的, 也就是说每调用一次observeOn() , 下游的线程就会切换一次。因为接受事件在每个ObserveOnObserver对象的onNext中都会切换一次。 最后我们 subscribe 的时候，是调用的最后创建的 observable 的方法。而每个 observable 内部又调用了 source 的 subscribe 方法，这样就形成了一层一层往上传递的调用链。当调用到最前面的一个 observable 的时候，就是我们自己创建的 source Observable，在这里我们需要手动触发该与该 observable 对应的 observer 对象的 onNext 方法。而 observer 的 onNext 方法的内部又调用了 actual 的 onNext 方法，这样就形成了一层一层往后传递的调用链。 虽然在我们的例子中，CreateEmitter 并不是一个 observer ，但是它也有 onNext 等方法，可以把它看做一个 observer。 如此，RxJava 的一个流程就理清楚了。这货的流程和 OkHttp 怎么有点像，只是稍微有点不一样。 补充一下关于背压的知识：在异步订阅的时候，使用 Observable，默认的缓冲大小是 128，超过 这个数量之后会 resize，也就是说会缓冲所有的事件，这样就会导致内存占用一直增加。]]></content>
      <categories>
        <category>拆轮子</category>
      </categories>
      <tags>
        <tag>Rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Window和WindowManager]]></title>
    <url>%2F2018%2F03%2F06%2F%E7%90%86%E8%A7%A3Window%E5%92%8CWindowManager%2F</url>
    <content type="text"><![CDATA[Window表示一个窗口的概念, 如有需要在桌面上显示一个类似悬浮窗的东西, 那么这种效果就需要Window来实现. Window是一个抽象类, 具体实现是PhoneWindow. 如果想要创建一个Window只需要通过WindowManager即可完成. WindowManager是外界访问Window的入口, Window具体实现位于WindowManagerService中, WM和WMS的交互是一个IPC过程. Android中所有的视图都是通过Window来呈现的, 不管是Activity, Dialog, Toast他们的视图实际上都是附加在Window上的. Window和WindowManager先演示使用WindowManger添加一个Window. 1234567891011121314151617public void addWindow()&#123; Button button = new Button(this); button.setText("动态添加"); WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT); layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED; layoutParams.gravity = Gravity.LEFT | Gravity.TOP; layoutParams.x = 100; layoutParams.y = 300; getWindowManager().addView(button, layoutParams); &#125; ​ Flag参数表示Window的属性,这些属性可以控制Window的显示特性. 下面是常用的属性: FLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点, 而不需要接收各种输入事件, 此标记会同时启动FLAG_NOT_TOUCH_MODAL, 最终事件会直接传递给下层的具有焦点的Window. FLAG_NOT_TOUCH_MODAL: 这种模式下, 系统会将当前Window区域以外的点击事件传递给底层的Window, 当前Window区域以内的单击事件则自己处理. 这个标记很重要, 一般来说都需要开启此标记, 否则其他Window将无法接收到单击事件. FLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上. Type参数表示Window的类型 Window共有三种类型, 分别是应用Window, 子Window, 系统Window. 应用类Window对应着一个Activity. 子Window不能单独存在, 他需要附属在特定的父Window中,比如常见的Dialog就是一个子Window. 系统Window是需要声明权限才能创建的Window, 比如Toast和系统状态栏都是系统的Window. Window是分层的, 每个Window都有对应的z-ordered, 层级大的会覆盖在层级小的Window的上面, 这和HTML中的z-index的概念一样. 应用Window的层级范围是1~99, 子Window的层级范围是1000~1999, 系统Window的层级范围是2000~2999. 如果想要在最顶层显示, 可以选择使用TYPE_SYSTEM_OVERLAY, TYPE_SYSTEM_ERROR. 如果采用了TYPE_SYSTEM_ERROR同时要声明权限: 1&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; 如果不声明那么在创建的时候就会报错. WindowManager常用的功能 在ViewManager接口中定义了三个方法. 就是我们常用的方法添加View,删除View,修改View. WM继承了这个接口. 12345public interface ViewManager &#123; public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view);&#125; Window的内部机制Window是一个抽象的概念, 每一Window都对应着一个View和一个ViewRootImpl, Window和View通过ViewRootImpl来建立联系, 因此Window并不是实际存在的, 他是以View的形式存在. 通过WindowManager的定义和提供的三个接口方法看出都是针对View的. 说明View才是Window存在的实体. 而在实际的使用中无法直接访问Window, 对Window的访问都是必须通过WM. Window的添加过程Window的添加过程需要通过WindowManager的addView()来实现, 而WindowManager是一个接口, 它的真正实现是WindowManagerImpl类, 在WindowManagerImpl中Window的三大操作如下. 1234567891011121314151617@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow);&#125;@Overridepublic void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.updateViewLayout(view, params);&#125; @Overridepublic void removeView(View view) &#123; mGlobal.removeView(view, false);&#125; WindowManagerImpl并没有直接实现Window的三大操作, 而是全部交给了WindowManagerGlobal来处理. WindowManagerGlobal以工厂的形式向外提供自己的实例. 而WindowManagerImpl这种工作模式就典型的桥接模式, 将所有的操作全部委托给WindowManagerGlobal来实现. WindowManagerGlobal的addView()主要分为 检查所有参数是否合法, 如果是子Window那么还需要调整一些布局参数. 创建ViewRootImpl并将View添加到列表中. 通过ViewRootImpl来更新界面并完成Window的添加过程. 这个过程是通过ViewRootImpl#setView()来完成的. View的绘制过程是由ViewRootImpl来完成的, 在内部会调用requestLayout()来完成异步刷新请求. 而scheduleTraversals()实际上是View绘制的入口. 接着会通过WindowSession(一个Binder对象，实现类是Session)完成Window的添加过程(Window的添加过程是一次IPC调用). 最终会通过WindowManagerService来实现Window的添加. WindowManagerService内部会为每一个应用保留一个单独的Session. Window的删除过程Window 的删除过程和添加过程一样, 都是先通过WindowManagerImpl后, 在进一步通过WindowManagerGlobal的removeView()来实现的. 123456789101112public void removeView(View view, boolean immediate) &#123; synchronized (mLock) &#123; int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) &#123; return; &#125; throw new IllegalStateException("Calling with view " + view + " but the ViewAncestor is attached to " + curView); &#125;&#125; 方法内首先通过findViewLocked来查找待删除的View的索引, 这个过程就是建立数组遍历, 然后调用removeViewLocked来做进一步的删除. 123456789101112131415161718private void removeViewLocked(int index, boolean immediate) &#123; ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) &#123; InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) &#123; imm.windowDismissed(mViews.get(index).getWindowToken()); &#125; &#125; boolean deferred = root.die(immediate); if (view != null) &#123; view.assignParent(null); if (deferred) &#123; mDyingViews.add(view); &#125; &#125;&#125; 这里通过ViewRootImpl的die()完成来完成删除操作. die()方法只是发送了请求删除的消息后就立刻返回了, 这个时候View并没有完成删除操作, 所以最后会将其添加到mDyingViews中, mDyingViews表示待删除的View的列表. 1234567891011121314151617boolean die(boolean immediate) &#123; // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate &amp;&amp; !mIsInTraversal) &#123; doDie(); return false; &#125; if (!mIsDrawing) &#123; destroyHardwareRenderer(); &#125; else &#123; Log.e(TAG, "Attempting to destroy the window while drawing!\n" + " window=" + this + ", title=" + mWindowAttributes.getTitle()); &#125; mHandler.sendEmptyMessage(MSG_DIE); return true;&#125; die方法中只是做了简单的判断, 如果是异步删除那么就发送一个MSG_DIE的消息, ViewRootImpl中的Handler会处理此消息并调用doDie(); 如果是同步删除, 那么就不发送消息直接调用doDie()方法. 在doDie()方法中会调用dispatchDetachedFromWindow()方法, 真正删除View的逻辑在这个方法内部实现. 其中主要做了四件事: 垃圾回收的相关工作, 比如清除数据和消息,移除回调. 通过Session的remove方法删除Window: mWindowSession.remove(mWindow), 这同样是一个IPC过程, 最终会调用WMS的removeWindow()方法. 调用View的dispatchDetachedFromWindow()方法, 内部会调用View的onDetachedFromWindow()以及onDetachedFromWindowInternal(). 而对于onDetachedFromWindow()就是在View从Window中移除时, 这个方法就会被调用, 可以在这个方法内部做一些资源回收的工作. 比如停止动画,停止线程。 调用WindowManagerGlobal#doRemoveView方法刷新数据, 包括mRoots, mParams, mDyingViews, 需要将当前Window所关联的这三类对象从列表中删除。 Window的更新过程WindowManagerGlobal#updateViewLayout()方法做的比较简单, 它需要更新View的LayoutParams并替换掉老的LayoutParams, 接着更新ViewRootImpl中的LayoutParams. 这一步主要是通过setLayoutParams()方法实现. 12345678910111213141516171819public void updateViewLayout(View view, ViewGroup.LayoutParams params) &#123; if(view == null) &#123; throw new IllegalArgumentException("view must not be null"); &#125; if(!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException("Params must be WindowManager.LayoutParams"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; view.setLayoutParams(wparams); synchronized(mLock) &#123; int index = findViewLocked(view, true); ViewRootImpl root = mRoots.get(index); mParams.remove(index); mParams.add(index, wparams); root.setLayoutParams(wparams, false); &#125;&#125; 在ViewRootImpl中会通过scheduleTraversals()来对View重新布局, 包括测量,布局,重绘. 除了View本身的重绘以外, ViewRootImpl还会通过WindowSession来更新Window的视图, 这个过程最后由WMS的relayoutWindow()实现，同样是一个IPC过程. Window的创建过程View是Android中视图的呈现方式, 但是View不能单独存在, 它必须依附在Window这个抽象的概念上面, 有视图的地方就有Window,因此Activity、Dialog、Toast等视图都对应着一个Window。 Activity的Window创建过程Activity的大体启动流程: 最终会由ActivityThread中的PerformLaunchActivity()来完成整个启动过程, 这个方法内部会通过类加载器创建Activity的实例对象, 并调用其attach()方法为其关联运行过程中所依赖的一系列上下文环境变量. 代码如下: 1234567891011121314151617181920private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; Activity activity = null; //获得类加载器 java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); ... Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); return activity;&#125; 在attach()方法里, 系统会创建Activity所属的Window对象并为其设置回调接口, Window对象的创建是通过PolicyManager#makeNewWindow()方法实现. 由于Activity实现了Window的CallBack接口, 因此当Window接收到外界的状态改变的时候就会回调Activity方法. 比如说我们熟悉的onAttachedToWindow(), onDetachedFromWindow(), dispatchTouchEvent()等等.代码如下 1234567891011mWindow = new PhoneWindow(this);mWindow.setCallback(this);mWindow.setOnWindowDismissedCallback(this);mWindow.getLayoutInflater().setPrivateFactory(this);if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode);&#125;if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions);&#125;mUiThread = Thread.currentThread(); 那么Activity视图是怎么附属在Window上的呢? 查看经常使用的setContentView()方法干了什么 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar();&#125; Activity将具体实现交给了Window处理, 而Window的具体实现就是PhoneWindow, 所以只需要看PhoneWindow的相关逻辑分为以下几步: 如果没有DecorView, 那么就创建它. 由installDecor()--&gt;generateDecor()触发 将View添加到DecorView的mContentParent中 12//将Activity的布局文件加载到DecorView的mContentParent中mLayoutInflater.inflate(layoutResID, mContentParent); 回调Activity的onContentChanged()通知activity视图已经发生改变 这个时候DecorView已经被创建并初始化完毕, Activity的布局文件也已经添加成功到DecorView的mContentParent中. 但是这个时候DecorView还没有被WindowManager正式添加到Window中. 虽然早在Activity的attach方法中window就已经被创建了, 但是这个时候由于DecorView并没有被WindowManager识别, 所以这个时候的Window无法提供具体功能, 因为他还无法接收外界的输入信息. 在ActivityThread#handleResumeActivity()方法中, 首先会调用Activity#onResume(), 接着会调用Activity#makeVisible(), 正是在makeVisible方法中, DecorView真正的完成了添加和显示这两个过程. 如下: 12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);&#125; Dialog的Window创建过程Dialog的Window的创建过程和Activity类似, 有如下几步 1. 创建Window Dialog中的Window同样是通过PolicyManager创建的makeNewWindow创建的，实际上就是PhoneWindow, 这个过程和Activity的Window创建过程一致. 2. 初始化DecorView并将Dialog的视图添加到DecorView中 123public void setContentView(int layoutResID) &#123; mWindow.setContentView(layoutResID);&#125; 这个过程也类似, 都是通过Window去添加指定的布局文件. 3. 将DecorView添加到Window中并显示 在Dialog的show方法中, 会通过WindowManager将DecorView添加Window中. 123mWindowManager.addView(mDecor, l);mShowing = true; sendShowMessage(); 普通的Dialog有一个特殊之处, 那就是必须采用Activity的Content, 如果采用Application的Content, 那么就会报错. 报的错是没有应用token所导致的, 而应用token一般只有Activity才拥有. 还有一种方法. 系统Window比较特殊, 他可以不需要token, 因此只需要指定对话框的Window为系统类型就可以正常弹出对话框. 12345//JAVA 给Dialog的Window改变为系统级的Windowdialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR);//XML 声明权限&lt;uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/&gt; Toast的Window创建过程Toast和Dialog不同, 它的工作过程就稍显复杂. 首先Toast也是基于Window来实现的. 但是由于Toast具有定时取消的功能, 所以系统采用了Handler. 在Toast的内部有两类IPC过程, 第一类是Toast访问NotificationManagerService后面简称NMS. 第二类是NotificationManagerService回调Toast里的TN接口。 Toast属于系统Window, 它内部的视图有两种方式指定, 一种是系统默认的样式, 另一种是通过setView方法来指定一个自定义View. 不管如何, 他们都对应Toast的一个View类型的内部成员mNextView. Toast内部提供了cancel和show两个方法. 分别用于显示和隐藏Toast. 他们内部是一个IPC过程，代码如下： 1234567891011121314151617181920212223242526public void show() &#123; if (mNextView == null) &#123; throw new RuntimeException("setView must have been called"); &#125; INotificationManager service = getService(); String pkg = mContext.getOpPackageName(); TN tn = mTN; tn.mNextView = mNextView; try &#123; service.enqueueToast(pkg, tn, mDuration); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125;public void cancel() &#123; mTN.hide(); try &#123; getService().cancelToast(mContext.getPackageName(), mTN); &#125; catch (RemoteException e) &#123; // Empty &#125;&#125; 显示和隐藏Toast都是需要通过NMS来实现的. 由于NMS运行在系统的进程中, 所以只能通过远程调用的方式来显示和隐藏Toast. 而TN这个类是一个Binder类. 在Toast和NMS进行IPC的过程中, 当NMS处理Toast的显示或隐藏请求时会跨进程回调TN的方法. 这个时候由于TN运行在Binder线程池中, 所以需要通过Handler将其切换到当前主线程. 所以由其可知, Toast无法在没有Looper的线程中弹出，因为Handler需要使用Looper才能完成切换线程的功能。 12345678910111213141516 if (!isSystemToast) &#123; int count = 0; final int N = mToastQueue.size(); for (int i=0; i&lt;N; i++) &#123; final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) &#123; count++; // MAX_PACKAGE_NOTIFICATIONS == 50 if (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123; Slog.e(TAG, "Package has already posted " + count + " toasts. Not showing more. Package=" + pkg); return; &#125; &#125; &#125;&#125; 对于非系统应用来说, 最多能同时存在对Toast封装的ToastRecord上限为50个. 这样做是为了防止DOS(Denial of Service). 如果不这样, 当通过大量循环去连续的弹出Toast, 这将会导致其他应用没有机会弹出Toast, 那么对于其他应用的Toast请求, 系统的行为就是拒绝服务, 这就是拒绝服务攻击的含义. 在ToastRecord被添加到mToastQueue()中后, NMS就会通过showNextToastLocked()方法来显示当前的Toast。Toast的显示是由ToastRecord的callback来完成的. 这个callback实际上就是Toast中的TN对象的远程Binder. 通过callback来访问TN中的方法是需要跨进程的. 最终被调用的TN中的方法会运行在发起Toast请求的应用的Binder线程池. 123456789101112131415161718void showNextToastLocked ()&#123; ToastRecord record = mToastQueue.get(0); while(record != null)&#123; if(DBG) Slog.d(TAG,"show pkg=" + record.pkg + "callback=" + record.callback); try&#123; record.callback.show(); scheduleTimeoutLocked(record); return; &#125;&#125;private void scheduleTimeoutLocked(ToastRecord r)&#123; mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay);&#125; 这个 callback 就是 Toast 中的 TN 对象的远程 Binder，最终被调用的 TN 中的方法会运行在发起 Toast 请求的应用的 Binder 线程池中。 从如上代码所示在Toast显示以后, NMS通过这个方法来发送一个延时消息, 具体取决Toast的时长. LONG_DELAY, SHORT_DELAY分别对应着3.5秒和2秒. 当延时时间达到的时候. NMS会通过cancelToastLocked()方法来隐藏Toast并将其从mToastQueue中移除, 这个时候如果mToastQueue中还有其余Toast那么NMS就继续显示其他. Toast的隐藏也会通过ToastRecord的callback完成的.同样是一次IPC过程. 方式和Toast显示类似. 12345678910111213void cancelToastLocked(int index) &#123;ToastRecord record = mToastQueue.get(index);try &#123; record.callback.hide();&#125; catch (RemoteException e) &#123; Slog.w(TAG, "Object died trying to hide notification " + record.callback + " in package " + record.pkg); // don't worry about this, we're about to remove it from // the list anyway&#125;mToastQueue.remove(index);...&#125; 以上基本说明Toast的显示和影响过程实际上是通过Toast中的TN这个类来实现的. 他有两个方法show(), hide(). 分别对应着Toast的显示和隐藏. 由于这两个方法是被NMS以跨进程的方式调用的, 因此他们运行在Binder线程池中. 为了将执行环境切换到Toast请求所在线程中, 在他们内部使用了handler,如下 1234567891011121314@Overridepublic void show() &#123; if (localLOGV) Log.v(TAG, "SHOW: " + this); mHandler.post(mShow);&#125;/*** schedule handleHide into the right thread*/@Overridepublic void hide() &#123; if (localLOGV) Log.v(TAG, "HIDE: " + this); mHandler.post(mHide);&#125; 上面代码中, mShow, mHide是两个Runnable, 他们内部分别调用了handleShow和handleHide方法. 所以这两个方法才是真正完成隐藏和显示Toast的地方. TN的handleShow中会将Toast的视图添加到Window中. TN的handleHide中会将Toast的视图从Window中移除. 具体实现代码如下: 123456789101112//handleShow() mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); mWM.addView(mView, mParams); //handleHide()if (mView != null) &#123; if (mView.getParent() != null) &#123; if (localLOGV) Log.v(TAG, "REMOVE! " + mView + " in " + this); mWM.removeView(mView); &#125; mView = null;&#125; 关于Toast流程已经完事. 除了说到的Activity, Dialog, Toast. 还有PopupWindow菜单栏, 状态栏都是通过Window来实现的.]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Window</tag>
        <tag>WindowManager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画深入分析]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[View动画View动画作用的对象是View, 它支持四种动画效果平移, 缩放, 旋转, 透明. 除了这四种典型的变化效果. 帧动画也属于View动画. View动画的种类View动画的四种变换效果对应着Animation的四个子类:TranslateAnimation, ScaleAnimation, RotateAnimation和AlphaAnimation. 对于View动画建议采用XML来定义动画 名称 标签 子类 效果 平移动画 &lt;translate&gt; TranslateAnimation 移动View 缩放动画 &lt;scale&gt; ScaleAnimation 放大或者缩小View 旋转动画 &lt;rotate&gt; RotateAnimation 旋转View 透明度动画 &lt;alpha&gt; AlphaAnimation 改变View的透明度 创建的动画的xml文件. 是放在res/anim这个文件夹下的. View动画描述文件的固有语法如下 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:shareInterpolator="true" android:interpolator="@android:anim/decelerate_interpolator" android:fillAfter="true"&gt; &lt;alpha android:fromAlpha="float" android:toAlpha="float"/&gt; &lt;scale android:fromXScale="float" android:toXScale="float" android:fromYScale="float" android:toYScale="float" android:pivotX="float" android:pivotY="float"/&gt; &lt;translate android:fromXDelta="float" android:toXDelta="float" android:fromYDelta="float" android:toYDelta="float"/&gt; &lt;rotate android:fromDegrees="float" android:toDegrees="float" android:pivotY="float" android:pivotX="float"/&gt;&lt;/set&gt; 关于动画我们可以只设置一种也可以设置多种的组合. set标签对应着AnimationSet类, 标签中的属性的意义: shareInterpolator 表示集合中的动画是否和集合共享一个插值器. 如果集合不指定插值器, 那么子动画就需要单独制定所需的插值器或者使用默认值 fillAfter 是否保留动画结束之后的状态 translate标签表示平移动画, 对应着TranslateAnimation类 属性值的意义就是from开头的为开始起点, to开头的结束点 scale标签表示缩放动画, 对应着ScaleAnimation类 属性值的意思from开头的表示开始时原图缩放的百分比. 用浮点数表示1表示100%(无变化),0.5表示50%(原来的一般), 2表示200%(原来的两倍). to开头的表示结束时的百分比. pivot表示缩放的轴点. rotate标签表示旋转动画, 对应着RotateAnimation类 fromDegrees旋转的开始角度, toDegrees旋转的结束角度. pivot旋转的轴点 alpha标签表示透明度动画, 对应AlphaAnimation类 fromAlpha表示透明度的起始值, toAlpha表示透明度的结束值. 上面这些标签还有一些通用的属性值. 例如duration执行时间. xml如果声明了之后那么我们就该在代码中应用了. 如下: 123View btn_main = findViewById(R.id.parent);Animation animation = AnimationUtils.loadAnimation(this, R.anim.temp);btn_main.startAnimation(animation); 同样也可以不需要xml直接在代码中生成动画对象. 123AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0);alphaAnimation.setDuration(1000);btn_main.startAnimation(alphaAnimation); 在开始动画之前可以给动画添加一个监听setAnimationListener()这样在动画开始结束和每一次循环下一次的时候都可以在回调方法中监听到. 12345public static interface AnimationListener &#123; void onAnimationStart(Animation animation); void onAnimationEnd(Animation animation); void onAnimationRepeat(Animation animation);&#125; 自定义View动画如果需要自定义View动画, 首先应该继承Animation这个抽象类来派生出一种新动画. 然后重写initialize()和applyTransformation()方法. 在initialize中做一些初始化动作, 在applyTransformation()中进行相应矩阵变换, 很多时候需要采用Camera来简化矩阵变换的过程. 而View动画变化主要就是矩阵的变换过程. 这里举一个Android中ApiDemo的一个自定义View动画. 大概效果就是这样可以参照官网的api也可在包中的MyRotateAnimation 帧动画帧动画是顺序播放一组预先定义好的图片, 类似于电影. 系统提供了AnimationDrawable来使用帧动画. 同样在xml中声明, 在res/drawable/包下创建文件, 并替换每个drawable图片即可 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android" android:oneshot="false"&gt; &lt;item android:drawable="@drawable/xx1" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx2" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx3" android:duration="500"/&gt; &lt;item android:drawable="@drawable/xx4" android:duration="500"/&gt;&lt;/animation-list&gt; 将上述的Drawable作为View的背景并通过Drawable来播放动画. 12AnimationDrawable background = (AnimationDrawable) iv_main.getBackground();background.start(); 帧动画比较容易引起OOM，应该尽量避免使用。 View动画的特殊使用场景前面介绍的View动画都是作用在某一个View对象上的. 还可以针对ViewGroup控制其子元素. 或者针对Activity切换的动画. LayoutAnimationLayoutAnimation作用于ViewGroup上的. 为ViewGroup指定一个动画, 这样当它的子元素出场时都会具有这种动画效果. 常用的使用场景是在ListView和GridView. 使用很简单步骤如下. 在res/anim/anim_item文件夹下创建xml文件. 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layoutAnimation xmlns:android="http://schemas.android.com/apk/res/android" android:delay="0.5" android:animationOrder="random" android:animation="@anim/layout"&gt; &lt;/layoutAnimation&gt; delay: 子元素开始动画的延迟时间, 传入值是浮点值. 1为100%. 例如如果是0.5 入场动画周期为300ms(下面关联动画的duration时间), 那么每个子元素都需要延迟150ms才能播放入场动画. 而且这个时间会根据item的递增而增加. 比方说第一个为延迟150ms, 第二个就是300ms依次类推. animationOrder: 子元素动画的顺序, 有三种选择normal,reverse,random. reverse表示排在后面的元素先执行入场动画. random随机子元素执行动画. animation: 为子元素指定具体的入场动画. 里面放的就是针对View的animation动画的xml layoutAnimation声明完成之后, 在要作用的ViewGroup标签中增加android:layoutAnimation:&quot;@anim/xxx&quot;进行关联即可. 同样也可以通过Java代码动态创建LayoutAnimation类来实现. 12345678910//获得子元素需要执行的View动画Animation animation = AnimationUtils.loadAnimation(this, R.anim.anim_item); //创建一个LayoutAnimation动画对象LayoutAnimationController controller = new LayoutAnimationController(animation);controller.setDelay(0.5f);controller.setOrder(LayoutAnimationController.ORDER_RANDOM); //对ViewGrop进行绑定listView.setLayoutAnimation(controller); Activity的切换效果Activity默认是有一种切换效果的. 如果需要自定义切换效果, 主要用到overridePendingTransition()这个方法, 这个方法必须在startActivity()或者finish()之后调用才会生效 需要的形参有两个, 第一个是被打开时候所需的动画资源id, 第二个是被暂停时,所需的动画资源id. 属性动画属性动画是API新加入的特性, 和View动画不同, 它对作用对象进行了扩展, 属性动画可以对任何对象做动画. 属性动画不再像View动画那样只能支持四种简单的交换 . 属性动画中有valueAnimator. ObjectAnimator, AnimatorSet等概念 使用属性动画属性动画可以对任何对象的属性进行动画而不仅仅是View, 动画默认时间间隔为300ms, 默认帧率10ms/帧. 可以达到的效果为: 在一段时间间隔内完成对象从一个属性值到另一个属性值的改变. 属性动画是从API11增加的. 如: 改变一个对象的背景色属性, 典型的改变View的背景色, 下面的动画可以让背景颜色的渐变, 动画会无限循环而且会有反转效果. 123456ObjectAnimator colorAnim = ObjectAnimator.ofInt(activity_main, "backgroundColor", 0xffffa000, 0xffffa0ff); colorAnim.setDuration(5000); colorAnim.setEvaluator(new ArgbEvaluator()); colorAnim.setRepeatCount(ValueAnimator.INFINITE); colorAnim.setRepeatMode(ValueAnimator.REVERSE); colorAnim.start(); 动画集合,5秒内对View旋转平移缩放透明 12345678910111213AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether( ObjectAnimator.ofFloat(iv_main, "rotationX", 0,360), ObjectAnimator.ofFloat(iv_main, "rotationY", 0,360), ObjectAnimator.ofFloat(iv_main, "rotation", 0,360), ObjectAnimator.ofFloat(iv_main, "translationX", 0,200), ObjectAnimator.ofFloat(iv_main, "translationY", 0,200), ObjectAnimator.ofFloat(iv_main, "scaleX", 1,1.5f), ObjectAnimator.ofFloat(iv_main, "scaleY", 1,1.5f), ObjectAnimator.ofFloat(iv_main, "alpha", 1, 0.25f, 1) ); animatorSet.setDuration(5*1000).start(); 也可以使用xml的形式形式来声明 1234567891011121314151617181920212223242526&lt;set android:ordering=["together" | "sequentially"]&gt; &lt;objectAnimator android:propertyName="string" android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"]/&gt; &lt;animator android:duration="int" android:valueFrom="float | int | color" android:valueTo="float | int | color" android:startOffset="int" android:repeatCount="int" android:repeatMode=["repeat" | "reverse"] android:valueType=["intType" | "floatType"]/&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; 代码中使用： 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator);set.setTarget(mButton);set.start(); 理解插值器和估值器TimeInterpolator时间插值器, 作用是根据时间流逝的百分比来计算当前属性值改变的百分比. 系统预置的有 LinearInterpolator(线性插值器:匀速动画) AccelerateDecelerateInterpolator(加速减速插值器:动画两头慢中间快) DecelerateInterpolator(减速插值器:动画越来越慢) TypeEvaluator 类型估值算法, 也叫估值器. 作用是根据当前属性改变的百分比来计算改变后的属性值. 系统预置的估值器有 IntEvaluator 整形估值器 FloatEvaluator 浮点型估值器 ArgbEvaluator Color属性估值器 属性动画中的插值器和估值器都很重要, 他们是实现非匀速动画的重要手段 属性动画要求对象的该属性有set``get方法. 插值器和估值器算法除了系统提供的外. 也可以自定义. 实现方式也很简单, 因为插值器和估值算法都是一个接口, 且内部都只有一个方法, 我们只要派生一个类实现接口接可以. 具体就是: 自定义插值器需要实现Interpolator或者TimeInterpolator. 自定义估值算法需要实现TypeEvaluator 属性动画的监听器属性动画提供了监听器用于监听动画的播放过程 主要有两个接口AnimatorUpdateListener和AnimatorListener接口. AnimatorListener 通过接口的定义可以看出, 监听了动画的开始,结束,取消,以及重复播放. 系统为了方便开发提供了AnimatorListenerAdapter类. 他是AnimatorListener的适配器. 这样就不需要非得实现四个抽象方法而是按照我们的需要选择复写. AnimatorUpdateListener 比较特殊, 他会监听整个动画过程, 动画是由许多帧组成的. 每播放一帧onAnimationUpdate就会被调用一次 对任意属性做动画问题: 如果需要把一个button控件的宽增加200px. 应该怎么做? View动画只是支持四种基本的属性操作, 而Scale只是缩放. 并且还会对内容进行拉伸并且伴随着y轴的增加. 所以属性动画在这里就可以派上用场. 但是如果直接对width属性进行修改那么不会有效果. 分析一下: 属性动画的原理: 属性动画要求动画作用的对象提供该属性的get和set方法, 属性动画根据外界传递的该属性值的初始值和最终值, 以动画的效果多次调用set每次set的值也是不同. 最终达到终点值. 所以要让动画生效应该满足两个条件: 必须提供setXXX()方法, 如果动画没有传递初始值还要提供getXXX()方法. 这样系统在需要初始属性的时候在取值时不会因为没有getXXX()而发生Crash. set修改的值必须能改通过某种形式反映出来, 比如会带来UI的改变. (如果不满足这条,动画无效果但不会Crash) 那Button本身具备setWidth()为什么会无效果. 这是因为虽然Button提供了方法, 但是这个setWidth()方法并不是改变视图大小的, 他是TextView新添加的方法, View却没有这样的方法. 而setWidth()方法的内部,作用不是设置View的大小, 而是设置TextView的最大宽度和最小宽度, 这个和TextView的宽是两个东西. 这样说控件的宽度对应xml中的layout_width, 而setWidth()对应的就是xml中的width属性. 所以综合上述原因, 满足条件一而不满足条件二. 官网文档中给出了三种解决方案: 给你的对象加上get和set方法, 如果你有权限的话. 用一个类来包装(Wrapper)原始对象, 间接为其提供get和set方法. 采用valueAnimator, 监听动画过程,自己实现属性的改变. 比较： 虽然简单但是没有权限去SDK内部实现去 可以创建一个内部包装类创建set(),get()方法对View真正的宽度的LayoutParams.width属性进行修改. 采用ValueAnimator, 监听动画过程, 自己实现属性改变. ValueAnimator本身不作用于任何对象. 但是他可以对一个值做动画. 然后监听其动画过程，在动画过程中配合估值器Evaluator修改我们的对象属性. 属性动画的工作原理前面说过, 说属性画要求作用的对象提供该属性方法set方法, 属性动画根据传递的该属性的初始值和最终值, 以动画的效果多次去调用set方法. 每次set方法时候传递的值都是不一样的. 也就是随着时间的推移所传递的值会越来越接近终点值. 源码分析: 针对ObjectAnimator的start()为入口 1234567891011121314151617181920212223242526272829303132333435363738394041424344 @Overridepublic void start() &#123; // See if any of the current active/pending animators need to be canceled AnimationHandler handler = sAnimationHandler.get(); if (handler != null) &#123; int numAnims = handler.mAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; numAnims = handler.mPendingAnimations.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; numAnims = handler.mDelayedAnims.size(); for (int i = numAnims - 1; i &gt;= 0; i--) &#123; if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) &#123; ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i); if (anim.mAutoCancel &amp;&amp; hasSameTargetAndProperties(anim)) &#123; anim.cancel(); &#125; &#125; &#125; &#125; if (DBG) &#123; Log.d(LOG_TAG, "Anim target, duration: " + getTarget() + ", " + getDuration()); for (int i = 0; i &lt; mValues.length; ++i) &#123; PropertyValuesHolder pvh = mValues[i]; Log.d(LOG_TAG, " Values[" + i + "]: " + pvh.getPropertyName() + ", " + pvh.mKeyframes.getValue(0) + ", " + pvh.mKeyframes.getValue(1)); &#125; &#125; super.start();&#125; 这段代码主要就是取消和当前动画相同的动画. 最开始判断了当前动画,等待动画,延迟动画是否有一致的. 如果有那么就给取消. 最后调用了父类方法. 因为ObjectAnimator继承了ValueAnimator,所以继续看一下父类的start() 1234567891011121314151617181920212223242526private void start(boolean playBackwards) &#123; if (Looper.myLooper() == null) &#123; throw new AndroidRuntimeException("Animators may only be run on Looper threads"); &#125; mReversing = playBackwards; mPlayingBackwards = playBackwards; int prevPlayingState = mPlayingState; mPlayingState = STOPPED; mStarted = true; mStartedDelay = false; mPaused = false; updateScaledDuration(); // in case the scale factor has changed since creation time AnimationHandler animationHandler = getOrCreateAnimationHandler(); animationHandler.mPendingAnimations.add(this); if (mStartDelay == 0) &#123; // This sets the initial value of the animation, prior to actually starting it running if (prevPlayingState != SEEKED) &#123; setCurrentPlayTime(0); &#125; mPlayingState = STOPPED; mRunning = true; notifyStartListeners(); &#125; animationHandler.start();&#125; 属性动画需要运行在有Looper的线程中, 最终会调用AnimationHandler.start()方法.AnimationHandler并不是Handler, 他是一个Runnable. 后面会调到JNI层, 然后JNI层还会调回, 然后run方法会被调用, 这个Runable涉及和底层的交互. 略过. 看重点. ValueAnimator的doAnimationFrame()方法, 内部最后调用了animationFrame()方法,而animationFrame()内部调用了animateValue()方法 1234567891011121314void animateValue(float fraction) &#123; fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i &lt; numValues; ++i) &#123; mValues[i].calculateValue(fraction); &#125; if (mUpdateListeners != null) &#123; int numListeners = mUpdateListeners.size(); for (int i = 0; i &lt; numListeners; ++i) &#123; mUpdateListeners.get(i).onAnimationUpdate(this); &#125; &#125;&#125; 看到了calculateValue()方法, 这个就是计算每帧动画所对应的属性的值, 然后看一下set,get方法. 比如之前说的如果没有初始值, 则调用get方法等.. 查看PropertyValuesHolder类的setupValue() 12345678910111213141516private void setupValue(Object target, Keyframe kf) &#123; if (mProperty != null) &#123; Object value = convertBack(mProperty.get(target)); kf.setValue(value); &#125; if (mGetter == null) &#123; Class targetClass = target.getClass(); setupGetter(targetClass); if (mGetter == null) &#123; // Already logged the error - just return to avoid NPE return; &#125; &#125; Object value = convertBack(mGetter.invoke(target)); kf.setValue(value); 当动画的下一帧到来的时, setAnimatedValue()方法会将新的属性值给对象, 调用其set()方法.同样set也是反射调用 123456789void setAnimatedValue(Object target) &#123; if (mProperty != null) &#123; mProperty.set(target, getAnimatedValue()); &#125; if (mSetter != null) &#123; mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); &#125;&#125; 使用动画的注意事项 OOM问题: 在帧动画时候容易发生 内存泄漏: 如果有无限循环的属性动画, 在界面退出的时候一定要停止动画 ,否则activity会无法释放. 而View动画并不存在此问题. 兼容性问题: 主要是3.0以下系统 View动画问题: 因为是对原始View做的影像效果. 并未真正改变View的状态. 所以在动画完成之后，回导致设置setVisibility(View.GONE)无效. 这个时候调用view.clearAnimation()清除View效果即可。 不要使用px 动画交互. 系统3.0之前无论是属性动画还是View动画新的位置都无法触发单击事件.需要注意； 从3.0开始，属性动画的点击事件的触发位置为移动后位置，但是View动画仍在原位置。 硬件加速,提高动画流畅度]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>属性动画</tag>
        <tag>View动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中的Drawable]]></title>
    <url>%2F2018%2F03%2F05%2FAndroid%E7%9A%84Drawable%2F</url>
    <content type="text"><![CDATA[Drawable简介Drawable表示一种图像的概念. 优点:使用比自定义View的成本低, 非图片类型的Drawable占用空间较小. Drawable本身是一个抽象类. 是所有Drawable对象的基类, 每个具体的Drawable都是其子类. Drawable内部宽高通过getIntrinsicWidth和getIntrinsicHeight这两个方法获得. 需要注意这个内部宽高的概念针对不同的类型的Drawable, 对于图片形成的Drawable内部宽高就是图片的宽高. 而颜色所形成的Drawable没有内部宽高的概念. Drawable的内部宽高不等于它的大小. 当作为View的背景的视图, Drawable会被拉伸至View的同等大小. Drawable的分类BitmapDrawable表示一张图片, 在开发中直接引用原始图片也可, 下面给出在XML中描述稍微完整的声明 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@mipmap/ic_sample" android:antialias="true" android:dither="true" android:filter="true" android:gravity="top" android:mipMap="true" android:tileMode="repeat" &gt;&lt;/bitmap&gt; src: 图片的资源文件id(AS下可能不会自动提示mipmap,直接写入即可) antialias: 图片抗锯齿.属性值boolean 开启可以让图片变得平滑. dither: 抖动效果. 属性值Boolean. 当图片的像素配置和手机屏幕的像素配置不一致时,开启此选项可以让高质量的图片在低质量的屏幕上继续保持较好效果. 例如图片模式为ARGB8888,而设备屏幕所支持为RGB555. 开启可以让图片不会过于失真. filter: 过滤效果. 当图片尺寸被拉伸或者压缩,可以保持较好的效果. gravity: 可以对图片进行定位. 可以使用|组合属性使用. 可供使用的属性 可选项 含义 top 放在顶部, 不改变图片大小 bottom 放在底部, 不改变图片大小 left 放在左端, 不改变图片大小 right 放在右端, 不改变图片大小 center_vertical 使图片竖直居中, 不改变图片大小 fill_vertical 图片竖直方向填充容器 center_horizontal 使图片水平居中, 不改变图片大小 fill_horizontal 图片水平方向填充容器 center 图片同时水平和垂直居中, 不改变图片大小 fill 图片水平和竖直方向均填充容器, 这是默认值 clip_vertical 表示竖直方向的裁剪, 较少使用 clip_horizontal 表示水平方向的裁剪, 较少使用 mipmap: 纹理映射 默认为false tileMode: 平铺模式. 有四种值: disable关闭平铺模式(默认值), repeat普通平铺开启, mirror平铺的同时,平铺图片做镜面效果. clamp在原始图片最右边像素向右延伸, 最下边像素向下延伸.如图: NinePatchDrawable 表示一张.9格式的图片, .9图片可以自动的根据所需要的宽高进行相应的缩放并保证不失真. 和BitmapDrawable使用一样直接引入图片即可. xml方式如下: 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;nine-patch xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:src=&quot;xxxx&quot; android:dither=&quot;true&quot;/&gt; ShapeDrawable这是一种通过颜色来构成的图片, 它可以为纯色的图形, 也可以具有渐变的图形. 以下是一个简单使用方法 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:shape=&quot;rectangle&quot;&gt; &lt;!--圆角--&gt; &lt;corners android:radius=&quot;50dp&quot;/&gt; &lt;padding android:top=&quot;5dp&quot;/&gt; &lt;!--填充--&gt; &lt;solid android:color=&quot;@color/colorPrimary&quot;/&gt; &lt;!--gradient 和solid 互斥属性谁放在后面谁才有效--&gt; &lt;!--渐变--&gt; &lt;gradient android:angle=&quot;90&quot; android:startColor=&quot;#f00&quot; android:centerColor=&quot;#0f0&quot; android:endColor=&quot;#00f&quot;/&gt; &lt;!--边框--&gt; &lt;stroke android:width=&quot;30dp&quot; android:color=&quot;#ff0000&quot; /&gt;&lt;/shape&gt; 来说说具体的属性都有什么 shape: 表示图片的形状, 有四个选项: rectangle()矩形, oval(椭圆), line(横线), ring(圆环). 默认值为矩形. 另外line和ring这两个选项必须要通过&lt;stroke&gt;标签来指定线的宽度和颜色等信息, 否则无法达到预期效果.当ring这个形状还需要添加几个属性innerRadius圆环内半径, thickness圆环的厚度,外半径减去内半径的距离. 还有两个半分比的属性.效果一样. useLevel:基本都是用false, 否则可能无法到达预期的显示效果,除非被当做LevelListDrawable.如下图可以看看几个方式的样子 &lt;corner&gt; 表示shape的四个角度. 它只适用于矩形shape. 支持属性总共有五个,一个Radius和四个顶角如topLeftRadius等等. Radius的优先级最低, 会被其他属性覆盖. &lt;gradient&gt; 它与&lt;solid&gt;标签是互相互斥的. 其中solid表示纯色填充, 而gradient则表示渐变效果. 有如下属性: android:angle –渐变的角度, 默认为0, 其值必须为45的倍数. 0表示从左到右, 90表示从下到上. android:centerX –渐变的中心点横坐标(范围0~1) android:centerY –渐变的中心点纵坐标(范围0~1) android:startColor –渐变的起始色 android:centerColor –渐变的中间色 android:endColor –渐变的结束色 android:gradientRadius –渐变半径, 仅当android:type=”radial”时有效,并且当type=”radial”的时候必须声明此属性,否则崩溃 android:useLevel –一般为false.当Drawable作为StateListDrawable使用时为true android:type –渐变的类型, 有linear(线性渐变), radial(径向渐变), sweep(扫描线渐变)三种, 默认为线性渐变 看看type不同的格式什么样子 &lt;solid&gt;表示纯色填充, 通过android:color来指定颜色 &lt;stroke&gt; shape的描边,有四个属性. width描边的宽度, color描边的颜色, dashWidth组成虚线的线段的宽度, dashGap组成虚线的线段之间的间隔. &lt;padding&gt; 这个表示空白, 但是他表示的不是shape的空白, 而是包含它的View的空白, 有上下左右四个属性 &lt;size&gt; Drawable有两个方法获得固有高度. getIntrinsicWidth(), getIntrinsicHeight(). 就是如果是图片Drawable那就是图片的属性大小. 如果不是那就是返回-1. 如果size标签设置了大小. 在方法返回的时候就不再是-1. 但是作为View的背景, shape还会被拉伸或者缩为View的大小. LayerDrawable对应的标签是&lt;layer-list&gt;, 他表示一个层次化得Drawable集合.通过将不同的Drawable放置在不同的层面上从而达到一种叠加的效果. 一个这种标签可以包含多个item, 每个item表示一个Drawable. Item的结构比较简单，常见的有android:top、android:bottom、android:left、android:right，表示Drawable相对于View的上下左右偏移量。可以直接通过drawable属性引用一个Drawable也可以在item中自定义一个Drawable. 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#0ac39e" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="60dp"&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:bottom="1dp" android:left="1dp" android:right="1dp"&gt; &lt;shape android:shape="rectangle" &gt; &lt;solid android:color="#ffffff" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/layer-list&gt; StateListDrawableStateList对应&lt;selector&gt;标签, 也是Drawable集合. 这个我们经常使用在开发中的按钮状态选择器. 1234567891011121314151617181920&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize="true" android:dither="true" android:variablePadding="false" &gt; &lt;!-- 只是列举一下 &lt;item android:state_pressed="true" android:drawable="xxx"/&gt; &lt;item android:state_focused="true" android:drawable="xxx"/&gt; &lt;item android:state_hovered="true" android:drawable="xxx"/&gt; &lt;item android:state_pressed="true" android:drawable="xxx"/&gt; &lt;item android:state_selected="true" android:drawable="xxx"/&gt; &lt;item android:state_checkable="true" android:drawable="xxx"/&gt; &lt;item android:state_checked="true" android:drawable="xxx"/&gt; &lt;item android:state_enabled="true" android:drawable="xxx"/&gt; &lt;item android:state_activated="true" android:drawable="xxx"/&gt; &lt;item android:state_window_focused="true" android:drawable="xxx"/&gt; --&gt;&lt;/selector&gt; select标签对应有三个属性 constantSize: 用于StateListDrawable的固有大小是否不随着其状态改变而改变的, 因为状态的改变会切换不同的item的drawable, 而不同的drawable具有不同的固有大小. 如果为true那就是整个StateListDrawable固有大小是内部所有Drawable的最大固有大小的值. false会随之变化, 默认为false dither: 是否开启抖动效果, 默认为true variablePadding: 表示padding是否随着状态的改变而改变, padding取得值是所有Drawable的最大值. 默认为false. 不会随之改变. &lt;item&gt;标签也比较简单, 指定一个drawable,并加一个状态判断值. 下面给出常见的状态判断 状态 含义 android:state_pressed 表示按下状态, 比如Button被按下后没有松开时的状态 android:state_focused 表示View已经获取了焦点 android:state_selected 表示用户选择了View android:state_checked 表示用户选中了View, 一般适用于CheckBox这类在选中和非选中之间切换的 android:state_enabled 表示View当前是否可用 默认状态的一定要放在最后一条, 因为系统是按照从上到下的顺序查找. 只要找到任何一个匹配状态的那么久结束了. LevelListDrawableLevelListDrawable对应于&lt;level-list&gt;标签, 也表示一个Drawable集合, 集合中每一个Drawable都有一个等级的概念, 根据不同的等级LevelListDrawable会切换不同的对应的Drawable. 12345678910111213&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_sample" android:maxLevel="2" android:minLevel="2"/&gt; &lt;item android:drawable="@mipmap/ic_launcher" android:maxLevel="1" android:minLevel="1" /&gt;&lt;/level-list&gt; 这里就相当于给每一个Drawable设定一个标识. level-list会根据这个标识去自己的item中查找. 默认等级为0, Level的取值在0~10000. 在给每个Item声明等级的时候尽量最大和最小等级保持一致. 让每个item都可以有一个唯一标识等级, 而避免有一些公共拥有等级的Item导致出现和我们预期的不符. 如果作为了背景, 那么获得Drawable对象通过getLevel(), setLevel()来得到和设置不同的等级做到切换图片的效果. 如果是ImageView那么通过setImageLevel()前景设置其等级就可以,一定别忘了把Drawable设置前景再通过这种方式实现. TransitionDrawable对应着&lt;transition&gt;标签, 它用于实现两个Drawable之间的淡入淡出效果. 1234567&lt;transition xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@mipmap/ic_sample"/&gt; &lt;item android:drawable="@mipmap/ic_launcher"/&gt;&lt;/transition&gt; 12 TransitionDrawable drawable = (TransitionDrawable) iv_main.getBackground();drawable.startTransition(5000); 这个没什么好说的了, 很简单. 注意一下如果是给ImageView设置前景的话那么不要用getBackground()来获取了,通过getDrawable()来获取. InsetDrawableInsetDrawable对应&lt;inset&gt;标签, 它可以将其他Drawable内嵌到自己当中, 并可以在四周留出一定的距离. 当一个View希望自己的背景比自己的实际区域小的时候, 可以使用这个来实现.(相当于给使用的View增加了margin效果) LayerDrawable也可以实现此效果 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:insetBottom="20dp" android:insetTop="50dp" android:insetRight="20dp" android:insetLeft="20dp"&gt; &lt;shape &gt; &lt;solid android:color="#ffff00"/&gt; &lt;/shape&gt;&lt;/inset&gt; ScaleDrawableScaleDrawable对应&lt;scale&gt;标签, 他可以根据自己的等级level将制定的Drawable缩放到一定比例. 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@mipmap/ic_sample" android:scaleHeight="10%" android:scaleWidth="10%" android:scaleGravity="center"&gt;&lt;/scale&gt; 并在代码中设置等级, 默认为0是不显示ScaleDrawable 12ScaleDrawable drawable = (ScaleDrawable) findViewById(R.id.activity_main).getBackground();drawable.setLevel(1); 其中scaleHeight和scaleWidth需要的是百分比值. 有点别扭, 如果你设置了10%, 那么实际的意义就是缩放了原大小的10%, 相当于去掉了设置的值. 最终呈现出来的是1-设定的百分比. 就是展现了90%. 而设置的等级会影响最终的图片大小, 等级越大图片越大. 最好等级控制到0~10000 最后. ClipDrawableClipDrawable对应于&lt;clip&gt;标签, 他可以根据自己当前的等级来裁剪Drawable, 裁剪的方向通过android:clipOrientation和android:gravity这两个属性来共同控制. 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;clip xmlns:android="http://schemas.android.com/apk/res/android" android:clipOrientation="horizontal" android:drawable="@mipmap/ic_sample" android:gravity="center"&gt;&lt;/clip&gt; 首先android:clipOrientation 如果参数添加水平 horizontal. 实际上是竖直切割, 保留垂直方向的完整. 如果是Vertical反之. 看图吧. 而gravity有的属性和BitmapDrawable中的gravity一样. 这里现在是android:clipOrientation=&quot;horizontal&quot;它是以水平方向做的垂直切割. 那么通过给gravity设置左 中 右就是left, center, right可以达到不同的效果. 如图 重要的一点还有动态代码设置等级, 要是不设置等级就是默认的0, 0就是切割掉100%的部分,所以剩下的部位为0也就是空的 12ClipDrawable drawable = (ClipDrawable) findViewById(R.id.activity_main).getBackground();drawable.setLevel(5000); 这个等级的数还是1~10000. 等级为0那么意味着裁剪Drawable的100%部分. 什么东西没有.空的 等级为5000那么意味着裁剪Drawable的50%部分, 我上面的演示的图片都是以等级为5000为标准测试的 等级为10000那么就意味的裁剪部分为Drawable的100%部分, 也就是完全显示了. 可以看出来了, 综合上面的看出, 上面的gravity的方向可以认为是从那边开始进行裁剪保留. 自定义Drawable一般Drawable都是作为View的背景图, 或者ImageView的显示图片. 其工作原理核心就是draw()方法. 而系统会调用Drawable的draw()来绘制View的背景, 所以我们通过重写draw()来实现自定义Drawable. 一般draw(), setAlpha(), setColorFilter(), 和getOpacity()都是要实现的 , draw()里面的具体实现和我们View的onDraw()很相似. 可以参考ShapeDrawable和BitmapDrawable的源码去仿造实现. 在自定义的时候注意: 如果要定义的Drawable有固有的大小值, 那么最好重写getIntrinsicWidth()和getIntrinsicHeight()这两个方法. 因为它会影响到View的wrap_content布局. 最后内部大小不一定等于Drawable的实际大小, Drawable实际大小可以通过getBound()来获取.]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Drawable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解RemoteViews]]></title>
    <url>%2F2018%2F03%2F05%2F%E7%90%86%E8%A7%A3RemoteViews%2F</url>
    <content type="text"><![CDATA[RemoteView的应用简介:在开发中, 通知栏都知道是通过NotificationManager的notify方法实现. 桌面小部件则是通过AppWidgetProvider实现. 后者本质上是一个广播.更新他们无法像以前那样.这是因为不是一个进程,小部件是SystemServer进程. 为了跨进程更新界面,RemoteViews提供了一系列的set方法… RemoteViews通知栏的应用先使用系统默认的样式. –! 先不记录notification了. 发现书上的方法在编译环境23版本以上无效. 23以下是没有问题的.notification.setLatestEventInfo()此方法已经被删除了. 贴出自定义布局通知栏代码利用remoteViews 123456789101112131415161718192021222324252627/** * 打开自定义布局的通知栏 */private void displayRemoteViews() &#123; Notification notification = new Notification(); notification.icon = R.mipmap.ic_launcher; notification.tickerText = "我是小部件"; notification.when = System.currentTimeMillis(); notification.flags = Notification.FLAG_AUTO_CANCEL; Intent intent = new Intent(getApplicationContext(), MainActivity.class); PendingIntent pedingIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); RemoteViews remoteViews = new RemoteViews(getPackageName(), R.layout.layout_notification); remoteViews.setTextViewText(R.id.tv_msg, "我是文字信息"); remoteViews.setImageViewResource(R.id.iv_icon, R.mipmap.favicon); notification.contentView = remoteViews; notification.contentIntent = pedingIntent; PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, OpenActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); remoteViews.setOnClickPendingIntent(R.id.tv_open, openActivity2PendingIntent); NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); manager.notify(2, notification);&#125; 传入了一个自定义布局里面有一个imageView两个textView. 如下图: RemoteView在桌面小部件上的应用AppWidgetProvider是系统提供的用于实现桌面小部件的类, 继承BroadcaseReceiver.可以当成广播理解. 桌面小部件的开发步骤 1.定义小部件界面 在创建一个布局xml当做这个小部件要展示的样子 2.定义小部件配置信息 在res/xml文件夹下新建一个xxx_info.xml的文件 12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android" android:initialLayout="@layout/layout_widget" android:minHeight="100dp" android:minWidth="100dp" android:updatePeriodMillis="60000" &gt;&lt;/appwidget-provider&gt; initiaLayout: 小工具所要使用的初始化布局 minHeight``minWidth: 指定小工具的尺寸 updatePeriodMillis: 自动刷新的时间, 单位毫秒 3.定义小部件的实现类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * Created by suzeyu on 16/8/11. * 定义小部件的实现类 */public class MyAppWidgetProvider extends AppWidgetProvider &#123; public static final String TAG = MyAppWidgetProvider.class.getName(); public static final String CLICK_ACTION = "com.szysky.note.androiddevseek_05.action.CLICK"; @Override public void onReceive(final Context context, Intent intent) &#123; super.onReceive(context, intent); Log.i(TAG, "onReceive: 接收到广播--&gt;"+intent.getAction()); //是触发的自己点击时发送的action那么就让小部件旋转 if (intent.getAction().equals(CLICK_ACTION))&#123; Toast.makeText(context, "准备旋转", Toast.LENGTH_SHORT).show(); AsyncTask.execute(new Runnable() &#123; @Override public void run() &#123; Bitmap srcBmp = BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon); AppWidgetManager widgetManager = AppWidgetManager.getInstance(context); for (int i = 0; i &lt; 37; i++) &#123; float degree = (i * 10) % 360; RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, rotateBmp(context, srcBmp, degree)); if (i==36)&#123; Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent peddingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, peddingIntent); &#125; widgetManager.updateAppWidget(new ComponentName(context, MyAppWidgetProvider.class), remoteViews); SystemClock.sleep(50); &#125; &#125; &#125;); &#125; &#125; /** * 旋转一个bitmap */ private Bitmap rotateBmp(Context context, Bitmap srcBmp, float degree) &#123; Matrix matrix = new Matrix(); matrix.reset(); matrix.setRotate(degree); return Bitmap.createBitmap(srcBmp, 0, 0, srcBmp.getWidth(), srcBmp.getHeight(), matrix, true); &#125; /** * 当自定义的小桌面被添加 这个方法只有在本实例中只有被添加的时候才调用 */ @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) &#123; super.onUpdate(context, appWidgetManager, appWidgetIds); final int counter = appWidgetIds.length; Log.i(TAG, "小桌面更新了 counter="+counter); for (int i = 0; i &lt; counter; i++) &#123; int appWidgetID = appWidgetIds[i]; onWidgetUpdate(context, appWidgetManager, appWidgetID); &#125; &#125; /** * 桌面小部件更新 这个方法只有在本实例中只有被添加的时候才调用 */ private void onWidgetUpdate(Context context, AppWidgetManager appWidgetManager, int appWidgetID) &#123; Log.i(TAG, "onWidgetUpdate: id=="+appWidgetID); RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon)); Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, pendingIntent); appWidgetManager.updateAppWidget(appWidgetID, remoteViews); &#125;&#125; 直接说用途把, 小部件被添加到桌面的时候, 会先走onUpdate()回调,这个时候执行方法通过RemoteViews()构建一个布局,并更新桌面上新的布局和设置了点击事件,然后走onReceive() . 如果当我们点击的小部件的时候, 会触发广播中的onReceive()然后进行图片的旋转.这就是上述代码的大体流程. 4.最后要在清单文件中声明小部件 12345678910&lt;receiver android:name=".MyAppWidgetProvider"&gt; &lt;meta-data android:name="android.appwidget.provider" android:resource="@xml/widget_provider_info"/&gt; &lt;intent-filter&gt; &lt;action android:name="android.appwidget.action.APPWIDGET_UPDATE"/&gt; &lt;action android:name="com.szysky.note.androiddevseek_05.action.CLICK"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 第一个action则是作为小部件的表示而必须存在的. 第二个action就是要识别设定的单击行为. 然后就可以在主屏幕上长按添加小部件查看效果了 嫌麻烦就直接扣代码,这是链接 AppWidgetProvider这个类还有其他生命周期的回调, 其实就是当广播到来之后, AppWidgetProvider会自动根据广播的Action通过onReceive()来自动进行分发广播. onEnable(): 当该窗口小部件第一次添加到桌面时调用该方法, 可添加多次但只在第一次调用. onUpdate(): 小部件被添加时或者每次小部件更新时都会调用一次该方法, 小部件的更新时机由updatePeriodMillis来指定, 每个周期小部件都会自动更新一次. onDeleted(): 每删除一次小部件就会调用一次. onReceive(): 这是广播的内置方法, 用于分发具体的事件给其他方法. 下面就是分析了 PendingIntent概述PendingIntent和Intent的区别: PendingIntent: 等待意图, 有一个Intent将在某个待定的时刻发生. Intent: 是立刻发生. 使用场景 最典型的就是给RemoteViews添加单击事件, 因为RemoteViews运行在远程进程中, 因此RemoteViews不同于普通的View, 所以无法直接向View那样通过setOnClickListener()方法那样设置单击事件. 要想给RemoteViews设置单击事件, 就必须使用PendingIntent, PendingIntent通过send()和cancel()来发送和取消特定的待定Intent. PendingIntent支持三种待定意图: 启动Activity, 启动Service, 和发送广播 对应着PendingIntent三个静态方法 getActivity(),getService(), getBroadCast(). 当这三种方法返回的PendingIntent待定意图发生时候, 对应的效果就是我们日常开启这三大组件的情形. 上述三个方法都需要四个参数. 需要说一下第二个参数requestCode和第四个参数flags. 其中requestCode表示PendingIntent发送方的请求码, 多数情况下设为0即可, 另外requestCode会影响到flags的效果. flags: 常用的类型有: FLAG_ONE_SHOT, FLAG_UPDATE_CURRENT, FLAG_NO_CREATE, FLAG_CANCEL_CURRENT. 在此之前首先要明确一个概念, PendingIntent的匹配规则, 在什么情况下两个PendingIntent是相同的. PendingIntent匹配规则: 如果两个PendingIntent的内部Intent相同并且requestCode也相同那么这两个PendingIntent就是想同的. requestCode是int值不需要解释. 而Intent匹配规则是: 如果两个Intent的ComponentName和intent-filter都相同, 那么这两个Intent就是相同的. Extras是不参与Intent的匹配规则. FLAG_ONE_SHOT: 当前描述的PendingIntent只能被使用一次, 然后它就会被自动cancle, 如果后续还有相同的PendingIntent, 那么它们的send方法就会调用失败. 对于通知栏消息来说, 如果采用此标记, 那么同类的通知只能使用一次, 后续的通知单击后将无法打开. FLAG_NO_CREATE: 当前描述的PendingIntent不会主动创建, 如果当前PendingIntent之前不存在, 那么getActivity, getService, getBroadcast方法会直接返回null, 即获取PendingIntent失败. 这个标记很少见, 它无法单独使用,因此日常中没有太多意义. FLAG_CANCEL_CURRENT: 当前描述的PendingIntent如果已经存在, 那么他们都会被cancel, 然后系统会创建一个新的PendingIntent. 对于通知栏消息来说, 那些被cancel的消息单击后将无法打开. FLAG_UPDATE_CURRENT: 当前描述的PendingIntent如果已经存在, 那么他们都会自动被更新, 即它们的Intent中的Extra会被换成新的. 规则说了接下来结合实际使用说明: 如果manager.notify(1, notification),如果参数1的id是常量,那么多次调用notify()只能弹出一个通知, 后续的通知会把前面的通知全部替代, 如果每次id都是不一样的, 那么多次调用notify()就会弹出多个通知. 所以如果notify()是常量, 那么不管PendingIntent是否匹配, 后面的通知都会直接替换前面的通知. 如果notify()每次不同, 那么当pendingIntent不匹配时(这里指的匹配就是上面介绍的Intent和requestCode是否同时相同), 不管采用何种标记, 这些通知之间都不会互相干扰. 但是如果PendingIntent匹配时就要用到去按照之前说的标记区别来划分 FLAG_ONE_SHOT–&gt; 那么后续通知中的PendingIntent会和第一条通知保持一致, 包括Extras, 单击任何一条通知后, 剩下的通知均无法再打开, 当所有的通知都被清除后, 会再次重复这个过程. FLAG_CANCEL_CURRENT–&gt; 那么只有最新的通知可以打开, 之前弹出的所有通知均无法打开 FLAG_UPDATE_CURRENT–&gt; 那么之前弹出的通知中的PendingIntent会被更新, 最终他们和最新的一条通知保持完全的一致, 包括其中的Extras,并且这些通知都是可以打开的. ​ RemoteViews的内部机制RemoteViews的作用是在其他进程中显示并更新View界面. 最常用的构造函数就是public RemoteViews(String packageName, int layoutId), 注意RemoteViews目前并不能支持所有的View类型, 目前支持如下(不包括其子类): Layout FrameLayout, LinearLayout, RelativeLayout, GridLayout View TextView, ImageView, ImageButton, Button, AnalogClock, Chronometer, ProgressBar, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub RemoteViews没有提供findviewById()方法, 只有一系列的set()方法. 方法名 作用 setTextViewText() 设置TextView的文本 setTextViewSize() 设置TextView的字体大小 setTextColor() 设置TextView的字体颜色 setImageViewResource() 设置imageView的图片资源 setImageViewBitmap() 设置imageView的图片 setInt() 反射调用View对象的参数类型为int的方法 setLong() 反射调用View对象的参数类型为long的方法 setBoolean() 反射调用View对象的参数类型为boolean的方法 setOnClickPendingIntent() 为View添加单击事件, 事件类型只能PendingIntent RemoteViews的工作流程 通知栏和桌面小部件分别由NotificationManager和AppWidgetManager管理, 而这两个管理者都是通过Binder分别和SystemServer进程中的NotificationManagerService以及AppWidgetService进行通信. 由此可见,通知栏和桌面小部件中的布局文件实际上是在NotificationManagerService以及AppWidgetService中被加载的, 而他们运行在系统的SystemServer中, 这就和我们的进程构成了进程间通信. 最开始RemoteViews会通过Binder传递到SystemServer进程, RemoteViews实现了Parcelable接口. 系统根据RemoteViews中的包名等信息去得到该应用的资源, 然后通过LayoutInflate去加载RemoteViews中的布局文件. 在SystemServer进程中加载后的布局文件是一个普通的View, 只不过相对于我们的进程他是一个RemoteViews而已. 接着系统会对View执行一系列界面更新任务, 这些任务就是之前的设置的set(). set方法对View所做的更新不是立即执行, 在RemoteViews内部会记录所有的更新操作, 具体的执行时机要等到RemoteViews被加载以后才能执行, 这样RemoteViews就可以在SystemServer进程中显示, 这就是我们看到的通知栏或者桌面小部件. 当需要更新RemoteViews时, 我们需要调用set方法并通过NotificationManager和AppWidgetManager来提交更新任务, 具体的更新操作也是在SystemServer进程中完成的. 为什么不支持所有的View和其操作? 因为代价太大, View的方法太多, 另外就是大量的IPC操作会影响效率. 为了解决这个问题, 系统并没有通过Binder直接支持View的跨进程访问, 而是提供了一个Action的概念, Action代表一个View操作, Action同样实现了Parcelable接口. 系统首先将View操作封装到Action对象并将这些对象跨进程传输到远程进程, 接着在远程进程中执行Action对象中的具体操作. 在我们的应用中每调用一次set(), RemoteViews中就会添加一个对应的Action对象, 当我们通过NotificationManager和AppWidgetManager来提交我们的更新时, 这些Action对象就会传输到远程进程并在远程进程中一次执行. 如图: 远程进程通过RemoteViews的apply方法来进行View的更新操作, RemoteViews的apply方法内部则会去遍历所有的Action对象并调用他们的apply方法, 具体的View更新操作是由Action对象的apply方法来完成的. 上述做法的好处是显而易见的, 首先不需要定义大量的Binder接口, 其次通过远程进程中批量执行RemoteViews的修改操作从而避免了大量的IPC操作, 这就提高了程序的性能. 接下来从源码角度分析. 首先最长用到的setTextViewText(),源码如下 123public void setTextViewText(int viewId, CharSequence text) &#123; setCharSequence(viewId, "setText", text);&#125; 接收的参数比较简单,继续跟进setCharSequence()方法. 123public void setCharSequence(int viewId, String methodName, CharSequence value) &#123; addAction(new ReflectionAction(viewId, methodName, ReflectionAction.CHAR_SEQUENCE, value));&#125; 从这里实现看到, 内部并没有对View进程直接的操作, 而是添加一个ReflectionAction()一个看名字类似反射类型的对象. 接下看addAction() 12345678910private void addAction(Action a) &#123; //省略部分代码... if (mActions == null) &#123; mActions = new ArrayList&lt;Action&gt;(); &#125; mActions.add(a); // update the memory usage stats a.updateMemoryUsageEstimate(mMemoryUsageCounter);&#125; 这里看到, 在RemoteViews内部有一个mActions成员, 它是一个ArrayList, 外界每调用一次set(), RemoteViews就会为其创建一个Action对象并加入到这个集合中, 这里仅仅将Action对象保存了起来, 并未对View进行实际的操作, 这一点在上面的理论分析中已经提到过. 接下来再看ReflectionAction的实现之前, 先看一下RemoteViews的apply()方法以及Action类的实现. 12345678910111213141516171819202122232425262728293031323334public View apply(Context context, ViewGroup parent, OnClickHandler handler) &#123; RemoteViews rvToApply = getRemoteViewsToApply(context); View result; final Context contextForResources = getContextForResources(context); Context inflationContext = new ContextWrapper(context) &#123; @Override public Resources getResources() &#123; return contextForResources.getResources(); &#125; @Override public Resources.Theme getTheme() &#123; return contextForResources.getTheme(); &#125; @Override public String getPackageName() &#123; return contextForResources.getPackageName(); &#125; &#125;; LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); // Clone inflater so we load resources from correct context and // we don't add a filter to the static version returned by getSystemService. inflater = inflater.cloneInContext(inflationContext); inflater.setFilter(this); result = inflater.inflate(rvToApply.getLayoutId(), parent, false); rvToApply.performApply(result, parent, handler); return result; &#125; 这段代码首先通过LayoutInflate去加载RemoteViews中的布局文件, RemoteViews中的布局文件可以通过getLayoutId()这个方法获得, 加载完布局文件后会通过performApply()去执行一些更新操作,如下: 12345678910private void performApply(View v, ViewGroup parent, OnClickHandler handler) &#123; if (mActions != null) &#123; handler = handler == null ? DEFAULT_ON_CLICK_HANDLER : handler; final int count = mActions.size(); for (int i = 0; i &lt; count; i++) &#123; Action a = mActions.get(i); a.apply(v, parent, handler); &#125; &#125; &#125; 这个实现就是遍历mActions并执行每个Action对象的apply()方法, 这里猜想Action对象的apply方法就是真正操作View的地方. RemoteViews在通知栏和桌面小部件中的工作过程和上面描述的过程是一致的. 当调用了RemoteViews的set方法时, 并不会立刻更新他们的界面, 而必须要通过NotificationManager的notify方法以及AppWidgetManager的updateAppWidget才能更新他们的界面. 实际上在AppWidgetManager的updateAppWidget内部实现中, 他们就是通过RemoteViews的apply以及reapply方法来加载或者更新布局的. apply和reApply的区别在于:前者会加载布局并更新界面, 而后者只会更新界面. 通知栏和桌面小部件在初始化界面的时候回调用apply()方法, 而在后续的更新界面时则会调用reapply()方法. 了解了apply()以及reapply()的作用后, 接着看Action的子类具体实现, 先看ReflectionAction的具体实现. 12345678910111213141516171819202122232425262728293031323334private final class ReflectionAction extends Action &#123; //省略部分代码 ... String methodName; int type; Object value; ReflectionAction(int viewId, String methodName, int type, Object value) &#123; this.viewId = viewId; this.methodName = methodName; this.type = type; this.value = value; &#125; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final View view = root.findViewById(viewId); if (view == null) return; Class&lt;?&gt; param = getParameterType(); if (param == null) &#123; throw new ActionException("bad type: " + this.type); &#125; try &#123; getMethod(view, this.methodName, param).invoke(view, wrapArg(this.value)); &#125; catch (ActionException e) &#123; throw e; &#125; catch (Exception ex) &#123; throw new ActionException(ex); &#125; &#125; // ...&#125; ReflectionAction表示的是一个反射动作, 通过它对View的操作会以反射的方式来调用, 其中getMethod就是根据方法名来得到反射所需要的Method对象. 除了ReflectionAction, 还有其他的Action. 例如: TextViewSizeAction, ViewPaddingAction, SetOnClickPendingIntent等. 看一下TextViewSizeAction 1234567891011121314151617181920212223private class TextViewSizeAction extends Action &#123; public TextViewSizeAction(int viewId, int units, float size) &#123; this.viewId = viewId; this.units = units; this.size = size; &#125; @Override public void apply(View root, ViewGroup rootParent, OnClickHandler handler) &#123; final TextView target = (TextView) root.findViewById(viewId); if (target == null) return; target.setTextSize(units, size); &#125; public String getActionName() &#123; return "TextViewSizeAction"; &#125; int units; float size; public final static int TAG = 13;&#125; 这个类没有使用反射, 因为setTextSize的方法有两个参数,因此无法复用ReflectionAction, 因为这个反射调用只能有一个参数. 关于单击事件, RemoteViews只支持发起PendingIntent,不支持onClickListener()这种模式. setOnClickPendingIntent,setPendingIntentTemplate,setOnClickFillIntent这三个的区别. setOnClickPendingIntent: 只支持普通View设置点击事件, 不能给集合(ListView,StackView)中的View设置点击事件,如item. 因为开销比较大, 系统禁止了这种方式. 如果要给集合中的item添加点击事件,则必须使用后两种组合使用才可以. RemoteViews的意义可以模拟一个通知栏效果并实现跨进程的UI更新. 一个应用需要能够更新另一个应用中的某个界面，这个时候我们当然可以选择AIDL去实现，但是如果对界面的更新比较频繁，这个时候就会有效率问题，同时AIDL接口就有可能会变得很复杂 这个时候如果采用RemoteViews来实现就没有这个问题了，当然RemoteViews也会有点缺点，那就是他仅支持一些常见的View,对于自定义VIew他是不支持的]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>RemoteViews</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的工作原理]]></title>
    <url>%2F2018%2F03%2F01%2FView%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[ViewRoot和DecorView这是在View三大流程之前(measure, layout, draw),需要了解的概念. ViewRoot对应于ViewRootImpl类, 它是连接WindowManager和DecorView的纽带. View的三大流程都是通过ViewRoot来完成的. 当一个Activity对象在ActivityThread被创建后. 会将DecorView添加到Window中, 同时会创建ViewRootImp对象, 并将ViewRootImpl对象和DecorView建立关联： 12root = new ViewRootImpl(view.getContext(), display);root.setView(view, wparams, panelParentView); View绘制流程是从ViewRoot的PerformTraversals()开始的. 经过三大流程才能将一个View绘制出来. PerformTraversals()会依次调用performMeasure, performLayout, performDraw. 而前两种内部的调用基本一致,都是先调用measure()/layout(),然后再调用onMeasure()/onLayout()在这个方法中会对所有子元素进行测量和绘制.依次向内部传递. performDraw()有点不同是在draw调用的dispatchDraw(). PerformTraversals绘制流程如下图： measure过程: 决定了View宽高, measure后可以通过getMeasureWidth和getMeasureHeight来获取View的宽高. 一般情况下是最终宽高. layout过程: 决定了View的顶点坐标和实际View的宽高. 完成后通过getTop, getBottom, getLeft, getRight获得四个顶点, 通过getWidth,和getHeight获得宽高 draw过程: 只有draw()方法完成之后View的内容才会显示出来. 12setContentView(R.layout.activity_inside_intercept);((ViewGroup) getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); 上面第一行可以说无时无刻不存在. 而下面这行在上一章说过就是获得我们设置的布局.那DecorView布局究竟是怎么样的, 下图. DecorView就是一个FrameLayout. 而一般情况下它的布局就如上面图那样(具体和主题有关系). 而我们经常setContentView(xxx). 就是把我们编写的xml的布局添加到了DecorView的android.R.id.content的控件布局中. 所以也就能说通为什么getChildAt(0)会获得我们的的布局.并且为什么我们用的关联布局的方法是setContent… MeasureSpec 很大程度上决定一个View的尺寸规格, 之所以不是绝对, 是因为这个过程还受父容器的影响. 理解MeasureSpecMeasureSpec本身是一个32位的int值, 但是却表示了两种信息. 高2位: 代表了SpecMode, 测量模式 低30位: 代表了SpecSize, 在上述测量模式中的大小 1234567891011121314151617181920212223242526272829303132public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT; public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; public static int makeSafeMeasureSpec(int size, int mode) &#123; if (sUseZeroUnspecifiedMeasureSpec &amp;&amp; mode == UNSPECIFIED) &#123; return 0; &#125; return makeMeasureSpec(size, mode); &#125; public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125; .....&#125; 是不是挺有意思. 三种类型分别高二位01, 00, 10来代表. 直接利用位运算. 来实现可以让频繁计算的东西使用最接近计算机的运算方式. 不需要额外的转换. 也避免了过多的对象内存分配. 说一下SpecMode的三种模式 UNSPECIFIED: 父容器不对View有任何的限制,要多大就给多大, 这种情况一般用于系统内部,表示一中测量状态 EXACTLY: 父容器已经检测出View所需要的精确大小, 这个时候View的最终大小就是SpecSize所指定的值. 对应着LayoutParams中的match_parent和具体的数值. AT_MOST: 父容器制定了一个可用的大小及SpecSize, View的大小不能超过这个值, 它对应与LayoutParams中的wrap_content MeasureSpec和LayoutParams关系通常设置的LayoutParams,系统会在父容器的的约束下转换成对应的MeasureSpec,然后根据这个MeasureSpec来确定View测量后的宽高. 所以View自身的MeasureSpec是需要LayoutParams和父容器一起组合生成的. 上面讲述的是普通View, 但是顶级View(DecorView)有所不同. DecorView是物理窗口尺寸和自身的LayoutParams决定的. 具体在ViewRootImpl类measureHierarchy()进行生成的. MeasureSpec一旦确定, onMeasure中就可以测量View的宽高. 对于我们日常操作的View View的measure过程是由ViewGroup传递而来的. 看ViewGroup#measureChildWithMargins()方法 123456789101112131415protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) &#123; final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; 上面会对子元素进行measure，而在此之前，会通过getChildMeasureSpec()来得到子元素的MeasureSpec. 通过调用方法传入的参数看到，生成View的MeasureSpec具体由以下因素共同决定： 父容器的MeasureSpec和padding，View自身的margin和LayoutParams，对于子View的LayoutParams如果是： dp/px: 不管父容器的MeasureSpec是什么. View都是EXACTLY(精确模式), 而大小遵循自身LayoutParams的大小. match_parent: 如果父容器是EXACTLY(精确模式),那么子View也是EXACTLY(精确模式)并且大小是父容器的剩余空间. 如果父容器是AT_MOST(最大模式),那么子View也是AT_MOST(最大模式)并且大小不会超过父容器的剩余空间. wrap_content: 不管父容器是什么. View都是AT_MOST(最大模式), 并且大小不能超过父容器剩余空间. 上述没有说明UNSPECIFIED在match_parent和wrap_content中. 因为这个模式主要用于系统多次Measure的情形,一般来说不需要关注. 普通View的MeasureSpec的创建流程,规则如下表所示： View的工作流程 主要指measure, layout, draw三大流程. 即测量,布局,绘制. measure过程这里面存在两种场景: View: 通过了measure方法就完成了测量过程 ViewGroup: 除了测量自己,还会遍历去调用所有子元素的measure方法. 各个子元素在递归去执行这个流程 View的measure过程 View的measure过程由其measure()方法来完成, measure()方法是一个final类型, 而在内部调用了onMeasure()这个可不是final, 所以也可以自定义的时候复写. 看一下内部. 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));&#125; setMeasureDimension()会设置View宽高的测量值. 这里需要看一下getDefaultSize()这个方法. 12345678910111213141516public static int getDefaultSize(int size, int measureSpec) &#123; int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) &#123; case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; &#125; return result;&#125; 看到如果这个view是EXACTLY(精准模式), 那么返回的大小就是SpecSize。 UNSPECIFIED一般用于系统测量先不说. 而AT_MOST(最大模式)的时候. 虽然是不同模式但是默认情况下和精确模式是一样的结果. getSuggestedMinimumWidth()和getSuggestedMinimumHeight(). 看一下实现. 1234567protected int getSuggestedMinimumWidth() &#123; return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());&#125;protected int getSuggestedMinimumHeight() &#123; return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());&#125; 首先会看是否设置了背景. 无背景: 那么宽度为mMinWidth,这个值对应布局中的android:minWidth属性,默认为0. 有背景: 那么取mMinWidth和mBackground.getMinimumWidth()最大值. 我们看一下:getMinimumHeight() 1234public int getMinimumHeight() &#123; final int intrinsicHeight = getIntrinsicHeight(); return intrinsicHeight &gt; 0 ? intrinsicHeight : 0;&#125; 原来getMinimumHeight()返回的就是Drawable的原始高度。 如果没有就返回0. 关于原始高度举个例子ShapeDrawable无原始宽高， BitmapDrawble有原始宽高就是图片的尺寸。 再总结下getDefaultSize()的默认行为，虽然我们在xml布局中使用了wrap_content，但实际效果为：View自身的MeasureSpec等于父容器自身的剩余大小，并没有去适配View本身的大小。因此： 对于直接继承View的自定义控件，需要重写onMeasure()方法并设置wrap_content时的自身大小。 自定义View的时候如果不对wrap_content进行额外处理，那么就会调用默认setMeasureDimension()方法. 而默认中方法的实参传递的是getDefaultSize()这个方法中对AT_MOST这种模式没有处理. 直接沿用和精确模式的大小(相当于设置了wrap_content却得到了match_parent的显示结果) 可以针对这个问题, 做出对应的编码进行解决: 123456789101112131415161718192021222324@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //默认会调用父类的setMeasuredDimension() super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpaceMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpaceMode = MeasureSpec.getMode(heightMeasureSpec); //设置两个默认值宽高 int defaultHeight = 100; int defaultWidth = 100; // 针对AT_MOST模式进行特殊处理 if (widthSpaceMode == MeasureSpec.AT_MOST &amp;&amp; heightSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, defaultHeight); &#125; else if (widthSpaceMode == MeasureSpec.AT_MOST)&#123; setMeasuredDimension(defaultWidth, heightSpaceSize); &#125; else if (heightSpaceMode == MeasureSpec.AT_MOST) setMeasuredDimension(widthMeasureSpec, defaultHeight); &#125; &#125; ViewGroup的Measure 对于ViewGroup不光会测量自己,还会遍历调用所有的子元素的measure(). 和View不同的是ViewGroup是一个抽象类,它没有重写onMeasure,但提供了measureChildren()的方法. 这个measureChildren()方法内部比较简单就是遍历自己的孩子然后调用-&gt;measureChild() 这个measureChild()这个方法前面贴过源码。就是取出子元素的LayoutParams，并调用 getChildMeasureSpec()， 通过传入子元素的LayoutParams里面的宽高属性和padding，父元素的margin和当前MeasureSpec属性来计算出子元素的MeasureSpec最后调用child.measure()传入之前计算的测量规格。 ViewGroup为什么没有定义测量的具体过程? 因为具体的测量过程需要交给子类去实现的. 比如LinearLayout,RelativeLayout. 看一下LinearLayout的onMeasure()是如何定义的. 12345678@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; if (mOrientation == VERTICAL) &#123; measureVertical(widthMeasureSpec, heightMeasureSpec); &#125; else &#123; measureHorizontal(widthMeasureSpec, heightMeasureSpec); &#125;&#125; 根据设置的排列方式这里分之了两种测量方法. 稍微看一下大概轮廓，选择measureVertical()不贴源码了这个方法300行呢! 首先LinearLayout的这个方法会遍历每个子元素并执行measureChildBeforeLayout()方法。这个方法内部会调用子元素的measure()，这样子元素会依次测量，并且会通过mTotalLenght这个变量来存储LinearLayout在竖直方向上的初步高度，每测量一个就会增加。当子元素测量完之后，LinearLayout会测量自己的大小。 在对自己进行测量的时候， 如果布局中的高度采用的是match_parent或者具体数值，那么它的测量过程和View一样，即高度为specSize。如果布局中采用wrap_content那么高度就是所有的子元素总和但是不能超过父元素剩余空间，具体可参考resolveSizeAndState()的实现。 到这里基本上measure测量过程已经做了比较详细的分析，这个过程也是三大过程中最复杂的一个，在measure完成之后就可以通过getMeasuredWidth/Height方法获取View的测量宽高。 但是请注意: 某些极端情况下，measure可能执行多次。 所以尽量在onLayout()方法中去获得最终宽高。 正确获取宽高方法首先明确一点:View的measure和Activity的生命周期方法不是同步执行.所以无法保证在某个生命周期(onCreate,onStart)获取到正确的测量宽高 Activity/View#onWindowFocusChanged() view.post(runnable) ViewTreeObserver#onGlobalLayout view.measure() onWindowFocusChanged() View已经初始化完毕，宽高已经准备好。这里需要注意只要Activity的焦点发生变化此方法就会被调用，所以如果你的界面在进行onPause和onResume，那么onWindowFocusChanged()也会得到调用。 View.post(runnable) 通过post可以将一个runnable投递到消息队列的尾部，然后等待Looper调用到此runnable的时候，View已经初始化完毕。 使用ViewTreeObserver 当View的可见性发生了改变的时候，onGlobalLayout()将发生回调，注意伴随着View树的状态改变等，这个回调方法可能会被调用多次.。使用代码如下 123456789ViewTreeObserver viewTreeObserver = view.getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() &#123; @Override public void onGlobalLayout() &#123; view.getViewTreeObserver().removeOnGlobalLayoutListener(this); int height = view.getMeasuredHeight(); int width = view.getMeasuredWidth(); &#125; &#125;); view.measure(widthMeasureSpec, heightMeasureSpec) 也可以手动进行测量，但是需要分情况处理MeasureSpec match_parent 当View是此属性的时候无法使用measure()，首先使用这种方法需要的参数，是通过父容器和子元素组合来生成的子元素的MeasureSpec属性。所以在外部我们不知道父元素的参数值得时候只能处理不需要父元素数据就可以生成子元素的MeasureSpec的模式 所以很清楚, 这个match_patch这个模式，在给其子元素构造MeasureSpec的时候需要得值parentSize，所以得到的也是无效。 具体数值px/dx 假设这里是100px, 首先构成宽高对应的MeasureSpec属性 123int widthSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY);int heightSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY); view.measure(widthSpec, heightSpec); wrap_content 123int widthSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST);int heightSpec = View.MeasureSpec.makeMeasureSpec(((1 &lt;&lt; 30)-1), View.MeasureSpec.AT_MOST); view.measure(widthSpec, heightSpec); 通过(1&lt;&lt;30) - 1 可以构成一个MeasureSpec低30位的最大值. 用理论上View能支持的最大值去构造MeasureSpec。 layout过程在ViewGroup中会先通过layout()方法确定本身的位置. 然后调用onLayout()方法遍历所有的子元素,并调用子元素的layout()方法确定子元素的位置…依次循环. 提出View的layout方法, 这里抽取部分代码 12345678910111213public void layout(int l, int t, int r, int b) &#123; int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; onLayout(changed, l, t, r, b); &#125; &#125; 这样来看,大致流程通过setFrame()方法来设定View的四个顶点的位置，即mLeft、mTop、mBottom、mRight这四个顶点一旦确定。当前View的位置也就确定，然后会调用onLayout()方法，这个方法是确定子元素的View位置。 这里的和onMeasure()类似， onLayout()具体实现和具体的布局有关, 所以View和ViewGroup均没有真正实现onLayout()方法。 看一下LinearLayout的onLayout()源码 12345678@Overrideprotected void onLayout(boolean changed, int l, int t, int r, int b) &#123; if (mOrientation == VERTICAL) &#123; layoutVertical(l, t, r, b); &#125; else &#123; layoutHorizontal(l, t, r, b); &#125;&#125; 和onMeasure()一样分支,接下来跟进layoutVertical()贴出主要代码 1234567891011121314151617181920212223242526272829303132void layoutVertical(int left, int top, int right, int bottom) &#123; //省略一部分... for (int i = 0; i &lt; count; i++) &#123; final View child = getVirtualChildAt(i); if (child == null) &#123; childTop += measureNullChild(i); &#125; else if (child.getVisibility() != GONE) &#123; final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity &lt; 0) &#123; gravity = minorGravity; &#125; //省略一部分... if (hasDividerBeforeChildAt(i)) &#123; childTop += mDividerHeight; &#125; childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); &#125; &#125; &#125; 上面代码大体逻辑: 首先遍历所有孩子并调用setChildFrame()来为子元素指定对应的位置. 其中childTop会逐渐增大, 这就意味着后面的子元素会被放置在靠下的位置. 而setChildFrame()内部仅有一行代码, 就是调用子元素的layout()并传入它自身应该存放的位置. 123private void setChildFrame(View child, int left, int top, int width, int height) &#123; child.layout(left, top, left + width, top + height); &#125; 而在setChildFrame()中传入的宽高就是子元素的测量宽高。 而在子元素的layout()中通过setFrame()来设置元素的四个顶点。 View的测量宽高getMeasureWidth()/getMeasureHeight() 和 layout后用getWidth()/getHeight()获得的最终宽/高有什么区别? 在一般情况下，测量measure和layout时候的值是完全一样的，因为layout()中接受的参数就是通过测量的结果获取到的。 并且内部直接通过setFrame()赋值到自己的四个成员变量上。但是如果对layout()进行了复写。如下 1234 @Overrideprotected void layout(int l, int t, int r, int b) &#123; super.layout( l, t+200, r, b+200);&#125; 如果进行了这样的复写, 那么最终宽高永远会与测量的出来的值相差200,但是这样做会导致显示不正常，并没有什么意义. draw过程这个过程只是将View绘制到屏幕上面. 绘制背景background.draw(canvas) 绘制自己onDraw() 绘制childrendispatchDraw() 绘制装饰onDrawScrollBars() View绘制过程传递是通过dispatchDraw()实现的. 传递了自己的画布. 这个方法会遍历子元素并且调用子元素的draw() View一个特有的方法setWillNotDraw()，这个方法是设置了true那么系统会进行相应的优化， 在View中默认是关闭的.，而ViewGroup默认是开启的。如果我们继承了自定义ViewGroup如果还需要绘制自己的内容那么需要显示的关闭此标记。 自定义View自定义View的分类1.直接继承View重写onDraw方法 这种方法主要用于实现一些不规则的效果,，不方便组合布局实现，或者又有动态显示的一些图形。 需要自己绘制那么就重写onDraw()方法。这种方法需要自己支持wrap_content和padding 2.直接继承ViewGroup派生特殊的Layout 这种方式用于实现自定义布局，这种布局的实现稍微复杂，需要合适的处理ViewGroup的测量，布局这两个过程，并同时处理子元素的测量和布局过程。 3.继承特定的View(TextView) 比较常见， 一般用于扩展已有的View的功能。这种不需要自己处理wrap_content和padding 4.继承特定ViewGroup(LinearLayout) 当某种效果看起来像几种View的组合在一起的时候，可以采用这种方式。这种方式不需要自己处理ViewGroup的测量和布局。 自定义View的须知 重写View的onMeasure()支持wrap_content属性 重写onMeasure()针对AT_MOST模式特殊处理。如果不处理，设置的wrap_content属性相当于match_parent的效果，参考前面的View的measure过程。 重写View的onDraw()支持padding属性 如果直接继承View，在onDraw()中不处理padding，那么属性是无法起作用的。还有继承ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin会造成的影响。 尽量不要在View中new Handler使用 内部已经提供了post系列方法（内部实现也是Handler），除非很明确要是用Handler发送消息。 View中如果有线程或者动画，需要及时的停止 当包含此View的Activity退出或者此View被remove的时候，View的onDetachedFromWindow()会被调用，可以适当处理防止内存泄漏。 View带有的滑动嵌套时，需要处理好滑动冲突 自定义View实例1.自定义View派生类 首先我们看一下自定义View可能涉及的属性，比如一个CircleView: 12345678&lt;com.ryg.chapter_4.ui.CircleView android:id="@+id/circleView1" android:layout_width="wrap_content" android:layout_height="100dp" android:layout_margin="20dp" android:background="#000000" android:padding="20dp" app:circle_color="@color/light_green" /&gt; 第一步: 适配wrap_content属性 对于直接继承View的空间，不管是设置match_parent也好，wrap_content也好父容器都会给分配自己剩余空间的大小给子容器作为specSize的空间大小。如果不对wrap_content处理那就是相当于和match_parent填充父容器的效果一样。 所以需要对onMeasure()方法中的AT_MOST模式的指定默认大小比如200px： 12345678910111213141516protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; //默认调用super.setMeasuredDimension() super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec); int widthSpecSize = MeasureSpec.getSize(widthMeasureSpec); int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec); int heightSpecSize = MeasureSpec.getSize(heightMeasureSpec); if (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(200, 200); &#125; else if (widthSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(200, heightSpecSize); &#125; else if (heightSpecMode == MeasureSpec.AT_MOST) &#123; setMeasuredDimension(widthSpecSize, 200); &#125; &#125; 第二步: 适配padding属性 margin是交给父容器分配的，但是padding是要子View自己要处理的. 这时需要重写onDraw()中来处理. 123456789101112protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); final int paddingLeft = getPaddingLeft(); final int paddingRight = getPaddingRight(); final int paddingTop = getPaddingTop(); final int paddingBottom = getPaddingBottom(); int width = getWidth() - paddingLeft - paddingRight; int height = getHeight() - paddingTop - paddingBottom; int radius = Math.min(width, height) / 2; canvas.drawCircle(paddingLeft + width / 2, paddingTop + height / 2, radius, mPaint); &#125; 第三步:有时候我们需要提供自定义属性， 例如android:id=这种，接下来添加自定义属性： 在values目录下创建自定义属性的xml. 名字随便当最好attrs.xml或者attrs_xxx_xxx.xml. 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="CircleView"&gt; &lt;attr name="circle_color" format="color"/&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 上面相当于,定义了一个CircleView的属性集合. 在这个集合里面会有自定义属性. 这里的format格式可以是指定尺寸的dimension, 资源id引用的reference, 基本类型string, integer ,boolean等. 声明好了属性在我们自定义View中就可以引用处理了. 如构造方法中. 1234567891011public CircleView(Context context, AttributeSet attrs) &#123; super(context, attrs, defStyleAttr); //获得一个自定义的对应属性值集合 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView); //取出属性集合中的某个属性值 mColor = typedArray.getColor(R.styleable.CircleView_circle_color, Color.GREEN); //释放资源 typedArray.recycle(); init(); &#125; 在布局中使用即可. 先声明schemas. xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; ,使用app来替代之前的类似android前缀的引导. 继承View的派生类就到此为止了：效果如下：]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
        <tag>View的工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View的事件体系]]></title>
    <url>%2F2018%2F02%2F28%2FView%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[View 的基础知识 View的位置参数 View相对于父容器的坐标top，left，right，bottom。 12width = right - leftheight = bottom - top 从Android 3.0开始增加了x、y、translationX、tranlationY；其中： View也提供了相应的get/set方法，关系换算： 12x = left + translationXy = top + translationY 注意⚠️：View在平移的过程中，top和left的值并不会改变，此时发生改变的是x、y、translationX和translationY。 MotionEvent 和 TouchSlop ACTION_DOWN——手指刚接触屏幕 ACTION_MOVE——手指在屏幕上移动 ACTION_UP——手指从屏幕上松开的一瞬间 getX/getY返回的是相对于当前View的左上角的x和y的坐标，而getRawX/getRawY返回的是是相对于手机屏幕左上角的坐标。 TouchSlop 是系统能识别出的被认为是滑动的最小距离(8dp)。 ViewConfigrarion.get(getContext()).getScaledTouchSlop() VelocityTracker、GestureDetector和Scroller VelocityTracker用于追踪手指在滑动过程中的速度。 GestureDetector 手势检测，用于检测单击、滑动、长按、双击等行为。需要实现接口onGestureListener和onDoubleTapListener比较常用的有：onSingleTapUp（单击）、onFling（快速滑动）、onScoll（拖动）、onLongPress（长按）、onDoubleTap（双击）。 Scroll实现弹性滑动。 View的滑动 使用scrollTo/srollBy123public void scrollTo (int x, int y);//绝对坐标滑动public void scrollBy(int x, int y);//相对坐标滑动 如果从左到右滑动，那么mSrollX为负值，反之为正；如果从上往下滑动，那么mScrollY为负值，反之为正；使用scrollTo和scrollBy来实现View的滑动，只能将View的内容进行移动，不影响内部元素的点击事件，但是并不能改变View的原始布局位置。 使用动画 View动画，用xml实现 View 动画是对View的影像做操作，并不能真正的改变View的位置参数和宽高；并且如果希望动画后的状态保留必须设置fillAfter属性为true。适用于没有交互性的（点击）场景。 属性动画 1ObjectAnimator.ofFloat(targetView, "translationX", 0, 100).setDuration(100).start(); 属性动画能够改变原始位置，没有缺点，优先推荐使用。 改变布局参数改变View的布局参数LayoutParams，适用于有交互的View，操作稍微复杂。 弹性滑动使用Scroller Scroller 本身不能实现 View 的滑动，它需要配合 View 的 computeScroll 方法才能完成弹性滑动的效果。通过不断地让 View 重绘，而每一次重绘距离滑动其实起始时间会有一个时间间隔，通过这个时间间隔 Scroller 得出 View 当前的滑动位置，知道了滑动位置就可以通过 scrollTo 方法完成 View 的滑动。 View 的每一次重绘都会导致 View 的小幅度滑动，而多次的小幅度滑动组成了弹性滑动，这就是 Scroller 滑动的工作机制。 123456789101112131415161718192021Scroller mScroller = new Scroller(mContext);// 缓慢滚动到指定的位置 private void smoothScrollTo(int destX, int destY)&#123; int scrollX = getScrollX(); int deltaX = destX - scrollX; // 以 1000ms 内滑向 destX， 效果是慢慢滑动 mScroller.startScroll(scrollX, destY, deltaX , 0, 1000); // View 的重绘 invalidate();&#125; // 重写 computeScroll 方法，并在内部完成平滑滚动的逻辑 @Overridepublic void computeScroll() &#123; //判断view是在指定时间内是否完成滑动,并计算出当前时间的 mScrolleX 和 mScrollY if (mScroller.computeScrollOffset())&#123; //通过mScroller获取当前位置，实现滑动 scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); // 再次进行重绘 postInvalidate(); &#125;&#125; 通过动画属性动画：12ObjectAnimator animator = ObjectAnimator.ofFloat(view, "translationX", 0.0f, 100.0f);animator.setDuration(100).start(); 或者 1234567891011121314151617181920private void scroller()&#123; //动画起始位置 final int startX = 0; //动画要滑动的距离 final int deltax = 1000; final ValueAnimator animator = ValueAnimator.ofInt(0, 1).setDuration(2000); //动画添加监听器 animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; //获取动画完成比例值 float fraction = animator.getAnimatedFraction(); //根据比例值对目标view进行滑动 targetView.scrollTo(startX +(int)(deltax * fraction), 0); //add other operation &#125; &#125;); //开始执行 animator.start();&#125; 第二种方法思想和Scroller很类似，通过时间流逝比例来计算滑动距离。 使用延迟策略 使用Handler或者View的postDelay方法，间隔的发送消息，计算滑动距离，并使用scrollTo完成滑动。 View的事件分发 点击事件的传递规则1public boolean dispatchTouchEvent(MotionEvent ev) 用来进行事件的分发，如果事件能够传递给当前的View，那么此方法一定会被调用，返回结果受当前View的onTouchEvent和下级的View的dispatchTouchEvent方法的影响，表示是否消耗当前事件。 1public boolean onInterceptTouchEvent(MotionEvent event) 在dispatchTouchEvent内部调用，用来判断是否拦截某个事件，如果当前View拦截了某个事件，那么在同一个事件序列中，此方法不会被再次调用，返回结果表示是否拦截当前事件。 1public boolean onTouchEvent(MotionEvent event) 在dispatchTouchEvent中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一事件序列中，当前View无法再次接收到事件。 伪代码表示： 123456789public boolean dispatchTouchEvent(MotionEvent ev) &#123; boolean consume = false; if (onIterceptTouchEvent(ev)) &#123; //拦截事件 consume = onTouchEvent(ev); //自己处理事件 &#125; else &#123; consume = child.dispatchTouchEvent(ev); //分发给子View处理事件 &#125; return consume;&#125; 注意⚠️如果一个View设置了OnTouchListener，那么onTouch方法将优先被调用；如果onTouch方法返回ture，onTouchEvent方法将不会被调用，返回false，onTouchEvent方法会被调用；在onTouchEvent中，如果设置了OnClickListener，那么它的onClick方法将被调用。优先级：onTouch—&gt;onTouchEvent—&gt;onClick 事件传递顺序：Activity—&gt;Window—&gt;View, 如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将被调用，以此类推，如果所有元素都不处理这个事件，那么最终传递给Activity的onTouchEvent来处理。 一个事件序列，从ACTION_DOWN开始，中间有数量不定的ACTION_MOVE,最终以ACTION_UP结束。 一个事件序列只能被一个View拦截且消耗，一旦某个View决定拦截，那么这个事件序列都只能由它来处理，并且它的onIterceptTouchEvent不会再被调用（onIterceptTouchEvent仅仅调用一次）。 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvent返回false），那么同一事件序列中的其他事件都不会再交给它处理，并且事件将重新交给它的父元素去处理。 ViewGroup默认不拦截任何事件，onInterceptEvent方法默认返回false。 View没有onInterceptEvent方法，一旦有事件传递给它，那么onTouchEvent方法就会被调用。 View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable默认都为false。enable属性不影响onTouchEvent的返回值。 onClick发生的前提是View是可点击的，并且收到了down和up事件。 事件传递过程是由父元素分发到子元素，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预夫元素的事件分发过程（ACTION_DOWN除外）。 事件分发源码解析事件分发总体图： Activity对点击事件的分发过程 1Activiy—&gt;Window(PhoneWindow)—&gt;DecorView—&gt;ContentView—&gt;顶级ViewGroup—&gt;Views ViewGroup对点击事件的分发过程 View对点击事件的处理 ​ 总结： 参考: Android事件分发机制详解 Android事件分发机制完全解析，带你从源码的角度彻底理解(下) Android View的事件分发机制和滑动冲突解决 图解 Android 事件分发机制 View 的滑动冲突常见的滑动冲突场景： 场景1——外部滑动方向和内部滑动方向不一致（ViewPager + ListView） 场景2——外部滑动方向和内部滑动方向一致（SrcollView + ListView） 场景3——上面两种情况的嵌套（SlideMenu + ScrollView + ListView） 怎么处理？利用事件分发机制，针对滑动冲突使用外部拦截法和内部拦截法 外部拦截法 指点击事件通过父容器的拦截处理，如果父View需要拦截就拦截，否则交给子View处理，这种方法符合事件的分发机制。需要重写父容器的onInterceptTouchEvent方法。 12345678910111213141516171819202122232425262728public boolean onInterceptTouchEvent(MotionEvent event) &#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; intercepted = false; //必须返回false break; &#125; case MotionEvent.ACTION_MOVE: &#123; if (满足父容器的拦截要求) &#123; intercepted = true; &#125; else &#123; intercepted = false; &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; intercepted = false; //必须返回false break; &#125; default: break; &#125; mLastXIntercept = x; mLastYIntercept = y; return intercepted;&#125; 根据业务逻辑需要，在ACTION_MOVE方法中进行判断，如果需要父View处理则返回true，否则返回false，事件分发给子View去处理。 ACTION_DOWN 一定返回false，不要拦截它，否则根据View事件分发机制，后续ACTION_MOVE 与 ACTION_UP事件都将默认交给父View去处理！ 原则上ACTION_UP也需要返回false，如果返回true，并且滑动事件交给子View处理，那么子View将接收不到ACTION_UP事件，子View的onClick事件也无法触发。而父View不一样，如果父View在ACTION_MOVE中开始拦截事件，那么后续ACTION_UP也将默认交给父View处理！ 内部拦截法 即父View不拦截任何事件，所有事件都传递给子View，子View根据需要决定是自己消费事件还是给父View处理。这需要子View使用requestDisallowInterceptTouchEvent方法才能正常工作。下面是子View的dispatchTouchEvent方法的伪代码： 12345678910111213141516171819202122232425262728public boolean dispatchTouchEvent(MotionEvent event) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: &#123; parent.requestDisallowInterceptTouchEvent(true);//父容器设置不拦截 break; &#125; case MotionEvent.ACTION_MOVE: &#123; int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) &#123; parent.requestDisallowInterceptTouchEvent(false);//父容器设置拦截 &#125; break; &#125; case MotionEvent.ACTION_UP: &#123; break; &#125; default: break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 父View需要重写onInterceptTouchEvent方法： 12345678public boolean onInterceptTouchEvent(MotionEvent event) &#123; int action = event.getAction(); if (action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125; 使用内部拦截法需要注意： 内部拦截法要求父View不能拦截ACTION_DOWN事件，由于ACTION_DOWN不受FLAG_DISALLOW_INTERCEPT标志位控制，一旦父容器拦截ACTION_DOWN那么所有的事件都不会传递给子View。 滑动策略的逻辑放在子View的dispatchTouchEvent方法的ACTION_MOVE中，如果父容器需要获取点击事件则调用 parent.requestDisallowInterceptTouchEvent(false)方法，让父容器去拦截事件。 参考： 一文解决Android View滑动冲突]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>View的事件分发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC机制]]></title>
    <url>%2F2018%2F02%2F22%2FIPC%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Android中的多进程模式开启多进程模式 在AndroidMenifest中为四大组件指定android:process属性 通过JNI在native层fork一个新的进程 查看进程信adb shell ps | grep packagename android:process 属性方式区别 “:remote”开头，进程名为packagename:remote ,属于当前应用的私有进程。 “com.packagename.remote”完整命名则属于全局进程，通过具有相同的ShareUID和签名，两个不同应用可以跑在同一个进程中。具有相同UID的应用可以共享数据（data目录、组件信息等） 多进程模式运行机制 不同的进程的组件会拥有独立的虚拟机、Application、以及内存空间。 多进程注意的问题： 静态成员和单列不能跨进程使用 线程同步失效 SharedPreference的可靠性下降 Application会多次创建 SharePref底层通过读写xml文件实现，并发执行读写操作可能会导致一定几率的数据丢失 ​ IPC基础概念介绍Serializable接口 123456public class User implements Serializable &#123; private static final long serialVersionUID = 87113688048893844L; public int userId; public String userName; public boolean isMale;&#125; 这个serialVersionUID是用来辅助序列化和反序列化的，序列化时会将该字段写入文件中，然后反序列化时检测文件中的serialVersionUID是否与当前类一致。如果不一致，将序列化失败。 最好能够手动指定serialVersionUID，这样版本更新后，我们可能删除或新增了一些Field，但是反序列化仍能成功。不指定的话由于类内部成员变化，所以计算hash值变化，导致反序列失败。 静态成员不参与序列化 transient关键字标记的成员变量不参与序列化 Serialable接口是序列化需要大量I/O操作，开销大 Parcelable接口 Parcelable主要用在内存序列化上，效率高，Android平台推荐用。 但是对象序列化后要网络传输和持久化存储推荐用Serialable。 Binder驱动 Client和Server分别属于不同的进程，他们之间的对象不能直接共享，那么是怎么传递的呢？ 其实就是通过Binder驱动。Client端拿到的其实是Server端Binder对象的Proxy对象，通过调用该Proxy对象的方法，实际效果相当于Server的Binder中的方法。 从进程间通信的角度看，Binder 是一种进程间通信的机制； 从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象； 从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理 从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。 ​ Binder Binder是客户端和服务端通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务和数据。aidl类核心实现内部类Stub以及Stub的内部代理类Proxy。 DESCRIPTOR Binder的唯一标示，一般用当前Binder的类名 asInterface(android.os.IBinder obj) 用于将服务端的Binder对象转换成客户端所需的AIDL接口类型对象，区分进程，如果客户端和服务端位于同一进程，返回服务端的Stub对象本身，否则返回Stub.proxy对象。 asBinder 返回当前的Binder对象 onTransact 运行在服务端的Binder线程池中，原型为 1public Boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flag) code确定目标方法，data目标参数，reply写入返回值。 Proxy#getBookList 这个方法运行在客户端，客户端远程调用该方法，创建输入型Parcel对象data，输出型Parcel对象_reply和返回值对象List。接着调用transact方法发起RPC（远程过程调用）请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC返回，当前线程继续执行，并从_reply中返回结果。 通过linkToDeath 和 unlinkToDeath给Binder设置死亡代理DeathRecipient，当服务端进程异常终止时，可以收到通知。 Android中的IPC方式 使用Bundle 使用文件共享（考虑并发读写的问题，注意⚠️SharedPrefences不支持跨进程读写） 使用Messenger 信使 使用AIDL ​ 使用Messager ​ Messgener的工作原理 AIDL 服务端：创建一个service来监听客户端的请求，创建一个AIDL文件，暴露出AIDL接口供客户端调用，最后在service中实现这个AIDL接口。 客户端：bindService绑定服务，调用AIDL接口 AIDL文件支持类型：基本数据类型、String、ArrayList、HashMap、Pacelable对象、其他AIDL接口。 注意⚠️自定义的Pacelable对象必须新建一个和它同名的AIDL文件，并显示import进来。 除了基本数据类型，其他参数必须表上方向：in、out、inout 1234##Book.aidlpackage com.ryg.chapter_2.aidl;parcelable Book; 123456789101112##IBookManager.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;import com.ryg.chapter_2.aidl.IOnNewBookArrivedListener;interface IBookManager &#123; List&lt;Book&gt; getBookList(); void addBook(in Book book); void registerListener(IOnNewBookArrivedListener listener);//obsever mode void unregisterListener(IOnNewBookArrivedListener listener);&#125; 12345678##IOnNewBookArrivedListener.aidlpackage com.ryg.chapter_2.aidl;import com.ryg.chapter_2.aidl.Book;interface IOnNewBookArrivedListener &#123; void onNewBookArrived(in Book newBook);&#125; AIDL中观察者模式的使用，提供一个AIDL接口，客户端需要实现该listener（通过继承该Listener.Stub接口），传递给服务端，服务端处理完成后再回调回客户端。 注册和解注册，使用==RemoteCallbackList==，专门提供用于删除跨进程的listener接口。 如果某个远程方法是耗时的，那么要避免在客户端UI线程中去访问远程方法，否则会导致客户端ANR。客户端的onServiceConnected和onServiceDisconnected方法都运行在UI线程中，所以也不能在这里调用服务端的耗时方法。解决的办法是在非UI线程中调用原厂方法。 同理，如果有服务端需要调用客户端的listener方法，被调用的方法将运行在客户端的Binder线程池中，如果listener中的方法比较耗时，也要注意服务端的ANR问题。 Binder意外死亡重连 给Binder设置DeathRecipient监听（在客户端Binder线程中被回调） 在onServiceDisconnected中重连远程服务（在客户端UI线程被回调） 权限验证 AndroidMenifest.xml声明权限 123&lt;permission android:name="com.ryg.chapter_2.permission.ACCESS_BOOK_SERVICE" android:protectionLevel="normal" /&gt; 在服务队的onBind或者onTransact方法中进行权限验证。 使用ContentProvider继承ContentProvider，通过ContentResolver的query、update、insert、delete方法实现数据库SQLiteOpenHelper的CRUD操作。 使用Socket使用ServerSocket—&gt;TCP连接; UDP也是跨进城的通信方式。 Binder连接池 面对多个模块需要用到AIDL，我们不能针对每一个AIDL接口单独创建多个Service。 这种模式下：每个业务模块创建自己的AIDL接口并实现此接口，不同业务模块之间没有耦合，并向服务端提供自己的唯一标识和对应的Binder对象；对于服务端来说，只需要提供一个Service，并包含一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象；不同业务模块拿到自己的Binder对象后就可以进行远程方法调用了。 Binder连接池的作用就是将每个业务模块的Binder请求统一转发到远程的Service中去执行，从而避免重复创建Service。 Binder连接池工作原理 123456## Module A package com.ryg.chapter_2.binderpool;interface ISecurityCenter &#123; String encrypt(String content); String decrypt(String password);&#125; 12345## Module Bpackage com.ryg.chapter_2.binderpool;interface ICompute &#123; int add(int a, int b);&#125; 12345678910## BinderPool aidl interfacepackage com.ryg.chapter_2.binderpool;interface IBinderPool &#123; /** * @param binderCode, the unique token of specific Binder&lt;br/&gt; * @return specific Binder who's token is binderCode. */ IBinder queryBinder(int binderCode);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134package com.ryg.chapter_2.binderpool;import java.util.concurrent.CountDownLatch;import android.content.ComponentName;import android.content.Context;import android.content.Intent;import android.content.ServiceConnection;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;public class BinderPool &#123; private static final String TAG = "BinderPool"; public static final int BINDER_NONE = -1; public static final int BINDER_COMPUTE = 0; public static final int BINDER_SECURITY_CENTER = 1; private Context mContext; private IBinderPool mBinderPool; //BinderPool aidl interface private static volatile BinderPool sInstance; private CountDownLatch mConnectBinderPoolCountDownLatch; private BinderPool(Context context) &#123; mContext = context.getApplicationContext(); connectBinderPoolService(); &#125; // singleton, double check public static BinderPool getInsance(Context context) &#123; if (sInstance == null) &#123; synchronized (BinderPool.class) &#123; if (sInstance == null) &#123; sInstance = new BinderPool(context); &#125; &#125; &#125; return sInstance; &#125; /** ** 绑定BinderPool的远程服务 **/ private synchronized void connectBinderPoolService() &#123; mConnectBinderPoolCountDownLatch = new CountDownLatch(1); Intent service = new Intent(mContext, BinderPoolService.class); mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE); try &#123; //将bindService这异步操作转为同步的，耗时操作 mConnectBinderPoolCountDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; /** * query binder by binderCode from binder pool * * @param binderCode * the unique token of binder * @return binder who's token is binderCode&lt;br&gt; * return null when not found or BinderPoolService died. */ public IBinder queryBinder(int binderCode) &#123; IBinder binder = null; try &#123; if (mBinderPool != null) &#123; binder = mBinderPool.queryBinder(binderCode); &#125; &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; return binder; &#125; private ServiceConnection mBinderPoolConnection = new ServiceConnection() &#123; @Override public void onServiceDisconnected(ComponentName name) &#123; // ignored. &#125; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinderPool = IBinderPool.Stub.asInterface(service); try &#123; mBinderPool.asBinder().linkToDeath(mBinderPoolDeathRecipient, 0); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; mConnectBinderPoolCountDownLatch.countDown(); &#125; &#125;; private IBinder.DeathRecipient mBinderPoolDeathRecipient = new IBinder.DeathRecipient() &#123; @Override public void binderDied() &#123; Log.w(TAG, "binder died."); mBinderPool.asBinder().unlinkToDeath(mBinderPoolDeathRecipient, 0); mBinderPool = null; connectBinderPoolService(); &#125; &#125;; /** * 当Binder连接池连接上远程服务时，会根据不同模块的标识bindeCode返回不同的Binder对象， * 通过这个对象所执行的操作发生在远程服务器 **/ public static class BinderPoolImpl extends IBinderPool.Stub &#123; public BinderPoolImpl() &#123; super(); &#125; @Override public IBinder queryBinder(int binderCode) throws RemoteException &#123; IBinder binder = null; switch (binderCode) &#123; case BINDER_SECURITY_CENTER: &#123; binder = new SecurityCenterImpl(); break; &#125; case BINDER_COMPUTE: &#123; binder = new ComputeImpl(); break; &#125; default: break; &#125; return binder; &#125; &#125;&#125; 有了BinderPool机制后，如果有一个新的业务模块需要加AIDL，那么在实现的自己的AIDL接口后，只需要修改BInderPoolImpl中的queryBinder方法给自己添加一个binderCode并返回对应的Binder对象即可，不需要创建新的Service。 选用合适的IPC方式 名称 优点 缺点 适用场景 Bundle 简单易用 只能传输Bundle支持的数据 四大组件间的进程通信 文件共享 简单易懂 不适合高并发场景，并且无法做到进程间即时通信 无并发，交换简单的数据、实时性不高的场景 AIDL 功能强大，支持一对多并发通信 使用复杂，需要处理好线程同步 一对多通信有RPC需求 Messager 功能一般，支持一对多串行通信 不能处理并发情形，不支持RPC，数据通过Message传输，只能支持Bundle数据类型 串行一对多即时通信，无RPC需求，或者无需返回结果RPC需求 ContentProvider 在数据源访问功能强大，支持一对多并发数据共享 可以理解为受约束的AIDL，主要提供数据源的CRUD 一对多的进程间数据共享 Socket 功能强大，通过网络传输字节流，支持一对多的并发实时通信 实现细节稍微繁琐，不支持直接的RPC 网络数据交换]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>AIDL</tag>
        <tag>Binder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的生命周期和启动模式]]></title>
    <url>%2F2017%2F07%2F13%2FActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activity的生命周期和启动模式生命周期分析典型生命周期分析 onStart和onStop是从Activity是否可见的这个角度回调的，而onResume和onPause是从Activity是否位于前台这个角度来回调的。 Activity的启动过程很复杂，涉及Instrumentation、ActivityThread和ActivityManagerService（简称AMS）；简单理解，启动Activity的请求会由Instrumentation来处理，然后它通过Binder向AMS发请求，AMS内部维护一个ActivityStack并负责栈内的Activity的状态同步，AMS通过ActivityThread去同步Activity的状态从而完成生命周期方法的调用。 假设当前Activity是A，新启动一个Activity B，那么A的onPause先执行，然后B的onCreate、onStart、onResume，再是A的onStop。 所以Android官方文档中有说明，不能在onPause中作重量级的耗时操作，因为onPause执行完后新的Activity才能Resume。注：不要在onPause和onStop中执行耗时操作，尤其是onPause。 异常情况下的生命周期分析 资源相关的系统配置改变导致Activity被杀死并重新创建 配置改变（旋转）onPause–&gt;onSaveInstanceState–&gt;onStop–&gt;onDestroy–&gt;重建–&gt;onCreate–&gt;onStart–&gt;onRestoreInstanceState 注意：onSaveInstanceState在onStop之前，onRestoreInstanceState在onStart之后 资源内存不足导致低优先级的Activity被杀死 屏幕旋转时候Activity不想重新创建，配置android:configChanges=&quot;orientation|screenSize|keyboardHidden&quot; Activity的启动模式（LaunchMode） standard：标准模式 与启动他的Activity运行在同一个的任务栈中； singleTop：栈顶复用模式 singleTask：栈内复用模式 多次启动Activity不会重复创建实例，回调其onNewIntent，并附带ClearTop效果。 什么是任务栈？？ 与参数TaskAffinity关联，也称为任务相关性，该属性表示任务栈的名字，默认就是packageName，也可以单独指定TaskAffinity的属性； 根据Activity是否位于暂停状态，又可以分为前台任务栈和后台任务栈。 1adb shell dumpsys activiy Activity的Flag FLAG_ACTIVITY_NEW_TASK—&gt;”singleTask” FLAG_ACTIVITY_SINGLE_TOP—&gt;”singleTop” FLAG_ACITIVY_CLEAR_TOP—&gt;一般配合“singleTask”使用，回调onNewIntent FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 移除历史Activity列表 IntentFilter的匹配规则 action的匹配规则—&gt;Intent中必须有一个action能够和IntentFilter中的某个action相同 categoty的匹配规则—&gt;Intent中可以没有category，但是如果有categoty，则每个category都需要和IntentFilter中的相同。 在startActiviy时，系统默认会为Intent加上android.intent.categoty.DEFAULT这个category，所以IntentFilter中必须有上述category才能接受隐式调用； data的匹配规则: mimeType + URI URI默认为content和file；如果要为Intent完整指定data，必须调用setDataAndType方法。 判断是否有Activity配置隐式Intent—&gt;可以用PackageManager的resolveActivity方法或者Intent的resolveActivity方法]]></content>
      <categories>
        <category>Android开发艺术探索</category>
      </categories>
      <tags>
        <tag>Activity的生命周期和启动模式</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F07%2F13%2Frefactor%2F</url>
    <content type="text"><![CDATA[#重构 Extract Method (提炼函数) Move Method (搬移函数） Self Encapsulate Field (自封装字段) Replace Type Code With State/Strategy (以状态／策略模式取代状态码) Replace Condition with Polymorphism (以多态取代条件表达式) ###重构原则 何为重构 对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 为何重构 改进软件设计、是软件更容易理解、帮助找到bug、提高编程速度。 何时重构 添加功能时重构、修补错误时重构、复审代码时重构 重构与间接层 间接层价值： 允许逻辑共享、分开解释意图和实现、隔离变化、封装条件逻辑（多态） 重构的难题 数据库迁移、修改已公布的接口、难以重构的复杂设计 ###代码的坏味道 Duplicated code（重复代码） Long Method（过长函数） Large Class（过大的类） Long Parameter List (过长参数列） Divergent Change （发散式变化）一种类受多种变化的影响，类过大，需Extract class Shotgun Surgery（散弹式修改）一种变化引起多个类修改，需Move Method移到同一个类 Feature Envy（依恋情结）总是一起变化的东西放在一块 Data Clumps （数据泥团）多个类中重复的字段、方法。需Extract class到一个独立对象 Primitive Obsesstion （基本类型偏执）必要时用对象代替基本数据 Switch Statement（switch语句）需要抽出方法，用子类或state/strategy模式替代 Parallel Inheritance Hierarchies （平行继承体系）散弹修改的一种，需用引用代替继承 Lazy Class（冗余类） Speculative Generality（夸夸其谈未来性）多余的抽象、委托、参数应该去除 Temporary Field (迷惑的暂时字段) 可以的话提炼到一个独立的类中 Message ChainsI（过度耦合的消息链） Middle Man（中间人）过度使用委托 Inappropriate Intimacy (狎昵关系) 拆散过渡亲密的类，Move Method 或 Move Field到合适的地方；提炼共性到新类；Replace Inheritance with Delegation Alternative Classes With Different Interfaces (异曲同工的类) 重新命名或提取超类 Incomplete Library Class (不完美的类库) Data Class（存粹的数据类）注意封装和访问权限 Refused Bequest（被拒绝的馈赠）子类服用的超类的行为（实现），却不愿支持超类的接口，需重构（这里思考Basesso类的3个abstract方法有这个问题，不愿支持超类的接口） Comments（过多注释） ###重新组织函数 Extract Method（提炼函数） 将一段代码放进一个独立的函数中，并让函数名称解释该函数的用途。 如果源函数中局部变量比较多，先用Replace Temp With Query减少临时变量，源函数中读取的临时变量和参数，提炼到目标函数作为参数，并考虑是否需要返回值。 Inline Method （内联函数） 一个函数和本体一样清楚易懂，在函数调用点插入函数体，然后移除该函数。 Inline Temp（内联临时变量） 将临时变量替换为对它赋值的表达式或函数。 Replace Temp With Query（以查询取代临时变量） 将临时变量的计算代码提炼到一个独立的函数中，这样临时变量的引用点就可以替换为新函数的调用。 以查询代替临时变量可以减少临时变量，是提炼函数的重要步骤。 Introduce Explaining Variable (引入解释性变量) 将该复杂表达式的结果放进一个临时变量，以此变量名称来解释表达式的作用。 或者Extract Method来处理 Split Temporary Variable (分解临时变量) 某个临时变量，既不是循环变量也不是收集变量；针对每次赋值，创造一个独立的、有合理名称的临时变量来分解重复赋值。 Remove Assignments to Parameters(移除对参数的赋值） 代码对参数进行赋值，以一个临时变量取代该参数的位置 Java是按值传递的 123void aMethod(Object foo) &#123; foo.modifySomeWay(); //that's OK，将改变foo引用的对象 foo = anothnerObject; //trouble will follow, 函数返回后并不会改变foo。 Replace Method with Method Object(以函数对象取代函数） 有一个大型函数其中存在大量的局部变量，很难Extract Method来分解这个函数，那么使用函数对象。 将原函数替代成函数对象，该函数对象的构造函数接受源对象和原函数的参数作为参数； 针对原函数每个临时变量和每个参数，在新的函数对象中建立一个对应的字段保存； 然后就可以在函数对象中Extract Method来分解原函数； Substitute Algorithm (替换算法) 将函数本体替换为新的算法，建议先考虑分解函数再做替换。 ###在对象之间搬移特性 Move Method (搬移函数) 函数与其他类耦合过多，考虑使用委托或搬移到合适的类中。 搬移过程中，当目标类需要源类特性时，1）将这个特性也搬移到目标类 2）建立使用目标类到源类的使用 3）将源对象或该特性变量作为参数传递给目标类 Move Field (搬移字段) 某个字段被所驻类之外的另一个类更多地用到，考虑搬移这个字段到目标类。 Self Encapsulate（使用自我封装）在字段搬移后，就只需要修改访问函数（set／get），而无需修改引用点。 Extract Class（提炼类） 建立一个新类，将相关字段和函数从旧类搬移到新类。 可能需要双向连接，尽量避免建议新类到旧类的连接；决定是否公开新类； Inline Class（内联化类） 将这个类的所有特性搬移到另一个类，然后移除这个类； Hide Delegate (隐藏“委托关系“) 客户类通过委托类来调用另一个对象，在服务类上建立客户需要的所有委托函数，用于隐藏委托关系。 ​ Remove Middle Man（移除中间人） 某个类做了过多的委托动作，那么可以直接让客户类调用受托类； 服务类中建立一个函数，直接返回受托类，客户类直接调用该类； 隐藏委托关系与移除中间人互为逆向的行为。 Introduce foreign Method (引入外加函数) 场景：你需要为提供服务的类增加一个函数，但是却无法修改这个类 应对：在客户类中建立一个函数，并传入一个服务类的实例参数； 如果需要外加多个函数，考虑使用引入本地扩展。 Introduce Local Extension (引入本地扩展) 场景：你需要为服务类提供一些额外的函数，但是你无法修改这个类 应对：建立一个新类，包含这些额外的函数，让这个扩展品称为源类的字类（subclass）或包装类（wrapper）； ###重新组织数据 Self Encapsulate Field (自封装字段) 直接访问字段，产生耦合关系；为这些字段建立get/set函数，并以这些函数访问字段。 直接访问字段还是通过get/set函数访问哪个好没有定论。 Replace Data Value with Object(以对象取代数据值) 如果有一个数据项需要与其他数据或者行为一起使用才有意义，那么将数据变成对象。 数据值 —&gt; 值对象,值对象应该是不可修改的 区别：如果数据可修改，使用引用对象，Change value to Reference Change Value into Reference(将值对象改为引用对象) 从一个类衍生出多个相等的实例，希望它们是同一个对象；将值对象变成引用对象； 多个Order共享同一个Customer对象 引用对象都代表真实世界中的一个实物，可以用==直接检查两个对象是否相等；如“客户”、“账户”等.. 值对象不可变，完全由其数据值来定义，有多个副本存在，需要复写equals()判断是否相等，如“日期”、“钱”.. Change Reference to Value(将引用对象改为值对象) 有一个引用对象，很小且不可变，将它改为值对象。 值对象是“不可变”（immutable）的，表示对象自身是不可变的。判断相等用equals()方法 Replace Array with Object(以对象代替组数) 有一个数组，其中的元素各自代表不同的东西 以对象代替数组，对于数组中的每一个元素，以一个字段来表示 Duplicate Observed Data(复制“被监视的数据”) 有一些领域（Model）数据置身于GUI控件中，而领域函数需要访问需要访问这数据； 将该数据复制到领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据； Change Unidirectional Association to Bidirectional(将单向关联改为双向关联) 场景：两个类都需要使用对方的特性，但只有一条单向关联 实现：添加一个反向指针，并使修改函数能够同事更新两条连接 决定哪个类是控制端；控制端（提供控制函数，维护反向指针），修改函数调用控制函数；被控制端（提供一个辅助函数提供反向指针），修改函数调用控制端的控制函数。 Change Bidirectional Association to Unidirectional（将双向关联改为单向关联) 场景：两个类之间有双向关联，但其中一个类如今不再需要另一个类的特性； 去除不必要的关联 Replace Magic Number with Symbolic Constant(以字面常量代替魔法数) 创建一个常量，根据其意义命名，替换上述魔法数 Encapsulate Field(封装字段) 将public字段声明为private，并提供相应的get/set访问函数 Encapsulate Collection(封装集合) 场景：有一个函数返回一个集合 优化：让这个函数返回该集合的一个只读副本，并提供添加／移除该集合元素的方法 Replace Record with Data Class(以数据类取代记录) 为记录结构型数据创建一个数据对象 Replace Type Code with Class(以类取代类型码) 场景：类中又一个数值类型码，但它并不影响类的行为 以一个新的类替换该数值类型码 Replace Type Code with Subclasses(以子类取代类型码) 场景：有一个不可变的类型码，它会影响类的行为 重构：以字类取代这个类型码，借助多态实现变化行为,将和特定字类相关的字段／函数push down到字类 Replace Type Code with State/Stratege(以状态／策略取代类型码) 场景：如果一个类型码的值在对象生命周期发生变化或者其他原因是宿主类不能被继承； 重构：以状态对象或策略模式取代类型码 Replace Subclass with Fields(以字段代替子类) 场景：各个子类的唯一差别只在“返回常量数据”的函数身上 重构：修改这些函数，使它们返回超类中的某个（新增）字段，然后销毁子类 ###简化条件表达式 Decompose Conditional(简化条件表达式) 场景：有一个复杂的条件if-then-else语句 从if、then、else段落中分别提炼出独立的函数，函数名可以直观反映出函数的用途 Consolidate Conditional Expression(合并条件表达式) 场景：有一系列的条件测试，均得到相同的结果 重构：将这些测试合并为一个条件表达式，并将这个条件表达式提炼为一个独立的函数 使用||、&amp;&amp;、？：合并测试条件 Consolidate Duplicate Conditional Fragments(合并重复的条件片段) 场景：在条件表达式的每个分支上都有相同的一段代码 重构：将这段代码搬移到条件表达式外，并提炼出独立函数 Remove Control Flag(移除控制标记) 在一系列的布尔表达式中，某个变量带有控制标记（control flag）的作用 以break或者return语句取代这个控制标记 Replace Nested Conditional with Guard Clauses(以位语句取代嵌套的条件表达式) 场景：函数中条件逻辑使人迷惑 重构：使用卫语句表现所有特殊情况，立即返回结果；最后处理正常逻辑； 使用卫语句检查特殊条件，立刻返回或抛出异常； 可以先将条件表达式反转实现卫语句（P253）； Replace Conditional with Polymorphism(以多态取代条件表达式) 场景：有一个条件表达式，根据对象类型的不同选择不同的行为 重构：将这个条件表达式的每个分支放进一个子类的复写函数中，然后将原始的函数声明为抽象 在使用Replace Coditional with Polymorphism之前,必须建立一个继承结构：优先使用Repalce Type Code with Subclass，但是如果需要在对象创建后修改类型码，就不能用继承手法，那么使用 Replace Type Code with State/Stratege; Introduce Null Object(引入Null对象) 场景：你需要再三检查某个对象是否为null 重构：建立Null对象，替换null值的判断 空对象继承源对象，或者实现Null Interface；空对象一定是一个常量，它的任何成分都不会变化； Introduce Assertion(引入断言) 某一段代码需要对程序状态作出假设，以断言明确表示这种假设 ###简化函数调用 Rename Method(函数改名) 给每一个函数取一个可以揭示函数用途的、直观的名字 Add Parameter(添加参数) 为此函数添加一个对象参数，让该对象参数带进函数所需信息 Remove Parameter(移除参数) 移除多余的参数 Separate Query from Modifier(将查询函数和修改函数分离) 场景：某个函数既返回对象状态值，有修改对象状态 重构：建立两个独立的函数，一个负责查询，另一个负责修改 注意并发编程中，可保留查询-修改函数，调用各自独立的查询函数和修改函数，并声明为synchronised Parameterize Method(令函数携带参数) 若干函数做了类似的工作，但因少数几个值致使行为略有不同 建立单一函数，以参数表达那些不同的值 Replace Parameter with Explicit Method(以明确函数取代参数) 有一个函数安全取决于参数值而采取不同的行为 针对该参数的每一个可能值，建立一个独立函数；相反与Parameterize Method Preserve Whole Object(保持完整对象) 场景：你从对象中取出一些值，将它们作为参数传递给函数 重构：改为传递整个对象 Replace Parameter with Methods(以函数取代参数) 场景：对象调用一个函数，并将所得的结果作为参数，传递给另一个函数 重构：让参数接收这去处该项参数，并直接调用前一个函数 如果函数可以通过其他途径获取参数值，那么就应该去除该多余的参数 Introduce Parameter Object(引入参数对象) 场景：某些参数总是很自然的同时出现 重构：以一个对象取代这些参数，比如Range模式，范围对象取代(start,end) Remove Setting Method(移除设值函数) 场景：类中的某个字段应该在对象创建的时候被设值，然后不再改变 重构：去除该字段所有设值函数，同时声明该字段为final Hide Method(隐藏函数) 有一个函数从类没有被其他任何类用到过 将这个函数修改为private Replace Constructor with Factory Method(以工厂函数取代构造函数) 场景：在派生子类的过程中，需要根据类型码，创建相应的对象 重构：使用工厂函数取代构造函数 Encapsulate Downcast(封装向下转型) 场景：某个函数返回的对象需要由函数的调用者执行向下转型 重构：将向下转型的动作移到函数中 123Object lastReading() &#123; return reading.lastElement();&#125; 改为： 123Reading lastReading() &#123; return (Reading)reading.lastElement();&#125; Replace Error Code with Exception(以异常取代错误码) 场景：某个函数返回一个特定的代码，表示某种错误的情况 重构：改用异常 12345678int withdraw(int amount) &#123; if(amount &gt; _balance) &#123; return -1; &#125; else &#123; _balance -= amount; return 0; &#125;&#125; 改为： 1234void withdraw(int amount) throws BalanceException &#123; if(amount &gt; _balance) throw new BalanceExctption(); _balance -= amount;&#125; 决定函数应该抛出受控异常（checked）还是非受控异常（unchecked） 如果函数的调用者有责任在调用前检查必要状态，就抛出unchecked异常 抛出checked异常可以新建一个异常类继承Exception，或者使用现有的checked异常类 Replace Exception with Test(以测试取代异常) 场景：面对一个调用者可以预先检查的条件，你抛出了一个异常 修改调用者，使它在函数调用之前预先检查 1234567double getValueForPeriod(int periodNumber) &#123; try &#123; return _values[periodNumber]; &#125; catch(ArrayIndexOutOfBoundsException e) &#123; return 0; &#125;&#125; 改为： 1234double getValueForPeriod(int periodNumber) &#123; if ( periodNumber &gt;= _values.length ) return 0; return _values[periodNumber];&#125; 异常应该只被用于那些产生意料之外的错误行为，而不应该成为条件检查的工具；不要用try-catch语句作为条件判断语句； ###概括处理关系 Pull Up Field(字段上移) 如果两个子类拥有相同的字段，将该子段移到超类 Pull Up Method(函数上移) 场景：有些函数在子类中产生完全相同的结果 重构：将该函数移至超类 Pull Up Method过程中最麻烦的一点就是：被提升的函数可能会引用只出现在子类而不出现在超类的特性。 如果被引用的是一个函数，你可以将该函数一同提升到超类；或者在超类中建立一个抽象函数；或者建立一个委托函数 如果被引用的是子类的字段，你可以将该字段也提升到超类；或者先在子类中自封装字段，然后在超类中把取值函数声明为抽象 Pull Up Constructor Body(构造函数本体上移) 在子类中各拥有一些构造函数，它们的本体几乎一致 在超类中新建一个构造函数，并在子类构造函数中调用它 Pull Down Method(函数下移) 超类中的某个函数只与部分（而非全部）子类有关，将这个函数移到相关的那些子类中去 Pull Down Field(字段下移) 超类中的某个字段只被部分（而非全部）子类所用到，将这个字段移到需要它的那个子类中去 Extract SubClass(提炼子类) 场景：类中的某些特性只被某些（而非全部）实例用到 重构：新建一个子类，将上述一部分特性移到子类中 Extract SuperClass(提炼超类) 场景：两个类具有相似的特性 重构：为这两个类建立一个超类，将这些相同的特性搬移到超类 Extract Interface(提炼接口) 场景：若干客户使用类接口中的同一子集，或者两个类的接口有相同的部分 重构：将相同的子集提炼到一个独立的接口中 Collapse Hierarchy(折叠继承体系) 超类和子类之间无太大区别，将它们合为一体 From Template Method(塑造模版函数) 场景：你有一些子类，其中相应的某些函数以相同的顺序执行类似的操作，但各个操作细节上有所不同 重构：将这些细节操作分别放进独立的函数中，并保持它们都有相同的签名，于是原函数也变得相同了；然后将原函数上移到超类 Replace Inheritance with Delegation(以委托取代继承) 场景：某些子类只使用超类接口中的一部分，或者根本不需要继承而来的数据 重构：在子类中新建一个子段用以保存超类；调整子类函数令它委托超类；然后去掉继承关系 Replace Delegation with Inheritance(以继承取代委托) 场景：你在两个类之间使用委托关系，并经常为整个接口编写很多及其简单的委托函数 重构：让委托类继承受托类 ###大型重构 Tease Apart Inheritance(梳理并分解继承体系) 场景：某个继承体系同时承担两项责任 重构：建立两个继承体系，并通过委托关系让其中一个可以调用另一个 Convert Procedural Design to Objects(将过程化设计转化为对象设计) 场景：你手中有一些传统过程化风格的代码 重构：将数据记录变为对象，将大块行为分为小块，并将行为移入相关对象之中 Separate Domain from Presentation(将领域和显示分离) 某些GUI类中包含了领域逻辑 将领域逻辑分离出来，为它们建立独立的领域类 Extract Hierarchy(提炼继承体系) 场景：你有某个类做了大量的工作，其中一部分工作是以大量的条件表达式完成的 重构：建立继承体系，以一个子类表示一种特殊情况]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2017%2F05%2F16%2Fhexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Generate static files1$ hexo generate More info: Generating Run server1$ hexo server More info: Server Deploy to remote sites1$ hexo deploy BenefitsWith this feature, now you can put all your configurations into one place (source/_data/next.yml), you don’t need to touch next/_config.yml. If there are any new options in new releases, you just need to copy those options from next/_config.yml, paste into _data/next.yml and set their values to whatever you want. How to use this feature Please ensure you are using Hexo 3 (or above) Create an file named next.yml in site’s source/_data directory (create _data directory if it did not exist) Copy NexT theme options both in site’s _config.yml and theme’s _config.yml into next.yml. Use --config source/_data/next.yml parameter to start server, generate or deploy.For example: hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml. More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
