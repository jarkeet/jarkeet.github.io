<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="OkHttp," />










<meta name="description" content="以下内容为转载自：  OkHttp源码分析——整体架构  OkHttp是一个处理网络请求的开源项目,是Android端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。随着OkHttp的不断成熟，越来越多的Android开发者使用OkHttp作为网络框架。 之所以可以赢得如此多开发者的喜爱，主要得益于如下特点：  支持">
<meta name="keywords" content="OkHttp">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp源码解析">
<meta property="og:url" content="http://yoursite.com/2018/04/04/OkHttp 3.7源码分析/index.html">
<meta property="og:site_name" content="Writing something">
<meta property="og:description" content="以下内容为转载自：  OkHttp源码分析——整体架构  OkHttp是一个处理网络请求的开源项目,是Android端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。随着OkHttp的不断成熟，越来越多的Android开发者使用OkHttp作为网络框架。 之所以可以赢得如此多开发者的喜爱，主要得益于如下特点：  支持">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tNc79gy1fq0qyshpimj30k10ubtbe.jpg">
<meta property="og:image" content="https://ws1.sinaimg.cn/large/006tNc79gy1fq0qypmv13j30rs18gdhq.jpg">
<meta property="og:image" content="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e67029972070a7dd84206023b179dbd1.png">
<meta property="og:image" content="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png">
<meta property="og:image" content="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/59d08a51c67491151da84524ea04ce7b.png">
<meta property="og:image" content="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/0a7e20cbfa732fc661e88eb670aa4aa9.png">
<meta property="og:image" content="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/03c77355f41162f738505e202ac7860d.png">
<meta property="og:image" content="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a0b6775e83c2c1a24ed85e06ffa514fe.png">
<meta property="og:updated_time" content="2018-04-09T16:26:22.416Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OkHttp源码解析">
<meta name="twitter:description" content="以下内容为转载自：  OkHttp源码分析——整体架构  OkHttp是一个处理网络请求的开源项目,是Android端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。随着OkHttp的不断成熟，越来越多的Android开发者使用OkHttp作为网络框架。 之所以可以赢得如此多开发者的喜爱，主要得益于如下特点：  支持">
<meta name="twitter:image" content="https://ws4.sinaimg.cn/large/006tNc79gy1fq0qyshpimj30k10ubtbe.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'GB10AN7BSS',
      apiKey: 'd96e100af839e1d1e7116c114785f5b9',
      indexName: 'algolia_index',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/04/04/OkHttp 3.7源码分析/"/>





  <title>OkHttp源码解析 | Writing something</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Writing something</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/04/OkHttp 3.7源码分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="jarkeet">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Writing something">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OkHttp源码解析</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-04T17:18:38+08:00">
                2018-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/拆轮子/" itemprop="url" rel="index">
                    <span itemprop="name">拆轮子</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>以下内容为转载自：</p>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/78105?spm=5176.8091938.0.0.hlEONd" target="_blank" rel="external">OkHttp源码分析——整体架构</a></p>
</blockquote>
<p>OkHttp是一个处理网络请求的开源项目,是Android端最火热的轻量级框架,由移动支付Square公司贡献用于替代HttpUrlConnection和Apache HttpClient。随着OkHttp的不断成熟，越来越多的Android开发者使用OkHttp作为网络框架。</p>
<p>之所以可以赢得如此多开发者的喜爱，主要得益于如下特点：</p>
<ul>
<li>支持HTTPS/HTTP2/WebSocket（在OkHttp3.7中已经剥离对Spdy的支持，转而大力支持HTTP2）</li>
<li>内部维护任务队列线程池，友好支持并发访问</li>
<li>内部维护连接池，支持多路复用，减少连接创建开销</li>
<li>socket创建支持最佳路由</li>
<li>提供拦截器链（InterceptorChain），实现request与response的分层处理(如透明GZIP压缩，logging等)</li>
</ul>
<p>为了一探OkHttp是如何具备以下特点的，笔者反复研究OkHttp框架源码，力求通过源码分析向各位解释一二。所以特意准备了几篇博客跟大家一起探讨下OkHttp的方方面面，今天首先从整体架构上分析下OkHttp。</p>
<a id="more"></a>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>首先来看下OkHttp的简单使用，OkHttp提供了两种调用方式：</p>
<ul>
<li>同步调用</li>
<li>异步调用</li>
</ul>
<h4 id="同步调用"><a href="#同步调用" class="headerlink" title="同步调用"></a>同步调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</div><div class="line">    Response result = getResponseWithInterceptorChain(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先加锁置标志位，接着使用分配器的executed方法将call加入到同步队列中，然后调用getResponseWithInterceptorChain方法（稍后分析）执行http请求，最后调用finishied方法将call从同步队列中删除</p>
<h4 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback, forWebSocket));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样先置标志位，然后将封装的一个执行体放到异步执行队列中。这里面引入了一个新的类AsyncCall，这个类继承于NamedRunnable，实现了Runnable接口。NamedRunnable可以给当前的线程设置名字，并且用模板方法将线程的执行体放到了execute方法中</p>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>除了同步调用和异步调用，OkHttp还提供了一个拦截器的概念。拦截器提供了拦截请求和拦截服务器应答的接口。OkHttp提供了一个拦截器链的概念，通过将一个个拦截器组合成一个拦截器链，可以达到在不同层面做不同拦截操作的效果，有点<a href="http://baike.baidu.com/link?url=hdbJNXckViY2qwhMFvtVW38UBpBmvrRW361E1aGZSWXrz7T1waNZkC4R05mSzOhtgCCsduyMta81U-6MobXbm_" target="_blank" rel="external">AOP</a>的意思。具体拦截器的使用可以参考：<a href="http://www.jianshu.com/p/2710ed1e6b48" target="_blank" rel="external">Okhttp-wiki 之 Interceptors 拦截器</a></p>
<h3 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h3><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fq0qyshpimj30k10ubtbe.jpg" alt="OkHttp整体架构图"></p>
<p>上图是OkHttp的总体架构，大致可以分为以下几层：</p>
<ul>
<li>Interface——接口层：接受网络访问请求</li>
<li>Protocol——协议层：处理协议逻辑</li>
<li>Connection——连接层：管理网络连接，发送新的请求，接收服务器访问</li>
<li>Cache——缓存层：管理本地缓存</li>
<li>I/O——I/O层：实际数据读写实现</li>
<li>Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑</li>
</ul>
<p>整体流程图：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fq0qypmv13j30rs18gdhq.jpg" ,="" width="500px"></p>
<h4 id="Interface——接口层："><a href="#Interface——接口层：" class="headerlink" title="Interface——接口层："></a>Interface——接口层：</h4><p>接口层接收用户的网络访问请求（同步请求/异步请求），发起实际的网络访问。<code>OkHttpClient</code>是OkHttp框架的客户端，更确切的说是一个用户面板。用户使用OkHttp进行各种设置，发起各种网络请求都是通过<code>OkHttpClient</code>完成的。每个<code>OkHttpClient</code>内部都维护了属于自己的任务队列，连接池，Cache，拦截器等，所以在使用OkHttp作为网络框架时应该全局共享一个<code>OkHttpClient</code>实例。</p>
<p><code>Call</code>描述一个实际的访问请求，用户的每一个网络请求都是一个<code>Call</code>实例。<code>Call</code>本身只是一个接口，定义了<code>Call</code>的接口方法，实际执行过程中，OkHttp会为每一个请求创建一个<code>RealCall</code>,每一个<code>RealCall</code>内部有一个<code>AsyncCall</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">  <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</div><div class="line"></div><div class="line">    AsyncCall(Callback responseCallback) &#123;</div><div class="line">      <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</div><div class="line">      <span class="keyword">this</span>.responseCallback = responseCallback;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> originalRequest.url().host();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> originalRequest;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">      ...</div><div class="line">  &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AsyncCall</code>继承的<code>NamedRunnable</code>继承自Runnable接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NamedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> String name;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NamedRunnable</span><span class="params">(String format, Object... args)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = Util.format(format, args);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    String oldName = Thread.currentThread().getName();</div><div class="line">    Thread.currentThread().setName(name);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      execute();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      Thread.currentThread().setName(oldName);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以每一个Call就是一个线程，而执行Call的过程就是执行其<code>execute</code>方法的过程。</p>
<p><code>Dispatcher</code>是OkHttp的任务队列，其内部维护了一个线程池，当有接收到一个<code>Call</code>时，<code>Dispatcher</code>负责在线程池中找到空闲的线程并执行其<code>execute</code>方法。这部分将会单独拿一篇博客进行介绍，详细内容可参考本系列接下来的文章。</p>
<h4 id="Protocol——协议层：处理协议逻辑"><a href="#Protocol——协议层：处理协议逻辑" class="headerlink" title="Protocol——协议层：处理协议逻辑"></a>Protocol——协议层：处理协议逻辑</h4><p>Protocol层负责处理协议逻辑，OkHttp支持Http1/Http2/WebSocket协议，并在3.7版本中放弃了对Spdy协议，鼓励开发者使用Http/2。</p>
<h4 id="Connection——连接层：管理网络连接，发送新的请求，接收服务器访问"><a href="#Connection——连接层：管理网络连接，发送新的请求，接收服务器访问" class="headerlink" title="Connection——连接层：管理网络连接，发送新的请求，接收服务器访问"></a>Connection——连接层：管理网络连接，发送新的请求，接收服务器访问</h4><p>连接层顾名思义就是负责网络连接。在连接层中有一个连接池，统一管理所有的Socket连接，当用户新发起一个网络请求时，OkHttp会首先从连接池中查找是否有符合要求的连接，如果有则直接通过该连接发送网络请求；否则新创建一个网络连接。</p>
<p><code>RealConnection</code>描述一个物理Socket连接，连接池中维护多个RealConnection实例。由于Http/2支持多路复用，一个<code>RealConnection</code>可以支持多个网络访问请求，所以OkHttp又引入了<code>StreamAllocation</code>来描述一个实际的网络请求开销（从逻辑上一个<code>Stream</code>对应一个<code>Call</code>，但在实际网络请求过程中一个<code>Call</code>常常涉及到多次请求。如重定向，Authenticate等场景。所以准确地说，一个<code>Stream</code>对应一次请求，而一个<code>Call</code>对应一组有逻辑关联的<code>Stream</code>），一个<code>RealConnection</code>对应一个或多个<code>StreamAllocation</code>,所以<code>StreamAllocation</code>可以看做是<code>RealConenction</code>的计数器，当<code>RealConnection</code>的引用计数变为0，且长时间没有被其他请求重新占用就将被释放。</p>
<p>连接层是OkHttp的核心部分，这部分当然也会单独拿一篇博客详细讲解，详细内容可参考本专题相关文章。</p>
<h4 id="Cache——缓存层：管理本地缓存"><a href="#Cache——缓存层：管理本地缓存" class="headerlink" title="Cache——缓存层：管理本地缓存"></a>Cache——缓存层：管理本地缓存</h4><p>Cache层负责维护请求缓存，当用户的网络请求在本地已有符合要求的缓存时，OkHttp会直接从缓存中返回结果，从而节省网络开销。这部分内容也会单独拿一篇博客进行介绍，详细内容可参考本专题相关文章。</p>
<h4 id="I-O——I-O层：实际数据读写实现"><a href="#I-O——I-O层：实际数据读写实现" class="headerlink" title="I/O——I/O层：实际数据读写实现"></a>I/O——I/O层：实际数据读写实现</h4><p>I/O层负责实际的数据读写。OkHttp的另一大有点就是其高效的I/O操作，这归因于其高效的I/O库<a href="https://github.com/square/okio" target="_blank" rel="external">okio</a></p>
<p>这部分内容笔者也打算另开一个专题进行介绍。详细内容可以参考本博客相关内容。</p>
<h4 id="Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑"><a href="#Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑" class="headerlink" title="Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑"></a>Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑</h4><p>拦截器层提供了一个类AOP接口，方便用户可以切入到各个层面对网络访问进行拦截并执行相关逻辑。在下一篇博客中，笔者将通过介绍一个实际的网络访问请求实例来介绍拦截器的原理。</p>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/78104?spm=5176.8091938.0.0.hlEONd" target="_blank" rel="external">OkHttp源码分析——拦截器</a></p>
</blockquote>
<p>前一篇博客中我们介绍了OkHttp的总体架构，接下来我们以一个具体的网络请求来讲述OkHttp进行网络访问的具体过程。由于该部分与OkHttp的拦截器概念紧密联系在一起，所以将这两部分放在一起进行讲解。</p>
<h3 id="1-构造Demo"><a href="#1-构造Demo" class="headerlink" title="1.构造Demo"></a>1.构造Demo</h3><p>首先构造一个简单的异步网络访问Demo:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();        </div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">  .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</div><div class="line">  .build();</div><div class="line"></div><div class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</div><div class="line">    Log.d(<span class="string">"OkHttp"</span>, <span class="string">"Call Failed:"</span> + e.getMessage());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Log.d(<span class="string">"OkHttp"</span>, <span class="string">"Call succeeded:"</span> + response.message());</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="2-发起请求"><a href="#2-发起请求" class="headerlink" title="2. 发起请求"></a>2. 发起请求</h3><p><code>OkHttpClient.newCall</code>实际是创建一个<code>RealCall</code>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Prepares the &#123;<span class="doctag">@code</span> request&#125; to be executed at some point in the future.</div><div class="line"> */</div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>RealCall.enqueue</code>实际就是讲一个<code>RealCall</code>放入到任务队列中，等待合适的机会执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可以看到最终<code>RealCall</code>被转化成一个<code>AsyncCall</code>并被放入到任务队列中，任务队列中的分发逻辑这里先不说，相关实现会放在<a href="">OkHttp源码分析——任务队列</a>疑问进行介绍。这里只需要知道AsyncCall的excute方法最终将会被执行:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">[RealCall.java]    </div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        Response response = getResponseWithInterceptorChain();</div><div class="line">        <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">          signalledCallback = <span class="keyword">true</span>;</div><div class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          signalledCallback = <span class="keyword">true</span>;</div><div class="line">          responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="keyword">if</span> (signalledCallback) &#123;</div><div class="line">          <span class="comment">// Do not signal the callback twice!</span></div><div class="line">          Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><code>execute</code>方法的逻辑并不复杂，简单的说就是：</p>
<ul>
<li>调用<code>getResponseWithInterceptorChain</code>获取服务器返回</li>
<li>通知任务分发器(<code>client.dispatcher</code>)该任务已结束</li>
</ul>
<p><code>getResponseWithInterceptorChain</code>构建了一个拦截器链，通过依次执行该拦截器链中的每一个拦截器最终得到服务器返回。</p>
<h3 id="3-构建拦截器链"><a href="#3-构建拦截器链" class="headerlink" title="3. 构建拦截器链"></a>3. 构建拦截器链</h3><p>首先来看下<code>getResponseWithInterceptorChain</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">[RealCall.java]  </div><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    interceptors.addAll(client.interceptors());</div><div class="line">    interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">      interceptors.addAll(client.networkInterceptors());</div><div class="line">    &#125;</div><div class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">        interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其逻辑大致分为两部分：</p>
<ul>
<li>创建一系列拦截器，并将其放入一个拦截器数组中。这部分拦截器即包括用户自定义的拦截器也包括框架内部拦截器</li>
<li>创建一个拦截器链<code>RealInterceptorChain</code>,并执行拦截器链的<code>proceed</code>方法</li>
</ul>
<p>接下来看下<code>RealInterceptorChain</code>的实现逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">[RealInterceptorChain.java]</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RealInterceptorChain</span> <span class="keyword">implements</span> <span class="title">Interceptor</span>.<span class="title">Chain</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> StreamAllocation streamAllocation;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HttpCodec httpCodec;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RealConnection connection;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Request request;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> calls;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RealInterceptorChain</span><span class="params">(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span></span></div><div class="line">                              HttpCodec httpCodec, RealConnection connection, <span class="keyword">int</span> index, Request request) &#123;</div><div class="line">    <span class="keyword">this</span>.interceptors = interceptors;</div><div class="line">    <span class="keyword">this</span>.connection = connection;</div><div class="line">    <span class="keyword">this</span>.streamAllocation = streamAllocation;</div><div class="line">    <span class="keyword">this</span>.httpCodec = httpCodec;</div><div class="line">    <span class="keyword">this</span>.index = index;</div><div class="line">    <span class="keyword">this</span>.request = request;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Connection <span class="title">connection</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> connection;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> StreamAllocation <span class="title">streamAllocation</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> streamAllocation;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> HttpCodec <span class="title">httpStream</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> httpCodec;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Request <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> request;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="keyword">return</span> proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></div><div class="line">      RealConnection connection) <span class="keyword">throws</span> IOException &#123;</div><div class="line"></div><div class="line">    ......</div><div class="line">    <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">        interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">    Interceptor interceptor = interceptors.get(index);</div><div class="line">    Response response = interceptor.intercept(next);</div><div class="line">    </div><div class="line">    ...... </div><div class="line"></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在<code>proceed</code>方法中的核心代码可以看到，proceed实际上也做了两件事：</p>
<ul>
<li>创建下一个拦截链。传入<code>index + 1</code>使得下一个拦截器链只能从下一个拦截器开始访问</li>
<li>执行索引为<code>index</code>的intercept方法，并将下一个拦截器链传入该方法</li>
</ul>
<p>接下来再看下第一个拦截器RetryAndFollowUpInterceptor的intercept方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">[RetryAndFollowUpInterceptor.java]</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RetryAndFollowUpInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = chain.request();</div><div class="line"></div><div class="line">    streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">        client.connectionPool(), createAddress(request.url()), callStackTrace);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</div><div class="line">    Response priorResponse = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (canceled) &#123;</div><div class="line">        streamAllocation.release();</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Response response = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">       <span class="comment">//执行下一个拦截器链的proceed方法</span></div><div class="line">        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        releaseConnection = <span class="keyword">false</span>;</div><div class="line">      &#125; <span class="keyword">catch</span> (RouteException e) &#123;</div><div class="line">        <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></div><div class="line">        <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</div><div class="line">          <span class="keyword">throw</span> e.getLastConnectException();</div><div class="line">        &#125;</div><div class="line">        releaseConnection = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></div><div class="line">        <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</div><div class="line">        <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</div><div class="line">        releaseConnection = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></div><div class="line">        <span class="keyword">if</span> (releaseConnection) &#123;</div><div class="line">          streamAllocation.streamFailed(<span class="keyword">null</span>);</div><div class="line">          streamAllocation.release();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></div><div class="line">      ......</div><div class="line"></div><div class="line">      Request followUp = followUpRequest(response);</div><div class="line"></div><div class="line"></div><div class="line">      closeQuietly(response.body());</div><div class="line">      ...</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码最关键的代码是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div></pre></td></tr></table></figure>
<p>这行代码就是执行下一个拦截器链的proceed方法。而我们知道在下一个拦截器链中又会执行下一个拦截器的intercept方法。所以整个执行链就在拦截器与拦截器链中交替执行，最终完成所有拦截器的操作。这也是OkHttp拦截器的链式执行逻辑。而一个拦截器的intercept方法所执行的逻辑大致分为三部分：</p>
<ul>
<li>在发起请求前对request进行处理</li>
<li>调用下一个拦截器，获取response</li>
<li>对response进行处理，返回给上一个拦截器</li>
</ul>
<p>这就是OkHttp拦截器机制的核心逻辑。所以一个网络请求实际上就是一个个拦截器执行其intercept方法的过程。而这其中除了用户自定义的拦截器外还有几个核心拦截器完成了网络访问的核心逻辑，按照先后顺序依次是：</p>
<ul>
<li>RetryAndFollowUpInterceptor</li>
<li>BridgeInterceptor</li>
<li>CacheInterceptor</li>
<li>ConnectIntercetot</li>
<li>CallServerInterceptor</li>
</ul>
<h3 id="4-RetryAndFollowUpInterceptor"><a href="#4-RetryAndFollowUpInterceptor" class="headerlink" title="4 RetryAndFollowUpInterceptor"></a>4 RetryAndFollowUpInterceptor</h3><p>如上文代码所示，RetryAndFollowUpInterceptor负责两部分逻辑：</p>
<ul>
<li>在网络请求失败后进行重试</li>
<li>当服务器返回当前请求需要进行重定向时直接发起新的请求，并在条件允许情况下复用当前连接</li>
</ul>
<h3 id="5-BridgeInterceptor"><a href="#5-BridgeInterceptor" class="headerlink" title="5 BridgeInterceptor"></a>5 BridgeInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CookieJar cookieJar;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BridgeInterceptor</span><span class="params">(CookieJar cookieJar)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.cookieJar = cookieJar;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Log.e(<span class="string">"haha"</span>, <span class="string">"BridgeInterceptor.intercept"</span>);</div><div class="line">    Request userRequest = chain.request();</div><div class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</div><div class="line"></div><div class="line">    RequestBody body = userRequest.body();</div><div class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</div><div class="line">      MediaType contentType = body.contentType();</div><div class="line">      <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</div><div class="line">        requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">long</span> contentLength = body.contentLength();</div><div class="line">      <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</div><div class="line">        requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</div><div class="line">        requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</div><div class="line">        requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></div><div class="line">    <span class="comment">// the transfer stream.</span></div><div class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">      transparentGzip = <span class="keyword">true</span>;</div><div class="line">      requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</div><div class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</div><div class="line">      requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</div><div class="line">      requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</div><div class="line"></div><div class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</div><div class="line"></div><div class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</div><div class="line">        .request(userRequest);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (transparentGzip</div><div class="line">        &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</div><div class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</div><div class="line">      GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</div><div class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</div><div class="line">          .removeAll(<span class="string">"Content-Encoding"</span>)</div><div class="line">          .removeAll(<span class="string">"Content-Length"</span>)</div><div class="line">          .build();</div><div class="line">      responseBuilder.headers(strippedHeaders);</div><div class="line">      responseBuilder.body(<span class="keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> responseBuilder.build();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>BridgeInterceptor主要负责以下几部分内容：</p>
<ul>
<li>设置内容长度，内容编码</li>
<li>设置gzip压缩，并在接收到内容后进行解压。省去了应用层处理数据解压的麻烦</li>
<li>添加cookie</li>
<li>设置其他报头，如<code>User-Agent</code>,<code>Host</code>,<code>Keep-alive</code>等。其中<code>Keep-Alive</code>是实现多路复用的必要步骤</li>
</ul>
<h3 id="6-CacheInterceptor"><a href="#6-CacheInterceptor" class="headerlink" title="6. CacheInterceptor"></a>6. CacheInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">[CacheInterceptor.intercept]</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Log.e(<span class="string">"haha"</span>, <span class="string">"CacheInterceptor.intercept"</span>);</div><div class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></div><div class="line">        ? cache.get(chain.request())</div><div class="line">        : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</div><div class="line">    Request networkRequest = strategy.networkRequest;</div><div class="line">    Response cacheResponse = strategy.cacheResponse;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">      cache.trackResponse(strategy);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></div><div class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</div><div class="line">          .request(chain.request())</div><div class="line">          .protocol(Protocol.HTTP_1_1)</div><div class="line">          .code(<span class="number">504</span>)</div><div class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</div><div class="line">          .body(Util.EMPTY_RESPONSE)</div><div class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</div><div class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If we don't need the network, we're done.</span></div><div class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</div><div class="line">          .cacheResponse(stripBody(cacheResponse))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response networkResponse = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      networkResponse = chain.proceed(networkRequest);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></div><div class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</div><div class="line">        closeQuietly(cacheCandidate.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If we have a cache response too, then we're doing a conditional get.</span></div><div class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</div><div class="line">        Response response = cacheResponse.newBuilder()</div><div class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</div><div class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</div><div class="line">            .cacheResponse(stripBody(cacheResponse))</div><div class="line">            .networkResponse(stripBody(networkResponse))</div><div class="line">            .build();</div><div class="line">        networkResponse.body().close();</div><div class="line"></div><div class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></div><div class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></div><div class="line">        cache.trackConditionalCacheHit();</div><div class="line">        cache.update(cacheResponse, response);</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        closeQuietly(cacheResponse.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = networkResponse.newBuilder()</div><div class="line">        .cacheResponse(stripBody(cacheResponse))</div><div class="line">        .networkResponse(stripBody(networkResponse))</div><div class="line">        .build();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</div><div class="line">        <span class="comment">// Offer this request to the cache.</span></div><div class="line">        CacheRequest cacheRequest = cache.put(response);</div><div class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          cache.remove(networkRequest);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">          <span class="comment">// The cache cannot be written.</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>CacheInterceptor的职责很明确，就是负责Cache的管理</p>
<ul>
<li>当网络请求有符合要求的Cache时直接返回Cache</li>
<li>当服务器返回内容有改变时更新当前cache</li>
<li>如果当前cache失效，删除</li>
</ul>
<h3 id="7-ConnectInterceptor"><a href="#7-ConnectInterceptor" class="headerlink" title="7 ConnectInterceptor"></a>7 ConnectInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[ConnectInterceptor.java]</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">final</span> OkHttpClient client;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ConnectInterceptor</span><span class="params">(OkHttpClient client)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.client = client;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Log.e(<span class="string">"haha"</span>, <span class="string">"ConnectInterceptor.intercept"</span>);</div><div class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">    Request request = realChain.request();</div><div class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line"></div><div class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></div><div class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</div><div class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</div><div class="line">    RealConnection connection = streamAllocation.connection();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConnectInterceptor的intercept方法只有一行关键代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RealConnection connection = streamAllocation.connection();</div></pre></td></tr></table></figure>
<p>即为当前请求找到合适的连接，可能复用已有连接也可能是重新创建的连接，返回的连接由连接池负责决定。</p>
<h3 id="8-CallServerInterceptor"><a href="#8-CallServerInterceptor" class="headerlink" title="8. CallServerInterceptor"></a>8. CallServerInterceptor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">[CallServerInterceptor.java]</div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</div><div class="line">    HttpCodec httpCodec = realChain.httpStream();</div><div class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</div><div class="line">    RealConnection connection = (RealConnection) realChain.connection();</div><div class="line">    Request request = realChain.request();</div><div class="line"></div><div class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</div><div class="line">    httpCodec.writeRequestHeaders(request);</div><div class="line"></div><div class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</div><div class="line">      ......</div><div class="line"></div><div class="line">    httpCodec.finishRequest();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</div><div class="line">      responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = responseBuilder</div><div class="line">        .request(request)</div><div class="line">        .handshake(streamAllocation.connection().handshake())</div><div class="line">        .sentRequestAtMillis(sentRequestMillis)</div><div class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">        .build();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> code = response.code();</div><div class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</div><div class="line">      <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(Util.EMPTY_RESPONSE)</div><div class="line">          .build();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      response = response.newBuilder()</div><div class="line">          .body(httpCodec.openResponseBody(response))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</div><div class="line">        || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</div><div class="line">      streamAllocation.noNewStreams();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</div><div class="line">          <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>CallServerInterceptor负责向服务器发起真正的访问请求，并在接收到服务器返回后读取响应返回。</p>
<h3 id="8-整体流程"><a href="#8-整体流程" class="headerlink" title="8.整体流程"></a>8.整体流程</h3><p>以上就是整个网络访问的核心步骤，总结起来如下图所示：<br><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/e67029972070a7dd84206023b179dbd1.png" alt="interceptors.png"></p>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/78103?spm=5176.8091938.0.0.hlEONd" target="_blank" rel="external">OkHttp源码分析——任务队列</a></p>
</blockquote>
<p>前面的博客已经提到过，OkHttp的一个高效之处在于在内部维护了一个线程池，方便高效地执行异步请求。本篇博客将详细介绍OkHttp的任务队列机制。</p>
<h3 id="1-线程池的优点"><a href="#1-线程池的优点" class="headerlink" title="1. 线程池的优点"></a>1. 线程池的优点</h3><p>OkHttp的任务队列在内部维护了一个线程池用于执行具体的网络请求。而线程池最大的好处在于通过线程复用减少非核心任务的损耗。</p>
<blockquote>
<p>多线程技术主要解决处理器单元内多个线程执行的问题，它可以显著减少处理器单元的闲置时间，增加处理器单元的吞吐能力。但如果对多线程应用不当，会增加对单个任务的处理时间。可以举一个简单的例子：</p>
<p>假设在一台服务器完成一项任务的时间为T</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; T1 创建线程的时间</div><div class="line">&gt; T2 在线程中执行任务的时间，包括线程间同步所需时间</div><div class="line">&gt; T3 线程销毁的时间</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>显然T ＝ T1＋T2＋T3。注意这是一个极度简化的假设。<br>可以看出T1,T3是多线程本身的带来的开销（在Java中，通过映射pThead，并进一步通过&gt;SystemCall实现native线程），我们渴望减少T1,T3所用的时间，从而减少T的时间。但一些线&gt;程的使用者并没有注意到这一点，所以在程序中频繁的创建或销毁线程，这导致T1和T3在T中占有&gt;相当比例。显然这是突出了线程的弱点（T1，T3），而不是优点（并发性）。</p>
</blockquote>
<p>线程池技术正是关注如何缩短或调整T1，T3时间的技术，从而提高服务器程序性能的。</p>
<ol>
<li>通过对线程进行缓存，减少了创建销毁的时间损失</li>
<li>通过控制线程数量阀值，减少了当线程过少时带来的CPU闲置（比如说长时间卡在I/O上了）与线程过多时对JVM的内存与线程切换时系统调用的压力</li>
</ol>
<blockquote>
<p>类似的还有Socket连接池、<a href="https://github.com/alibaba/druid" target="_blank" rel="external">DB连接池</a>、CommonPool(比如Jedis)等技术。</p>
</blockquote>
<h3 id="2-OkHttp的任务队列"><a href="#2-OkHttp的任务队列" class="headerlink" title="2. OkHttp的任务队列"></a>2. OkHttp的任务队列</h3><p>OkHttp的任务队列主要由两部分组成：</p>
<ul>
<li>任务分发器dispatcher：负责为任务找到合适的执行线程</li>
<li>网络请求任务线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequests = <span class="number">64</span>;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxRequestsPerHost = <span class="number">5</span>;</div><div class="line">  <span class="keyword">private</span> Runnable idleCallback;</div><div class="line"></div><div class="line">  <span class="comment">/** Executes calls. Created lazily. */</span></div><div class="line">  <span class="keyword">private</span> ExecutorService executorService;</div><div class="line"></div><div class="line">  <span class="comment">/** Ready async calls in the order they'll be run. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.executorService = executorService;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</div><div class="line">      executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</div><div class="line">          <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> executorService;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<ul>
<li>readyAsyncCalls：待执行异步任务队列</li>
<li>runningAsyncCalls：运行中异步任务队列</li>
<li>runningSyncCalls：运行中同步任务队列</li>
<li>executorService：任务队列线程池：</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">&gt;                               <span class="keyword">int</span> maximumPoolSize,</div><div class="line">&gt;                               <span class="keyword">long</span> keepAliveTime,</div><div class="line">&gt;                               TimeUnit unit,</div><div class="line">&gt;                               BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">&gt;                               ThreadFactory threadFactory) &#123;</div><div class="line">&gt;         <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</div><div class="line">&gt;              threadFactory, defaultHandler);</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<ul>
<li>int corePoolSize: 最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁</li>
<li>int maximumPoolSize: 最大线程数，当任务进来时可以扩充的线程最大值，当大于了这个值就会根据丢弃处理机制来处理</li>
<li>long keepAliveTime: 当线程数大于<code>corePoolSize</code>时，多余的空闲线程的最大存活时间，类似于HTTP中的Keep-alive</li>
<li>TimeUnit unit: 时间单位，一般用秒</li>
<li>BlockingQueue workQueue: 工作队列，先进先出，可以看出并不像Picasso那样设置优先队列</li>
<li>ThreadFactory threadFactory: 单个线程的工厂，可以打Log，设置<code>Daemon</code>(即当JVM退出时，线程自动结束)等</li>
</ul>
<p>可以看出，在Okhttp中，构建了一个阀值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做”OkHttp Dispatcher”的线程工厂。</p>
<p>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建十个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p>
</blockquote>
<h3 id="3-Dispatcher分发器"><a href="#3-Dispatcher分发器" class="headerlink" title="3. Dispatcher分发器"></a>3. Dispatcher分发器</h3><p>dispatcher分发器类似于Ngnix中的反向代理，通过Dispatcher将任务分发到合适的空闲线程，实现<code>非阻塞，高可用，高并发连接</code></p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6940db734d692fadc156c1364e81cd7e.png" alt="dispatcher.png"></p>
<h4 id="1-同步请求"><a href="#1-同步请求" class="headerlink" title="1.同步请求"></a>1.同步请求</h4><p>当我们使用OkHttp进行同步请求时，一般构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">    .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</div><div class="line">    .build();</div><div class="line">Response response = client.newCall(request).execute();</div></pre></td></tr></table></figure>
<p>接下来看看<code>RealCall.execute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    client.dispatcher().executed(<span class="keyword">this</span>);</div><div class="line">    Response result = getResponseWithInterceptorChain();</div><div class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同步调用的执行逻辑是：</p>
<ul>
<li>将对应任务加入分发器</li>
<li>执行任务</li>
<li>执行完成后通知dispatcher对应任务已完成，对应任务出队</li>
</ul>
<h4 id="2-异步请求"><a href="#2-异步请求" class="headerlink" title="2.异步请求"></a>2.异步请求</h4><p>异步请求一般构造如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</div><div class="line">Request request = <span class="keyword">new</span> Request.Builder()</div><div class="line">        .url(<span class="string">"http://publicobject.com/helloworld.txt"</span>)</div><div class="line">        .build();</div><div class="line"></div><div class="line">client.newCall(request).enqueue(<span class="keyword">new</span> Callback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span> </span>&#123;</div><div class="line">        Log.d(<span class="string">"OkHttp"</span>, <span class="string">"Call Failed:"</span> + e.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        Log.d(<span class="string">"OkHttp"</span>, <span class="string">"Call succeeded:"</span> + response.message());</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当HttpClient的请求入队时，根据代码，我们可以发现实际上是Dispatcher进行了入队操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">      <span class="comment">//添加正在运行的请求</span></div><div class="line">    runningAsyncCalls.add(call);</div><div class="line">       <span class="comment">//线程池执行请求</span></div><div class="line">    executorService().execute(call);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//添加到缓存队列排队等待</span></div><div class="line">    readyAsyncCalls.add(call);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果满足条件：</p>
<ul>
<li>当前请求数小于最大请求数（64）</li>
<li>对单一host的请求小于阈值（5）</li>
</ul>
<p>将该任务插入正在执行任务队列，并执行对应任务。如果不满足则将其放入待执行队列。</p>
<p>接下来看看<code>AsyncCall.execute</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//执行耗时IO任务</span></div><div class="line">    Response response = getResponseWithInterceptorChain(forWebSocket);</div><div class="line">    <span class="keyword">if</span> (canceled) &#123;</div><div class="line">      signalledCallback = <span class="keyword">true</span>;</div><div class="line">      <span class="comment">//回调，注意这里回调是在线程池中，而不是想当然的主线程回调</span></div><div class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      signalledCallback = <span class="keyword">true</span>;</div><div class="line">      <span class="comment">//回调，同上</span></div><div class="line">      responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">    <span class="keyword">if</span> (signalledCallback) &#123;</div><div class="line">      <span class="comment">// Do not signal the callback twice!</span></div><div class="line">      logger.log(Level.INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">//最关键的代码</span></div><div class="line">    client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当任务执行完成后，无论成功与否都会调用dispatcher.finished方法，通知分发器相关任务已结束：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> runningCallsCount;</div><div class="line">  Runnable idleCallback;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</div><div class="line">    <span class="keyword">if</span> (promoteCalls) promoteCalls();</div><div class="line">    runningCallsCount = runningCallsCount();</div><div class="line">    idleCallback = <span class="keyword">this</span>.idleCallback;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</div><div class="line">    idleCallback.run();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>空闲出多余线程，调用promoteCalls调用待执行的任务</li>
<li>如果当前整个线程池都空闲下来，执行空闲通知回调线程(idleCallback)</li>
</ul>
<p>接下来看看promoteCalls：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></div><div class="line">  <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></div><div class="line"></div><div class="line">  <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</div><div class="line">    AsyncCall call = i.next();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">      i.remove();</div><div class="line">      runningAsyncCalls.add(call);</div><div class="line">      executorService().execute(call);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>promoteCalls的逻辑也很简单：扫描待执行任务队列，将任务放入正在执行任务队列，并执行该任务。</p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>以上就是整个任务队列的实现细节，总结起来有以下几个特点：</p>
<ul>
<li>OkHttp采用Dispatcher技术，类似于Nginx，与线程池配合实现了高并发，低阻塞的运行</li>
<li>Okhttp采用Deque作为缓存，按照入队的顺序先进先出</li>
<li>OkHttp最出彩的地方就是在try/finally中调用了<code>finished</code>函数，可以主动控制等待队列的移动，而不是采用锁或者wait/notify，极大减少了编码复杂性</li>
</ul>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/78102?spm=5176.8091938.0.0.hlEONd" target="_blank" rel="external">OkHttp源码分析——缓存策略</a></p>
</blockquote>
<p>合理地利用本地缓存可以有效地减少网络开销，减少响应延迟。HTTP报头也定义了很多与缓存有关的域来控制缓存。今天就来讲讲OkHttp中关于缓存部分的实现细节。</p>
<h3 id="1-HTTP缓存策略"><a href="#1-HTTP缓存策略" class="headerlink" title="1. HTTP缓存策略"></a>1. HTTP缓存策略</h3><p>首先来了解下HTTP协议中缓存部分的相关域。</p>
<h4 id="1-1-Expires"><a href="#1-1-Expires" class="headerlink" title="1.1 Expires"></a>1.1 Expires</h4><p>超时时间，一般用在服务器的response报头中用于告知客户端对应资源的过期时间。当客户端需要再次请求相同资源时先比较其过期时间，如果尚未超过过期时间则直接返回缓存结果，如果已经超过则重新请求。</p>
<h4 id="1-2-Cache-Control"><a href="#1-2-Cache-Control" class="headerlink" title="1.2 Cache-Control"></a>1.2 Cache-Control</h4><p>相对值，单位时秒，表示当前资源的有效期。<code>Cache-Control</code>比<code>Expires</code>优先级更高：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cache-Control:max-age=31536000,public</div></pre></td></tr></table></figure>
<h4 id="1-3-条件GET请求"><a href="#1-3-条件GET请求" class="headerlink" title="1.3 条件GET请求"></a>1.3 条件GET请求</h4><h5 id="1-3-1-Last-Modified-Date"><a href="#1-3-1-Last-Modified-Date" class="headerlink" title="1.3.1 Last-Modified-Date"></a>1.3.1 Last-Modified-Date</h5><p>客户端第一次请求时，服务器返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Last-Modified: Tue, 12 Jan 2016 09:31:27 GMT</div></pre></td></tr></table></figure>
<p>当客户端二次请求时，可以头部加上如下header:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-Modified-Since: Tue, 12 Jan 2016 09:31:27 GMT</div></pre></td></tr></table></figure>
<p>如果当前资源没有被二次修改，服务器返回304告知客户端直接复用本地缓存。</p>
<h5 id="1-3-2-ETag"><a href="#1-3-2-ETag" class="headerlink" title="1.3.2 ETag"></a>1.3.2 ETag</h5><p>ETag是对资源文件的一种摘要，可以通过ETag值来判断文件是否有修改。当客户端第一次请求某资源时，服务器返回：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ETag: &quot;5694c7ef-24dc&quot;</div></pre></td></tr></table></figure>
<p>客户端再次请求时，可在头部加上如下域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">If-None-Match: &quot;5694c7ef-24dc&quot;</div></pre></td></tr></table></figure>
<p>如果文件并未改变，则服务器返回304告知客户端可以复用本地缓存。</p>
<h4 id="1-4-no-cache-no-store"><a href="#1-4-no-cache-no-store" class="headerlink" title="1.4 no-cache/no-store"></a>1.4 no-cache/no-store</h4><p>不使用缓存</p>
<h4 id="1-5-only-if-cached"><a href="#1-5-only-if-cached" class="headerlink" title="1.5 only-if-cached"></a>1.5 only-if-cached</h4><p>只使用缓存</p>
<h3 id="2-Cache源码分析"><a href="#2-Cache源码分析" class="headerlink" title="2. Cache源码分析"></a>2. Cache源码分析</h3><p>OkHttp的缓存工作都是在<code>CacheInterceptor</code>中完成的,Cache部分有如下几个关键类：</p>
<ul>
<li>Cache：Cache管理器，其内部包含一个DiskLruCache将cache写入文件系统:</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt;  * &lt;h3&gt;Cache Optimization&lt;/h3&gt;</div><div class="line">&gt;  *</div><div class="line">&gt;  * &lt;p&gt;To measure cache effectiveness, this class tracks three statistics:</div><div class="line">&gt;  * &lt;ul&gt;</div><div class="line">&gt;  *     &lt;li&gt;&lt;strong&gt;&#123;@linkplain #requestCount() Request Count:&#125;&lt;/strong&gt; the number of HTTP</div><div class="line">&gt;  *         requests issued since this cache was created.</div><div class="line">&gt;  *     &lt;li&gt;&lt;strong&gt;&#123;@linkplain #networkCount() Network Count:&#125;&lt;/strong&gt; the number of those</div><div class="line">&gt;  *         requests that required network use.</div><div class="line">&gt;  *     &lt;li&gt;&lt;strong&gt;&#123;@linkplain #hitCount() Hit Count:&#125;&lt;/strong&gt; the number of those requests</div><div class="line">&gt;  *         whose responses were served by the cache.</div><div class="line">&gt;  * &lt;/ul&gt;</div><div class="line">&gt;  *</div><div class="line">&gt;  * Sometimes a request will result in a conditional cache hit. If the cache contains a stale copy of</div><div class="line">&gt;  * the response, the client will issue a conditional &#123;@code GET&#125;. The server will then send either</div><div class="line">&gt;  * the updated response if it has changed, or a short &apos;not modified&apos; response if the client&apos;s copy</div><div class="line">&gt;  * is still valid. Such responses increment both the network count and hit count.</div><div class="line">&gt;  *</div><div class="line">&gt;  * &lt;p&gt;The best way to improve the cache hit rate is by configuring the web server to return</div><div class="line">&gt;  * cacheable responses. Although this client honors all &lt;a</div><div class="line">&gt;  * href=&quot;http://tools.ietf.org/html/rfc7234&quot;&gt;HTTP/1.1 (RFC 7234)&lt;/a&gt; cache headers, it doesn&apos;t cache</div><div class="line">&gt;  * partial responses.</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>Cache内部通过<code>requestCount</code>,<code>networkCount</code>,<code>hitCount</code>三个统计指标来优化缓存效率</p>
</blockquote>
<ul>
<li>CacheStrategy：缓存策略。其内部维护一个request和response，通过指定request和response来描述是通过网络还是缓存获取response，抑或二者同时使用</li>
</ul>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; [CacheStrategy.java]</div><div class="line">&gt; /**</div><div class="line">&gt; * Given a request and cached response, this figures out whether to use the network, the cache, or</div><div class="line">&gt; * both.</div><div class="line">&gt; *</div><div class="line">&gt; * &lt;p&gt;Selecting a cache strategy may add conditions to the request (like the &quot;If-Modified-Since&quot;</div><div class="line">&gt; * header for conditional GETs) or warnings to the cached response (if the cached data is</div><div class="line">&gt; * potentially stale).</div><div class="line">&gt; */</div><div class="line">&gt; public final class CacheStrategy &#123;</div><div class="line">&gt;  /** The request to send on the network, or null if this call doesn&apos;t use the network. */</div><div class="line">&gt;  public final Request networkRequest;</div><div class="line">&gt;</div><div class="line">&gt;  /** The cached response to return or validate; or null if this call doesn&apos;t use a cache. */</div><div class="line">&gt;  public final Response cacheResponse;</div><div class="line">&gt;  ......</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>CacheStrategy$Factory:缓存策略工厂类根据实际请求返回对应的缓存策略</li>
</ul>
<p>既然实际的缓存工作都是在<code>CacheInterceptor</code>中完成的，那么接下来看下<code>CahceInterceptor</code>的核心方法<code>intercept</code>方法源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line">[CacheInterceptor.java]</div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//首先尝试获取缓存</span></div><div class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></div><div class="line">        ? cache.get(chain.request())</div><div class="line">        : <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">      <span class="comment">//获取缓存策略</span></div><div class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</div><div class="line">    Request networkRequest = strategy.networkRequest;</div><div class="line">    Response cacheResponse = strategy.cacheResponse;</div><div class="line"></div><div class="line">    <span class="comment">//如果有缓存，更新下相关统计指标：命中率</span></div><div class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">      cache.trackResponse(strategy);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果当前缓存不符合要求，将其close</span></div><div class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">      closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果不能使用网络，同时又没有符合条件的缓存，直接抛504错误</span></div><div class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</div><div class="line">          .request(chain.request())</div><div class="line">          .protocol(Protocol.HTTP_1_1)</div><div class="line">          .code(<span class="number">504</span>)</div><div class="line">          .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</div><div class="line">          .body(Util.EMPTY_RESPONSE)</div><div class="line">          .sentRequestAtMillis(-<span class="number">1L</span>)</div><div class="line">          .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果有缓存同时又不使用网络，则直接返回缓存结果</span></div><div class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> cacheResponse.newBuilder()</div><div class="line">          .cacheResponse(stripBody(cacheResponse))</div><div class="line">          .build();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//尝试通过网络获取回复</span></div><div class="line">    Response networkResponse = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      networkResponse = chain.proceed(networkRequest);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></div><div class="line">      <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</div><div class="line">        closeQuietly(cacheCandidate.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果既有缓存，同时又发起了请求，说明此时是一个Conditional Get请求</span></div><div class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">// 如果服务端返回的是NOT_MODIFIED,缓存有效，将本地缓存和网络响应做合并</span></div><div class="line">      <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</div><div class="line">        Response response = cacheResponse.newBuilder()</div><div class="line">            .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</div><div class="line">            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</div><div class="line">            .cacheResponse(stripBody(cacheResponse))</div><div class="line">            .networkResponse(stripBody(networkResponse))</div><div class="line">            .build();</div><div class="line">        networkResponse.body().close();</div><div class="line"></div><div class="line">        <span class="comment">// Update the cache after combining headers but before stripping the</span></div><div class="line">        <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></div><div class="line">        cache.trackConditionalCacheHit();</div><div class="line">        cache.update(cacheResponse, response);</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果响应资源有更新，关掉原有缓存</span></div><div class="line">        closeQuietly(cacheResponse.body());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Response response = networkResponse.newBuilder()</div><div class="line">        .cacheResponse(stripBody(cacheResponse))</div><div class="line">        .networkResponse(stripBody(networkResponse))</div><div class="line">        .build();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</div><div class="line">        <span class="comment">// 将网络响应写入cache中</span></div><div class="line">        CacheRequest cacheRequest = cache.put(response);</div><div class="line">        <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">          cache.remove(networkRequest);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">          <span class="comment">// The cache cannot be written.</span></div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>核心逻辑都以中文注释的形式在代码中标注出来了，大家看代码即可。通过上面的代码可以看出，几乎所有的动作都是以CacheStrategy缓存策略为依据做出的，那么接下来看下缓存策略是如何生成的，相关代码实现在<code>CacheStrategy$Factory.get()</code>方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">[CacheStrategy$Factory]</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Returns a strategy to satisfy &#123;<span class="doctag">@code</span> request&#125; using the a cached response &#123;<span class="doctag">@code</span> response&#125;.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">      CacheStrategy candidate = getCandidate();</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</div><div class="line">        <span class="comment">// We're forbidden from using the network and the cache is insufficient.</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">return</span> candidate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/** Returns a strategy to use assuming the request can use the network. */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">// 若本地没有缓存，发起网络请求</span></div><div class="line">      <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 如果当前请求是HTTPS，而缓存没有TLS握手，重新发起网络请求</span></div><div class="line">      <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// If this response shouldn't have been stored, it should never be used</span></div><div class="line">      <span class="comment">// as a response source. This check should be redundant as long as the</span></div><div class="line">      <span class="comment">// persistence store is well-behaved and the rules are constant.</span></div><div class="line">      <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">      &#125;</div><div class="line">        </div><div class="line"> </div><div class="line">      <span class="comment">//如果当前的缓存策略是不缓存或者是conditional get，发起网络请求</span></div><div class="line">      CacheControl requestCaching = request.cacheControl();</div><div class="line">      <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//ageMillis:缓存age</span></div><div class="line">      <span class="keyword">long</span> ageMillis = cacheResponseAge();</div><div class="line">      <span class="comment">//freshMillis：缓存保鲜时间</span></div><div class="line">      <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">        freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">        minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</div><div class="line">      CacheControl responseCaching = cacheResponse.cacheControl();</div><div class="line">      <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">        maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">//如果 age + min-fresh &gt;= max-age &amp;&amp; age + min-fresh &lt; max-age + max-stale，则虽然缓存过期了，     //但是缓存继续可以使用，只是在头部添加 110 警告码</span></div><div class="line">      <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis)         &#123;</div><div class="line">        Response.Builder builder = cacheResponse.newBuilder();</div><div class="line">        <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</div><div class="line">          builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</div><div class="line">        <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</div><div class="line">          builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 发起conditional get请求</span></div><div class="line">      String conditionName;</div><div class="line">      String conditionValue;</div><div class="line">      <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</div><div class="line">        conditionName = <span class="string">"If-None-Match"</span>;</div><div class="line">        conditionValue = etag;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</div><div class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</div><div class="line">        conditionValue = lastModifiedString;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</div><div class="line">        conditionName = <span class="string">"If-Modified-Since"</span>;</div><div class="line">        conditionValue = servedDateString;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</div><div class="line">      Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</div><div class="line"></div><div class="line">      Request conditionalRequest = request.newBuilder()</div><div class="line">          .headers(conditionalRequestHeaders.build())</div><div class="line">          .build();</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到其核心逻辑在getCandidate函数中。基本就是HTTP缓存协议的实现，核心代码逻辑已通过中文注释说明，大家直接看代码就好。</p>
<h3 id="3-DiskLruCache"><a href="#3-DiskLruCache" class="headerlink" title="3. DiskLruCache"></a>3. DiskLruCache</h3><p>Cache内部通过DiskLruCache管理cache在文件系统层面的创建，读取，清理等等工作，接下来看下DiskLruCache的主要逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskLruCache</span> <span class="keyword">implements</span> <span class="title">Closeable</span>, <span class="title">Flushable</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">final</span> FileSystem fileSystem;</div><div class="line">  <span class="keyword">final</span> File directory;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File journalFile;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File journalFileTmp;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> File journalFileBackup;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> appVersion;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span> maxSize;</div><div class="line">  <span class="keyword">final</span> <span class="keyword">int</span> valueCount;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span> size = <span class="number">0</span>;</div><div class="line">  BufferedSink journalWriter;</div><div class="line">  <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Must be read and written when synchronized on 'this'.</span></div><div class="line">  <span class="keyword">boolean</span> initialized;</div><div class="line">  <span class="keyword">boolean</span> closed;</div><div class="line">  <span class="keyword">boolean</span> mostRecentTrimFailed;</div><div class="line">  <span class="keyword">boolean</span> mostRecentRebuildFailed;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * To differentiate between old and current snapshots, each entry is given a sequence number each</div><div class="line">   * time an edit is committed. A snapshot is stale if its sequence number is not equal to its</div><div class="line">   * entry's sequence number.</div><div class="line">   */</div><div class="line">  <span class="keyword">private</span> <span class="keyword">long</span> nextSequenceNumber = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">/** Used to run 'cleanupRunnable' for journal rebuilds. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">  ...</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="3-1-journalFile"><a href="#3-1-journalFile" class="headerlink" title="3.1 journalFile"></a>3.1 journalFile</h4><p>DiskLruCache内部日志文件，对cache的每一次读写都对应一条日志记录，DiskLruCache通过分析日志分析和创建cache。日志文件格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> libcore.io.DiskLruCache</div><div class="line"> <span class="number">1</span></div><div class="line"> <span class="number">100</span></div><div class="line"> <span class="number">2</span></div><div class="line"></div><div class="line"> CLEAN <span class="number">3400330</span>d1dfc7f3f7f4b8d4d803dfcf6 <span class="number">832</span> <span class="number">21054</span></div><div class="line"> DIRTY <span class="number">335</span>c4c6028171cfddfbaae1a9c313c52</div><div class="line"> CLEAN <span class="number">335</span>c4c6028171cfddfbaae1a9c313c52 <span class="number">3934</span> <span class="number">2342</span></div><div class="line"> REMOVE <span class="number">335</span>c4c6028171cfddfbaae1a9c313c52</div><div class="line"> DIRTY <span class="number">1</span>ab96a171faeeee38496d8b330771a7a</div><div class="line"> CLEAN <span class="number">1</span>ab96a171faeeee38496d8b330771a7a <span class="number">1600</span> <span class="number">234</span></div><div class="line"> READ <span class="number">335</span>c4c6028171cfddfbaae1a9c313c52</div><div class="line"> READ <span class="number">3400330</span>d1dfc7f3f7f4b8d4d803dfcf6</div><div class="line"></div><div class="line">前<span class="number">5</span>行固定不变，分别为：常量：libcore.io.DiskLruCache；diskCache版本；应用程序版本；valueCount(后文介绍)，空行</div><div class="line"></div><div class="line">接下来每一行对应一个cache entry的一次状态记录，其格式为：[状态（DIRTY,CLEAN,READ,REMOVE），key，状态相关value(可选)]:</div><div class="line">- DIRTY:表明一个cache entry正在被创建或更新，每一个成功的DIRTY记录都应该对应一个CLEAN或REMOVE操作。如果一个DIRTY缺少预期匹配的CLEAN/REMOVE，则对应entry操作失败，需要将其从lruEntries中删除</div><div class="line">- CLEAN:说明cache已经被成功操作，当前可以被正常读取。每一个CLEAN行还需要记录其每一个value的长度</div><div class="line">- READ: 记录一次cache读取操作</div><div class="line">- REMOVE:记录一次cache清除</div></pre></td></tr></table></figure>
<p>日志文件的应用场景主要有四个：</p>
<ul>
<li>DiskCacheLru初始化时通过读取日志文件创建cache容器：lruEntries。同时通过日志过滤操作不成功的cache项。相关逻辑在DiskLruCache.readJournalLine,DiskLruCache.processJournal</li>
<li>初始化完成后，为避免日志文件不断膨胀，对日志进行重建精简，具体逻辑在DiskLruCache.rebuildJournal</li>
<li>每当有cache操作时将其记录入日志文件中以备下次初始化时使用</li>
<li>当冗余日志过多时，通过调用cleanUpRunnable线程重建日志</li>
</ul>
<h4 id="3-2-DiskLruCache-Entry"><a href="#3-2-DiskLruCache-Entry" class="headerlink" title="3.2 DiskLruCache.Entry"></a>3.2 DiskLruCache.Entry</h4><p>每一个DiskLruCache.Entry对应一个cache记录：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> String key;</div><div class="line"></div><div class="line">  <span class="comment">/** Lengths of this entry's files. */</span></div><div class="line">  <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</div><div class="line">  <span class="keyword">final</span> File[] cleanFiles;</div><div class="line">  <span class="keyword">final</span> File[] dirtyFiles;</div><div class="line"></div><div class="line">  <span class="comment">/** True if this entry has ever been published. */</span></div><div class="line">  <span class="keyword">boolean</span> readable;</div><div class="line"></div><div class="line">  <span class="comment">/** The ongoing edit or null if this entry is not being edited. */</span></div><div class="line">  Editor currentEditor;</div><div class="line"></div><div class="line">  <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></div><div class="line">  <span class="keyword">long</span> sequenceNumber;</div><div class="line"></div><div class="line">  Entry(String key) &#123;</div><div class="line">    <span class="keyword">this</span>.key = key;</div><div class="line"></div><div class="line">    lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</div><div class="line">    cleanFiles = <span class="keyword">new</span> File[valueCount];</div><div class="line">    dirtyFiles = <span class="keyword">new</span> File[valueCount];</div><div class="line"></div><div class="line">    <span class="comment">// The names are repetitive so re-use the same builder to avoid allocations.</span></div><div class="line">    StringBuilder fileBuilder = <span class="keyword">new</span> StringBuilder(key).append(<span class="string">'.'</span>);</div><div class="line">    <span class="keyword">int</span> truncateTo = fileBuilder.length();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">      fileBuilder.append(i);</div><div class="line">      cleanFiles[i] = <span class="keyword">new</span> File(directory, fileBuilder.toString());</div><div class="line">      fileBuilder.append(<span class="string">".tmp"</span>);</div><div class="line">      dirtyFiles[i] = <span class="keyword">new</span> File(directory, fileBuilder.toString());</div><div class="line">      fileBuilder.setLength(truncateTo);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">   </div><div class="line">      <span class="comment">/**</span></div><div class="line">   * Returns a snapshot of this entry. This opens all streams eagerly to guarantee that we see a</div><div class="line">   * single published snapshot. If we opened streams lazily then the streams could come from</div><div class="line">   * different edits.</div><div class="line">   */</div><div class="line">  <span class="function">Snapshot <span class="title">snapshot</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!Thread.holdsLock(DiskLruCache.<span class="keyword">this</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line"></div><div class="line">    Source[] sources = <span class="keyword">new</span> Source[valueCount];</div><div class="line">    <span class="keyword">long</span>[] lengths = <span class="keyword">this</span>.lengths.clone(); <span class="comment">// Defensive copy since these can be zeroed out.</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">        sources[i] = fileSystem.source(cleanFiles[i]);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(key, sequenceNumber, sources, lengths);</div><div class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">      <span class="comment">// A file must have been deleted manually!</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (sources[i] != <span class="keyword">null</span>) &#123;</div><div class="line">          Util.closeQuietly(sources[i]);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Since the entry is no longer valid, remove it so the metadata is accurate (i.e. the cache</span></div><div class="line">      <span class="comment">// size.)</span></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        removeEntry(<span class="keyword">this</span>);</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个Entry主要由以下几部分构成：</p>
<ul>
<li>key：每个cache都有一个key作为其标识符。当前cache的key为其对应URL的MD5字符串</li>
<li>cleanFiles/dirtyFiles：每一个Entry对应多个文件，其对应的文件数由DiskLruCache.valueCount指定。当前在OkHttp中valueCount为2。即每个cache对应2个cleanFiles，2个dirtyFiles。其中第一个cleanFiles/dirtyFiles记录cache的meta数据（如URL,创建时间，SSL握手记录等等），第二个文件记录cache的真正内容。cleanFiles记录处于稳定状态的cache结果，dirtyFiles记录处于创建或更新状态的cache</li>
<li>currentEditor：entry编辑器，对entry的所有操作都是通过其编辑器完成。编辑器内部添加了同步锁</li>
</ul>
<h4 id="3-3-cleanupRunnable"><a href="#3-3-cleanupRunnable" class="headerlink" title="3.3 cleanupRunnable"></a>3.3 cleanupRunnable</h4><p>清理线程，用于重建精简日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!initialized | closed) &#123;</div><div class="line">        <span class="keyword">return</span>; <span class="comment">// Nothing to do</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        trimToSize();</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">        mostRecentTrimFailed = <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (journalRebuildRequired()) &#123;</div><div class="line">          rebuildJournal();</div><div class="line">          redundantOpCount = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        mostRecentRebuildFailed = <span class="keyword">true</span>;</div><div class="line">        journalWriter = Okio.buffer(Okio.blackhole());</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其触发条件在journalRebuildRequired()方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * We only rebuild the journal when it will halve the size of the journal and eliminate at least</div><div class="line"> * 2000 ops.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">journalRebuildRequired</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">final</span> <span class="keyword">int</span> redundantOpCompactThreshold = <span class="number">2000</span>;</div><div class="line">  <span class="keyword">return</span> redundantOpCount &gt;= redundantOpCompactThreshold</div><div class="line">      &amp;&amp; redundantOpCount &gt;= lruEntries.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当冗余日志超过日志文件本身的一般且总条数超过2000时执行</p>
<h4 id="3-4-SnapShot"><a href="#3-4-SnapShot" class="headerlink" title="3.4 SnapShot"></a>3.4 SnapShot</h4><p>cache快照，记录了特定cache在某一个特定时刻的内容。每次向DiskLruCache请求时返回的都是目标cache的一个快照,相关逻辑在DiskLruCache.get中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">[DiskLruCache.java]  </div><div class="line"><span class="comment">/**</span></div><div class="line">   * Returns a snapshot of the entry named &#123;<span class="doctag">@code</span> key&#125;, or null if it doesn't exist is not currently</div><div class="line">   * readable. If a value is returned, it is moved to the head of the LRU queue.</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    initialize();</div><div class="line"></div><div class="line">    checkNotClosed();</div><div class="line">    validateKey(key);</div><div class="line">    Entry entry = lruEntries.get(key);</div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span> || !entry.readable) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    Snapshot snapshot = entry.snapshot();</div><div class="line">    <span class="keyword">if</span> (snapshot == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    redundantOpCount++;</div><div class="line">    <span class="comment">//日志记录</span></div><div class="line">    journalWriter.writeUtf8(READ).writeByte(<span class="string">' '</span>).writeUtf8(key).writeByte(<span class="string">'\n'</span>);</div><div class="line">    <span class="keyword">if</span> (journalRebuildRequired()) &#123;</div><div class="line">      executor.execute(cleanupRunnable);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> snapshot;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h4 id="3-5-lruEntries"><a href="#3-5-lruEntries" class="headerlink" title="3.5 lruEntries"></a>3.5 lruEntries</h4><p>管理cache entry的容器，其数据结构是LinkedHashMap。通过LinkedHashMap本身的实现逻辑达到cache的LRU替换</p>
<h4 id="3-6-FileSystem"><a href="#3-6-FileSystem" class="headerlink" title="3.6 FileSystem"></a>3.6 FileSystem</h4><p>使用Okio对File的封装，简化了I/O操作。</p>
<h4 id="3-7-DiskLruCache-edit"><a href="#3-7-DiskLruCache-edit" class="headerlink" title="3.7 DiskLruCache.edit"></a>3.7 DiskLruCache.edit</h4><p>DiskLruCache可以看成是Cache在文件系统层的具体实现，所以其基本操作接口存在一一对应的关系：</p>
<ul>
<li>Cache.get() —&gt;DiskLruCache.get()</li>
<li>Cache.put()—&gt;DiskLruCache.edit() //cache插入</li>
<li>Cache.remove()—&gt;DiskLruCache.remove()</li>
<li>Cache.update()—&gt;DiskLruCache.edit()//cache更新</li>
</ul>
<p>其中get操作在3.4已经介绍了，remove操作较为简单，put和update大致逻辑相似，因为篇幅限制，这里仅介绍Cache.put操作的逻辑，其他的操作大家看代码就好:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">[okhttp3.Cache.java]</div><div class="line">  <span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;</div><div class="line">    String requestMethod = response.request().method();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (HttpMethod.invalidatesCache(response.request().method())) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        remove(response.request());</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">        <span class="comment">// The cache cannot be written.</span></div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!requestMethod.equals(<span class="string">"GET"</span>)) &#123;</div><div class="line">      <span class="comment">// Don't cache non-GET responses. We're technically allowed to cache</span></div><div class="line">      <span class="comment">// HEAD requests and some POST requests, but the complexity of doing</span></div><div class="line">      <span class="comment">// so is high and the benefit is low.</span></div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (HttpHeaders.hasVaryAll(response)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Entry entry = <span class="keyword">new</span> Entry(response);</div><div class="line">    DiskLruCache.Editor editor = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      editor = cache.edit(key(response.request().url()));</div><div class="line">      <span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">      &#125;</div><div class="line">      entry.writeTo(editor);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CacheRequestImpl(editor);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      abortQuietly(editor);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>可以看到核心逻辑在<code>editor = cache.edit(key(response.request().url()));</code>,相关代码在DiskLruCache.edit:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">[okhttp3.internal.cache.DiskLruCache.java]  </div><div class="line"><span class="function"><span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key, <span class="keyword">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    initialize();</div><div class="line"></div><div class="line">    checkNotClosed();</div><div class="line">    validateKey(key);</div><div class="line">    Entry entry = lruEntries.get(key);</div><div class="line">    <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == <span class="keyword">null</span></div><div class="line">        || entry.sequenceNumber != expectedSequenceNumber)) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Snapshot is stale.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span> &amp;&amp; entry.currentEditor != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 当前cache entry正在被其他对象操作</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mostRecentTrimFailed || mostRecentRebuildFailed) &#123;</div><div class="line">      <span class="comment">// The OS has become our enemy! If the trim job failed, it means we are storing more data than</span></div><div class="line">      <span class="comment">// requested by the user. Do not allow edits so we do not go over that limit any further. If</span></div><div class="line">      <span class="comment">// the journal rebuild failed, the journal writer will not be active, meaning we will not be</span></div><div class="line">      <span class="comment">// able to record the edit, causing file leaks. In both cases, we want to retry the clean up</span></div><div class="line">      <span class="comment">// so we can get out of this state!</span></div><div class="line">      executor.execute(cleanupRunnable);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 日志接入DIRTY记录</span></div><div class="line">    journalWriter.writeUtf8(DIRTY).writeByte(<span class="string">' '</span>).writeUtf8(key).writeByte(<span class="string">'\n'</span>);</div><div class="line">    journalWriter.flush();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (hasJournalErrors) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Don't edit; the journal can't be written.</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</div><div class="line">      entry = <span class="keyword">new</span> Entry(key);</div><div class="line">      lruEntries.put(key, entry);</div><div class="line">    &#125;</div><div class="line">    Editor editor = <span class="keyword">new</span> Editor(entry);</div><div class="line">    entry.currentEditor = editor;</div><div class="line">    <span class="keyword">return</span> editor;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>edit方法返回对应CacheEntry的editor编辑器。接下来再来看下<code>Cache.put()</code>方法的<code>entry.writeTo(editor);</code>,其相关逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">[okhttp3.internal.cache.DiskLruCache.java]    </div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeTo</span><span class="params">(DiskLruCache.Editor editor)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">      BufferedSink sink = Okio.buffer(editor.newSink(ENTRY_METADATA));</div><div class="line"></div><div class="line">      sink.writeUtf8(url)</div><div class="line">          .writeByte(<span class="string">'\n'</span>);</div><div class="line">      sink.writeUtf8(requestMethod)</div><div class="line">          .writeByte(<span class="string">'\n'</span>);</div><div class="line">      sink.writeDecimalLong(varyHeaders.size())</div><div class="line">          .writeByte(<span class="string">'\n'</span>);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = varyHeaders.size(); i &lt; size; i++) &#123;</div><div class="line">        sink.writeUtf8(varyHeaders.name(i))</div><div class="line">            .writeUtf8(<span class="string">": "</span>)</div><div class="line">            .writeUtf8(varyHeaders.value(i))</div><div class="line">            .writeByte(<span class="string">'\n'</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      sink.writeUtf8(<span class="keyword">new</span> StatusLine(protocol, code, message).toString())</div><div class="line">          .writeByte(<span class="string">'\n'</span>);</div><div class="line">      sink.writeDecimalLong(responseHeaders.size() + <span class="number">2</span>)</div><div class="line">          .writeByte(<span class="string">'\n'</span>);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = responseHeaders.size(); i &lt; size; i++) &#123;</div><div class="line">        sink.writeUtf8(responseHeaders.name(i))</div><div class="line">            .writeUtf8(<span class="string">": "</span>)</div><div class="line">            .writeUtf8(responseHeaders.value(i))</div><div class="line">            .writeByte(<span class="string">'\n'</span>);</div><div class="line">      &#125;</div><div class="line">      sink.writeUtf8(SENT_MILLIS)</div><div class="line">          .writeUtf8(<span class="string">": "</span>)</div><div class="line">          .writeDecimalLong(sentRequestMillis)</div><div class="line">          .writeByte(<span class="string">'\n'</span>);</div><div class="line">      sink.writeUtf8(RECEIVED_MILLIS)</div><div class="line">          .writeUtf8(<span class="string">": "</span>)</div><div class="line">          .writeDecimalLong(receivedResponseMillis)</div><div class="line">          .writeByte(<span class="string">'\n'</span>);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (isHttps()) &#123;</div><div class="line">        sink.writeByte(<span class="string">'\n'</span>);</div><div class="line">        sink.writeUtf8(handshake.cipherSuite().javaName())</div><div class="line">            .writeByte(<span class="string">'\n'</span>);</div><div class="line">        writeCertList(sink, handshake.peerCertificates());</div><div class="line">        writeCertList(sink, handshake.localCertificates());</div><div class="line">        <span class="comment">// The handshake’s TLS version is null on HttpsURLConnection and on older cached responses.</span></div><div class="line">        <span class="keyword">if</span> (handshake.tlsVersion() != <span class="keyword">null</span>) &#123;</div><div class="line">          sink.writeUtf8(handshake.tlsVersion().javaName())</div><div class="line">              .writeByte(<span class="string">'\n'</span>);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      sink.close();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>其主要逻辑就是将对应请求的meta数据写入对应CacheEntry的索引为ENTRY_METADATA（0）的dirtyfile中。</p>
<p>最后再来看<code>Cache.put()</code>方法的<code>return new CacheRequestImpl(editor);</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">[okhttp3.Cache$CacheRequestImpl]</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheRequestImpl</span> <span class="keyword">implements</span> <span class="title">CacheRequest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiskLruCache.Editor editor;</div><div class="line">    <span class="keyword">private</span> Sink cacheOut;</div><div class="line">    <span class="keyword">private</span> Sink body;</div><div class="line">    <span class="keyword">boolean</span> done;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CacheRequestImpl</span><span class="params">(<span class="keyword">final</span> DiskLruCache.Editor editor)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.editor = editor;</div><div class="line">      <span class="keyword">this</span>.cacheOut = editor.newSink(ENTRY_BODY);</div><div class="line">      <span class="keyword">this</span>.body = <span class="keyword">new</span> ForwardingSink(cacheOut) &#123;</div><div class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">          <span class="keyword">synchronized</span> (Cache.<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (done) &#123;</div><div class="line">              <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            done = <span class="keyword">true</span>;</div><div class="line">            writeSuccessCount++;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">super</span>.close();</div><div class="line">          editor.commit();</div><div class="line">        &#125;</div><div class="line">      &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">synchronized</span> (Cache.<span class="keyword">this</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (done) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        done = <span class="keyword">true</span>;</div><div class="line">        writeAbortCount++;</div><div class="line">      &#125;</div><div class="line">      Util.closeQuietly(cacheOut);</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        editor.abort();</div><div class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Sink <span class="title">body</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">return</span> body;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其中<code>close</code>,<code>abort</code>方法会调用<code>editor.abort</code>和<code>editor.commit</code>来更新日志，<code>editor.commit</code>还会将dirtyFile重置为cleanFile作为稳定可用的缓存，相关逻辑在<code>okhttp3.internal.cache.DiskLruCache$Editor.completeEdit</code>中:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">[okhttp3.internal.cache.DiskLruCache$Editor.completeEdit]  </div><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">completeEdit</span><span class="params">(Editor editor, <span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Entry entry = editor.entry;</div><div class="line">    <span class="keyword">if</span> (entry.currentEditor != editor) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// If this edit is creating the entry for the first time, every index must have a value.</span></div><div class="line">    <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">        <span class="keyword">if</span> (!editor.written[i]) &#123;</div><div class="line">          editor.abort();</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Newly created entry didn't create value for index "</span> + i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!fileSystem.exists(entry.dirtyFiles[i])) &#123;</div><div class="line">          editor.abort();</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</div><div class="line">      File dirty = entry.dirtyFiles[i];</div><div class="line">      <span class="keyword">if</span> (success) &#123;</div><div class="line">        <span class="keyword">if</span> (fileSystem.exists(dirty)) &#123;</div><div class="line">          File clean = entry.cleanFiles[i];</div><div class="line">          fileSystem.rename(dirty, clean);<span class="comment">//将dirtyfile置为cleanfile</span></div><div class="line">          <span class="keyword">long</span> oldLength = entry.lengths[i];</div><div class="line">          <span class="keyword">long</span> newLength = fileSystem.size(clean);</div><div class="line">          entry.lengths[i] = newLength;</div><div class="line">          size = size - oldLength + newLength;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        fileSystem.delete(dirty);<span class="comment">//若失败则删除dirtyfile</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    redundantOpCount++;</div><div class="line">    entry.currentEditor = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//更新日志</span></div><div class="line">    <span class="keyword">if</span> (entry.readable | success) &#123;</div><div class="line">      entry.readable = <span class="keyword">true</span>;</div><div class="line">      journalWriter.writeUtf8(CLEAN).writeByte(<span class="string">' '</span>);</div><div class="line">      journalWriter.writeUtf8(entry.key);</div><div class="line">      entry.writeLengths(journalWriter);</div><div class="line">      journalWriter.writeByte(<span class="string">'\n'</span>);</div><div class="line">      <span class="keyword">if</span> (success) &#123;</div><div class="line">        entry.sequenceNumber = nextSequenceNumber++;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      lruEntries.remove(entry.key);</div><div class="line">      journalWriter.writeUtf8(REMOVE).writeByte(<span class="string">' '</span>);</div><div class="line">      journalWriter.writeUtf8(entry.key);</div><div class="line">      journalWriter.writeByte(<span class="string">'\n'</span>);</div><div class="line">    &#125;</div><div class="line">    journalWriter.flush();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;</div><div class="line">      executor.execute(cleanupRunnable);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>CacheRequestImpl实现CacheRequest接口，向外部类(主要是CacheInterceptor)透出，外部对象通过CacheRequestImpl更新或写入缓存数据。</p>
<h4 id="3-8总结"><a href="#3-8总结" class="headerlink" title="3.8总结"></a>3.8总结</h4><p>总结起来DiskLruCache主要有以下几个特点：</p>
<ul>
<li>通过LinkedHashMap实现LRU替换</li>
<li>通过本地维护Cache操作日志保证Cache原子性与可用性，同时为防止日志过分膨胀定时执行日志精简</li>
<li>每一个Cache项对应两个状态副本：DIRTY,CLEAN。CLEAN表示当前可用状态Cache，外部访问到的cache快照均为CLEAN状态；DIRTY为更新态Cache。由于更新和创建都只操作DIRTY状态副本，实现了Cache的读写分离</li>
<li>每一个Cache项有四个文件，两个状态（DIRTY,CLEAN）,每个状态对应两个文件：一个文件存储Cache meta数据，一个文件存储Cache内容数据</li>
</ul>
<blockquote>
<p><a href="https://yq.aliyun.com/articles/78101?spm=5176.8091938.0.0.hlEONd" target="_blank" rel="external">OkHttp源码分析——多路复用</a></p>
</blockquote>
<p>接下来讲下OkHttp的连接池管理，这也是OkHttp的核心部分。通过维护连接池，最大限度重用现有连接，减少网络连接的创建开销，以此提升网络请求效率。</p>
<h3 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h3><h4 id="1-1-keep-alive机制"><a href="#1-1-keep-alive机制" class="headerlink" title="1.1 keep-alive机制"></a>1.1 keep-alive机制</h4><p>在HTTP1.0中HTTP的请求流程如下：</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/59d08a51c67491151da84524ea04ce7b.png" alt="connectionpool_keepalive.png"></p>
<p>这种方法的好处是简单，各个请求互不干扰。但在复杂的网络请求场景下这种方式几乎不可用。例如：浏览器加载一个HTML网页，HTML中可能需要加载数十个资源，典型场景下这些资源中大部分来自同一个站点。按照HTTP1.0的做法，这需要建立数十个TCP连接，每个连接负责一个资源请求。创建一个TCP连接需要3次握手，而释放连接则需要2次或4次握手。重复的创建和释放连接极大地影响了网络效率，同时也增加了系统开销。</p>
<p>为了有效地解决这一问题，HTTP/1.1提出了<code>Keep-Alive</code>机制：当一个HTTP请求的数据传输结束后，TCP连接不立即释放，如果此时有新的HTTP请求，且其请求的Host通上次请求相同，则可以直接复用为释放的TCP连接，从而省去了TCP的释放和再次创建的开销，减少了网络延时:</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/0a7e20cbfa732fc661e88eb670aa4aa9.png" alt="connection_keepalive2.png"></p>
<p>在现代浏览器中，一般同时开启6～8个keepalive connections的socket连接，并保持一定的链路生命，当不需要时再关闭；而在服务器中，一般是由软件根据负载情况(比如FD最大值、Socket内存、超时时间、栈内存、栈数量等)决定是否主动关闭。</p>
<h4 id="1-2-HTTP-2"><a href="#1-2-HTTP-2" class="headerlink" title="1.2 HTTP/2"></a>1.2 HTTP/2</h4><p>在HTTP/1.x中，如果客户端想发起多个并行请求必须建立多个TCP连接，这无疑增大了网络开销。另外HTTP/1.x不会压缩请求和响应报头，导致了不必要的网络流量；HTTP/1.x不支持资源优先级导致底层TCP连接利用率低下。而这些问题都是HTTP/2要着力解决的。简单来说HTTP/2主要解决了以下问题：</p>
<ul>
<li>报头压缩：HTTP/2使用HPACK压缩格式压缩请求和响应报头数据，减少不必要流量开销</li>
<li>请求与响应复用：HTTP/2通过引入新的二进制分帧层实现了完整的请求和响应复用，客户端和服务器可以将HTTP消息分解为互不依赖的帧，然后交错发送，最后再在另一端将其重新组装</li>
<li>指定数据流优先级：将 HTTP 消息分解为很多独立的帧之后，我们就可以复用多个数据流中的帧，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素。为了做到这一点，HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系</li>
<li>流控制：HTTP/2 提供了一组简单的构建块，这些构建块允许客户端和服务器实现其自己的数据流和连接级流控制</li>
</ul>
<p>HTTP/2所有性能增强的核心在于新的二进制分帧层，它定义了如何封装HTTP消息并在客户端与服务器之间进行传输:</p>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/03c77355f41162f738505e202ac7860d.png" alt="http2framing.png"></p>
<p>同时HTTP/2引入了三个新的概念：</p>
<ul>
<li>数据流：基于TCP连接之上的逻辑双向字节流，对应一个请求及其响应。客户端每发起一个请求就建立一个数据流，后续该请求及其响应的所有数据都通过该数据流传输</li>
<li>消息：一个请求或响应对应的一系列数据帧</li>
<li>帧：HTTP/2的最小数据切片单位</li>
</ul>
<p>上述概念之间的逻辑关系：</p>
<ul>
<li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流</li>
<li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息</li>
<li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧</li>
<li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载，等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装</li>
<li>每个HTTP消息被分解为多个独立的帧后可以交错发送，从而在宏观上实现了多个请求或响应并行传输的效果。这类似于多进程环境下的时间分片机制</li>
</ul>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/a0b6775e83c2c1a24ed85e06ffa514fe.png" alt="http2multiplexing.png"></p>
<h3 id="2-连接池的使用与分析"><a href="#2-连接池的使用与分析" class="headerlink" title="2. 连接池的使用与分析"></a>2. 连接池的使用与分析</h3><p>无论是HTTP/1.1的<code>Keep-Alive</code>机制还是HTTP/2的多路复用机制，在实现上都需要引入连接池来维护网络连接。接下来看下OkHttp中的连接池实现。</p>
<p>OkHttp内部通过ConnectionPool来管理连接池，首先来看下ConnectionPool的主要成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span> <span class="comment">/* corePoolSize */</span>,</div><div class="line">      Integer.MAX_VALUE <span class="comment">/* maximumPoolSize */</span>, <span class="number">60L</span> <span class="comment">/* keepAliveTime */</span>, TimeUnit.SECONDS,</div><div class="line">      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp ConnectionPool"</span>, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">  <span class="comment">/** The maximum number of idle connections for each address. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxIdleConnections;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> keepAliveDurationNs;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Runnable cleanupRunnable = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealConnection&gt; connections = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line">  <span class="keyword">final</span> RouteDatabase routeDatabase = <span class="keyword">new</span> RouteDatabase();</div><div class="line">  <span class="keyword">boolean</span> cleanupRunning;</div><div class="line">  ......</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">    *返回符合要求的可重用连接，如果没有返回NULL</div><div class="line">   */</div><div class="line">  <span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line">  * 去除重复连接。主要针对多路复用场景下一个address只需要一个连接</div><div class="line">  */</div><div class="line">  <span class="function">Socket <span class="title">deduplicate</span><span class="params">(Address address, StreamAllocation streamAllocation)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line">  * 将连接加入连接池</div><div class="line">  */</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(RealConnection connection)</span> </span>&#123;</div><div class="line">      ......</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line">  * 当有连接空闲时唤起cleanup线程清洗连接池</div><div class="line">  */</div><div class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">connectionBecameIdle</span><span class="params">(RealConnection connection)</span> </span>&#123;</div><div class="line">      ......</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 扫描连接池，清除空闲连接</div><div class="line">  */</div><div class="line">  <span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/*</span></div><div class="line">   * 标记泄露连接</div><div class="line">  */</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相关概念：</p>
<ul>
<li><code>Call</code>：对Http请求的封装</li>
<li><code>Connection/RealConnection</code>:物理连接的封装，其内部有<code>List&lt;WeakReference&lt;StreamAllocation&gt;&gt;</code>的引用计数</li>
<li><code>StreamAllocation</code>: okhttp中引入了StreamAllocation负责管理一个连接上的流，同时在connection中也通过一个StreamAllocation的引用的列表来管理一个连接的流，从而使得连接与流之间解耦。关于StreamAllocation的定义可以看下这篇文章:<a href="https://www.atatech.org/articles/78702" target="_blank" rel="external">okhttp源码学习笔记（二）– 连接与连接管理</a></li>
<li><code>connections</code>: Deque双端队列，用于维护连接的容器</li>
<li><code>routeDatabase</code>:用来记录连接失败的<code>Route</code>的黑名单，当连接失败的时候就会把失败的线路加进去</li>
</ul>
<h4 id="2-1-实例化"><a href="#2-1-实例化" class="headerlink" title="2.1 实例化"></a>2.1 实例化</h4><p>首先来看下ConnectionPool的实例化过程，一个OkHttpClient只包含一个ConnectionPool，其实例化过程也在OkHttpClient的实例化过程中实现，值得一提的是ConnectionPool各个方法的调用并没有直接对外暴露，而是通过OkHttpClient的Internal接口统一对外暴露：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OkHttpClient</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Call</span>.<span class="title">Factory</span>, <span class="title">WebSocket</span>.<span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">    Internal.instance = <span class="keyword">new</span> Internal() &#123;</div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLenient</span><span class="params">(Headers.Builder builder, String line)</span> </span>&#123;</div><div class="line">        builder.addLenient(line);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLenient</span><span class="params">(Headers.Builder builder, String name, String value)</span> </span>&#123;</div><div class="line">        builder.addLenient(name, value);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCache</span><span class="params">(Builder builder, InternalCache internalCache)</span> </span>&#123;</div><div class="line">        builder.setInternalCache(internalCache);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connectionBecameIdle</span><span class="params">(</span></span></div><div class="line">          ConnectionPool pool, RealConnection connection) &#123;</div><div class="line">        <span class="keyword">return</span> pool.connectionBecameIdle(connection);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> RealConnection <span class="title">get</span><span class="params">(ConnectionPool pool, Address address,</span></span></div><div class="line">          StreamAllocation streamAllocation, Route route) &#123;</div><div class="line">        <span class="keyword">return</span> pool.get(address, streamAllocation, route);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsNonHost</span><span class="params">(Address a, Address b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a.equalsNonHost(b);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Socket <span class="title">deduplicate</span><span class="params">(</span></span></div><div class="line">          ConnectionPool pool, Address address, StreamAllocation streamAllocation) &#123;</div><div class="line">        <span class="keyword">return</span> pool.deduplicate(address, streamAllocation);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(ConnectionPool pool, RealConnection connection)</span> </span>&#123;</div><div class="line">        pool.put(connection);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> RouteDatabase <span class="title">routeDatabase</span><span class="params">(ConnectionPool connectionPool)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> connectionPool.routeDatabase;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">code</span><span class="params">(Response.Builder responseBuilder)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> responseBuilder.code;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(ConnectionSpec tlsConfiguration, SSLSocket sslSocket, <span class="keyword">boolean</span> isFallback)</span>         </span>&#123;</div><div class="line">        tlsConfiguration.apply(sslSocket, isFallback);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> HttpUrl <span class="title">getHttpUrlChecked</span><span class="params">(String url)</span></span></div><div class="line">          <span class="keyword">throws</span> MalformedURLException, UnknownHostException &#123;</div><div class="line">        <span class="keyword">return</span> HttpUrl.getChecked(url);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> StreamAllocation <span class="title">streamAllocation</span><span class="params">(Call call)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> ((RealCall) call).streamAllocation();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newWebSocketCall</span><span class="params">(OkHttpClient client, Request originalRequest)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RealCall(client, originalRequest, <span class="keyword">true</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">     ......</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样做的原因是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Escalate internal APIs in &#123;@code okhttp3&#125; so they can be used from OkHttp&apos;s implementation</div><div class="line">packages. The only implementation of this interface is in &#123;@link OkHttpClient&#125;.</div></pre></td></tr></table></figure>
<p>Internal的唯一实现在OkHttpClient中，OkHttpClient通过这种方式暴露其API给外部类使用。</p>
<h4 id="2-2-连接池维护"><a href="#2-2-连接池维护" class="headerlink" title="2.2 连接池维护"></a>2.2 连接池维护</h4><p>ConnectionPool内部通过一个双端队列(dequeue)来维护当前所有连接，主要涉及到的操作包括：</p>
<ul>
<li>put：放入新连接</li>
<li>get：从连接池中获取连接</li>
<li>evictAll：关闭所有连接</li>
<li>connectionBecameIdle：连接变空闲后调用清理线程</li>
<li>deduplicate：清除重复的多路复用线程</li>
</ul>
<h5 id="2-2-1-StreamAllocation-findConnection"><a href="#2-2-1-StreamAllocation-findConnection" class="headerlink" title="2.2.1 StreamAllocation.findConnection"></a>2.2.1 StreamAllocation.findConnection</h5><p>get是ConnectionPool中最为重要的方法，<code>StreamAllocation</code>在其findConnection方法内部通过调用get方法为其找到stream找到合适的连接，如果没有则新建一个连接。首先来看下<code>findConnection</code>的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,</span></span></div><div class="line">                                        <span class="keyword">boolean</span> connectionRetryEnabled) <span class="keyword">throws</span> IOException &#123;</div><div class="line">    Route selectedRoute;</div><div class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">      <span class="keyword">if</span> (released) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"released"</span>);</div><div class="line">      <span class="keyword">if</span> (codec != <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"codec != null"</span>);</div><div class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line"></div><div class="line">      <span class="comment">// 一个StreamAllocation刻画的是一个Call的数据流动，一个Call可能存在多次请求(重定向，Authenticate等)，所以当发生类似重定向等事件时优先使用原有的连接</span></div><div class="line">      RealConnection allocatedConnection = <span class="keyword">this</span>.connection;</div><div class="line">      <span class="keyword">if</span> (allocatedConnection != <span class="keyword">null</span> &amp;&amp; !allocatedConnection.noNewStreams) &#123;</div><div class="line">        <span class="keyword">return</span> allocatedConnection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 试图从连接池中找到可复用的连接</span></div><div class="line">      Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, <span class="keyword">null</span>);</div><div class="line">      <span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> connection;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      selectedRoute = route;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取路由配置，所谓路由其实就是代理，ip地址等参数的一个组合</span></div><div class="line">    <span class="keyword">if</span> (selectedRoute == <span class="keyword">null</span>) &#123;</div><div class="line">      selectedRoute = routeSelector.next();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    RealConnection result;</div><div class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">      <span class="keyword">if</span> (canceled) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line"></div><div class="line">      <span class="comment">//拿到路由后可以尝试重新从连接池中获取连接，这里主要针对http2协议下清除域名碎片机制</span></div><div class="line">      Internal.instance.get(connectionPool, address, <span class="keyword">this</span>, selectedRoute);</div><div class="line">      <span class="keyword">if</span> (connection != <span class="keyword">null</span>) <span class="keyword">return</span> connection;</div><div class="line"></div><div class="line">      <span class="comment">//新建连接</span></div><div class="line">      route = selectedRoute;</div><div class="line">      refusedStreamCount = <span class="number">0</span>;</div><div class="line">      result = <span class="keyword">new</span> RealConnection(connectionPool, selectedRoute);</div><div class="line">      <span class="comment">//修改result连接stream计数，方便connection标记清理</span></div><div class="line">      acquire(result);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Do TCP + TLS handshakes. This is a blocking operation.</span></div><div class="line">    result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</div><div class="line">    routeDatabase().connected(result.route());</div><div class="line"></div><div class="line">    Socket socket = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">synchronized</span> (connectionPool) &#123;</div><div class="line">      <span class="comment">// 将新建的连接放入到连接池中</span></div><div class="line">      Internal.instance.put(connectionPool, result);</div><div class="line"></div><div class="line">      <span class="comment">// 如果同时存在多个连向同一个地址的多路复用连接，则关闭多余连接，只保留一个</span></div><div class="line">      <span class="keyword">if</span> (result.isMultiplexed()) &#123;</div><div class="line">        socket = Internal.instance.deduplicate(connectionPool, address, <span class="keyword">this</span>);</div><div class="line">        result = connection;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    closeQuietly(socket);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其主要逻辑大致分为以下几个步骤：</p>
<ul>
<li>查看当前streamAllocation是否有之前已经分配过的连接，有则直接使用</li>
<li>从连接池中查找可复用的连接，有则返回该连接</li>
<li>配置路由，配置后再次从连接池中查找是否有可复用连接，有则直接返回</li>
<li>新建一个连接，并修改其StreamAllocation标记计数，将其放入连接池中</li>
<li>查看连接池是否有重复的多路复用连接，有则清除</li>
</ul>
<h5 id="2-2-2-ConnectionPool-get"><a href="#2-2-2-ConnectionPool-get" class="headerlink" title="2.2.2 ConnectionPool.get"></a>2.2.2 ConnectionPool.get</h5><p>接下来再来看get方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[ConnectionPool.java]</div><div class="line">  <span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation, Route route)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</div><div class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</div><div class="line">      <span class="keyword">if</span> (connection.isEligible(address, route)) &#123;</div><div class="line">        streamAllocation.acquire(connection);</div><div class="line">        <span class="keyword">return</span> connection;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>其逻辑比较简单，遍历当前连接池，如果有符合条件的连接则修改器标记计数，然后返回。这里的关键逻辑在<code>RealConnection.isEligible</code>方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">[RealConnection.java]</div><div class="line">/**</div><div class="line">   * Returns true if this connection can carry a stream allocation to &#123;@code address&#125;. If non-null</div><div class="line">   * &#123;@code route&#125; is the resolved route for a connection.</div><div class="line">   */</div><div class="line">  public boolean isEligible(Address address, Route route) &#123;</div><div class="line">    // If this connection is not accepting new streams, we&apos;re done.</div><div class="line">    if (allocations.size() &gt;= allocationLimit || noNewStreams) return false;</div><div class="line"></div><div class="line">    // If the non-host fields of the address don&apos;t overlap, we&apos;re done.</div><div class="line">    if (!Internal.instance.equalsNonHost(this.route.address(), address)) return false;</div><div class="line"></div><div class="line">    // If the host exactly matches, we&apos;re done: this connection can carry the address.</div><div class="line">    if (address.url().host().equals(this.route().address().url().host())) &#123;</div><div class="line">      return true; // This connection is a perfect match.</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // At this point we don&apos;t have a hostname match. But we still be able to carry the request if</div><div class="line">    // our connection coalescing requirements are met. See also:</div><div class="line">    // https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</div><div class="line">    // https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/</div><div class="line"></div><div class="line">    // 1. This connection must be HTTP/2.</div><div class="line">    if (http2Connection == null) return false;</div><div class="line"></div><div class="line">    // 2. The routes must share an IP address. This requires us to have a DNS address for both</div><div class="line">    // hosts, which only happens after route planning. We can&apos;t coalesce connections that use a</div><div class="line">    // proxy, since proxies don&apos;t tell us the origin server&apos;s IP address.</div><div class="line">    if (route == null) return false;</div><div class="line">    if (route.proxy().type() != Proxy.Type.DIRECT) return false;</div><div class="line">    if (this.route.proxy().type() != Proxy.Type.DIRECT) return false;</div><div class="line">    if (!this.route.socketAddress().equals(route.socketAddress())) return false;</div><div class="line"></div><div class="line">    // 3. This connection&apos;s server certificate&apos;s must cover the new host.</div><div class="line">    if (route.address().hostnameVerifier() != OkHostnameVerifier.INSTANCE) return false;</div><div class="line">    if (!supportsUrl(address.url())) return false;</div><div class="line"></div><div class="line">    // 4. Certificate pinning must match the host.</div><div class="line">    try &#123;</div><div class="line">      address.certificatePinner().check(address.url().host(), handshake().peerCertificates());</div><div class="line">    &#125; catch (SSLPeerUnverifiedException e) &#123;</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return true; // The caller&apos;s address can be carried by this connection.</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<ul>
<li>连接没有达到共享上限</li>
<li>非host域必须完全一样</li>
<li>如果此时host域也相同，则符合条件，可以被复用</li>
<li>如果host不相同，在HTTP/2的域名切片场景下一样可以复用，具体细节可以参考：<a href="https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding" target="_blank" rel="external">https://hpbn.co/optimizing-application-delivery/#eliminate-domain-sharding</a></li>
</ul>
<h5 id="2-2-3-deduplicate"><a href="#2-2-3-deduplicate" class="headerlink" title="2.2.3 deduplicate"></a>2.2.3 deduplicate</h5><p>deduplicate方法主要是针对在HTTP/2场景下多个多路复用连接清除的场景。如果当前连接是HTTP/2，那么所有指向该站点的请求都应该基于同一个TCP连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">[ConnectionPool.java]</div><div class="line">  <span class="comment">/**</span></div><div class="line">   * Replaces the connection held by &#123;<span class="doctag">@code</span> streamAllocation&#125; with a shared connection if possible.</div><div class="line">   * This recovers when multiple multiplexed connections are created concurrently.</div><div class="line">   */</div><div class="line">  <span class="function">Socket <span class="title">deduplicate</span><span class="params">(Address address, StreamAllocation streamAllocation)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> (Thread.holdsLock(<span class="keyword">this</span>));</div><div class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</div><div class="line">      <span class="keyword">if</span> (connection.isEligible(address, <span class="keyword">null</span>)</div><div class="line">          &amp;&amp; connection.isMultiplexed()</div><div class="line">          &amp;&amp; connection != streamAllocation.connection()) &#123;</div><div class="line">        <span class="keyword">return</span> streamAllocation.releaseAndAcquire(connection);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>put和evictAll比较简单，在这里就不写了，大家自行看源码。</p>
<h4 id="2-3-自动回收"><a href="#2-3-自动回收" class="headerlink" title="2.3 自动回收"></a>2.3 自动回收</h4><p>连接池中有socket回收，而这个回收是以<code>RealConnection</code>的弱引用<code>List&lt;Reference&lt;StreamAllocation&gt;&gt;</code>是否为0来为依据的。ConnectionPool有一个独立的线程<code>cleanupRunnable</code>来清理连接池，其触发时机有两个：</p>
<ul>
<li>当连接池中put新的连接时</li>
<li>当connectionBecameIdle接口被调用时</li>
</ul>
<p>其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">  <span class="comment">//执行清理并返回下场需要清理的时间</span></div><div class="line">  <span class="keyword">long</span> waitNanos = cleanup(System.nanoTime());</div><div class="line">  <span class="keyword">if</span> (waitNanos == -<span class="number">1</span>) <span class="keyword">return</span>;</div><div class="line">  <span class="keyword">if</span> (waitNanos &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">synchronized</span> (ConnectionPool.<span class="keyword">this</span>) &#123;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">//在timeout内释放锁与时间片</span></div><div class="line">        ConnectionPool.<span class="keyword">this</span>.wait(TimeUnit.NANOSECONDS.toMillis(waitNanos));</div><div class="line">      &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段死循环实际上是一个阻塞的清理任务，首先进行清理(clean)，并返回下次需要清理的间隔时间，然后调用<code>wait(timeout)</code>进行等待以释放锁与时间片，当等待时间到了后，再次进行清理，并返回下次要清理的间隔时间…</p>
<p>接下来看下cleanup函数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">[ConnectionPool.java]</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">cleanup</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">  <span class="keyword">int</span> inUseConnectionCount = <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> idleConnectionCount = <span class="number">0</span>;</div><div class="line">  RealConnection longestIdleConnection = <span class="keyword">null</span>;</div><div class="line">  <span class="keyword">long</span> longestIdleDurationNs = Long.MIN_VALUE;</div><div class="line"></div><div class="line">  <span class="comment">//遍历`Deque`中所有的`RealConnection`，标记泄漏的连接</span></div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (RealConnection connection : connections) &#123;</div><div class="line">      <span class="comment">// 查询此连接内部StreamAllocation的引用数量</span></div><div class="line">      <span class="keyword">if</span> (pruneAndGetAllocationCount(connection, now) &gt; <span class="number">0</span>) &#123;</div><div class="line">        inUseConnectionCount++;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      idleConnectionCount++;</div><div class="line"></div><div class="line">      <span class="comment">//选择排序法，标记出空闲连接</span></div><div class="line">      <span class="keyword">long</span> idleDurationNs = now - connection.idleAtNanos;</div><div class="line">      <span class="keyword">if</span> (idleDurationNs &gt; longestIdleDurationNs) &#123;</div><div class="line">        longestIdleDurationNs = idleDurationNs;</div><div class="line">        longestIdleConnection = connection;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (longestIdleDurationNs &gt;= <span class="keyword">this</span>.keepAliveDurationNs</div><div class="line">        || idleConnectionCount &gt; <span class="keyword">this</span>.maxIdleConnections) &#123;</div><div class="line">      <span class="comment">//如果(`空闲socket连接超过5个`</span></div><div class="line">      <span class="comment">//且`keepalive时间大于5分钟`)</span></div><div class="line">      <span class="comment">//就将此泄漏连接从`Deque`中移除</span></div><div class="line">      connections.remove(longestIdleConnection);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idleConnectionCount &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">//返回此连接即将到期的时间，供下次清理</span></div><div class="line">      <span class="comment">//这里依据是在上文`connectionBecameIdle`中设定的计时</span></div><div class="line">      <span class="keyword">return</span> keepAliveDurationNs - longestIdleDurationNs;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inUseConnectionCount &gt; <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">//全部都是活跃的连接，5分钟后再次清理</span></div><div class="line">      <span class="keyword">return</span> keepAliveDurationNs;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">//没有任何连接，跳出循环</span></div><div class="line">      cleanupRunning = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//关闭连接，返回`0`，也就是立刻再次清理</span></div><div class="line">  closeQuietly(longestIdleConnection.socket());</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其基本逻辑如下：</p>
<ul>
<li>遍历连接池中所有连接，标记泄露连接</li>
<li>如果被标记的连接满足(<code>空闲socket连接超过5个</code>&amp;&amp;<code>keepalive时间大于5分钟</code>)，就将此连接从<code>Deque</code>中移除，并关闭连接，返回<code>0</code>，也就是将要执行<code>wait(0)</code>，提醒立刻再次扫描</li>
<li>如果(<code>目前还可以塞得下5个连接，但是有可能泄漏的连接(即空闲时间即将达到5分钟)</code>)，就返回此连接即将到期的剩余时间，供下次清理</li>
<li>如果(<code>全部都是活跃的连接</code>)，就返回默认的<code>keep-alive</code>时间，也就是5分钟后再执行清理</li>
</ul>
<p>而<code>pruneAndGetAllocationCount</code>负责标记并找到不活跃连接:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[ConnnecitonPool.java]</div><div class="line"><span class="comment">//类似于引用计数法，如果引用全部为空，返回立刻清理</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">pruneAndGetAllocationCount</span><span class="params">(RealConnection connection, <span class="keyword">long</span> now)</span> </span>&#123;</div><div class="line">  <span class="comment">//虚引用列表</span></div><div class="line">  List&lt;Reference&lt;StreamAllocation&gt;&gt; references = connection.allocations;</div><div class="line">  <span class="comment">//遍历弱引用列表</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; references.size(); ) &#123;</div><div class="line">    Reference&lt;StreamAllocation&gt; reference = references.get(i);</div><div class="line">    <span class="comment">//如果正在被使用，跳过，接着循环</span></div><div class="line">    <span class="comment">//是否置空是在上文`connectionBecameIdle`的`release`控制的</span></div><div class="line">    <span class="keyword">if</span> (reference.get() != <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="comment">//非常明显的引用计数</span></div><div class="line">      i++;</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//否则移除引用</span></div><div class="line">    references.remove(i);</div><div class="line">    connection.noNewStreams = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">//如果所有分配的流均没了，标记为已经距离现在空闲了5分钟</span></div><div class="line">    <span class="keyword">if</span> (references.isEmpty()) &#123;</div><div class="line">      connection.idleAtNanos = now - keepAliveDurationNs;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> references.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OkHttp的连接池通过计数+标记清理的机制来管理连接池，使得无用连接可以被会回收，并保持多个健康的keep-alive连接。这也是OkHttp的连接池能保持高效的关键原因。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OkHttp/" rel="tag"># OkHttp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/27/HashMap/" rel="next" title="HashMap、LinkedHashMap、ConcurrentHashMap">
                <i class="fa fa-chevron-left"></i> HashMap、LinkedHashMap、ConcurrentHashMap
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/10/Retrofit源码分析/" rel="prev" title="Retrofit源码解析">
                Retrofit源码解析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="jarkeet" />
            
              <p class="site-author-name" itemprop="name">jarkeet</p>
              <p class="site-description motion-element" itemprop="description">总结、思考、践行</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/jarkeet" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单使用"><span class="nav-number">1.</span> <span class="nav-text">简单使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步调用"><span class="nav-number">1.1.</span> <span class="nav-text">同步调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#异步请求"><span class="nav-number">1.2.</span> <span class="nav-text">异步请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拦截器"><span class="nav-number">1.3.</span> <span class="nav-text">拦截器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总体架构"><span class="nav-number">2.</span> <span class="nav-text">总体架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Interface——接口层："><span class="nav-number">2.1.</span> <span class="nav-text">Interface——接口层：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Protocol——协议层：处理协议逻辑"><span class="nav-number">2.2.</span> <span class="nav-text">Protocol——协议层：处理协议逻辑</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection——连接层：管理网络连接，发送新的请求，接收服务器访问"><span class="nav-number">2.3.</span> <span class="nav-text">Connection——连接层：管理网络连接，发送新的请求，接收服务器访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cache——缓存层：管理本地缓存"><span class="nav-number">2.4.</span> <span class="nav-text">Cache——缓存层：管理本地缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I-O——I-O层：实际数据读写实现"><span class="nav-number">2.5.</span> <span class="nav-text">I/O——I/O层：实际数据读写实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑"><span class="nav-number">2.6.</span> <span class="nav-text">Inteceptor——拦截器层：拦截网络访问，插入拦截逻辑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-构造Demo"><span class="nav-number">3.</span> <span class="nav-text">1.构造Demo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-发起请求"><span class="nav-number">4.</span> <span class="nav-text">2. 发起请求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-构建拦截器链"><span class="nav-number">5.</span> <span class="nav-text">3. 构建拦截器链</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-RetryAndFollowUpInterceptor"><span class="nav-number">6.</span> <span class="nav-text">4 RetryAndFollowUpInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-BridgeInterceptor"><span class="nav-number">7.</span> <span class="nav-text">5 BridgeInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-CacheInterceptor"><span class="nav-number">8.</span> <span class="nav-text">6. CacheInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-ConnectInterceptor"><span class="nav-number">9.</span> <span class="nav-text">7 ConnectInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-CallServerInterceptor"><span class="nav-number">10.</span> <span class="nav-text">8. CallServerInterceptor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-整体流程"><span class="nav-number">11.</span> <span class="nav-text">8.整体流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-线程池的优点"><span class="nav-number">12.</span> <span class="nav-text">1. 线程池的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-OkHttp的任务队列"><span class="nav-number">13.</span> <span class="nav-text">2. OkHttp的任务队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Dispatcher分发器"><span class="nav-number">14.</span> <span class="nav-text">3. Dispatcher分发器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-同步请求"><span class="nav-number">14.1.</span> <span class="nav-text">1.同步请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-异步请求"><span class="nav-number">14.2.</span> <span class="nav-text">2.异步请求</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-总结"><span class="nav-number">15.</span> <span class="nav-text">4. 总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP缓存策略"><span class="nav-number">16.</span> <span class="nav-text">1. HTTP缓存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-Expires"><span class="nav-number">16.1.</span> <span class="nav-text">1.1 Expires</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-Cache-Control"><span class="nav-number">16.2.</span> <span class="nav-text">1.2 Cache-Control</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-条件GET请求"><span class="nav-number">16.3.</span> <span class="nav-text">1.3 条件GET请求</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-Last-Modified-Date"><span class="nav-number">16.3.1.</span> <span class="nav-text">1.3.1 Last-Modified-Date</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-ETag"><span class="nav-number">16.3.2.</span> <span class="nav-text">1.3.2 ETag</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-no-cache-no-store"><span class="nav-number">16.4.</span> <span class="nav-text">1.4 no-cache/no-store</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-only-if-cached"><span class="nav-number">16.5.</span> <span class="nav-text">1.5 only-if-cached</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Cache源码分析"><span class="nav-number">17.</span> <span class="nav-text">2. Cache源码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-DiskLruCache"><span class="nav-number">18.</span> <span class="nav-text">3. DiskLruCache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-journalFile"><span class="nav-number">18.1.</span> <span class="nav-text">3.1 journalFile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-DiskLruCache-Entry"><span class="nav-number">18.2.</span> <span class="nav-text">3.2 DiskLruCache.Entry</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-cleanupRunnable"><span class="nav-number">18.3.</span> <span class="nav-text">3.3 cleanupRunnable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-SnapShot"><span class="nav-number">18.4.</span> <span class="nav-text">3.4 SnapShot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-lruEntries"><span class="nav-number">18.5.</span> <span class="nav-text">3.5 lruEntries</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-FileSystem"><span class="nav-number">18.6.</span> <span class="nav-text">3.6 FileSystem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-DiskLruCache-edit"><span class="nav-number">18.7.</span> <span class="nav-text">3.7 DiskLruCache.edit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8总结"><span class="nav-number">18.8.</span> <span class="nav-text">3.8总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-背景"><span class="nav-number">19.</span> <span class="nav-text">1. 背景</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-keep-alive机制"><span class="nav-number">19.1.</span> <span class="nav-text">1.1 keep-alive机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-HTTP-2"><span class="nav-number">19.2.</span> <span class="nav-text">1.2 HTTP/2</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-连接池的使用与分析"><span class="nav-number">20.</span> <span class="nav-text">2. 连接池的使用与分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-实例化"><span class="nav-number">20.1.</span> <span class="nav-text">2.1 实例化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-连接池维护"><span class="nav-number">20.2.</span> <span class="nav-text">2.2 连接池维护</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-StreamAllocation-findConnection"><span class="nav-number">20.2.1.</span> <span class="nav-text">2.2.1 StreamAllocation.findConnection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-ConnectionPool-get"><span class="nav-number">20.2.2.</span> <span class="nav-text">2.2.2 ConnectionPool.get</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-deduplicate"><span class="nav-number">20.2.3.</span> <span class="nav-text">2.2.3 deduplicate</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-自动回收"><span class="nav-number">20.3.</span> <span class="nav-text">2.3 自动回收</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">jarkeet</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
